<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>盘根错节：GLibc 堆内存管理机制简介 - Lab on Mercury</title><meta name=Description content="Lab on Mercury"><meta property="og:title" content="盘根错节：GLibc 堆内存管理机制简介"><meta property="og:description" content="The heap is a beautiful mess."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.sigmerc.top/glibc-heap/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-12-08T16:53:39+00:00"><meta property="article:modified_time" content="2019-12-08T16:53:39+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="盘根错节：GLibc 堆内存管理机制简介"><meta name=twitter:description content="The heap is a beautiful mess."><meta name=application-name content="Lab on Mercury"><meta name=apple-mobile-web-app-title content="Lab on Mercury"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.sigmerc.top/glibc-heap/><link rel=prev href=https://blog.sigmerc.top/binary-exp/><link rel=next href=https://blog.sigmerc.top/how2heap/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"盘根错节：GLibc 堆内存管理机制简介","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.sigmerc.top\/glibc-heap\/"},"genre":"posts","keywords":"Linux, 堆漏洞","wordcount":6136,"url":"https:\/\/blog.sigmerc.top\/glibc-heap\/","datePublished":"2019-12-08T16:53:39+00:00","dateModified":"2019-12-08T16:53:39+00:00","publisher":{"@type":"Organization","name":"Mercury","logo":{"@type":"ImageObject","url":"https:\/\/blog.sigmerc.top\/my_avatar.png","width":400,"height":400}},"author":{"@type":"Person","name":"Mercury"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Lab on Mercury"><span class=header-title-pre><i class="fas fa-meteor fa-fw"></i></span>Lab on Mercury</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/><i class="fas fa-archive fa-fw"></i> 文章 </a><a class=menu-item href=/tags/><i class="fas fa-tags fa-fw"></i> 标签 </a><a class=menu-item href=/categories/><i class="fas fa-th fa-fw"></i> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Lab on Mercury"><span class=header-title-pre><i class="fas fa-meteor fa-fw"></i></span>Lab on Mercury</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title><i class="fas fa-archive fa-fw"></i>文章</a><a class=menu-item href=/tags/ title><i class="fas fa-tags fa-fw"></i>标签</a><a class=menu-item href=/categories/ title><i class="fas fa-th fa-fw"></i>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">盘根错节：GLibc 堆内存管理机制简介</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>Mercury</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/><i class="far fa-folder fa-fw"></i>二进制安全</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2019-12-08>2019-12-08</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 6136 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 13 分钟&nbsp;<span id=/glibc-heap/ class=leancloud_visitors data-flag-title="盘根错节：GLibc 堆内存管理机制简介">
<i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
</span>&nbsp;</div></div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/0.png data-srcset="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/0.png, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/0.png 1.5x, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/0.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/0.png title=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/0.png></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#什么是堆>什么是堆？</a></li><li><a href=#使用动态分配的内存>使用动态分配的内存</a></li><li><a href=#两个系统调用>两个系统调用</a><ul><li><a href=#brk>brk()</a></li><li><a href=#mmap>mmap()</a></li></ul></li><li><a href=#多线程与-arena>多线程与 Arena</a></li><li><a href=#维护多个堆>维护多个堆</a></li><li><a href=#chunk-的结构>Chunk 的结构</a><ul><li><a href=#allocated-chunk>Allocated chunk</a></li><li><a href=#free-chunk>Free chunk</a></li><li><a href=#top-chunk>Top chunk</a></li><li><a href=#last-remainder-chunk>Last Remainder chunk</a></li></ul></li><li><a href=#bin-的结构>Bin 的结构</a><ul><li><a href=#fast-bins>fast bins</a></li><li><a href=#unsorted-bin>unsorted bin</a></li><li><a href=#small-bins>small bins</a></li><li><a href=#large-bins>large bins</a></li></ul></li><li><a href=#内存分配流程>内存分配流程</a></li><li><a href=#内存释放流程>内存释放流程</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></div><div class=content id=content><p>The heap is a beautiful mess.</p><p>本文将对 Glibc 堆上的内存管理作简要介绍，部分内容翻译自参考资料中的文章。略过了许多细节，主要是为了对新手友好。</p><p>默认读者熟悉操作系统、C 语言及其运行机制，并且对于 C 中的函数调用栈有所了解。</p><h2 id=什么是堆>什么是堆？</h2><p>堆是每个程序被分配到的一块内存区域，和栈的区别主要在于堆内存是动态分配的。也就是说，程序可以从 <code>heap</code> 段请求一块内存，或者释放一块内存。</p><p>另外，堆内存是全局的，即在程序的任意位置都可以访问到堆，并不一定要在调用 <code>malloc</code> 的那个函数里访问。这是因为 C 语言使用指针指向动态分配的内存。但相比访问栈上的静态局部变量，使用指针也带来了一定的开销。</p><h2 id=使用动态分配的内存>使用动态分配的内存</h2><p>GLibc 采用 ptmalloc2 内存分配器管理堆内存，相比前身 dlmalloc，它增加了对多线程的支持。多线程的好处就不多赘述了。</p><p>借助 <code>stdlib.h</code> 我们可以使用 <code>malloc</code> 和 <code>free</code> 函数来操作堆内存：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>strcpy</span><span class=p>(</span><span class=n>buffer</span><span class=p>,</span><span class=s>&#34;hello&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>free</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>第一行分配了 10 字节给 <code>buffer</code>，注意这里的强制类型转换是必须的；第 2-3 行使用了 <code>buffer</code> 这块内存，并在最后一行释放。</p><p>下面是 <code>malloc</code> 和 <code>free</code> 函数的注释：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>  malloc(size_t n)
</span></span></span><span class=line><span class=cl><span class=cm>  Returns a pointer to a newly allocated chunk of at least n bytes, or null
</span></span></span><span class=line><span class=cl><span class=cm>  if no space is available. Additionally, on failure, errno is
</span></span></span><span class=line><span class=cl><span class=cm>  set to ENOMEM on ANSI C systems.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>  If n is zero, malloc returns a minumum-sized chunk. (The minimum
</span></span></span><span class=line><span class=cl><span class=cm>  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit
</span></span></span><span class=line><span class=cl><span class=cm>  systems.)  On most systems, size_t is an unsigned type, so calls
</span></span></span><span class=line><span class=cl><span class=cm>  with negative arguments are interpreted as requests for huge amounts
</span></span></span><span class=line><span class=cl><span class=cm>  of space, which will often fail. The maximum supported value of n
</span></span></span><span class=line><span class=cl><span class=cm>  differs across systems, but is in all cases less than the maximum
</span></span></span><span class=line><span class=cl><span class=cm>  representable value of a size_t.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>  free(void* p)
</span></span></span><span class=line><span class=cl><span class=cm>  Releases the chunk of memory pointed to by p, that had been previously
</span></span></span><span class=line><span class=cl><span class=cm>  allocated using malloc or a related routine such as realloc.
</span></span></span><span class=line><span class=cl><span class=cm>  It has no effect if p is null. It can have arbitrary (i.e., bad!)
</span></span></span><span class=line><span class=cl><span class=cm>  effects if p has already been freed.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>  Unless disabled (using mallopt), freeing very large spaces will
</span></span></span><span class=line><span class=cl><span class=cm>  when possible, automatically trigger operations that give
</span></span></span><span class=line><span class=cl><span class=cm>  back unused memory to the system, thus reducing program footprint.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></td></tr></table></div></div><p>注意，即使申请 0 字节内存，<code>malloc</code> 依然会分配一个最小的 chunk；如果传给 <code>free</code> 的参数是空指针，<code>free</code> 不会做任何事，而如果传入的是一个已经 <code>free</code> 过的指针，那么后果是不可预期的。这里尤其需要注意的是，与 <code>Java</code> 等语言不同，C 语言中释放掉分配到的内存的责任在于程序员，并且分配到的内存只应使用<em>一次</em>。</p><p>这两个函数在更底层上是使用 <code>brk()</code> 和 <code>mmap()</code> 这两个系统调用来管理内存的。</p><h2 id=两个系统调用>两个系统调用</h2><p>注意申请内存时，Linux 内核只会先分配一段虚拟内存，真正使用时才会映射到物理内存上去。</p><h3 id=brk>brk()</h3><p><code>brk()</code> 通过增加 <code>break location</code> 来获取内存，一开始 <code>heap</code> 段的起点 <code>start_brk</code> 和 <code>heap</code> 段的终点 <code>brk</code> 指向同一个位置。</p><ul><li>ASLR 关闭时，两者指向 data/bss 段的末尾，也就是 <code>end_data</code></li><li>ASLR 开启时，两者指向 data/bss 段的末尾加上一段随机 brk 偏移</li></ul><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/1.png title="图 1｜Process Virtual Memory Layout" data-thumbnail=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/1.png data-sub-html="<h2> </h2><p>图 1｜Process Virtual Memory Layout</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/1.png data-srcset="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/1.png, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/1.png 1.5x, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/1.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/1.png></a><figcaption class=image-caption>图 1｜Process Virtual Memory Layout</figcaption></figure></p><blockquote><p>注：注意与 <code>sbrk()</code> 的区别，后者是 C 语言库函数，<code>malloc</code> 源码中的 <code>MORECORE</code> 就是调用的 <code>sbrk()</code>。</p></blockquote><h3 id=mmap>mmap()</h3><p>用于创建私有的匿名映射段，主要是为了分配一块新的内存，且这块内存只有调用 <code>mmap()</code> 的进程可以使用，所以称之为私有的。与之进行相反操作的是 <code>munmap()</code>，删除一块内存区域上的映射。</p><h2 id=多线程与-arena>多线程与 Arena</h2><p>前面提到，ptmalloc2 的一大改进就在于多线程，那么他是如何做到的呢？不难猜到，每个线程必定要维护一些独立的数据结构，并且对这些数据结构的访问是需要加锁的。的确，在 ptmalloc2 中，每个线程拥有自己的 <code>freelist</code>，也就是维护空闲内存的一个链表；以及自己的 <code>arena</code>，一段连续的堆内存区域。特别地，主线程的 <code>arena</code> 叫做 <code>main_arena</code>。注意<strong>只有 <code>main_arena</code> 可以访问 <code>heap</code> 段和 <code>mmap</code> 映射区域，<code>non_main_arena</code> 只能访问 <code>mmap</code> 映射区域</strong>。</p><blockquote><p>注：线程较多时，互斥锁机制会导致性能下降。</p></blockquote><p>当我们在程序中第一次申请内存时还没有 <code>heap</code> 段，因此 132KB 的 <code>heap</code> 段，也就是我们的 <code>main_arena</code>，会被创建（<strong>通过 <code>brk()</code>调用</strong>），无论我们申请的内存是多大。对于接下来的内存申请，<code>malloc</code> 都会从 <code>main_arena</code> 中尝试取出一块内存进行分配。如果空间不够，<code>main_arena</code> 可以通过 <code>brk()</code> 扩张；如果空闲空间太多，也可以缩小。</p><p>那么对于 <code>non_main_arena</code> 呢？前面提到它只能访问 <code>mmap</code> 映射区域，因为在创建时它就是由 <code>mmap()</code> 创建的——1MB 的内存空间会被映射到进程地址空间，不过实际上只有 132KB 是可读写的，这 132KB 就是该线程的 <code>heap</code> 结构，或者叫 <code>non_main_arena</code>。</p><blockquote><p>注：当然了，当申请的空间大于 128KB 且 <code>arena</code> 中没有足够空间时，无论在哪个 <code>arena</code> 里都只能通过 <code>mmap()</code> 分配内存。</p></blockquote><p><code>arena</code> 也不是和线程一对一的，实际上有数量限制：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>For 32 bit systems:
</span></span><span class=line><span class=cl>     Number of arena = 2 * number of cores.
</span></span><span class=line><span class=cl>For 64 bit systems:
</span></span><span class=line><span class=cl>     Number of arena = 8 * number of cores.
</span></span></code></pre></td></tr></table></div></div><p>而当我们 <code>free</code> 一小块内存时，内存也不会直接归还给内核，而是给 ptmalloc2 让他去维护，后者会将空闲内存丢入 bin 中，或者说 <code>freelist</code> 中也可以。如果过了一会我们的程序又要申请内存，那么 ptmalloc2 就会从 bin 中找一块空闲的内存进行分配，找不到的话才会去问内核要内存。</p><h2 id=维护多个堆>维护多个堆</h2><p>前面提到，<code>main_arena</code> 只有一个堆，并且可以灵活地放缩；<code>non_main_arena</code> 则只能通过 <code>mmap()</code> 获得一个堆。那么如果 <code>non_main_arena</code> 里分配的堆内存不够了怎么办？很简单，再 <code>mmap()</code> 一次，创建一个新的堆。</p><p>所以，在 <code>non_main_arena</code> 里，我们必须考虑如何维护多个堆的问题。这里我们会涉及三个头部：</p><ul><li><code>heap_info</code>：每个堆的头部，<code>main_arena</code> 是没有的</li><li><code>malloc_state</code>：<code>arena</code> 的头部，<code>main_arena</code> 的这个部分是<strong>全局变量</strong>而不属于堆段</li><li><code>malloc_chunk</code>：每个 chunk 的头部</li></ul><p>具体一点，<code>heap_info</code> 完整定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_heap_info</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>mstate</span> <span class=n>ar_ptr</span><span class=p>;</span> <span class=cm>/* Arena for this heap. */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>_heap_info</span> <span class=o>*</span><span class=n>prev</span><span class=p>;</span> <span class=cm>/* Previous heap. */</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>size</span><span class=p>;</span>   <span class=cm>/* Current size in bytes. */</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>mprotect_size</span><span class=p>;</span> <span class=cm>/* Size in bytes that has been mprotected
</span></span></span><span class=line><span class=cl><span class=cm>                           PROT_READ|PROT_WRITE.  */</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* Make sure the following data is properly aligned, particularly
</span></span></span><span class=line><span class=cl><span class=cm>     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of
</span></span></span><span class=line><span class=cl><span class=cm>     MALLOC_ALIGNMENT. */</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>pad</span><span class=p>[</span><span class=o>-</span><span class=mi>6</span> <span class=o>*</span> <span class=n>SIZE_SZ</span> <span class=o>&amp;</span> <span class=n>MALLOC_ALIGN_MASK</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>heap_info</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>而 <code>malloc_state</code> 的完整定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>malloc_state</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* Serialize access.  */</span>
</span></span><span class=line><span class=cl>  <span class=n>mutex_t</span> <span class=n>mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Flags (formerly in max_fast).  */</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Fastbins */</span>
</span></span><span class=line><span class=cl>  <span class=n>mfastbinptr</span> <span class=n>fastbinsY</span><span class=p>[</span><span class=n>NFASTBINS</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Base of the topmost chunk -- not otherwise kept in a bin */</span>
</span></span><span class=line><span class=cl>  <span class=n>mchunkptr</span> <span class=n>top</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* The remainder from the most recent split of a small request */</span>
</span></span><span class=line><span class=cl>  <span class=n>mchunkptr</span> <span class=n>last_remainder</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Normal bins packed as described above */</span>
</span></span><span class=line><span class=cl>  <span class=n>mchunkptr</span> <span class=n>bins</span><span class=p>[</span><span class=n>NBINS</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>-</span> <span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Bitmap of bins */</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>binmap</span><span class=p>[</span><span class=n>BINMAPSIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Linked list */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_state</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Linked list for free arenas.  Access to this field is serialized
</span></span></span><span class=line><span class=cl><span class=cm>     by free_list_lock in arena.c.  */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_state</span> <span class=o>*</span><span class=n>next_free</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Number of threads attached to this arena.  0 if the arena is on
</span></span></span><span class=line><span class=cl><span class=cm>     the free list.  Access to this field is serialized by
</span></span></span><span class=line><span class=cl><span class=cm>     free_list_lock in arena.c.  */</span>
</span></span><span class=line><span class=cl>  <span class=n>INTERNAL_SIZE_T</span> <span class=n>attached_threads</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Memory allocated from the system in this arena.  */</span>
</span></span><span class=line><span class=cl>  <span class=n>INTERNAL_SIZE_T</span> <span class=n>system_mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>INTERNAL_SIZE_T</span> <span class=n>max_system_mem</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>其中 <code>INTERNAL_SIZE_T</code> 默认和 <code>size_t</code> 相同：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifndef INTERNAL_SIZE_T
</span></span></span><span class=line><span class=cl><span class=cp>#define INTERNAL_SIZE_T size_t
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></td></tr></table></div></div><p>在后面介绍 chunk 和 bin 的时候，我们会发现其中几个字段的作用，<code>malloc_chunk</code> 我们也会在后面看到。</p><p>对于 <code>arena</code> 中只有单个堆的情况：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/2.png title="图 2｜Single Heap" data-thumbnail=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/2.png data-sub-html="<h2> </h2><p>图 2｜Single Heap</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/2.png data-srcset="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/2.png, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/2.png 1.5x, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/2.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/2.png></a><figcaption class=image-caption>图 2｜Single Heap</figcaption></figure></p><p>对于 <code>non_main_arena</code> 中有多个堆的情况：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/3.png title="图 3｜Multiple Heap" data-thumbnail=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/3.png data-sub-html="<h2> </h2><p>图 3｜Multiple Heap</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/3.png data-srcset="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/3.png, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/3.png 1.5x, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/3.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/3.png></a><figcaption class=image-caption>图 3｜Multiple Heap</figcaption></figure></p><p>注意到有多个堆的情况下，旧的堆的 Top chunk 会被认为是普通的空闲块。</p><h2 id=chunk-的结构>Chunk 的结构</h2><p>通俗地说，一块由分配器分配的内存块叫做一个 chunk，包含了元数据和用户数据。具体一点，chunk 完整定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>malloc_chunk</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>INTERNAL_SIZE_T</span>      <span class=n>mchunk_prev_size</span><span class=p>;</span>  <span class=cm>/* Size of previous chunk (if free).  */</span>
</span></span><span class=line><span class=cl>  <span class=n>INTERNAL_SIZE_T</span>      <span class=n>mchunk_size</span><span class=p>;</span>       <span class=cm>/* Size in bytes, including overhead. */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>fd</span><span class=p>;</span>                <span class=cm>/* double links -- used only if free. */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>bk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* Only used for large blocks: pointer to next larger size.  */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>fd_nextsize</span><span class=p>;</span> <span class=cm>/* double links -- used only if free. */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>bk_nextsize</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>mchunkptr</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>这里出现的 6 个字段均为元数据。</p><p>一个 chunk 可以是以下几种类型之一：</p><ul><li>已分配的（Allocated chunk）</li><li>空闲的（Free chunk）</li><li>Top chunk</li><li>Last Remainder chunk</li></ul><p>我们一个一个来看。</p><h3 id=allocated-chunk>Allocated chunk</h3><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/4.png title="图 4｜Allocated chunk" data-thumbnail=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/4.png data-sub-html="<h2> </h2><p>图 4｜Allocated chunk</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/4.png data-srcset="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/4.png, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/4.png 1.5x, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/4.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/4.png></a><figcaption class=image-caption>图 4｜Allocated chunk</figcaption></figure></p><p>第一个部分（32 位上 4B，64 位上 8B）叫做 <code>prev_size</code>，只有在前一个 chunk 空闲时才表示前一个块的大小，否则这里就是无效的，可以被前一个块征用（存储用户数据）。</p><blockquote><p>这里的前一个 chunk，指内存中相邻的前一个，而不是 freelist 链表中的前一个。<code>PREV_INUSE</code> 代表的 “前一个 chunk” 同理。</p></blockquote><p>第二个部分的高位存储当前 chunk 的大小，低 3 位分别表示：</p><ul><li>P: <code>PREV_INUSE</code> 之前的 chunk 已经被分配则为 1</li><li>M: <code>IS_MMAPED</code> 当前 chunk 是 <code>mmap()</code> 得到的则为 1</li><li>N: <code>NON_MAIN_ARENA</code> 当前 chunk 在 <code>non_main_arena</code> 里则为 1</li></ul><p>对应源码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* size field is or&#39;ed with PREV_INUSE when previous adjacent chunk in use */</span>
</span></span><span class=line><span class=cl><span class=cp>#define PREV_INUSE 0x1
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* extract inuse bit of previous chunk */</span>
</span></span><span class=line><span class=cl><span class=cp>#define prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* size field is or&#39;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span>
</span></span><span class=line><span class=cl><span class=cp>#define IS_MMAPPED 0x2
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* check for mmap()&#39;ed chunk */</span>
</span></span><span class=line><span class=cl><span class=cp>#define chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* size field is or&#39;ed with NON_MAIN_ARENA if the chunk was obtained
</span></span></span><span class=line><span class=cl><span class=cm>   from a non-main arena.  This is only set immediately before handing
</span></span></span><span class=line><span class=cl><span class=cm>   the chunk to the user, if necessary.  */</span>
</span></span><span class=line><span class=cl><span class=cp>#define NON_MAIN_ARENA 0x4
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* check for chunk from non-main arena */</span>
</span></span><span class=line><span class=cl><span class=cp>#define chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)
</span></span></span></code></pre></td></tr></table></div></div><p>你可能会有几个困惑：</p><ol><li><p><code>fd</code>、<code>bk</code>、<code>fd_nextsize</code>、<code>bk_nextsize</code> 这几个字段去哪里了？
对于已分配的 chunk 来说它们没用，所以也被征用了，用来存储用户数据。</p></li><li><p>为什么第二个部分的低 3 位就这么被吞了而不会影响 <code>size</code>？
这是因为 <code>malloc</code> 会将用户申请的内存大小转化为实际分配的内存，以此来满足（至少）8 字节对齐的要求，同时留出额外空间存放 chunk 头部。由于（至少）8 字节对齐了，低 3 位自然就没用了。在获取真正的 <code>size</code> 时，会忽略低 3 位：</p></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   Bits to mask off when extracting size
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>   Note: IS_MMAPPED is intentionally not masked off from size field in
</span></span></span><span class=line><span class=cl><span class=cm>   macros for which mmapped chunks should never be seen. This should
</span></span></span><span class=line><span class=cl><span class=cm>   cause helpful core dumps to occur if it is tried by accident by
</span></span></span><span class=line><span class=cl><span class=cm>   people extending or adapting this malloc.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=cp>#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* Get size, ignoring use bits */</span>
</span></span><span class=line><span class=cl><span class=cp>#define chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))
</span></span></span></code></pre></td></tr></table></div></div><ol start=3><li><code>malloc</code> 是如何将申请的大小转化为实际分配的大小的呢？
核心在于 <code>request2size</code> 宏：</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* pad request bytes into a usable size -- internal version */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define request2size(req)                                         \
</span></span></span><span class=line><span class=cl><span class=cp>  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt;MINSIZE)  ?             \
</span></span></span><span class=line><span class=cl><span class=cp>   MINSIZE :                                                      \
</span></span></span><span class=line><span class=cl><span class=cp>   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)
</span></span></span></code></pre></td></tr></table></div></div><p>其中用到的其它宏定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#  define MALLOC_ALIGNMENT       (2 *SIZE_SZ)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* The corresponding bit mask value */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* The smallest possible chunk */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* The smallest size we can malloc is an aligned minimal chunk */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MINSIZE  \
</span></span></span><span class=line><span class=cl><span class=cp>  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))
</span></span></span></code></pre></td></tr></table></div></div><ol start=4><li>这里还有一个 <code>mem</code> 指针，是做什么用的？
这是调用 <code>malloc</code> 时返回给用户的指针。实际上，真正的 chunk 是从 <code>chunk</code> 指针开始的。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* The corresponding word size */</span>
</span></span><span class=line><span class=cl><span class=cp>#define SIZE_SZ                (sizeof(INTERNAL_SIZE_T))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* conversion from malloc headers to user pointers, and back */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))
</span></span></span><span class=line><span class=cl><span class=cp>#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))
</span></span></span></code></pre></td></tr></table></div></div><ol start=5><li>用户申请的内存大小就是用户数据可用的内存大小吗？
不一定，原因还是字节对齐问题。要获得可用内存大小，可以用 <code>malloc_usable_size()</code> 获得，其核心函数是：</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=n>size_t</span>
</span></span><span class=line><span class=cl><span class=nf>musable</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>mem</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>mchunkptr</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>mem</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>p</span> <span class=o>=</span> <span class=n>mem2chunk</span> <span class=p>(</span><span class=n>mem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>__builtin_expect</span> <span class=p>(</span><span class=n>using_malloc_checking</span> <span class=o>==</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>malloc_check_get_size</span> <span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>chunk_is_mmapped</span> <span class=p>(</span><span class=n>p</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>chunksize</span> <span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>-</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>SIZE_SZ</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>inuse</span> <span class=p>(</span><span class=n>p</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>chunksize</span> <span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=o>-</span> <span class=n>SIZE_SZ</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=free-chunk>Free chunk</h3><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/5.png title="图 5｜Free chunk" data-thumbnail=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/5.png data-sub-html="<h2> </h2><p>图 5｜Free chunk</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/5.png data-srcset="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/5.png, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/5.png 1.5x, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/5.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/5.png></a><figcaption class=image-caption>图 5｜Free chunk</figcaption></figure></p><p>首先，<code>prev_size</code> 必定存储上一个块的用户数据，因为 Free chunk 的上一个块必定是 Allocated chunk，否则会发生合并。</p><p>接着，多出来的 <code>fd</code> 指向同一个 bin 中的前一个 Free chunk，<code>bk</code> 指向同一个 bin 中的后一个 Free chunk。</p><p>这里提到了 bin，我们将在后面介绍。</p><p>此外，对于 large bins 中的 Free chunk，<code>fd_nextsize</code> 与 <code>bk_nextsize</code> 会生效，分别指向 large bins 中前一个（更大的）和后一个（更小的）空闲块。</p><h3 id=top-chunk>Top chunk</h3><p>一个 <code>arena</code> 顶部的 chunk 叫做 Top chunk，它不属于任何 bin。当所有 bin 中都没有空闲的可用 chunk 时，我们切割 Top chunk 来满足用户的内存申请。假设 Top chunk 当前大小为 N 字节，用户申请了 K 字节的内存，那么 Top chunk 将被切割为：</p><ul><li>一个 K 字节的 chunk，分配给用户</li><li>一个 N-K 字节的 chunk，称为 Last Remainder chunk</li></ul><p>后者成为新的 Top chunk。如果连 Top chunk 都不够用了，那么：</p><ul><li>在 <code>main_arena</code> 中，用 <code>brk()</code> 扩张 Top chunk</li><li>在 <code>non_main_arena</code> 中，用 <code>mmap()</code> 分配新的堆</li></ul><blockquote><p>注：Top chunk 的 PREV_INUSE 位总是 1</p></blockquote><h3 id=last-remainder-chunk>Last Remainder chunk</h3><p>当需要分配一个比较小的 K 字节的 chunk 但是 small bins 中找不到满足要求的，且 Last Remainder chunk 的大小 N 能满足要求，那么 Last Remainder chunk 将被切割为：</p><ul><li>一个 K 字节的 chunk，分配给用户</li><li>一个 N-K 字节的 chunk，成为新的 Last Remainder chunk</li></ul><p>它的存在使得连续的小空间内存申请，分配到的内存都是相邻的，从而达到了更好的局部性。</p><h2 id=bin-的结构>Bin 的结构</h2><p>bin 是实现了空闲链表的数据结构，用来存储空闲 chunk，可分为：</p><ul><li>10 个 fast bins，存储在 <code>fastbinsY</code> 中</li><li>1 个 unsorted bin，存储在 <code>bin[1]</code></li><li>62 个 small bins，存储在 <code>bin[2]</code> 至 <code>bin[63]</code></li><li>63 个 large bins，存储在 <code>bin[64]</code> 至 <code>bin[126]</code></li></ul><p>还是一个一个来看。</p><h3 id=fast-bins>fast bins</h3><p>非常像高速缓存 cache，主要用于提高小内存分配效率。相邻空闲 chunk 不会被合并，这会导致外部碎片增多但是 <code>free</code> 效率提升。注意 fast bins 是 10 个 <strong>LIFO 的单链表</strong>。最后三个链表保留未使用。</p><p>chunk 大小（含 chunk 头部）：0x10-0x40（64 位 0x20-0x80）B，相邻 bin 存放的大小相差 0x8（0x10）B。</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/6.png title="图 6｜fast bins" data-thumbnail=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/6.png data-sub-html="<h2> </h2><p>图 6｜fast bins</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/6.png data-srcset="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/6.png, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/6.png 1.5x, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/6.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/6.png></a><figcaption class=image-caption>图 6｜fast bins</figcaption></figure></p><blockquote><p>注：加入 fast bins 的 chunk，它的 <code>IN_USE</code> 位（准确地说，是下一个 chunk 的 <code>PREV_INUSE</code> 位）依然是 1。这就是为什么相邻的 “空闲”chunk 不会被合并，因为它们根本不会被认为是空闲的。</p></blockquote><p>关于 fastbin 最大大小，参见宏 <code>DEFAULT_MXFAST</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifndef DEFAULT_MXFAST
</span></span></span><span class=line><span class=cl><span class=cp>#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></td></tr></table></div></div><p>在初始化时，这个值会被赋值给全局变量 <code>global_max_fast</code>。</p><p>申请 fast chunk 时遵循 <code>first fit</code> 原则。释放一个 fast chunk 时，首先检查它的大小以及对应 fastbin 此时的第一个 chunk <code>old</code> 的大小是否合法，随后它会被插入到对应 fastbin 的链表头，此时其 <code>fd</code> 指向 <code>old</code>。</p><h3 id=unsorted-bin>unsorted bin</h3><p>非常像缓冲区 buffer，大小超过 fast bins 阈值的 chunk 被释放时会加入到这里，这使得 ptmalloc2 可以复用最近释放的 chunk，从而提升效率。</p><p>unsorted bin 是一个双向循环链表，chunk 大小：大于 <code>global_max_fast</code>。<figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/0.png title="图 7｜unsorted bin" data-thumbnail=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/0.png data-sub-html="<h2> </h2><p>图 7｜unsorted bin</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/0.png data-srcset="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/0.png, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/0.png 1.5x, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/0.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/0.png></a><figcaption class=image-caption>图 7｜unsorted bin</figcaption></figure></p><p>当程序申请大于 <code>global_max_fast</code> 内存时，分配器遍历 unsorted bin，每次取最后的一个 unsorted chunk。</p><ol><li><p>如果 unsorted chunk 满足以下四个条件，它就会被切割为一块满足申请大小的 chunk 和另一块剩下的 chunk，前者返回给程序，后者重新回到 unsorted bin。</p><ul><li>申请大小属于 small bin 范围</li><li>unosrted bin 中只有该 chunk</li><li>这个 chunk 同样也是 last remainder chunk</li><li>切割之后的大小依然可以作为一个 chunk</li></ul></li><li><p>否则，从 unsorted bin 中删除 unsorted chunk。</p><ul><li>若 unsorted chunk 恰好和申请大小相同，则直接返回这个 chunk</li><li>若 unsorted chunk 属于 small bin 范围，插入到相应 small bin</li><li>若 unsorted chunk 属于 large bin 范围，则跳转到 3。</li></ul></li><li><p>此时 unsorted chunk 属于 large bin 范围。</p><ul><li>若对应 large bin 为空，直接插入 unsorted chunk，其 <code>fd_nextsize</code> 与 <code>bk_nextsize</code> 指向自身。</li><li>否则，跳转到 4。</li></ul></li><li><p>到这一步，我们需按大小降序插入对应 large bin。</p><ul><li>若对应 large bin 最后一个 chunk 大于 unsorted chunk，则插入到最后</li><li>否则，从对应 large bin 第一个 chunk 开始，沿 <code>fd_nextsize</code>（即变小）方向遍历，直到找到一个 chunk <code>fwd</code>，其大小小于等于 unsorted chunk 的大小<ul><li>若 <code>fwd</code> 大小等于 unsorted chunk 大小，则插入到 <code>fwd</code> 后面</li><li>否则，插入到 <code>fwd</code> 前面</li></ul></li></ul></li></ol><p>直到找到满足要求的 unsorted chunk，或无法找到，去 top chunk 切割为止。</p><h3 id=small-bins>small bins</h3><p>小于 0x200（0x400）B 的 chunk 叫做 small chunk，而 small bins 可以存放的就是这些 small chunks。chunk 大小同样是从 16B 开始每次 + 8B。</p><p>small bins 是 62 个双向循环链表，并且是 FIFO 的，这点和 fast bins 相反。同样相反的是相邻的空闲 chunk 会被合并。</p><p>chunk 大小：0x10-0x1f0B（0x20-0x3f0），相邻 bin 存放的大小相差 0x8（0x10）B。</p><p>释放非 fast chunk 时，按以下步骤执行：</p><ol><li>若前一个相邻 chunk 空闲，则合并，触发对前一个相邻 chunk 的 <code>unlink</code> 操作</li><li>若下一个相邻 chunk 是 top chunk，则合并并结束；否则继续执行 3</li><li>若下一个相邻 chunk 空闲，则合并，触发对下一个相邻 chunk 的 <code>unlink</code> 操作；否则，设置下一个相邻 chunk 的 <code>PREV_INUSE</code> 为 <code>0</code></li><li>将现在的 chunk 插入 unsorted bin。</li><li>若 <code>size</code> 超过了 <code>FASTBIN_CONSOLIDATION_THRESHOLD</code>，则尽可能地合并 fastbin 中的 chunk，放入 unsorted bin。若 top chunk 大小超过了 <code>mp_.trim_threshold</code>，则归还部分内存给 OS。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifndef DEFAULT_TRIM_THRESHOLD
</span></span></span><span class=line><span class=cl><span class=cp>#define DEFAULT_TRIM_THRESHOLD (128 * 1024)
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)
</span></span></span></code></pre></td></tr></table></div></div><h3 id=large-bins>large bins</h3><p>大于等于 0x200（0x400）B 的 chunk 叫做 large chunk，而 large bins 可以存放的就是这些 large chunks。</p><p>large bins 是 63 个双向循环链表，插入和删除可以发生在任意位置，相邻空闲 chunk 也会被合并。chunk 大小就比较复杂了：</p><ul><li>前 32 个 bins：从 0x200B 开始每次 + 0x40B</li><li>接下来的 16 个 bins：每次 + 0x200B</li><li>接下来的 8 个 bins：每次 + 0x1000B</li><li>接下来的 4 个 bins：每次 + 0x8000B</li><li>接下来的 2 个 bins：每次 + 0x40000B</li><li>最后的 1 个 bin：只有一个 chunk，大小和 large bins 剩余的大小相同</li></ul><p>注意同一个 bin 中的 chunks 不是相同大小的，按大小降序排列。这和上面的几种 bins 都不一样。而在取出 chunk 时，也遵循 <code>best fit</code> 原则，取出满足大小的最小 chunk。</p><h2 id=内存分配流程>内存分配流程</h2><p>我觉得这类复杂的流程比较需要靠流程图来理解，因此我画了一下：</p><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/7.png title="图 8｜Procedure of malloc()" data-thumbnail=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/7.png data-sub-html="<h2> </h2><p>图 8｜Procedure of malloc()</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/7.png data-srcset="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/7.png, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/7.png 1.5x, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/7.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/7.png></a><figcaption class=image-caption>图 8｜Procedure of malloc()</figcaption></figure></p><p>相关宏：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define NBINS             128
</span></span></span><span class=line><span class=cl><span class=cp>#define NSMALLBINS         64
</span></span></span><span class=line><span class=cl><span class=cp>#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
</span></span></span><span class=line><span class=cl><span class=cp>#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT&gt; 2 * SIZE_SZ)
</span></span></span><span class=line><span class=cl><span class=cp>#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define in_smallbin_range(sz)  \
</span></span></span><span class=line><span class=cl><span class=cp>  ((unsigned long) (sz) &lt;(unsigned long) MIN_LARGE_SIZE)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#ifndef DEFAULT_MMAP_THRESHOLD_MIN
</span></span></span><span class=line><span class=cl><span class=cp>#define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#ifndef DEFAULT_MMAP_THRESHOLD
</span></span></span><span class=line><span class=cl><span class=cp>#define DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></td></tr></table></div></div><h2 id=内存释放流程>内存释放流程</h2><p><figure><a class=lightgallery href=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/8.png title="图 9｜Procedure of free()" data-thumbnail=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/8.png data-sub-html="<h2> </h2><p>图 9｜Procedure of free()</p>"><img class=lazyload src=/svg/loading.min.svg data-src=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/8.png data-srcset="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/8.png, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/8.png 1.5x, https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/8.png 2x" data-sizes=auto alt=https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GLibcHeap/8.png></a><figcaption class=image-caption>图 9｜Procedure of free()</figcaption></figure></p><h2 id=参考资料>参考资料</h2><ul><li><a href=https://heap-exploitation.dhavalkapil.com/ target=_blank rel="noopener noreffer">Heap Exploitation</a></li><li><a href=https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/ target=_blank rel="noopener noreffer">Understanding glibc malloc</a></li><li><a href=https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/ target=_blank rel="noopener noreffer">Syscalls used by malloc</a></li><li><a href=https://paper.seebug.org/papers/Archive/refs/heap/glibc%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86ptmalloc%e6%ba%90%e4%bb%a3%e7%a0%81%e5%88%86%e6%9e%90.pdf target=_blank rel="noopener noreffer">glibc 内存管理 ptmalloc 源代码分析</a></li><li><a href=https://sensepost.com/blog/2017/painless-intro-to-the-linux-userland-heap/ target=_blank rel="noopener noreffer">Painless intro to the Linux userland heap</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2019-12-08</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/linux/>Linux</a>,&nbsp;<a href=/tags/%E5%A0%86%E6%BC%8F%E6%B4%9E/>堆漏洞</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/binary-exp/ class=prev rel=prev title=水漫金山：《二进制漏洞利用入门》课程总结><i class="fas fa-angle-left fa-fw"></i>水漫金山：《二进制漏洞利用入门》课程总结</a>
<a href=/how2heap/ class=next rel=next title="how2heap 学习">how2heap 学习<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=valine class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://valine.js.org/>Valine</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.96.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2017 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Mercury</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/valine/valine.min.css><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/valine/Valine.min.js></script><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/algoliasearch/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:30},comment:{valine:{appId:"RkxCznUcvfzFBgfMiMr0BAfd-gzGzoHsz",appKey:"sw2sEPOl4haCAXKUFYiBFMrR",avatar:"mp",el:"#valine",emojiCDN:"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/",emojiMaps:{100:"1f4af.png",alien:"1f47d.png",anger:"1f4a2.png",angry:"1f620.png",anguished:"1f627.png",astonished:"1f632.png",black_heart:"1f5a4.png",blue_heart:"1f499.png",blush:"1f60a.png",bomb:"1f4a3.png",boom:"1f4a5.png",broken_heart:"1f494.png",brown_heart:"1f90e.png",clown_face:"1f921.png",cold_face:"1f976.png",cold_sweat:"1f630.png",confounded:"1f616.png",confused:"1f615.png",cry:"1f622.png",crying_cat_face:"1f63f.png",cupid:"1f498.png",dash:"1f4a8.png",disappointed:"1f61e.png",disappointed_relieved:"1f625.png",dizzy:"1f4ab.png",dizzy_face:"1f635.png",drooling_face:"1f924.png",exploding_head:"1f92f.png",expressionless:"1f611.png",face_vomiting:"1f92e.png",face_with_cowboy_hat:"1f920.png",face_with_hand_over_mouth:"1f92d.png",face_with_head_bandage:"1f915.png",face_with_monocle:"1f9d0.png",face_with_raised_eyebrow:"1f928.png",face_with_rolling_eyes:"1f644.png",face_with_symbols_on_mouth:"1f92c.png",face_with_thermometer:"1f912.png",fearful:"1f628.png",flushed:"1f633.png",frowning:"1f626.png",ghost:"1f47b.png",gift_heart:"1f49d.png",green_heart:"1f49a.png",grimacing:"1f62c.png",grin:"1f601.png",grinning:"1f600.png",hankey:"1f4a9.png",hear_no_evil:"1f649.png",heart:"2764-fe0f.png",heart_decoration:"1f49f.png",heart_eyes:"1f60d.png",heart_eyes_cat:"1f63b.png",heartbeat:"1f493.png",heartpulse:"1f497.png",heavy_heart_exclamation_mark_ornament:"2763-fe0f.png",hole:"1f573-fe0f.png",hot_face:"1f975.png",hugging_face:"1f917.png",hushed:"1f62f.png",imp:"1f47f.png",innocent:"1f607.png",japanese_goblin:"1f47a.png",japanese_ogre:"1f479.png",joy:"1f602.png",joy_cat:"1f639.png",kiss:"1f48b.png",kissing:"1f617.png",kissing_cat:"1f63d.png",kissing_closed_eyes:"1f61a.png",kissing_heart:"1f618.png",kissing_smiling_eyes:"1f619.png",laughing:"1f606.png",left_speech_bubble:"1f5e8-fe0f.png",love_letter:"1f48c.png",lying_face:"1f925.png",mask:"1f637.png",money_mouth_face:"1f911.png",nauseated_face:"1f922.png",nerd_face:"1f913.png",neutral_face:"1f610.png",no_mouth:"1f636.png",open_mouth:"1f62e.png",orange_heart:"1f9e1.png",partying_face:"1f973.png",pensive:"1f614.png",persevere:"1f623.png",pleading_face:"1f97a.png",pouting_cat:"1f63e.png",purple_heart:"1f49c.png",rage:"1f621.png",relaxed:"263a-fe0f.png",relieved:"1f60c.png",revolving_hearts:"1f49e.png",right_anger_bubble:"1f5ef-fe0f.png",robot_face:"1f916.png",rolling_on_the_floor_laughing:"1f923.png",scream:"1f631.png",scream_cat:"1f640.png",see_no_evil:"1f648.png",shushing_face:"1f92b.png",skull:"1f480.png",skull_and_crossbones:"2620-fe0f.png",sleeping:"1f634.png",sleepy:"1f62a.png",slightly_frowning_face:"1f641.png",slightly_smiling_face:"1f642.png",smile:"1f604.png",smile_cat:"1f638.png",smiley:"1f603.png",smiley_cat:"1f63a.png",smiling_face_with_3_hearts:"1f970.png",smiling_imp:"1f608.png",smirk:"1f60f.png",smirk_cat:"1f63c.png",sneezing_face:"1f927.png",sob:"1f62d.png",space_invader:"1f47e.png",sparkling_heart:"1f496.png",speak_no_evil:"1f64a.png",speech_balloon:"1f4ac.png","star-struck":"1f929.png",stuck_out_tongue:"1f61b.png",stuck_out_tongue_closed_eyes:"1f61d.png",stuck_out_tongue_winking_eye:"1f61c.png",sunglasses:"1f60e.png",sweat:"1f613.png",sweat_drops:"1f4a6.png",sweat_smile:"1f605.png",thinking_face:"1f914.png",thought_balloon:"1f4ad.png",tired_face:"1f62b.png",triumph:"1f624.png",two_hearts:"1f495.png",unamused:"1f612.png",upside_down_face:"1f643.png",weary:"1f629.png",white_frowning_face:"2639-fe0f.png",white_heart:"1f90d.png",wink:"1f609.png",woozy_face:"1f974.png",worried:"1f61f.png",yawning_face:"1f971.png",yellow_heart:"1f49b.png",yum:"1f60b.png",zany_face:"1f92a.png",zipper_mouth_face:"1f910.png",zzz:"1f4a4.png"},enableQQ:!1,highlight:!0,lang:"zh-cn",pageSize:10,placeholder:"你的评论 ...",recordIP:!1,visitor:!0}},lightGallery:{actualSize:!1,exThumbImage:"data-thumbnail",hideBarsDelay:2e3,selector:".lightgallery",speed:400,thumbContHeight:80,thumbWidth:80,thumbnail:!0},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"P149SBLX5U",algoliaIndex:"blog",algoliaSearchKey:"cbd5db1f3910ee11bc18688f21b64bd4",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>