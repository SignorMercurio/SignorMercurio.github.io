<!doctype html><html lang=zh dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="zh"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>水漫金山：《二进制漏洞利用入门》课程总结 &#183; Lab on Mercury</title><meta name=title content="水漫金山：《二进制漏洞利用入门》课程总结 &#183; Lab on Mercury"><meta name=description content="Lab on Mercury"><link rel=canonical href=https://blog.sigmerc.top/posts/binary-exp/><link type=text/css rel=stylesheet href=/css/main.bundle.min.32ddf7dee8011260365c3436dd92254eeda3ec27bea2822527e6cb67f6ede1ff17904557445f0f6747a03b5aa59bbf754e43fc9b0c77b1cd957ef7061fd0c6d2.css integrity="sha512-Mt333ugBEmA2XDQ23ZIlTu2j7Ce+ooIlJ+bLZ/bt4f8XkEVXRF8PZ0egO1qlm791TkP8mwx3sc2VfvcGH9DG0g=="><script type=text/javascript src=/js/appearance.min.badab316c9287a5a42a843e4eb45da65bb3d194a5a0f5fa4a3e516160e67df0b8c65f4f19a8e146436e29d583699e6cb41d6bbe99e05e1dbaa877763bad9f8e2.js integrity="sha512-utqzFskoelpCqEPk60XaZbs9GUpaD1+ko+UWFg5n3wuMZfTxmo4UZDbinVg2mebLQda76Z4F4duqh3djutn44g=="></script>
<script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.15ae6e2c9b1ac24a9ccf40003fa689efb1a18db1ee9b73d780b01a6c31b150441415862513e93184f68fe385759e4698b8763cba6a0f79493c1fed99ad5868d4.js integrity="sha512-Fa5uLJsawkqcz0AAP6aJ77GhjbHum3PXgLAabDGxUEQUFYYlE+kxhPaP44V1nkaYuHY8umoPeUk8H+2ZrVho1A==" data-copy=Copy data-copied=Copied></script>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:title" content="水漫金山：《二进制漏洞利用入门》课程总结"><meta property="og:description" content="其实我也刚学。"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.sigmerc.top/posts/binary-exp/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-12-05T22:37:20+00:00"><meta property="article:modified_time" content="2022-06-23T14:51:02+08:00"><meta property="og:site_name" content="Lab on Mercury"><meta name=twitter:card content="summary"><meta name=twitter:title content="水漫金山：《二进制漏洞利用入门》课程总结"><meta name=twitter:description content="其实我也刚学。"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"水漫金山：《二进制漏洞利用入门》课程总结","headline":"水漫金山：《二进制漏洞利用入门》课程总结","abstract":"\u003cp\u003e其实我也刚学。\u003c\/p\u003e","inLanguage":"zh","url":"https:\/\/blog.sigmerc.top\/posts\/binary-exp\/","author":{"@type":"Person","name":"Mercury"},"copyrightYear":"2019","dateCreated":"2019-12-05T22:37:20\u002b00:00","datePublished":"2019-12-05T22:37:20\u002b00:00","dateModified":"2022-06-23T14:51:02\u002b08:00","keywords":["整数溢出","栈漏洞","fsb"],"mainEntityOfPage":"true","wordCount":"1704"}]</script><meta name=author content="Mercury"><link href=mailto:signormercurio@gmail.com rel=me><link href=https://github.com/SignorMercurio rel=me><link href=https://t.me/m9r_at_tG rel=me></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 bg-neutral text-neutral-900 sm:px-14 md:px-24 lg:px-32 dark:bg-neutral-800 dark:text-neutral max-w-7xl"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 dark:bg-neutral-600 focus:translate-y-0" href=#main-content><span class="font-bold ltr:pr-2 rtl:pl-2 text-primary-600 dark:text-primary-400">&darr;</span>Skip to main content</a></div><header class="py-6 font-semibold sm:py-10 text-neutral-900 dark:text-neutral print:hidden"><nav class="flex justify-between"><div><span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentcolor" d="M112.1 454.3c0 6.297 1.816 12.44 5.284 17.69l17.14 25.69c5.25 7.875 17.17 14.28 26.64 14.28h61.67c9.438.0 21.36-6.401 26.61-14.28l17.08-25.68c2.938-4.438 5.348-12.37 5.348-17.7L272 415.1H112L112.1 454.3zM191.4.0132C89.44.3257 16 82.97 16 175.1c0 44.38 16.44 84.84 43.56 115.8 16.53 18.84 42.34 58.23 52.22 91.45.0313.25.0938.5166.125.7823h160.2c.0313-.2656.0938-.5166.125-.7823 9.875-33.22 35.69-72.61 52.22-91.45C351.6 260.8 368 220.4 368 175.1 368 78.61 288.9-.2837 191.4.0132zM192 96.01c-44.13.0-80 35.89-80 79.1.0 9.69-7.2 16.89-16 16.89S80 184.8 80 176c0-61.76 50.25-111.1 112-111.1 8.844.0 16 7.159 16 16S200.8 96.01 192 96.01z"/></svg></span><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" rel=me href=/>Lab on Mercury</a></div><ul class="flex flex-col list-none ltr:text-right rtl:text-left sm:flex-row"><li class="mb-1 sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/posts/ title=Posts>文章</a></li><li class="mb-1 sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/categories/ title=Categories>分类</a></li><li class="mb-1 sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=/tags/ title=Tags>标签</a></li><li class="ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><button id=search-button class="text-base hover:text-primary-600 dark:hover:text-primary-400" title="Search (/)">
<span class="relative inline-block align-text-bottom icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button></li></ul></nav></header><div class="relative flex flex-col grow"><main id=main-content class=grow><article><header class=max-w-prose><ol class="text-sm text-neutral-500 dark:text-neutral-400 print:hidden"><li class="inline hidden"><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/>Lab on Mercury</a><span class="px-1 text-primary-500">/</span></li><li class=inline><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/posts/>Posts</a><span class="px-1 text-primary-500">/</span></li><li class="inline hidden"><a class="hover:underline decoration-neutral-300 dark:underline-neutral-600" href=/posts/binary-exp/>水漫金山：《二进制漏洞利用入门》课程总结</a><span class="px-1 text-primary-500">/</span></li></ol><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">水漫金山：《二进制漏洞利用入门》课程总结</h1><div class="mt-8 mb-12 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2019-12-05 22:37:20 +0000 UTC">2019-12-05</time><span class="px-2 text-primary-500">&#183;</span><time datetime="2022-06-23 14:51:02 +0800 +0800">Updated: 2022-06-23</time></div><div class="my-1 text-xs text-neutral-500 dark:text-neutral-400"><a href=/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/ class="px-1 py-[1px] border rounded-md border-neutral-200 dark:border-neutral-600 hover:border-primary-300 hover:text-primary-700 dark:hover:border-primary-600 dark:hover:text-primary-400">二进制安全</a>
<a href=/tags/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/ class="px-1 py-[1px] border rounded-md border-neutral-200 dark:border-neutral-600 hover:border-primary-300 hover:text-primary-700 dark:hover:border-primary-600 dark:hover:text-primary-400">整数溢出</a>
<a href=/tags/%E6%A0%88%E6%BC%8F%E6%B4%9E/ class="px-1 py-[1px] border rounded-md border-neutral-200 dark:border-neutral-600 hover:border-primary-300 hover:text-primary-700 dark:hover:border-primary-600 dark:hover:text-primary-400">栈漏洞</a>
<a href=/tags/fsb/ class="px-1 py-[1px] border rounded-md border-neutral-200 dark:border-neutral-600 hover:border-primary-300 hover:text-primary-700 dark:hover:border-primary-600 dark:hover:text-primary-400">fsb</a></div></div></header><section class="flex flex-col max-w-full mt-0 prose lg:flex-row dark:prose-invert"><div class="order-first px-0 lg:max-w-xs ltr:lg:pl-8 rtl:lg:pr-8 lg:order-last"><div class="ltr:pl-5 rtl:pr-5 toc lg:sticky lg:top-10 print:hidden"><details open class="mt-0 sideNav rounded-lg rtl:pr-5 ltr:pl-5 ltr:-ml-5 rtl:-mr-5 lg:mt-3"><summary class="block sticky top-0 py-1 text-lg font-semibold cursor-pointer rtl:pr-5 ltr:pl-5 ltr:-ml-5 rtl:-mr-5 text-neutral-800 dark:text-neutral-100 lg:hidden bg-neutral-100 dark:bg-neutral-700">Table of Contents</summary><div class="py-2 pr-2 border-dotted ltr:border-l rtl:border-r rtl:pr-5 ltr:pl-5 ltr:-ml-5 rtl:-mr-5 border-neutral-300 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#pwn-简介>Pwn 简介</a><ul><li><a href=#什么是-pwn>什么是 Pwn？</a></li><li><a href=#pwn-概览>Pwn 概览</a></li><li><a href=#pwn-实例>Pwn 实例</a></li></ul></li><li><a href=#整型溢出>整型溢出</a></li><li><a href=#linux-基础>Linux 基础</a><ul><li><a href=#目录管理>目录管理</a></li><li><a href=#文件操作>文件操作</a></li><li><a href=#用户管理>用户管理</a></li><li><a href=#工作命令>工作命令</a></li><li><a href=#特性>特性</a></li></ul></li><li><a href=#c-程序运行机制>C 程序运行机制</a></li><li><a href=#c-语言函数调用栈>C 语言函数调用栈</a><ul><li><a href=#调用>调用</a></li><li><a href=#返回>返回</a></li></ul></li><li><a href=#gdb-简介>gdb 简介</a></li><li><a href=#缓冲区溢出漏洞栈溢出>缓冲区溢出漏洞——栈溢出</a></li><li><a href=#pwn-相关工具>Pwn 相关工具</a></li><li><a href=#花式栈溢出>花式栈溢出</a><ul><li><a href=#ret2text>ret2text</a></li><li><a href=#ret2shellcode>ret2shellcode</a></li></ul></li><li><a href=#栈溢出保护>栈溢出保护</a></li><li><a href=#x86-汇编>x86 汇编</a><ul><li><a href=#重要寄存器>重要寄存器</a></li><li><a href=#数据操作>数据操作</a></li><li><a href=#条件跳转>条件跳转</a></li><li><a href=#函数调用>函数调用</a></li><li><a href=#例计算字符串长度>例：计算字符串长度</a></li></ul></li><li><a href=#x86-64-汇编>x86-64 汇编</a></li><li><a href=#花式栈溢出续>花式栈溢出：续</a><ul><li><a href=#泄露-canary>泄露 canary</a></li><li><a href=#got--plt>GOT & PLT</a></li><li><a href=#ret2libc>ret2libc</a></li><li><a href=#rop--ret2syscall>ROP & ret2syscall</a></li><li><a href=#got-hijacking>GOT Hijacking</a></li></ul></li><li><a href=#格式化字符串漏洞>格式化字符串漏洞</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></details></div></div><div class="min-w-0 min-h-0 max-w-prose"><figure><img class="my-0 rounded-md" src=0.png alt=featuredImage></figure><p>其实我也刚学。</p><p>本课程主要介绍对于远程服务进行二进制层面的漏洞利用（也称 <code>Pwn</code>）的基础技巧，使用的编程语言主要包括 C 语言、汇编语言和 Python 语言，涉及的平台包括 32 位与 64 位 Linux 操作系统。内容包含：</p><ul><li>Pwn 简介</li><li>整型溢出漏洞</li><li>Linux 基础</li><li>C 程序运行机制</li><li>C 语言函数调用栈</li><li>缓冲区溢出漏洞——栈溢出</li><li>Pwn 相关工具</li><li>x86(-64) 汇编基础</li><li>花式栈溢出与栈溢出保护</li><li>格式化字符串漏洞</li></ul><p>时间有限，课程仅介绍了二进制安全中最基础的三类漏洞及其利用：整型溢出、栈溢出与格式化字符串漏洞。</p><h2 id=pwn-简介 class="relative group">Pwn 简介 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#pwn-%e7%ae%80%e4%bb%8b aria-label=锚点>#</a></span></h2><h3 id=什么是-pwn class="relative group">什么是 Pwn？ <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e4%bb%80%e4%b9%88%e6%98%af-pwn aria-label=锚点>#</a></span></h3><blockquote><p>&ldquo;pwn&rdquo; - means to compromise or control, specifically another computer (server or PC), web site, gateway device, or application. It is synonymous with one of the definitions of hacking or cracking, including iOS jailbreaking.  -  Wikipedia.</p></blockquote><h3 id=pwn-概览 class="relative group">Pwn 概览 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#pwn-%e6%a6%82%e8%a7%88 aria-label=锚点>#</a></span></h3><ul><li>GLIBC Pwn<ul><li>Linux 下内存管理相关</li></ul></li><li>Browser Pwn<ul><li>浏览器相关</li></ul></li><li>Kernel Pwn<ul><li>Windows Kernel</li><li>Linux Kernel</li></ul></li></ul><h3 id=pwn-实例 class="relative group">Pwn 实例 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#pwn-%e5%ae%9e%e4%be%8b aria-label=锚点>#</a></span></h3><p>包括但不限于：Web 框架、OS 内核、浏览器、路由器等设备……</p><ul><li>CVE-2017-5638<ul><li>Apache Struts2 远程代码执行</li></ul></li><li>CVE-2019-9213<ul><li>Linux 内核用户空间 0 虚拟地址映射</li></ul></li><li>CVE-2019-11707<ul><li>64 位火狐浏览器任意读写 + 代码执行</li></ul></li><li>CVE-2018-5767<ul><li>TENDA AC15 路由器权远程代码执行</li></ul></li><li>……</li></ul><h2 id=整型溢出 class="relative group">整型溢出 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%95%b4%e5%9e%8b%e6%ba%a2%e5%87%ba aria-label=锚点>#</a></span></h2><p>例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>x</span> <span class=o>=</span> <span class=mh>0xff</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>++</span><span class=n>x</span><span class=p>);</span>
</span></span></code></pre></div><p>考虑这里的 <code>++x</code>，二进制表示实际就是：</p><pre tabindex=0><code>1111 1111 + 1 = 1 0000 0000
</code></pre><p>然而，<code>unsigned char</code> 是 1 字节即 8 比特的，上面的结果却是 9 比特，那么对于最高位的 <code>1</code> 只能舍弃，因此有：</p><pre tabindex=0><code>(0xff+1) mod 256 = 0
</code></pre><p>也就是说，程序的执行结果为 0。<code>0xff</code> 这样的大数加 1 后变成了 0，显然不是我们预期的结果。类似地，对于：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>signed</span> <span class=kt>char</span> <span class=n>x</span> <span class=o>=</span> <span class=mh>0x7f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>++</span><span class=n>x</span><span class=p>);</span>
</span></span></code></pre></div><p>这里的 <code>++x</code> 就是：</p><pre tabindex=0><code>0111 1111 + 1 = 1000 0000
</code></pre><p>幸运的是，这次没有出现多出一比特的情况。然而对于 <code>signed char</code>，我们知道其最高位是符号位，换而言之我们的结果是一个负数。</p><pre tabindex=0><code>0x7f+1 = 0x80 = -(unsigned char) 1000 0000 = -128
</code></pre><p>注意这里的补码运算。</p><p>整型溢出漏洞原理非常简单，其造成的危害却是十分隐蔽的，例如，我们有时会这样倒序遍历字符串：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=o>--</span><span class=n>i</span><span class=p>)</span>
</span></span></code></pre></div><p>这样写会引起编译器 warning，因为将无符号类型转换到了有符号类型。为什么会这样？我们来看一下 <code>strlen</code> 函数的定义：</p><pre tabindex=0><code>size_t strlen (const char * str)
</code></pre><p>返回值是 <code>size_t</code> 类型，我们可以将它等效为 <code>unsigned int</code> 类型。</p><p>现在考虑 <code>s</code> 是一个空串时的情况，这时 <code>i</code> 的初始值是什么？</p><p>你可能会认为是 - 1。实际上，由于 <code>strlen</code> 的返回值是无符号的，那么它减 1 的结果同样会被认为是无符号的，那么 <code>i</code> 被赋值的实际上是 <code>(size_t)(-1)</code>，也就是一个很大的正数。此时必然会发生数组越界。</p><p>一个更常见的错误是这样的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>binary_search</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>low</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>high</span> <span class=o>=</span> <span class=n>len</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>low</span><span class=o>&lt;=</span><span class=n>high</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span> <span class=o>+</span> <span class=n>high</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>key</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>mid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>key</span> <span class=o>&lt;</span> <span class=n>a</span><span class=p>[</span><span class=n>mid</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>high</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>low</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这不就是最普通的二分查找写法吗？的确，但是即使我们确保 <code>low</code> 和 <code>high</code> 不溢出，<code>low+high</code> 的结果依然可能溢出，而此时 <code>mid</code> 会变成一个负数，造成越界。</p><p>而且，整型溢出不仅在 C 语言中存在。在最近的一次 <a href=https://blog.sigmerc.top/hackergame2019/>中科大比赛</a> 中我们就遇到了对 js 整型溢出的利用。</p><h2 id=linux-基础 class="relative group">Linux 基础 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#linux-%e5%9f%ba%e7%a1%80 aria-label=锚点>#</a></span></h2><p>课程的第二部分介绍了一些 Linux 相关基础。Linux 是一个开源的 OS 内核，基于 C 和汇编编写，可执行文件格式是 ELF 格式，这也是我们后面要主要研究的。这里附上一个非常有趣的 <a href=http://overthewire.org/wargames/bandit/>Linux 练习网站</a>。</p><p>安装与配置请自行搜索，推荐使用虚拟机安装。课程使用的发行版是 <code>Ubuntu 16.04LTS</code>，不过最近发现哈佛的 <a href=https://ide.cs50.io/>CS50 IDE</a> 也非常好用。</p><p>下面是一些基础 Linux 命令：</p><h3 id=目录管理 class="relative group">目录管理 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e7%9b%ae%e5%bd%95%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h3><ul><li><code>ls</code><ul><li>列出当前目录下文件</li><li><code>-a</code> 列出所有文件（包括隐藏的）</li><li><code>-l</code> 详细信息</li></ul></li><li><code>cd [path]</code><ul><li>改变目录到 <code>path</code></li><li><code>.</code> 当前目录</li><li><code>..</code> 上级目录</li></ul></li><li><code>pwd</code><ul><li>显示当前目录</li></ul></li></ul><h3 id=文件操作 class="relative group">文件操作 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c aria-label=锚点>#</a></span></h3><ul><li><code>cat [file]</code><ul><li>显示文件 <code>file</code> 的内容</li></ul></li><li><code>more [file]</code><ul><li>类似 <code>cat</code>，但对于长文件可以分页显示</li></ul></li><li><code>mv [file1] [file2]</code><ul><li>把 <code>file1</code> 移动到 <code>file2</code>，如果后者已存在则覆盖</li></ul></li><li><code>cp [file1] [file2]</code><ul><li>将 <code>file1</code> 复制到 <code>file2</code>，如果后者已存在则覆盖</li></ul></li><li><code>rm [file]</code><ul><li>删除文件 <code>file</code></li></ul></li><li><code>touch [file]</code><ul><li>创建文件 <code>file</code>，或更新文件 <code>file</code> 的修改时间</li></ul></li><li><code>mkdir [directory]</code><ul><li>创建目录 <code>directory</code></li></ul></li><li><code>chmod [file]</code><ul><li>改变文件 <code>file</code> 的权限</li></ul></li></ul><h3 id=用户管理 class="relative group">用户管理 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e7%94%a8%e6%88%b7%e7%ae%a1%e7%90%86 aria-label=锚点>#</a></span></h3><ul><li><code>sudo</code><ul><li>以管理员权限执行命令</li></ul></li><li><code>su [user]</code><ul><li>切换到用户 <code>user</code></li></ul></li><li><code>whoami</code><ul><li>显示当前用户用户名</li></ul></li><li><code>id</code><ul><li>显示当前用户 ID 和所在用户组 ID</li></ul></li><li><code>passwd</code><ul><li>更改当前用户密码</li></ul></li></ul><h3 id=工作命令 class="relative group">工作命令 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e5%b7%a5%e4%bd%9c%e5%91%bd%e4%bb%a4 aria-label=锚点>#</a></span></h3><ul><li><code>date</code><ul><li>显示当前系统时间</li></ul></li><li><code>ps</code><ul><li>显示当前运行进程</li></ul></li><li><code>uname</code><ul><li>显示系统相关信息</li></ul></li><li><code>echo "hello"</code><ul><li>在终端中显示 <code>hello</code></li><li><code>echo $((0xDEADBEEF))</code></li></ul></li><li><code>grep "hello"</code><ul><li>查找含有 <code>hello</code> 的行并显示</li></ul></li></ul><h3 id=特性 class="relative group">特性 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e7%89%b9%e6%80%a7 aria-label=锚点>#</a></span></h3><ul><li>管道：从一个程序中获取输出，作为另一个程序的输入<ul><li><code>echo "hello" | /usr/games/cowsay</code></li><li><code>echo "hello" | /usr/games/cowsay | grep "hello"</code></li></ul></li><li>重定向：指定输入输出的来源，而不是直接读 <code>stdin</code> 写 <code>stdout</code><ul><li><code>echo "hello" | /usr/games/cowsay > cowsay</code></li><li><code>echo "hello" > cowsay</code></li><li><code>echo "hello" >> cowsay</code></li></ul></li><li><code>man [command]</code><ul><li>显示命令 <code>command</code> 的说明</li></ul></li><li>方向 ↑ 键：上一条命令</li><li>Tab 键：自动补全命令</li></ul><p>这里通过 pwnable.kr 上的 <code>cmd1</code>，<code>cmd2</code> 和 <code>blukat</code> 三题，演示了 Linux 下的一些小把戏。</p><h2 id=c-程序运行机制 class="relative group">C 程序运行机制 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#c-%e7%a8%8b%e5%ba%8f%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6 aria-label=锚点>#</a></span></h2><p>以 <code>Hello World</code> 程序为例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Hello World!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个程序到底是怎么运行起来的？我们分三步介绍：</p><ol><li>源代码被编译为机器语言，随后汇编为目标文件</li><li>目标文件中引入相关依赖，链接为可执行文件（ELF）</li><li>可执行文件载入内存并运行</li></ol><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/1_hub02bcad69d83f348600eb5b92d8bbf3d_164572_330x0_resize_box_3.png 330w,
/posts/binary-exp/1_hub02bcad69d83f348600eb5b92d8bbf3d_164572_660x0_resize_box_3.png 660w,
/posts/binary-exp/1_hub02bcad69d83f348600eb5b92d8bbf3d_164572_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/1_hub02bcad69d83f348600eb5b92d8bbf3d_164572_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/1_hub02bcad69d83f348600eb5b92d8bbf3d_164572_660x0_resize_box_3.png alt="图 1"></figure></p><p>编译一个程序非常简单，如果你的源代码是 <code>1.c</code>，那么只需要 <code>gcc 1.c</code> 就能生成一个叫做 <code>a.out</code> 的 ELF 文件，你也可以用 <code>-o</code> 选项来设置 ELF 文件的名字。</p><p>我们所要研究的就是 ELF 文件中究竟有什么。首先是 ELF 文件头，包含了 ELF 文件的许多元数据，我们可以用 <code>readelf -h a.out</code> 来查看：</p><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/2_hu0001b10a6998faa6400d4cd5ec97c787_110220_330x0_resize_box_3.png 330w,
/posts/binary-exp/2_hu0001b10a6998faa6400d4cd5ec97c787_110220_660x0_resize_box_3.png 660w,
/posts/binary-exp/2_hu0001b10a6998faa6400d4cd5ec97c787_110220_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/2_hu0001b10a6998faa6400d4cd5ec97c787_110220_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/2_hu0001b10a6998faa6400d4cd5ec97c787_110220_660x0_resize_box_3.png alt="图 2"></figure></p><p>ELF 文件的内容则是由一个个段 (segment) 组成的，如：</p><ul><li>文本段 text segment<ul><li>程序的代码就在这里</li></ul></li><li>数据段 data segment<ul><li>存储了程序中变量的数据等等</li></ul></li><li>重定位段 reloc<ul><li>包含重定位信息，之后会具体讨论</li></ul></li><li>符号表 symbol table<ul><li>存储了变量名、函数名等信息</li></ul></li><li>字符串表 string table<ul><li>存储了只读字符串等信息</li></ul></li></ul><p><code>objdump -s a.out</code> 可以帮助我们查看这些段的信息：</p><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/3_hu4f0aec29b343b7f0a9be38981dc1a7ea_234667_330x0_resize_box_3.png 330w,
/posts/binary-exp/3_hu4f0aec29b343b7f0a9be38981dc1a7ea_234667_660x0_resize_box_3.png 660w,
/posts/binary-exp/3_hu4f0aec29b343b7f0a9be38981dc1a7ea_234667_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/3_hu4f0aec29b343b7f0a9be38981dc1a7ea_234667_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/3_hu4f0aec29b343b7f0a9be38981dc1a7ea_234667_660x0_resize_box_3.png alt="图 3"></figure></p><p>而如果要查看其中的汇编代码，就需要靠 <code>objdump -d a.out</code> 了：</p><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/4_huac35ae437ef3a74f8777e43a51d318ce_69450_330x0_resize_box_3.png 330w,
/posts/binary-exp/4_huac35ae437ef3a74f8777e43a51d318ce_69450_660x0_resize_box_3.png 660w,
/posts/binary-exp/4_huac35ae437ef3a74f8777e43a51d318ce_69450_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/4_huac35ae437ef3a74f8777e43a51d318ce_69450_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/4_huac35ae437ef3a74f8777e43a51d318ce_69450_660x0_resize_box_3.png alt="图 4"></figure></p><p>我们注意到，上图中 <code>put@plt</code> 的地址是 <code>ff ff</code>，这是因为程序还没有进行第二步——链接。现在的 C 程序默认采用动态链接的方式，是因为传统静态链接容易造成重复链接比较浪费，同时也十分难维护。而动态链接会在运行时才进行链接。</p><p>最后，当我们 <code>./a.out</code> 运行程序时，可执行文件会被载入内存，不同的段将被分配不同的虚拟地址，并映射到对应的物理地址。当程序计数器指向了代码段的起始位置之后，我们的程序也就准备好开始运行了。</p><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/5_hu657426a4ca9230c44a1ac8cdca46016a_160617_330x0_resize_box_3.png 330w,
/posts/binary-exp/5_hu657426a4ca9230c44a1ac8cdca46016a_160617_660x0_resize_box_3.png 660w,
/posts/binary-exp/5_hu657426a4ca9230c44a1ac8cdca46016a_160617_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/5_hu657426a4ca9230c44a1ac8cdca46016a_160617_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/5_hu657426a4ca9230c44a1ac8cdca46016a_160617_660x0_resize_box_3.png alt="图 5"></figure></p><p>上图展示了虚拟地址是如何映射到物理地址的，同时也展示出 ELF 文件中的两个特殊的段：<code>heap</code> 段与 <code>stack</code> 段的生长方式。可以看到，堆是从低地址向高地址生长的，而栈是从高地址向低地址生长。但是，数据的存储却是从低地址向高地址存储，这也是我们能够实施栈溢出攻击的基础。</p><h2 id=c-语言函数调用栈 class="relative group">C 语言函数调用栈 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#c-%e8%af%ad%e8%a8%80%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e6%a0%88 aria-label=锚点>#</a></span></h2><p>C 程序运行过程中，会持续地维护这个 <code>stack</code> 段也就是栈，用来控制函数调用的流程。当发生函数调用时，栈的主要任务是保存调用者函数 caller 的状态，并创建被调用函数 callee 的状态，这里的 “状态” 在栈上被称为栈帧，每个栈帧之间是相互独立的。</p><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/6_hu77c11b444b7b5cb1a13a33f4e63dd068_76961_330x0_resize_box_3.png 330w,
/posts/binary-exp/6_hu77c11b444b7b5cb1a13a33f4e63dd068_76961_660x0_resize_box_3.png 660w,
/posts/binary-exp/6_hu77c11b444b7b5cb1a13a33f4e63dd068_76961_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/6_hu77c11b444b7b5cb1a13a33f4e63dd068_76961_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/6_hu77c11b444b7b5cb1a13a33f4e63dd068_76961_660x0_resize_box_3.png alt="图 6"></figure></p><h3 id=调用 class="relative group">调用 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e8%b0%83%e7%94%a8 aria-label=锚点>#</a></span></h3><p>在调用一个函数时，首先会将函数的参数<strong>按倒序</strong>压入栈中：</p><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/7_hu1cd49d943bb4ac74850f967acec942a8_63945_330x0_resize_box_3.png 330w,
/posts/binary-exp/7_hu1cd49d943bb4ac74850f967acec942a8_63945_660x0_resize_box_3.png 660w,
/posts/binary-exp/7_hu1cd49d943bb4ac74850f967acec942a8_63945_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/7_hu1cd49d943bb4ac74850f967acec942a8_63945_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/7_hu1cd49d943bb4ac74850f967acec942a8_63945_660x0_resize_box_3.png alt="图 7"></figure></p><p>注意图中栈是向下生长的，下面的 <code>esp</code> 寄存器指向<strong>栈顶</strong>，而上面的 <code>ebp</code> 寄存器指向当前运行函数的栈帧的<strong>底部</strong>，也就是栈帧开始的地方。</p><p>接下来压入函数返回地址。当函数调用结束后，函数必定需要返回到调用它的语句的下一句处，但是它怎么知道它要返回到哪里？这只能由我们告诉他，方式就是存储到栈上。</p><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/8_hueb8581f83d88e013514f26dded07715b_69443_330x0_resize_box_3.png 330w,
/posts/binary-exp/8_hueb8581f83d88e013514f26dded07715b_69443_660x0_resize_box_3.png 660w,
/posts/binary-exp/8_hueb8581f83d88e013514f26dded07715b_69443_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/8_hueb8581f83d88e013514f26dded07715b_69443_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/8_hueb8581f83d88e013514f26dded07715b_69443_660x0_resize_box_3.png alt="图 8"></figure></p><p>这里存储到栈上的值实际上就是 caller 的 <code>eip</code>。<code>eip</code> 寄存器保存了 CPU 当前执行的指令的<strong>下一条指令</strong>的地址。</p><p>随后，我们压入 caller 的 <code>ebp</code>，并更新 <code>ebp</code> 的值。后者很好理解，因为我们现在进入到了 callee 这个函数了，栈帧基址当然也要跟着变化，那么前者是为什么呢？我们会在函数返回时发现这样做的原因。</p><p>最后就是压入局部变量了，这一步没有太多可以解释的。</p><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/0_hu7d2533cb0a55ce884f0079bbfd042961_57986_330x0_resize_box_3.png 330w,
/posts/binary-exp/0_hu7d2533cb0a55ce884f0079bbfd042961_57986_660x0_resize_box_3.png 660w,
/posts/binary-exp/0_hu7d2533cb0a55ce884f0079bbfd042961_57986_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/0_hu7d2533cb0a55ce884f0079bbfd042961_57986_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/0_hu7d2533cb0a55ce884f0079bbfd042961_57986_660x0_resize_box_3.png alt="图 9"></figure></p><h3 id=返回 class="relative group">返回 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e8%bf%94%e5%9b%9e aria-label=锚点>#</a></span></h3><p>函数返回的第一步就是弹出局部变量，依然很简单：</p><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/9_hu16c7768af50ee8aff2a3e30a39511df5_67645_330x0_resize_box_3.png 330w,
/posts/binary-exp/9_hu16c7768af50ee8aff2a3e30a39511df5_67645_660x0_resize_box_3.png 660w,
/posts/binary-exp/9_hu16c7768af50ee8aff2a3e30a39511df5_67645_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/9_hu16c7768af50ee8aff2a3e30a39511df5_67645_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/9_hu16c7768af50ee8aff2a3e30a39511df5_67645_660x0_resize_box_3.png alt="图 10"></figure></p><p>第二步，我们要取出 caller 的 <code>ebp</code> 值并赋值给 <code>ebp</code>：</p><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/10_hube7823136868944f10e4b20b72349019_69083_330x0_resize_box_3.png 330w,
/posts/binary-exp/10_hube7823136868944f10e4b20b72349019_69083_660x0_resize_box_3.png 660w,
/posts/binary-exp/10_hube7823136868944f10e4b20b72349019_69083_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/10_hube7823136868944f10e4b20b72349019_69083_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/10_hube7823136868944f10e4b20b72349019_69083_660x0_resize_box_3.png alt="图 11"></figure></p><p>这里就可以很清晰地看到，我们在调用时为何要保存这个值了，如果不保存，那么返回的时候 <code>ebp</code> 不知道应该返回到哪里。而保存了 caller 的 <code>ebp</code> 实际上就是保存了 <code>caller</code> 栈帧的基址。</p><p>第三步弹出返回地址，第四步依次弹出参数。</p><p>为了让大家能对函数调用栈有一个更直观的认识，我演示了 pwnable.kr 上的 <code>random</code> 这题的解法，而为了解决这题，就不得不用到调试工具 gdb。</p><h2 id=gdb-简介 class="relative group">gdb 简介 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#gdb-%e7%ae%80%e4%bb%8b aria-label=锚点>#</a></span></h2><p>这里仅仅列出了一些最常用的 gdb 命令：</p><ul><li><code>b 12</code> 在第 12 行下断点</li><li><code>b 1.c:12</code> 在 <code>1.c</code> 的 12 行下断点</li><li><code>b main</code> 在 <code>main</code> 函数下断点</li><li><code>b *0x8048abc</code> 在 <code>0x8048abc</code> 地址处下断点</li><li><code>r</code> 执行程序</li><li><code>c</code> 执行到下一个断点</li><li><code>s</code> 单步调试，遇到函数则进入</li><li><code>n</code> 单步调试，遇到函数不进入</li><li><code>until</code> 运行到退出循环</li><li><code>until 12</code> 运行到 12 行</li><li><code>q</code> 退出</li><li><code>info b</code> 查看所有断点</li><li><code>info func</code> 查看所有函数</li><li><code>p var</code> 打印出 C 语言变量 <code>var</code> 的值</li><li><code>bt</code> 查看函数调用栈</li><li><code>x/8xw 0x8048abc</code> 以 16 进制显示 <code>0x8048abc</code> 地址后 8 个内存单元的值，每个内存单元大小 4 字节</li><li><code>x/4ch 0x8048abc</code> 以字符格式显示 <code>0x8048abc</code> 地址后 4 个内存单元的值，每个内存单元大小 2 字节</li><li><code>help x</code> 查看关于命令 x 的帮助</li></ul><h2 id=缓冲区溢出漏洞栈溢出 class="relative group">缓冲区溢出漏洞——栈溢出 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba%e6%bc%8f%e6%b4%9e%e6%a0%88%e6%ba%a2%e5%87%ba aria-label=锚点>#</a></span></h2><p>至此，可以介绍栈溢出了。栈溢出即通过覆盖栈上的数据，控制程序执行流程的一种攻击手段。攻击成功至少需要两个前提：</p><ol><li>程序必须向栈上写数据</li><li>写入的数据大小没有被良好地控制</li></ol><p>关于栈溢出，有这样一些 “危险函数” 是我们可以利用的：</p><ul><li><code>gets</code></li><li><code>scanf</code></li><li><code>read</code></li><li><code>sprintf</code></li><li><code>strcpy</code></li><li><code>strcat</code></li></ul><h2 id=pwn-相关工具 class="relative group">Pwn 相关工具 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#pwn-%e7%9b%b8%e5%85%b3%e5%b7%a5%e5%85%b7 aria-label=锚点>#</a></span></h2><p>为了真正实施攻击，一些辅助工具是必不可少的，例如：</p><ul><li>checksec 检查程序</li><li>gdb 调试并分析程序</li><li>peda 一个 gdb 的可视化插件</li><li>pwndbg 另一个 gdb 的可视化插件</li><li>IDA 著名的反编译工具</li><li>pwntools 用于方便地编写攻击脚本的 python 库</li><li>LibcSearcher 用于实施 ret2libc 攻击的 python 库</li><li>ROPgadgets 用于实施 ROP 攻击的 python 库</li><li>(netcat) 连接到远程主机上开放的服务的命令行工具</li><li>(ssh) 登录远程主机的命令行工具</li></ul><p>介绍完了这些，我演示了对于 pwnable.kr 的 <code>bof</code> 这题的攻击，通过溢出局部变量来覆盖函数参数的值。</p><h2 id=花式栈溢出 class="relative group">花式栈溢出 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e8%8a%b1%e5%bc%8f%e6%a0%88%e6%ba%a2%e5%87%ba aria-label=锚点>#</a></span></h2><p>栈溢出之所以值得开一门课来讲授，正是因为这种攻击有很多玩法，例如：</p><ul><li>Basic<ul><li>ret2text</li><li>ret2shellcode</li><li>ret2syscall</li><li>ret2libc</li><li>ROP</li><li>GOT Hijacking</li></ul></li><li>Intermediate<ul><li>ret2csu</li><li>ret2reg</li><li>BROP</li></ul></li><li>Advanced<ul><li>ret2dl_runtime_resolve</li><li>SROP</li><li>ret2VDSO</li><li>JOP</li><li>COP</li><li>&mldr;</li></ul></li></ul><p>本课程只介绍 Basic 部分。</p><h3 id=ret2text class="relative group">ret2text <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#ret2text aria-label=锚点>#</a></span></h3><p>首先介绍了 <code>ret2text</code>，即通过栈溢出覆盖函数的返回地址，以控制程序的控制流。在例题 bugku 的 <code>pwn2</code> 中，就是利用 <code>ret2text</code> 返回到了 <code>text</code> 段已经存在的一个后门函数来获取 shell。</p><h3 id=ret2shellcode class="relative group">ret2shellcode <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#ret2shellcode aria-label=锚点>#</a></span></h3><p>但不是什么时候程序中都会有一个现成的后门函数，因此有时我们需要自己创造条件。<code>ret2shellcode</code> 就是这样的攻击方法。我们向栈上写入一段恶意的汇编代码，随后利用程序中的漏洞执行栈上的这段代码即可完成攻击。Hackergame 的 <code>ShellHacker</code> 这道题就是一个很好的例子。</p><p>然而上面的两种攻击依然太过理想化了，现实中的程序往往不会那么容易被栈溢出攻击，因为开启了各种保护措施。</p><h2 id=栈溢出保护 class="relative group">栈溢出保护 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%a0%88%e6%ba%a2%e5%87%ba%e4%bf%9d%e6%8a%a4 aria-label=锚点>#</a></span></h2><p>课程介绍了 4 种常见的栈溢出保护。其中，NX 使栈上的数据不可被执行；Canary 在局部变量和 caller&rsquo;s ebp 之间插入了一个随机值，并在函数返回时检查随机值是否被修改；PIE 将使整个进程中的数据地址变得随机，每次运行时都不相同；RELRO 使重定向段不可写。</p><ul><li>NX (No eXecution) 默认开启<ul><li>Windows: DEP (Data Execution Prevention)</li><li><code>gcc –z execstack</code> 禁用 NX</li><li><code>gcc –z noexecstack</code> 启用 NX</li></ul></li><li>Canary 默认不开启<ul><li><code>gcc –fno-stack-protector</code> 禁用 canary</li><li><code>gcc –fstack-protector</code> 只为局部变量中含有 char 数组的函数插入 canary</li><li><code>gcc –fstack-protector-all</code> 为所有函数插入 canary</li></ul></li><li>PIE (Position-Independent Executables) 默认不开启<ul><li>Windows: ASLR (Address Space Layout Randomization)</li><li>Level 0 - 表示关闭进程地址空间随机化</li><li>Level 1 - 表示将 mmap 的基址、栈和 VDSO 页面随机化</li><li>Level 2 - 表示在 1 的基础上增加堆的随机化</li><li><code>gcc –fpie –pie</code> 开启 1 级 PIE</li><li><code>gcc –fPIE –pie</code> 开启 2 级 PIE</li></ul></li><li>RELRO (RELocation Read Only) 默认 Partial<ul><li><code>gcc –z norelro</code> 关闭 RELRO</li><li><code>gcc –z lazy</code> 部分开启 RELRO，GOT 表可写</li><li><code>gcc –z now</code> 全部开启 RELRO</li></ul></li></ul><p>这些保护机制并不是那么容易绕过。为了突破这些保护，我们需要了解 32 位与 64 位汇编语言的知识。</p><h2 id=x86-汇编 class="relative group">x86 汇编 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#x86-%e6%b1%87%e7%bc%96 aria-label=锚点>#</a></span></h2><p>汇编语言是 Intel 推出的一系列汇编的指令集合，有两种语法：</p><ol><li>Intel 语法：<code>operand destination, source</code></li></ol><ul><li><code>mov eax, 5</code></li></ul><ol start=2><li>AT&T 语法：<code>operand source, destination</code></li></ol><ul><li><code>mov $5, %eax</code></li></ul><p>本课程将使用更简单的 Intel 语法（CSAPP 使用 AT&T 语法）。</p><h3 id=重要寄存器 class="relative group">重要寄存器 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e9%87%8d%e8%a6%81%e5%af%84%e5%ad%98%e5%99%a8 aria-label=锚点>#</a></span></h3><ul><li>eax ebx ecx edx 泛用型寄存器（eax 通常存储函数返回值）</li><li>esp 指向栈帧顶部</li><li>ebp 指向栈帧底部</li><li>eip 指向下一条 CPU 将要执行的指令</li><li>eflags 存储标志位<ul><li>ZF 运算结果为 0 时置 1</li><li>CF 运算结果最高有效位发生进位或借位时置 1</li><li>SF 运算结果为负时置 1</li></ul></li></ul><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/11_hud20083d10e3e09a4966b0f273d145584_68587_330x0_resize_box_3.png 330w,
/posts/binary-exp/11_hud20083d10e3e09a4966b0f273d145584_68587_660x0_resize_box_3.png 660w,
/posts/binary-exp/11_hud20083d10e3e09a4966b0f273d145584_68587_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/11_hud20083d10e3e09a4966b0f273d145584_68587_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/11_hud20083d10e3e09a4966b0f273d145584_68587_660x0_resize_box_3.png alt="图 12"></figure></p><h3 id=数据操作 class="relative group">数据操作 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%95%b0%e6%8d%ae%e6%93%8d%e4%bd%9c aria-label=锚点>#</a></span></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>mov</span> <span class=no>ebx</span><span class=p>,</span> <span class=no>eax</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>0XDEADBEEF</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=no>edx</span><span class=p>,</span> <span class=no>DWORD</span> <span class=no>PTR</span> <span class=p>[</span><span class=mi>0x41424344</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=no>ecx</span><span class=p>,</span> <span class=no>DWORD</span> <span class=no>PTR</span> <span class=p>[</span><span class=no>edx</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=no>DWORD</span> <span class=no>PTR</span> <span class=p>[</span><span class=no>ecx</span><span class=err>+</span><span class=no>esi</span><span class=p>*</span><span class=mi>8</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>sub</span> <span class=no>edx</span><span class=p>,</span> <span class=mi>0x11</span>
</span></span><span class=line><span class=cl><span class=nf>add</span> <span class=no>eax</span><span class=p>,</span> <span class=no>ebx</span>
</span></span><span class=line><span class=cl><span class=nf>inc</span> <span class=no>edx</span>
</span></span><span class=line><span class=cl><span class=nf>dec</span> <span class=no>ebx</span>
</span></span><span class=line><span class=cl><span class=nf>xor</span> <span class=no>eax</span><span class=p>,</span> <span class=no>eax</span>
</span></span><span class=line><span class=cl><span class=nf>or</span> <span class=no>edx</span><span class=p>,</span> <span class=mi>0x1337</span>
</span></span></code></pre></div><p>写成类似的 C 伪代码即：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ebx</span> <span class=o>=</span> <span class=n>eax</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>eax</span> <span class=o>=</span> <span class=mh>0xDEADBEEF</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>edx</span> <span class=o>=</span> <span class=o>*</span><span class=mh>0x41424344</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>ecx</span> <span class=o>=</span> <span class=o>*</span><span class=n>edx</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>eax</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>ecx</span><span class=o>+</span><span class=n>esi</span><span class=o>*</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edx</span> <span class=o>-=</span> <span class=mh>0x11</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>eax</span> <span class=o>+=</span> <span class=n>ebx</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>edx</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>ebx</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>eax</span> <span class=o>^=</span> <span class=n>eax</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>edx</span> <span class=o>|=</span> <span class=mh>0x1337</span><span class=p>;</span>
</span></span></code></pre></div><p>这里的 <code>DWORD PTR</code> 指 4 字节指针，相应的有 <code>BYTE PTR/WORD PTR/QWORD PTR</code> 表示 1/2/8 字节指针。注意 <code>[0x41424344]</code> 表示取地址 <code>0x41424344</code> 位置的值，如果里面是寄存器同理。</p><h3 id=条件跳转 class="relative group">条件跳转 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%9d%a1%e4%bb%b6%e8%b7%b3%e8%bd%ac aria-label=锚点>#</a></span></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>jz</span> <span class=no>$LOC</span>
</span></span><span class=line><span class=cl><span class=nf>jnz</span> <span class=no>$LOC</span>
</span></span><span class=line><span class=cl><span class=nf>jg</span> <span class=no>$LOC</span>
</span></span><span class=line><span class=cl><span class=nf>jle</span> <span class=no>$LOC</span>
</span></span></code></pre></div><p>分别表示，当上一条语句执行结果为：</p><ul><li>0</li><li>非 0</li><li>目标操作数大于源操作数</li><li>目标操作数小于等于源操作数
时，跳转到 <code>$LOC</code> 的位置。</li></ul><h3 id=函数调用 class="relative group">函数调用 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8 aria-label=锚点>#</a></span></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>push</span> <span class=no>ebx</span> <span class=c1>; is equal to:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>sub</span> <span class=no>esp</span><span class=p>,</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=no>DWORD</span> <span class=no>PTR</span> <span class=p>[</span><span class=no>esp</span><span class=p>],</span> <span class=no>ebx</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>pop</span> <span class=no>ebx</span> <span class=c1>; is equal to:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>mov</span> <span class=no>ebx</span><span class=p>,</span> <span class=no>DWORD</span> <span class=no>PTR</span> <span class=p>[</span><span class=no>esp</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>add</span> <span class=no>esp</span><span class=p>,</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>call</span> <span class=no>some_function</span> <span class=c1>; is equal to:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>push</span> <span class=no>eip</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=no>eip</span><span class=p>,</span> <span class=no>some_function</span> <span class=c1>; actually invalid
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>ret</span> <span class=c1>; is equal to:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>pop</span> <span class=no>eip</span> <span class=c1>; actually invalid
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nf>nop</span> <span class=c1>; do nothing
</span></span></span></code></pre></div><h3 id=例计算字符串长度 class="relative group">例：计算字符串长度 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e4%be%8b%e8%ae%a1%e7%ae%97%e5%ad%97%e7%ac%a6%e4%b8%b2%e9%95%bf%e5%ba%a6 aria-label=锚点>#</a></span></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=err>0</span><span class=nl>x08048624:</span> <span class=err>&#34;</span><span class=nf>MERCURY</span><span class=err>\</span><span class=mi>0</span><span class=err>&#34;</span>
</span></span><span class=line><span class=cl>  <span class=nf>mov</span> <span class=no>ebx</span><span class=p>,</span> <span class=mi>0x08048624</span>
</span></span><span class=line><span class=cl>  <span class=nf>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=nl>LOOPY:</span>
</span></span><span class=line><span class=cl>  <span class=nf>mov</span> <span class=no>cl</span><span class=p>,</span> <span class=no>BYTE</span> <span class=no>PTR</span> <span class=p>[</span><span class=no>ebx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=nf>cmp</span> <span class=no>cl</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>  <span class=nf>jz</span> <span class=no>end</span>
</span></span><span class=line><span class=cl>  <span class=nf>inc</span> <span class=no>eax</span>
</span></span><span class=line><span class=cl>  <span class=nf>inc</span> <span class=no>ebx</span>
</span></span><span class=line><span class=cl>  <span class=nf>jmp</span> <span class=no>LOOPY</span>
</span></span><span class=line><span class=cl><span class=nl>end:</span>
</span></span><span class=line><span class=cl>  <span class=nf>ret</span>
</span></span></code></pre></div><p>等效于下面的 C 代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;MERCURY&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=o>*</span><span class=n>name</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>len</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>name</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>len</span><span class=p>;</span>
</span></span></code></pre></div><h2 id=x86-64-汇编 class="relative group">x86-64 汇编 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#x86-64-%e6%b1%87%e7%bc%96 aria-label=锚点>#</a></span></h2><p>再放一次这张图。<figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/11_hud20083d10e3e09a4966b0f273d145584_68587_330x0_resize_box_3.png 330w,
/posts/binary-exp/11_hud20083d10e3e09a4966b0f273d145584_68587_660x0_resize_box_3.png 660w,
/posts/binary-exp/11_hud20083d10e3e09a4966b0f273d145584_68587_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/11_hud20083d10e3e09a4966b0f273d145584_68587_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/11_hud20083d10e3e09a4966b0f273d145584_68587_660x0_resize_box_3.png alt="图 13"></figure></p><p>64 位架构下，新增了寄存器 <code>r8-r15</code>，用 <code>xmm0-xmm7</code> 存储浮点参数，同时原来的 <code>eax</code> 变成了 <code>rax</code> 等。但最重要的，还是传参方式的变化：函数前 6 个参数会被依次存储在寄存器 rdi, rsi, rdx, rcx, r8, r9 中，之后的参数才遵循栈上约定。</p><h2 id=花式栈溢出续 class="relative group">花式栈溢出：续 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e8%8a%b1%e5%bc%8f%e6%a0%88%e6%ba%a2%e5%87%ba%e7%bb%ad aria-label=锚点>#</a></span></h2><h3 id=泄露-canary class="relative group">泄露 canary <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%b3%84%e9%9c%b2-canary aria-label=锚点>#</a></span></h3><p>介绍了这么多，终于可以演示一些保护机制的绕过方法了，首先是绕过 canary，这里采用了泄露 canary 的方式，实际上还有很多其他方式。前面提到过，canary 在栈上大概在这个位置：</p><pre tabindex=0><code>| args       |
 ------------
| ret addr   |
 ------------  &lt;- ebp
| saved ebp  |
 ------------
| padding    |
 ------------  &lt;- ebp-0x??
| canary     |
 ------------
| local vars |
</code></pre><p>那么我们栈溢出时，从局部变量出发向上走，必定要经过 canary 并覆盖其值，那么函数返回时就会检测到，并终止程序。</p><p>然而，canary 在设计时规定末尾的字节必为 <code>00</code>，也就是 C 语言中的 <code>\0</code>，这是因为当我们打印栈信息时（从低地址向高地址打印），遇到 <code>00</code> 字节就会认为是字符串结束符，因此停止打印，这样 canary 的值就不会泄露。然而这同时也是我们可以利用的点。如果我们覆盖掉 canary 的最后一个字节为 <code>0a</code> 或者别的什么值，那么打印栈时就不会在 canary 处停下来，从而打印出 canary 的值。这是我们再将 <code>0a</code> 恢复为 <code>00</code> 便得到了完整的 canary 值。</p><p>得到 canary 后，我们只需要在栈溢出时注意，溢出到 canary 的位置的时候插入刚才得到的 canary 值，随后继续正常溢出，那么函数返回时就会认为 canary 未被修改，绕过了检查。</p><h3 id=got--plt class="relative group">GOT & PLT <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#got--plt aria-label=锚点>#</a></span></h3><p>为了更好地理解接下来的攻击技术，这里主要介绍了 Linux 中函数调用时的延迟绑定规则，这就涉及到 ELF 文件中的两个段：<code>.plt</code> 段与 <code>.got.plt</code> 段（实际上，GOT 表被分成 <code>.got</code> 与 <code>.got.plt</code> 两个段，前者与函数无关），分别对应我们的 Procedure Linkage Table 和 Global Offset Table。所谓延迟绑定，即一个函数的真实地址直到其第一次被调用时才会确定。</p><p>我们以 Hello World 程序的 <code>puts</code> 函数调用为例，调用语句是 <code>call &lt;puts@plt></code>。我们假设 <code>.plt</code> 结构如下：</p><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/12_hu1d5db531314e4d6e0c65856de82dd1bb_264491_330x0_resize_box_3.png 330w,
/posts/binary-exp/12_hu1d5db531314e4d6e0c65856de82dd1bb_264491_660x0_resize_box_3.png 660w,
/posts/binary-exp/12_hu1d5db531314e4d6e0c65856de82dd1bb_264491_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/12_hu1d5db531314e4d6e0c65856de82dd1bb_264491_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/12_hu1d5db531314e4d6e0c65856de82dd1bb_264491_660x0_resize_box_3.png alt="图 14"><figcaption>图 14</figcaption></figure></p><p>称 <code>.plt</code> 开头的三条指令为 <code>.plt[0]</code>，<code>puts</code> 的 PLT 表是 <code>.plt[1]</code>，那么第一次调用 <code>puts</code> 时会访问 <code>puts@plt</code> 也就是 <code>.plt[1]</code>。<code>.plt[1]</code> 会跳转到 <code>puts</code> 对应的 GOT 表条目 <code>.got.plt[3]</code>。为什么下标是 3？这是因为 <code>.got.plt</code> 段是长这样的：</p><p><figure><img class="my-0 rounded-md" srcset="/posts/binary-exp/13_huc16fb095ecc03e235ff07229dc88f0e3_222961_330x0_resize_box_3.png 330w,
/posts/binary-exp/13_huc16fb095ecc03e235ff07229dc88f0e3_222961_660x0_resize_box_3.png 660w,
/posts/binary-exp/13_huc16fb095ecc03e235ff07229dc88f0e3_222961_1024x0_resize_box_3.png 1024w,
/posts/binary-exp/13_huc16fb095ecc03e235ff07229dc88f0e3_222961_1320x0_resize_box_3.png 2x" src=/posts/binary-exp/13_huc16fb095ecc03e235ff07229dc88f0e3_222961_660x0_resize_box_3.png alt="图 15"><figcaption>图 15</figcaption></figure></p><p>可以看到，<code>.got.plt</code> 的前三条指令不属于任何函数，他们分别存储着：</p><ul><li><code>.dynamic</code> 动态链接信息</li><li>模块 ID</li><li>动态链接器中的 <code>dl_runtime_resolve_avx()</code> 函数地址</li></ul><p>于是 <code>puts</code> 的 GOT 表项就被挤到下标为 3 的地方去了。</p><p>在第一次调用前，<code>.got.plt[3]</code> 指向 <code>.plt[1]</code> 的下一条指令的地址，也就是说直接让 <code>.plt[1]</code> 继续执行下去，就好像它没有访问过 <code>.got.plt[3]</code> 一样。</p><p>随后，我们的 <code>.plt[1]</code> 的第二条指令会跳转到 <code>.plt[0]</code>，后者再跳转到 <code>.got.plt[2]</code>，也就是 <code>dl_runtime_resolve_avx()</code> 函数的地址去调用该函数，该函数从 <code>libc.so</code> 中拿到 <code>puts</code> 的真实地址，并写入 <code>.got.plt[3]</code> 中。至此，<code>puts</code> 函数的延迟绑定工作完成了。</p><p>接下来，在第 <code>n>=1</code> 次调用中，当我们再次访问 <code>.plt[1]</code> 时，又会去取 <code>.got.plt[3]</code> 中的地址，注意此时这里已经存好了 <code>puts</code> 的真实地址，那么我们就调用成功了。</p><h3 id=ret2libc class="relative group">ret2libc <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#ret2libc aria-label=锚点>#</a></span></h3><p>这样以后就能介绍 <code>ret2libc</code> 了，这是在没有诸如 <code>system</code> 和 <code>/bin/sh</code> 字符串的情况下，通过返回到 <code>libc</code> 动态链接库中查找 <code>system</code> 函数地址和 <code>/bin/sh</code> 字符串地址，来执行 <code>system("/bin/sh")</code> 的攻击。为此，我们需要通过栈溢出泄露出 <code>libc</code> 中某个函数的真实地址，例如 <code>__libc_start_main</code> 等，随后使用 <code>LibcSearcher</code> 搜索出程序使用的 <code>libc</code> 版本，从而获得 <code>libc</code> 基址，以及 <code>system</code> 和 <code>/bin/sh</code> 的偏移量。将基址和偏移相加就可以得到两者的真实地址。这种攻击不仅可以绕过 NX 保护，同时由于 PIE 不会随机化函数地址的低 12 位，而泄露出 <code>__libc_start_main</code> 的低 12 位就可以确定 <code>libc</code> 版本，<code>ret2libc</code> 攻击在 PIE 保护下也不会失效。</p><h3 id=rop--ret2syscall class="relative group">ROP & ret2syscall <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#rop--ret2syscall aria-label=锚点>#</a></span></h3><p>同样我们还可以 <code>ret2syscall</code>。我们想做的就是构造系统调用 <code>execve("/bin/sh",NULL,NULL)</code>。为此，我们需要：</p><ol><li>让 <code>eax</code> 等于 <code>0xb</code>（<code>execve</code> 的系统调用号）</li><li>找到 <code>/bin/sh</code> 字符串的地址</li><li>让 <code>ebx</code> 等于 <code>/bin/sh</code> 字符串的地址</li><li>让 <code>ecx</code> 和 <code>edx</code> 等于 0</li><li>找到 <code>int 0x80</code> 语句的地址，并返回到这句语句上</li></ol><p>可以发现，这里我们需要控制寄存器的值，但是我们是无法直接控制的，而是需要通过一些 <code>gadgets</code> 来控制。</p><p>回顾 x86 汇编部分，我们介绍了 <code>push</code> 和 <code>pop</code> 两种对称的操作。然而，没有人规定这两个操作必须成对出现。如果我们先布置好栈顶的值，然后跳转到 <code>pop eax</code> 指令所在的地址并执行，那么栈顶的值就会被赋值给 <code>eax</code>，这样，我们相当于控制了寄存器的值。</p><p>但是，跳转到 <code>pop eax</code> 后，我们还需要控制 <code>ebx</code> 等寄存器，还需要跳转到别的地方，此时的跳转我们同样要通过修改返回地址实现，因此我们必须要有返回语句，也就是 <code>ret</code>。因此 <code>pop eax; ret</code> 这样的语句我们就称之为一个 <code>gadget</code>。</p><p>我们可以通过栈溢出先在栈上布置好我们想 <code>pop</code> 出去的值，通过 <code>ROPgadget</code> 工具寻找一些这样的 <code>gadgets</code>（还可以找 <code>/bin/sh</code> 地址和 <code>int 0x80</code> 地址）也依次放到栈上，那么我们就构造了一条 ROP(Return Oriented Programming) 链：</p><pre tabindex=0><code>| int 0x80                       |
 --------------------------------
| addr of /bin/sh                |
 --------------------------------
| 0                              |
 --------------------------------
| 0                              |
 --------------------------------
| pop edx; pop ecx; pop ebx; ret |
 --------------------------------
| 0xb                            |
 --------------------------------
| pop eax; ret                   |
</code></pre><h3 id=got-hijacking class="relative group">GOT Hijacking <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#got-hijacking aria-label=锚点>#</a></span></h3><p>栈溢出部分最后介绍的是 GOT Hijacking，也就是 GOT 表劫持。当程序开启 <code>Partial RELRO</code> 时，GOT 表是可写的，那么我们就可以将一个现有的普通函数例如 <code>fflush</code> 的 GOT 表地址放在栈上，随后利用程序漏洞（如 <code>scanf</code> 不加 <code>&</code> 等）向该地址写入另一个地址，如 <code>system("/bin/sh")</code> 的地址，那么当我们执行 <code>fflush()</code> 时，由于其 GOT 表已经被劫持到了 <code>system("/bin/sh")</code>，实际执行的是后者。</p><h2 id=格式化字符串漏洞 class="relative group">格式化字符串漏洞 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e6%a0%bc%e5%bc%8f%e5%8c%96%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%bc%8f%e6%b4%9e aria-label=锚点>#</a></span></h2><p>课程最后介绍的是格式化字符串漏洞，大家都比较熟悉格式化字符串。其完整格式形如：</p><pre tabindex=0><code>%[parameter][flags][field width][.precision][length]type
</code></pre><p>这里我们主要关注 <code>parameter</code> 和 <code>type</code>。<code>parameter</code> 处一个广为人知的攻击点是 <code>n$</code>，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%2$d %2$#x; %1$d %1$#x&#34;</span><span class=p>,</span><span class=mi>16</span><span class=p>,</span><span class=mi>17</span><span class=p>)</span>
</span></span></code></pre></div><p>这句语句中，<code>2$</code> 就是值格式化字符串后的第 2 个参数。</p><p>类似地，<code>type</code> 中的攻击点在于 <code>%n</code> 这个类型，指定为该类型时，不输出，而是将已成功输出的字符数写入对应的整型指针参数所指的变量。这可以用来写内存，不过课程并没有涉及这一点。</p><p>为了利用该漏洞，首先要理解格式化字符串的工作原理。对于语句；</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Color %s, Number %d, Float %4.2f&#34;</span><span class=p>,</span> <span class=s>&#34;red&#34;</span><span class=p>,</span> <span class=mi>123456</span><span class=p>,</span> <span class=mf>3.1416</span><span class=p>);</span>
</span></span></code></pre></div><p>会输出</p><pre tabindex=0><code>Color red, Number 123456, Float 3.14
</code></pre><p>栈上布局为：</p><pre tabindex=0><code>| 3.1416                  |
 -------------------------
| 123456                  |
 -------------------------
| addr of &#34;red&#34;           |
 -------------------------
| addr of &#34;Color %s, ...&#34; |
</code></pre><p><code>printf</code> 函数在读格式化字符串时，如果遇到 <code>%</code>，那么就会去读取对应位置的参数并解析，这个参数位于栈上。那么，如果我的语句是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Color %s, Number %d, Float %4.2f&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>即参数个数不匹配，会怎么样呢？</p><p>答案是 <code>printf</code> 照常解析，此时栈上原本应该放参数的那个位置上的内容就会被读取并打印出来。利用这个漏洞，我们就可以泄露栈内存。实际上，可以泄露任意地址内存。</p><p>举个例子，当程序运行时我们发现用户输入的参数被存储在了栈上，并且栈上还有 <code>__libc_start_main</code> 的地址。那么我们可以计算两者在栈上的偏移量 <code>offset</code>，随后：</p><ul><li>除以 4（32 位）</li><li>除以 8 后加 6（64 位，别忘了 6 个存参数的寄存器）</li></ul><p>得到的就是，<code>__libc_start_main</code> 可以被认为是 <code>printf</code> 的第几个参数。假如是第 11 个参数，那么我们只要构造语句 <code>printf("%11$p");</code> 即可泄露 <code>__libc_start_main</code> 的地址，从而实施 <code>ret2libc</code> 攻击。</p><h2 id=参考资料 class="relative group">参考资料 <span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=锚点>#</a></span></h2><ul><li><a href=https://pwnable.kr/>https://pwnable.kr/</a></li><li><a href=https://ctf-wiki.github.io/ctf-wiki/pwn/readme-zh/>https://ctf-wiki.github.io/ctf-wiki/pwn/readme-zh/</a></li><li><a href=https://ctf.bugku.com/challenges>https://ctf.bugku.com/challenges</a></li><li><a href=https://zhuanlan.zhihu.com/p/25816426>https://zhuanlan.zhihu.com/p/25816426</a></li><li><a href=http://security.cs.rpi.edu/courses/binexp-spring2015/>http://security.cs.rpi.edu/courses/binexp-spring2015/</a></li><li><a href=https://ropemporium.com/guide.html>https://ropemporium.com/guide.html</a></li><li>所有使用的工具的官方文档</li><li>《深入理解计算机系统》（CS: APP）</li></ul></div></section><footer class="pt-8 max-w-prose print:hidden"><div class=flex><img class="w-24 h-24 !mt-0 !mb-0 ltr:mr-4 rtl:ml-4 rounded-full" width=96 height=96 alt=Mercury src=/my_avatar_huffcabec77dc887387e1e045311cbdc8b_49733_192x192_fill_box_smart1_3.png><div class=place-self-center><div class="text-[0.6rem] leading-3 text-neutral-500 dark:text-neutral-400 uppercase">作者</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">Mercury</div><div class="text-sm text-neutral-700 dark:text-neutral-400">A student</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=mailto:signormercurio@gmail.com target=_blank aria-label=Email rel="me noopener noreferrer"><span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg></span></a><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://github.com/SignorMercurio target=_blank aria-label=Github rel="me noopener noreferrer"><span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></a><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://t.me/m9r_at_tG target=_blank aria-label=Telegram rel="me noopener noreferrer"><span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M248 8C111.033 8 0 119.033.0 256S111.033 504 248 504 496 392.967 496 256 384.967 8 248 8zM362.952 176.66c-3.732 39.215-19.881 134.378-28.1 178.3-3.476 18.584-10.322 24.816-16.948 25.425-14.4 1.326-25.338-9.517-39.287-18.661-21.827-14.308-34.158-23.215-55.346-37.177-24.485-16.135-8.612-25 5.342-39.5 3.652-3.793 67.107-61.51 68.335-66.746.153-.655.3-3.1-1.154-4.384s-3.59-.849-5.135-.5q-3.283.746-104.608 69.142-14.845 10.194-26.894 9.934c-8.855-.191-25.888-5.006-38.551-9.123-15.531-5.048-27.875-7.717-26.8-16.291q.84-6.7 18.45-13.7 108.446-47.248 144.628-62.3c68.872-28.647 83.183-33.623 92.511-33.789 2.052-.034 6.639.474 9.61 2.885a10.452 10.452.0 013.53 6.716A43.765 43.765.0 01362.952 176.66z"/></svg></span></a></div></div></div></div><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group" href=/posts/glibc-heap/><span class="mr-3 ltr:inline rtl:hidden text-neutral-700 dark:text-neutral group-hover:text-primary-600 dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 ltr:hidden rtl:inline text-neutral-700 dark:text-neutral group-hover:text-primary-600 dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">盘根错节：GLibc 堆内存管理机制简介</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2019-12-08 16:53:39 +0000 UTC">2019-12-08</time></span></span></a></span>
<span><a class="flex text-right group" href=/posts/buu-web/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">BUUCTF Web 练习记录</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2019-11-29 18:36:25 +0000 UTC">2019-11-29</time></span></span>
<span class="ml-3 ltr:inline rtl:hidden text-neutral-700 dark:text-neutral group-hover:text-primary-600 dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 ltr:hidden rtl:inline text-neutral-700 dark:text-neutral group-hover:text-primary-600 dark:group-hover:text-primary-400">&larr;</span></a></span></div></div></footer><script src=//unpkg.com/valine/dist/Valine.min.js></script><div id=vcomments class="mt-8 max-w-prose print:hidden"></div><script>new Valine({el:"#vcomments",appId:"RkxCznUcvfzFBgfMiMr0BAfd-gzGzoHsz",appKey:"sw2sEPOl4haCAXKUFYiBFMrR",avatar:"robohash",requiredFields:["nick"]})</script></article><div class="absolute top-[100vh] ltr:right-0 rtl:left-0 w-12 pointer-events-none bottom-0"><a href=#the-top class="w-12 h-12 sticky pointer-events-auto top-[calc(100vh-5.5rem)] bg-neutral/50 dark:bg-neutral-800/50 backdrop-blur rounded-full text-xl flex items-center justify-center text-neutral-700 dark:text-neutral hover:text-primary-600 dark:hover:text-primary-400" aria-label="Scroll to top" title="Scroll to top">&uarr;</a></div></main><footer class="py-10 print:hidden"><nav class="pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex flex-col list-none sm:flex-row"><li class="mb-1 ltr:text-right rtl:text-left sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2" href=https://creativecommons.org/licenses/by-nc/4.0/ title>CC BY-NC 4.0</a></li></ul></nav><div class="flex items-center justify-between"><div><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2023
Mercury</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://git.io/hugo-congo target=_blank rel="noopener noreferrer">Congo</a> 强力驱动</p></div><div class="text-sm cursor-pointer text-neutral-700 dark:text-neutral hover:text-primary-600 dark:hover:text-primary-400 ltr:mr-14 rtl:ml-14"><button id=appearance-switcher class="w-12 h-12" type=button title=切换为深色模式>
<span class="inline dark:hidden"><span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></span><span class="hidden dark:inline"><span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></span></button></div></div></footer><div id=search-wrapper class="fixed inset-0 z-50 flex flex-col p-4 sm:p-6 md:p-[10vh] lg:p-[12vh] w-screen h-screen cursor-default bg-neutral-500/50 backdrop-blur-sm dark:bg-neutral-900/50 invisible" data-url=https://blog.sigmerc.top><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg border-neutral-200 top-20 bg-neutral dark:bg-neutral-800 dark:border-neutral-700"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative inline-block align-text-bottom icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-transparent focus:outline-2" placeholder=Search tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 dark:text-neutral hover:text-primary-600 dark:hover:text-primary-400" title="Close (Esc)">
<span class="relative inline-block align-text-bottom icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>