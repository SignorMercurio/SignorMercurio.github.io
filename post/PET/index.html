<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>扑朔迷离：隐私增强技术实践 - Lab on Mercury</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Lab on Mercury"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Lab on Mercury"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Privacy Enhancing Technologies (PET)，实际上还是密码学。"><meta property="og:type" content="blog"><meta property="og:title" content="扑朔迷离：隐私增强技术实践"><meta property="og:url" content="https://signormercurio.me/post/PET/"><meta property="og:site_name" content="Lab on Mercury"><meta property="og:description" content="Privacy Enhancing Technologies (PET)，实际上还是密码学。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/PET/0.png"><meta property="article:published_time" content="2022-02-04T09:23:11.000Z"><meta property="article:author" content="Mercury"><meta property="article:tag" content="密码学"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/PET/0.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://signormercurio.me/post/PET/"},"headline":"扑朔迷离：隐私增强技术实践","image":["https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/PET/0.png"],"datePublished":"2022-02-04T09:23:11.000Z","author":{"@type":"Person","name":"Mercury"},"publisher":{"@type":"Organization","name":"Lab on Mercury","logo":{"@type":"ImageObject","url":"https://signormercurio.me/img/favicon.png"}},"description":"Privacy Enhancing Technologies (PET)，实际上还是密码学。"}</script><link rel="canonical" href="https://signormercurio.me/post/PET/"><link rel="alternate" href="/atom.xml" title="Lab on Mercury" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/favicon.png" alt="Lab on Mercury" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/PET/0.png" alt="扑朔迷离：隐私增强技术实践"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-04T09:23:11.000Z" title="2022/2/4 上午9:23:11">2022-02-04</time></span><span class="level-item"><a class="link-muted" href="/categories/%E5%AE%89%E5%85%A8/">安全</a></span><span class="level-item">an hour read (About 10710 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">扑朔迷离：隐私增强技术实践</h1><div class="content"><p>Privacy Enhancing Technologies (PET)，实际上还是密码学。</p>
<a id="more"></a>

<h2 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h2><p>隐私可以看作是对数据的控制的一种准许：</p>
<ul>
<li>机密性 - 保证一个人的秘密不被泄漏</li>
<li>控制 - 给个人控制自己个人信息的权利</li>
<li>自我实现 - 允许个人使用这些信息来达成自己的目的</li>
</ul>
<p>Solove 分类将隐私侵犯分为 4 类：</p>
<ul>
<li>信息收集</li>
<li>信息处理</li>
<li>信息传播</li>
<li>入侵（即干扰个人的活动与决策）</li>
</ul>
<h2 id="PET"><a href="#PET" class="headerlink" title="PET"></a>PET</h2><p>根据不同的假设，隐私增强技术可以分为 Soft PET 和 Hard PET。前者主要关注合规性，假设处理用户数据的第三方服务是合法可信的，因此侧重于建立安全信道、强化访问控制策略等等。</p>
<p>后者则假设任一第三方服务均不可信，因此注重完整性、审计、不泄漏数据给第三方等等。</p>
<p>举个例子，如果 Alice 和 Bob 要通过一台服务器（第三方服务）进行通信，那么在 Soft PET 中，双方都会与服务器建立 TLS 连接传输加密数据。服务器可以看到数据明文，不过监听者看不到。</p>
<p>而在 Hard PET 中，Alice 和 Bob 不信任服务器。此时 Alice 可能使用 Bob 的公钥加密后经服务器传输给 Bob，这一过程中服务器就无法看到明文了。</p>
<h2 id="通信隐私"><a href="#通信隐私" class="headerlink" title="通信隐私"></a>通信隐私</h2><p>这个部分比较简单，即密码学中的混合加密机制。</p>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>首先是对称加密部分，现在通常采用 AEAD 方式同时确保机密性和完整性，最著名的算法莫过于 AES-GCM 了。</p>
<blockquote>
<p>需要注意的是，对于同一密钥不能重复使用相同的 IV。</p>
</blockquote>
<p>我们需要实现 <code>encrypt_message</code> 和 <code>decrypt_message</code> 两个函数，在实现前先利用 pytest 写好测试，以 AES-128-GCM 为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_gcm_encrypt</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Tests encryption with AES-GCM &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line">    key = urandom(<span class="number">16</span>)</span><br><span class="line">    message = <span class="string">b&quot;Hello World!&quot;</span></span><br><span class="line">    iv, ciphertext, tag = encrypt_message(key, message)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(iv) == <span class="number">16</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(ciphertext) == <span class="built_in">len</span>(message)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(tag) == <span class="number">16</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_gcm_decrypt</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Tests decryption with AES-GCM &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line">    key = urandom(<span class="number">16</span>)</span><br><span class="line">    message = <span class="string">b&quot;Hello World!&quot;</span></span><br><span class="line">    iv, ciphertext, tag = encrypt_message(key, message)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(iv) == <span class="number">16</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(ciphertext) == <span class="built_in">len</span>(message)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(tag) == <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    m = decrypt_message(key, iv, ciphertext, tag)</span><br><span class="line">    <span class="keyword">assert</span> m == message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_gcm_fails</span>():</span></span><br><span class="line">    <span class="keyword">from</span> pytest <span class="keyword">import</span> raises</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line">    key = urandom(<span class="number">16</span>)</span><br><span class="line">    message = <span class="string">b&quot;Hello World!&quot;</span></span><br><span class="line">    iv, ciphertext, tag = encrypt_message(key, message)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        decrypt_message(key, iv, urandom(<span class="built_in">len</span>(ciphertext)), tag)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;decryption failed&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(excinfo.value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        decrypt_message(key, iv, ciphertext, urandom(<span class="built_in">len</span>(tag)))</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;decryption failed&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(excinfo.value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        decrypt_message(key, urandom(<span class="built_in">len</span>(iv)), ciphertext, tag)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;decryption failed&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(excinfo.value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        decrypt_message(urandom(<span class="built_in">len</span>(key)), iv, ciphertext, tag)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;decryption failed&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(excinfo.value)</span><br></pre></td></tr></table></figure>

<p>函数实现部分则利用 petlib，注意捕获异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_message</span>(<span class="params">key, message</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Encrypt a message under a key given as input &quot;&quot;&quot;</span></span><br><span class="line">    length = <span class="built_in">len</span>(key)</span><br><span class="line">    iv = urandom(length)</span><br><span class="line"></span><br><span class="line">    aes = Cipher(<span class="string">&quot;aes-128-gcm&quot;</span>)</span><br><span class="line">    ciphertext, tag = aes.quick_gcm_enc(key, iv, message)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iv, ciphertext, tag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_message</span>(<span class="params">key, iv, ciphertext, tag</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Decrypt a cipher text under a key given as input</span></span><br><span class="line"><span class="string">        In case the decryption fails, throw an exception.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    aes = Cipher(<span class="string">&quot;aes-128-gcm&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        plain = aes.quick_gcm_dec(key, iv, ciphertext, tag)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;decryption failed&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> plain</span><br></pre></td></tr></table></figure>

<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称部分采用 ECDH 来减小密钥长度，考虑到 Forward Secrecy 的要求，可以升级成 ECDHE。在此之前，先复习一下椭圆曲线算术。</p>
<p>假设曲线为 $y^2\equiv x^3+ax+b\ (mod\ p)$，首先需要一个判断点是否在曲线上的函数。我们用封装好的 <code>petlib.ec</code> 写测试，但只使用 <code>petlib.Bn</code> 来计算椭圆曲线算术：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_on_curve</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Test the procedues that tests whether a point is on a curve.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Example on how to define a curve</span></span><br><span class="line">    <span class="keyword">from</span> petlib.ec <span class="keyword">import</span> EcGroup, EcPt</span><br><span class="line">    group = EcGroup(<span class="number">713</span>)  <span class="comment"># NIST curve</span></span><br><span class="line">    d = group.parameters()</span><br><span class="line">    a, b, p = d[<span class="string">&quot;a&quot;</span>], d[<span class="string">&quot;b&quot;</span>], d[<span class="string">&quot;p&quot;</span>]</span><br><span class="line">    g = group.generator()</span><br><span class="line">    gx, gy = g.get_affine()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> Lab01Code <span class="keyword">import</span> is_point_on_curve</span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, gx, gy)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_point_on_curve</span>(<span class="params">a, b, p, x, y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Check that a point (x, y) is on the curve defined by a,b and prime p.</span></span><br><span class="line"><span class="string">    Reminder: an Elliptic Curve on a prime field p is defined as:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">              y^2 = x^3 + ax + b (mod p)</span></span><br><span class="line"><span class="string">                  (Weierstrass form)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return True if point (x,y) is on curve, otherwise False.</span></span><br><span class="line"><span class="string">    By convention a (None, None) point represents &quot;infinity&quot;.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(a, Bn)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(b, Bn)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(p, Bn) <span class="keyword">and</span> p &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> (<span class="built_in">isinstance</span>(x, Bn) <span class="keyword">and</span> <span class="built_in">isinstance</span>(y, Bn)) \</span><br><span class="line">        <span class="keyword">or</span> (x <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> y <span class="keyword">is</span> <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    lhs = (y * y) % p</span><br><span class="line">    rhs = (x * x * x + a * x + b) % p</span><br><span class="line">    on_curve = (lhs == rhs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> on_curve</span><br></pre></td></tr></table></figure>

<p>随后，对于 $(x_r,y_r)=(x_p,y_p)+(x_q,y_q)$，我们有：<br>$$<br>\lambda=(y_q-y_p)(x_q-x_p)^{-1}\ (mod\ p)\\<br>x_r=\lambda^2-x_p-x_q\ (mod\ p) \\<br>y_r=\lambda(x_p-x_r)-y_p\ (mod\ p)<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_point_addition</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Test whether the EC point addition is correct.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">from</span> pytest <span class="keyword">import</span> raises</span><br><span class="line">    <span class="keyword">from</span> petlib.ec <span class="keyword">import</span> EcGroup, EcPt</span><br><span class="line">    group = EcGroup(<span class="number">713</span>)  <span class="comment"># NIST curve</span></span><br><span class="line">    d = group.parameters()</span><br><span class="line">    a, b, p = d[<span class="string">&quot;a&quot;</span>], d[<span class="string">&quot;b&quot;</span>], d[<span class="string">&quot;p&quot;</span>]</span><br><span class="line">    g = group.generator()</span><br><span class="line">    gx0, gy0 = g.get_affine()</span><br><span class="line"></span><br><span class="line">    r = group.order().random()</span><br><span class="line">    gx1, gy1 = (r * g).get_affine()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, gx0, gy0)</span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, gx1, gy1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Test a simple addition</span></span><br><span class="line">    h = (r + <span class="number">1</span>) * g</span><br><span class="line">    hx1, hy1 = h.get_affine()</span><br><span class="line"></span><br><span class="line">    x, y = point_add(a, b, p, gx0, gy0, gx1, gy1)</span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, x, y)</span><br><span class="line">    <span class="keyword">assert</span> x == hx1</span><br><span class="line">    <span class="keyword">assert</span> y == hy1</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ensure commutativity</span></span><br><span class="line">    xp, yp = point_add(a, b, p, gx1, gy1, gx0, gy0)</span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, xp, yp)</span><br><span class="line">    <span class="keyword">assert</span> x == xp</span><br><span class="line">    <span class="keyword">assert</span> y == yp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ensure addition with neutral returns the element</span></span><br><span class="line">    xp, yp = point_add(a, b, p, gx1, gy1, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, xp, yp)</span><br><span class="line">    <span class="keyword">assert</span> xp == gx1</span><br><span class="line">    <span class="keyword">assert</span> yp == gy1</span><br><span class="line"></span><br><span class="line">    xp, yp = point_add(a, b, p, <span class="literal">None</span>, <span class="literal">None</span>, gx0, gy0)</span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, xp, yp)</span><br><span class="line">    <span class="keyword">assert</span> gx0 == xp</span><br><span class="line">    <span class="keyword">assert</span> gy0 == yp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># An error is raised in case the points are equal</span></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        point_add(a, b, p, gx0, gy0, gx0, gy0)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;EC Points must not be equal&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(excinfo.value)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">@pytest.mark.task3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_point_addition_check_inf_result</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Test whether the EC point addition is correct for pt - pt = inf</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">from</span> petlib.ec <span class="keyword">import</span> EcGroup</span><br><span class="line">    group = EcGroup(<span class="number">713</span>)  <span class="comment"># NIST curve</span></span><br><span class="line">    d = group.parameters()</span><br><span class="line">    a, b, p = d[<span class="string">&quot;a&quot;</span>], d[<span class="string">&quot;b&quot;</span>], d[<span class="string">&quot;p&quot;</span>]</span><br><span class="line">    g = group.generator()</span><br><span class="line">    gx0, gy0 = g.get_affine()</span><br><span class="line">    gx1, gy1 = gx0, p - gy0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, gx0, gy0)</span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, gx1, gy1)</span><br><span class="line"></span><br><span class="line">    x, y = point_add(a, b, p, gx0, gy0, gx1, gy1)</span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, x, y)</span><br><span class="line">    <span class="keyword">assert</span> (x, y) == (<span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">point_add</span>(<span class="params">a, b, p, x0, y0, x1, y1</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Define the &quot;addition&quot; operation for 2 EC Points.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Reminder: (xr, yr) = (xq, yq) + (xp, yp)</span></span><br><span class="line"><span class="string">    is defined as:</span></span><br><span class="line"><span class="string">        lam = (yq - yp) * (xq - xp)^-1 (mod p)</span></span><br><span class="line"><span class="string">        xr  = lam^2 - xp - xq (mod p)</span></span><br><span class="line"><span class="string">        yr  = lam * (xp - xr) - yp (mod p)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Return the point resulting from the addition by</span></span><br><span class="line"><span class="string">    implementing the above pseudocode.</span></span><br><span class="line"><span class="string">    Raises an Exception if the points are equal.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x0 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> y0 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> x1, y1</span><br><span class="line">    <span class="keyword">if</span> x1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> y1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> x0, y0</span><br><span class="line">    <span class="keyword">if</span> x0 == x1 <span class="keyword">and</span> y0 == y1:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;EC Points must not be equal&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> (<span class="built_in">isinstance</span>(x0, Bn) <span class="keyword">and</span> <span class="built_in">isinstance</span>(</span><br><span class="line">        y0, Bn))</span><br><span class="line">    <span class="keyword">assert</span> (<span class="built_in">isinstance</span>(x1, Bn) <span class="keyword">and</span> <span class="built_in">isinstance</span>(</span><br><span class="line">        y1, Bn))</span><br><span class="line"></span><br><span class="line">    inv = <span class="number">0</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        inv = (x1-x0).mod_inverse(p)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    lamb = (y1-y0).mod_mul(inv, p)</span><br><span class="line">    xr = lamb.mod_pow(<span class="number">2</span>, p).mod_sub(x0+x1, p)</span><br><span class="line">    yr = lamb.mod_mul(x0-xr, p).mod_sub(y0, p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xr, yr</span><br></pre></td></tr></table></figure>

<p>特别地，当两个加数相同时：<br>$$<br>\lambda=(3x_p^2+a)(2y_p)^{-1}\ (mod\ p)\\<br>x_r=\lambda^2-2x_p\ (mod\ p)\\<br>y_r=\lambda(x_p-x_r)-y_p\ (mod\ p)<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_point_doubling</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Test whether the EC point doubling is correct.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> petlib.ec <span class="keyword">import</span> EcGroup</span><br><span class="line">    group = EcGroup(<span class="number">713</span>)  <span class="comment"># NIST curve</span></span><br><span class="line">    d = group.parameters()</span><br><span class="line">    a, b, p = d[<span class="string">&quot;a&quot;</span>], d[<span class="string">&quot;b&quot;</span>], d[<span class="string">&quot;p&quot;</span>]</span><br><span class="line">    g = group.generator()</span><br><span class="line">    gx0, gy0 = g.get_affine()</span><br><span class="line"></span><br><span class="line">    gx2, gy2 = (<span class="number">2</span> * g).get_affine()</span><br><span class="line"></span><br><span class="line">    x2, y2 = point_double(a, b, p, gx0, gy0)</span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, x2, y2)</span><br><span class="line">    <span class="keyword">assert</span> x2 == gx2 <span class="keyword">and</span> y2 == gy2</span><br><span class="line"></span><br><span class="line">    x2, y2 = point_double(a, b, p, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, x2, y2)</span><br><span class="line">    <span class="keyword">assert</span> x2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> y2 <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">point_double</span>(<span class="params">a, b, p, x, y</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Define &quot;doubling&quot; an EC point.</span></span><br><span class="line"><span class="string">     A special case, when a point needs to be added to itself.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     Reminder:</span></span><br><span class="line"><span class="string">        lam = (3 * xp ^ 2 + a) * (2 * yp) ^ -1 (mod p)</span></span><br><span class="line"><span class="string">        xr  = lam ^ 2 - 2 * xp</span></span><br><span class="line"><span class="string">        yr  = lam * (xp - xr) - yp (mod p)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns the point representing the double of the input (x, y).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> x, y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> (<span class="built_in">isinstance</span>(x, Bn) <span class="keyword">and</span> <span class="built_in">isinstance</span>(</span><br><span class="line">        y, Bn))</span><br><span class="line"></span><br><span class="line">    inv = (<span class="number">2</span>*y).mod_inverse(p)</span><br><span class="line">    lamb = (<span class="number">3</span>*x**<span class="number">2</span>+a).mod_mul(inv, p)</span><br><span class="line">    xr = lamb.mod_pow(<span class="number">2</span>, p).mod_sub(x*<span class="number">2</span>, p)</span><br><span class="line">    yr = lamb.mod_mul(x-xr, p).mod_sub(y, p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xr, yr</span><br></pre></td></tr></table></figure>

<p>而对于乘法，我们可以使用快速幂的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_point_scalar_mult_double_and_add</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Test the scalar multiplication using double and add.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> petlib.ec <span class="keyword">import</span> EcGroup</span><br><span class="line">    group = EcGroup(<span class="number">713</span>)  <span class="comment"># NIST curve</span></span><br><span class="line">    d = group.parameters()</span><br><span class="line">    a, b, p = d[<span class="string">&quot;a&quot;</span>], d[<span class="string">&quot;b&quot;</span>], d[<span class="string">&quot;p&quot;</span>]</span><br><span class="line">    g = group.generator()</span><br><span class="line">    gx0, gy0 = g.get_affine()</span><br><span class="line">    r = group.order().random()</span><br><span class="line"></span><br><span class="line">    gx2, gy2 = (r * g).get_affine()</span><br><span class="line"></span><br><span class="line">    x2, y2 = point_scalar_multiplication_double_and_add(a, b, p, gx0, gy0, r)</span><br><span class="line">    <span class="keyword">assert</span> is_point_on_curve(a, b, p, x2, y2)</span><br><span class="line">    <span class="keyword">assert</span> gx2 == x2</span><br><span class="line">    <span class="keyword">assert</span> gy2 == y2</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">point_scalar_multiplication_double_and_add</span>(<span class="params">a, b, p, x, y, scalar</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Implement Point multiplication with a scalar:</span></span><br><span class="line"><span class="string">        r * (x, y) = (x, y) + ... + (x, y)    (r times)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Reminder of Double and Multiply algorithm: r * P</span></span><br><span class="line"><span class="string">        Q = infinity</span></span><br><span class="line"><span class="string">        for i = 0 to num_bits(P)-1</span></span><br><span class="line"><span class="string">            if bit i of r == 1 then</span></span><br><span class="line"><span class="string">                Q = Q + P</span></span><br><span class="line"><span class="string">            P = 2 * P</span></span><br><span class="line"><span class="string">        return Q</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    Q = (<span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">    P = (x, y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(x, Bn)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(y, Bn)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(scalar, Bn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(scalar.num_bits()):</span><br><span class="line">        <span class="keyword">if</span> scalar.is_bit_set(i):</span><br><span class="line">            Q = point_add(a, b, p, Q[<span class="number">0</span>], Q[<span class="number">1</span>], P[<span class="number">0</span>], P[<span class="number">1</span>])</span><br><span class="line">        P = point_double(a, b, p, P[<span class="number">0</span>], P[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Q</span><br></pre></td></tr></table></figure>

<p>在后续实验中需要注意的是，整数域上的运算“迁移”到椭圆曲线上时会降阶，即乘法变为加法，幂运算变为乘法。</p>
<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>在我们的混合加密体制中还可以加入数字签名，这里用 ECDSA：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_key_gen</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Tests the key generation of ECDSA&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">from</span> Lab01Code <span class="keyword">import</span> ecdsa_key_gen</span><br><span class="line">    ecdsa_key_gen()</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_produce_signature</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Tests signature function &quot;&quot;&quot;</span></span><br><span class="line">    msg = <span class="string">b&quot;Test&quot;</span> * <span class="number">1000</span></span><br><span class="line">    <span class="keyword">from</span> Lab01Code <span class="keyword">import</span> ecdsa_key_gen, ecdsa_sign</span><br><span class="line"></span><br><span class="line">    group, priv, pub = ecdsa_key_gen()</span><br><span class="line">    ecdsa_sign(group, priv, msg)</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_check_signature</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Tests signature and verification function &quot;&quot;&quot;</span></span><br><span class="line">    msg = <span class="string">b&quot;Test&quot;</span> * <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    group, priv, pub = ecdsa_key_gen()</span><br><span class="line"></span><br><span class="line">    sig = ecdsa_sign(group, priv, msg)</span><br><span class="line">    <span class="keyword">assert</span> ecdsa_verify(group, pub, msg, sig)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_check_fail</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Ensures verification fails when it should &quot;&quot;&quot;</span></span><br><span class="line">    msg = <span class="string">b&quot;Test&quot;</span> * <span class="number">1000</span></span><br><span class="line">    msg2 = <span class="string">b&quot;Text&quot;</span> * <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    group, priv, pub = ecdsa_key_gen()</span><br><span class="line"></span><br><span class="line">    sig = ecdsa_sign(group, priv, msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> ecdsa_verify(group, pub, msg2, sig)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ecdsa_key_gen</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Returns an EC group, a random private key for signing </span></span><br><span class="line"><span class="string">        and the corresponding public key for verification&quot;&quot;&quot;</span></span><br><span class="line">    group = EcGroup()</span><br><span class="line">    priv_sign = group.order().random()</span><br><span class="line">    pub_verify = priv_sign * group.generator()</span><br><span class="line">    <span class="keyword">return</span> group, priv_sign, pub_verify</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ecdsa_sign</span>(<span class="params">group, priv_sign, message</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Sign the SHA256 digest of the message using ECDSA and return a signature &quot;&quot;&quot;</span></span><br><span class="line">    digest = sha256(message).digest()</span><br><span class="line">    kinv_rp = do_ecdsa_setup(group, priv_sign)</span><br><span class="line">    sig = do_ecdsa_sign(group, priv_sign, digest, kinv_rp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ecdsa_verify</span>(<span class="params">group, pub_verify, message, sig</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Verify the ECDSA signature on the message &quot;&quot;&quot;</span></span><br><span class="line">    digest = sha256(message).digest()</span><br><span class="line">    res = do_ecdsa_verify(group, pub_verify, sig, digest)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="完整的加密通信实现"><a href="#完整的加密通信实现" class="headerlink" title="完整的加密通信实现"></a>完整的加密通信实现</h3><p>将上面实现的部分组合到一起，加上 DH 密钥交换，就是完整的加密通信过程了。在下面的代码里假设 Alice 发送 Bob 接收，但因为通信的对称性，对于相反的情况也同样适用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_encrypt</span>():</span></span><br><span class="line">    ecdsa_group, ecdsa_priv_alice, ecdsa_pub_alice = ecdsa_key_gen()</span><br><span class="line">    alice_sig = (ecdsa_group, ecdsa_priv_alice)</span><br><span class="line"></span><br><span class="line">    dh_group, dh_priv_bob, dh_pub_bob = dh_get_key()</span><br><span class="line">    message = <span class="string">b&quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line">    iv, ciphertext, tag, sig, dh_pub_alice = dh_encrypt(</span><br><span class="line">        dh_pub_bob, message, alice_sig)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(iv) == <span class="number">16</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(ciphertext) == <span class="built_in">len</span>(message)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(tag) == <span class="number">16</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_decrypt</span>():</span></span><br><span class="line">    ecdsa_group, ecdsa_priv_alice, ecdsa_pub_alice = ecdsa_key_gen()</span><br><span class="line">    alice_sig = (ecdsa_group, ecdsa_priv_alice)</span><br><span class="line">    alice_ver = (ecdsa_group, ecdsa_pub_alice)</span><br><span class="line"></span><br><span class="line">    dh_group, dh_priv_bob, dh_pub_bob = dh_get_key()</span><br><span class="line">    message = <span class="string">b&quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line">    iv, ciphertext, tag, sig, dh_pub_alice = dh_encrypt(</span><br><span class="line">        dh_pub_bob, message, alice_sig)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(iv) == <span class="number">16</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(ciphertext) == <span class="built_in">len</span>(message)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(tag) == <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    encrypted = (iv, ciphertext, tag, sig)</span><br><span class="line">    m = dh_decrypt(dh_priv_bob, dh_pub_alice, encrypted, alice_ver)</span><br><span class="line">    <span class="keyword">assert</span> m == message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_fails</span>():</span></span><br><span class="line">    ecdsa_group, ecdsa_priv_alice, ecdsa_pub_alice = ecdsa_key_gen()</span><br><span class="line">    alice_sig = (ecdsa_group, ecdsa_priv_alice)</span><br><span class="line">    alice_ver = (ecdsa_group, ecdsa_pub_alice)</span><br><span class="line"></span><br><span class="line">    dh_group, dh_priv_bob, dh_pub_bob = dh_get_key()</span><br><span class="line">    message = <span class="string">b&quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line">    iv, ciphertext, tag, sig, dh_pub_alice = dh_encrypt(</span><br><span class="line">        dh_pub_bob, message, alice_sig)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(iv) == <span class="number">16</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(ciphertext) == <span class="built_in">len</span>(message)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(tag) == <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Random ciphertext</span></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        encrypted = (iv, urandom(<span class="built_in">len</span>(ciphertext)), tag, sig)</span><br><span class="line">        dh_decrypt(dh_priv_bob, dh_pub_alice, encrypted, alice_ver)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;decryption failed&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(excinfo.value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Random AES-GCM tag</span></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        encrypted = (iv, ciphertext, urandom(<span class="built_in">len</span>(tag)), sig)</span><br><span class="line">        dh_decrypt(dh_priv_bob, dh_pub_alice, encrypted, alice_ver)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;decryption failed&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(excinfo.value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Random IV</span></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        encrypted = (urandom(<span class="built_in">len</span>(iv)), ciphertext, tag, sig)</span><br><span class="line">        dh_decrypt(dh_priv_bob, dh_pub_alice, encrypted, alice_ver)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;decryption failed&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(excinfo.value)</span><br><span class="line"></span><br><span class="line">    encrypted_normal = (iv, ciphertext, tag, sig)</span><br><span class="line">    group_rand, priv_rand, pub_rand = dh_get_key()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Random DH private key of Bob</span></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        dh_decrypt(priv_rand, dh_pub_alice, encrypted_normal, alice_ver)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;decryption failed&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(excinfo.value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Random DH public key of Alice</span></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        dh_decrypt(dh_priv_bob, pub_rand, encrypted_normal, alice_ver)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;decryption failed&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(excinfo.value)</span><br><span class="line"></span><br><span class="line">    ecdsa_group_rand, ecdsa_priv_rand, ecdsa_pub_rand = ecdsa_key_gen()</span><br><span class="line">    alice_ver_rand = (ecdsa_group_rand, ecdsa_pub_rand)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Random ECDSA verificaiton key</span></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        dh_decrypt(dh_priv_bob, dh_pub_alice, encrypted_normal, alice_ver_rand)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;verification failed&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(excinfo.value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Random signature</span></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        encrypted = (iv, ciphertext, tag, (Bn(<span class="number">100</span>), Bn(<span class="number">200</span>)))</span><br><span class="line">        dh_decrypt(dh_priv_bob, dh_pub_alice, encrypted, alice_ver)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;verification failed&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(excinfo.value)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dh_get_key</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Generate a DH key pair &quot;&quot;&quot;</span></span><br><span class="line">    group = EcGroup()</span><br><span class="line">    priv_dec = group.order().random()</span><br><span class="line">    pub_enc = priv_dec * group.generator()</span><br><span class="line">    <span class="keyword">return</span> group, priv_dec, pub_enc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dh_encrypt</span>(<span class="params">pub, message, alice_sig=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Assume you know the public key of someone else (Bob), </span></span><br><span class="line"><span class="string">    and wish to Encrypt a message for them.</span></span><br><span class="line"><span class="string">        - Generate a fresh DH key for this message.</span></span><br><span class="line"><span class="string">        - Derive a fresh shared key.</span></span><br><span class="line"><span class="string">        - Use the shared key to AES_GCM encrypt the message.</span></span><br><span class="line"><span class="string">        - Optionally: sign the message with Alice&#x27;s key.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(pub, EcPt)</span><br><span class="line"></span><br><span class="line">    group, priv_dh, pub_dh = dh_get_key()</span><br><span class="line">    secret = priv_dh * pub</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(secret, EcPt)</span><br><span class="line"></span><br><span class="line">    key = sha256(secret.export()).digest()[:<span class="number">16</span>]</span><br><span class="line">    iv, ciphertext, tag = encrypt_message(key, message)</span><br><span class="line"></span><br><span class="line">    sig = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> alice_sig <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        group, priv_sign = alice_sig</span><br><span class="line">        sig = ecdsa_sign(group, priv_sign, message)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iv, ciphertext, tag, sig, pub_dh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dh_decrypt</span>(<span class="params">priv, pub, ciphertext, alice_ver=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Decrypt a received message encrypted using your public key, </span></span><br><span class="line"><span class="string">    of which the private key is provided.</span></span><br><span class="line"><span class="string">    Optionally verify the message came from Alice using her verification</span></span><br><span class="line"><span class="string">    key.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(priv, Bn)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(pub, EcPt)</span><br><span class="line"></span><br><span class="line">    secret = priv * pub</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(secret, EcPt)</span><br><span class="line"></span><br><span class="line">    key = sha256(secret.export()).digest()[:<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">    iv, cipher, tag, sig = ciphertext</span><br><span class="line">    plain = decrypt_message(key, iv, cipher, tag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> alice_ver <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        group, pub_verify = alice_ver</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ecdsa_verify(group, pub_verify, plain, sig):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;verification failed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plain</span><br></pre></td></tr></table></figure>

<h3 id="侧信道攻击"><a href="#侧信道攻击" class="headerlink" title="侧信道攻击"></a>侧信道攻击</h3><p>最后，我们编写函数测试椭圆曲线点乘法所消耗的时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_scalar_mul</span>(<span class="params">f</span>):</span>  <span class="comment"># pragma: no cover</span></span><br><span class="line">    start = time.perf_counter()</span><br><span class="line"></span><br><span class="line">    group = EcGroup(<span class="number">713</span>)</span><br><span class="line">    d = group.parameters()</span><br><span class="line">    a, b, p = d[<span class="string">&quot;a&quot;</span>], d[<span class="string">&quot;b&quot;</span>], d[<span class="string">&quot;p&quot;</span>]</span><br><span class="line">    g = group.generator()</span><br><span class="line">    gx0, gy0 = g.get_affine()</span><br><span class="line">    r = group.order().random()</span><br><span class="line"></span><br><span class="line">    f(a, b, p, gx0, gy0, r)</span><br><span class="line">    <span class="keyword">return</span> r, time.perf_counter()-start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_double_add</span>(<span class="params">times</span>):</span>  <span class="comment"># pragma: no cover</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        r, time_double_add = time_scalar_mul(</span><br><span class="line">            point_scalar_multiplication_double_and_add)</span><br><span class="line">        print(r, time_double_add)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Python3.8 移除了 <code>time.clock()</code>，使用 <code>time.perf_counter()</code> 替代。</p>
</blockquote>
<p>运行后可以发现，快速幂的方式花费时间浮动很大，可能导致基于时间的侧信道攻击。为了防止这一攻击，我们可以采用 Montgomerry Ladder 算法重新实现乘法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">point_scalar_multiplication_montgomerry_ladder</span>(<span class="params">a, b, p, x, y, scalar</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Implement Point multiplication with a scalar:</span></span><br><span class="line"><span class="string">        r * (x, y) = (x, y) + ... + (x, y)    (r times)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Reminder of Double and Multiply algorithm: r * P</span></span><br><span class="line"><span class="string">        R0 = infinity</span></span><br><span class="line"><span class="string">        R1 = P</span></span><br><span class="line"><span class="string">        for i in num_bits(P)-1 to zero:</span></span><br><span class="line"><span class="string">            if di = 0:</span></span><br><span class="line"><span class="string">                R1 = R0 + R1</span></span><br><span class="line"><span class="string">                R0 = 2R0</span></span><br><span class="line"><span class="string">            else</span></span><br><span class="line"><span class="string">                R0 = R0 + R1</span></span><br><span class="line"><span class="string">                R1 = 2 R1</span></span><br><span class="line"><span class="string">        return R0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    R0 = (<span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">    R1 = (x, y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(x, Bn)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(y, Bn)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(scalar, Bn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">0</span>, scalar.num_bits())):</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> ADD YOUR CODE HERE</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> scalar.is_bit_set(i):</span><br><span class="line">            R1 = point_add(a, b, p, R0[<span class="number">0</span>], R0[<span class="number">1</span>], R1[<span class="number">0</span>], R1[<span class="number">1</span>])</span><br><span class="line">            R0 = point_double(a, b, p, R0[<span class="number">0</span>], R0[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            R0 = point_add(a, b, p, R0[<span class="number">0</span>], R0[<span class="number">1</span>], R1[<span class="number">0</span>], R1[<span class="number">1</span>])</span><br><span class="line">            R1 = point_double(a, b, p, R1[<span class="number">0</span>], R1[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> R0</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_montgomery</span>(<span class="params">times</span>):</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        r, time_montgomery = time_scalar_mul(</span><br><span class="line">            point_scalar_multiplication_montgomerry_ladder)</span><br><span class="line">        print(r, time_montgomery)</span><br></pre></td></tr></table></figure>

<p>此时的计时结果非常稳定，因为 Montgomerry Ladder 算法确保了对不同输入的处理花费大致相同的时间。</p>
<h2 id="匿名通信"><a href="#匿名通信" class="headerlink" title="匿名通信"></a>匿名通信</h2><p>匿名通信的匿名性大概有如下几种：</p>
<ul>
<li>发送者匿名：Alice 发送消息给 Bob，Bob 并不知道发送者是谁</li>
<li>接收者匿名：Alice 发送消息给 Bob，但不知道 Bob 是谁</li>
<li>双向匿名：Alice 与 Bob 通信，但不知道对方身份</li>
<li>第三方匿名：Alice 与 Bob 通信并知道对方身份，但第三方并不知道</li>
</ul>
<p>为了满足匿名性，我们常常需要满足：</p>
<ul>
<li>不可观测性：Alice 与 Bob 通信，而其他人并不知道他们各自在发送还是接收消息</li>
<li>不可关联性：Alice 发送（或 Bob 接收）的任意两条消息无法被关联到同一个发送者（或接收者）</li>
<li>伪匿名性：Alice 的所有行为都可以被关联到一个实体，但实体的身份无法确定</li>
</ul>
<p>实现匿名通信有多种方法，其中最简单的莫过于所有发送的消息都通过广播的方式，如果接收到消息的人发现可以成功解密，说明消息是发送给自己的，否则丢弃。这当然不是好办法，但如果我们要自己设计匿名通信机制，需要注意不能比这一办法更差。</p>
<h3 id="高延迟匿名通信"><a href="#高延迟匿名通信" class="headerlink" title="高延迟匿名通信"></a>高延迟匿名通信</h3><p>Mix 是一种高延迟匿名通信机制，实际上就是发送者将消息都发到一个叫做 Mix 的黑盒子里，随后消息从黑盒子里出来，再发送到接收者。如果 Mix 可以抵抗流量分析并提供比特级的不可关联性，那么就能保证匿名性了。</p>
<p>Alice 用 Mix 公钥加密消息后发送给 Mix，随后 Mix 解密并发送给 Bob。由于任何人都可以给 Mix 发消息，而 Mix 的模式实际上为攻击者提供了一个解密 Oracle，因此攻击者可以通过修改输入来进行选择密文攻击，这就要求加密机制是 IND-CCA 的。否则，攻击者就可以关联输入和输出，破坏比特不可关联性。</p>
<p>另一方面，如果 Mix 采用 FIFO 方式接收和发送消息，那么攻击者只需要进行流量分析就能简单地关联输入和输出了，此时 Mix 是不能抵抗流量分析的。可以看到，抗流量分析保护元数据，而比特不可关联性保护数据。</p>
<p>因此，顾名思义，Mix 需要像洗牌一样打乱收到的消息并随机输出，在 Mix 内部也需要一个消息池来暂存还没有发出去的消息，通过延迟、故意插入无用包、故意丢包等手段抵抗流量分析，这就是高延迟的由来。</p>
<h4 id="单个-Mix"><a href="#单个-Mix" class="headerlink" title="单个 Mix"></a>单个 Mix</h4><p>接下来来构建这样的黑盒子，首先是 Mix Server 部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aes_ctr_enc_dec</span>(<span class="params">key, iv, message</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; A helper function that implements AES Counter (CTR) Mode encryption and decryption. </span></span><br><span class="line"><span class="string">    Expects a key (16 byte), and IV (16 bytes) and an input plaintext / ciphertext.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If it is not obvious convince yourself that CTR encryption and decryption are in </span></span><br><span class="line"><span class="string">    fact the same operations.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    aes = Cipher(<span class="string">&quot;AES-128-CTR&quot;</span>)</span><br><span class="line"></span><br><span class="line">    enc = aes.enc(key, iv)</span><br><span class="line">    output = enc.update(message)</span><br><span class="line">    output += enc.finalize()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment"># This is the type of messages destined for the one-hop mix</span></span><br><span class="line">OneHopMixMessage = namedtuple(<span class="string">&#x27;OneHopMixMessage&#x27;</span>, [<span class="string">&#x27;ec_public_key&#x27;</span>,</span><br><span class="line">                                                   <span class="string">&#x27;hmac&#x27;</span>,</span><br><span class="line">                                                   <span class="string">&#x27;address&#x27;</span>,</span><br><span class="line">                                                   <span class="string">&#x27;message&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mix_server_one_hop</span>(<span class="params">private_key, message_list</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Implements the decoding for a simple one-hop mix. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Each message is decoded in turn:</span></span><br><span class="line"><span class="string">        - A shared key is derived from the message public key and the mix private_key.</span></span><br><span class="line"><span class="string">        - the hmac is checked against all encrypted parts of the message</span></span><br><span class="line"><span class="string">        - the address and message are decrypted, decoded and returned</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    G = EcGroup()</span><br><span class="line"></span><br><span class="line">    out_queue = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Process all messages</span></span><br><span class="line">    <span class="keyword">for</span> msg <span class="keyword">in</span> message_list:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check elements and lengths</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> G.check_point(msg.ec_public_key) <span class="keyword">or</span> \</span><br><span class="line">                <span class="keyword">not</span> <span class="built_in">len</span>(msg.hmac) == <span class="number">20</span> <span class="keyword">or</span> \</span><br><span class="line">                <span class="keyword">not</span> <span class="built_in">len</span>(msg.address) == <span class="number">258</span> <span class="keyword">or</span> \</span><br><span class="line">                <span class="keyword">not</span> <span class="built_in">len</span>(msg.message) == <span class="number">1002</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;Malformed input message&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># First get a shared key</span></span><br><span class="line">        shared_element = private_key * msg.ec_public_key</span><br><span class="line">        key_material = sha512(shared_element.export()).digest()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Use different parts of the shared key for different operations</span></span><br><span class="line">        hmac_key = key_material[:<span class="number">16</span>]</span><br><span class="line">        address_key = key_material[<span class="number">16</span>:<span class="number">32</span>]</span><br><span class="line">        message_key = key_material[<span class="number">32</span>:<span class="number">48</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check the HMAC</span></span><br><span class="line">        h = Hmac(<span class="string">b&quot;sha512&quot;</span>, hmac_key)</span><br><span class="line">        h.update(msg.address)</span><br><span class="line">        h.update(msg.message)</span><br><span class="line">        expected_mac = h.digest()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> secure_compare(msg.hmac, expected_mac[:<span class="number">20</span>]):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;HMAC check failure&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Decrypt the address and the message</span></span><br><span class="line">        iv = <span class="string">b&quot;\x00&quot;</span> * <span class="number">16</span></span><br><span class="line"></span><br><span class="line">        address_plaintext = aes_ctr_enc_dec(address_key, iv, msg.address)</span><br><span class="line">        message_plaintext = aes_ctr_enc_dec(message_key, iv, msg.message)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Decode the address and message</span></span><br><span class="line">        address_len, address_full = unpack(<span class="string">&quot;!H256s&quot;</span>, address_plaintext)</span><br><span class="line">        message_len, message_full = unpack(<span class="string">&quot;!H1000s&quot;</span>, message_plaintext)</span><br><span class="line"></span><br><span class="line">        output = (address_full[:address_len], message_full[:message_len])</span><br><span class="line">        out_queue += [output]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(out_queue)</span><br></pre></td></tr></table></figure>

<p>根据 Mix Server 逻辑编写 Mix Client 的逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mix_client_one_hop</span>(<span class="params">public_key, address, message</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Encode a message to travel through a single mix with a set public key. </span></span><br><span class="line"><span class="string">    The maximum size of the final address and the message are 256 bytes and 1000 bytes respectively.</span></span><br><span class="line"><span class="string">    Returns an &#x27;OneHopMixMessage&#x27; with four parts: a public key, an HMAC (20 bytes),</span></span><br><span class="line"><span class="string">    an address ciphertext (256 + 2 bytes) and a message ciphertext (1002 bytes). </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    G = EcGroup()</span><br><span class="line">    <span class="keyword">assert</span> G.check_point(public_key)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(address, <span class="built_in">bytes</span>) <span class="keyword">and</span> <span class="built_in">len</span>(address) &lt;= <span class="number">256</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(message, <span class="built_in">bytes</span>) <span class="keyword">and</span> <span class="built_in">len</span>(message) &lt;= <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Encode the address and message</span></span><br><span class="line">    <span class="comment"># Use those as the payload for encryption</span></span><br><span class="line">    address_plaintext = pack(<span class="string">&quot;!H256s&quot;</span>, <span class="built_in">len</span>(address), address)</span><br><span class="line">    message_plaintext = pack(<span class="string">&quot;!H1000s&quot;</span>, <span class="built_in">len</span>(message), message)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generate a fresh public key</span></span><br><span class="line">    private_key = G.order().random()</span><br><span class="line">    client_public_key = private_key * G.generator()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># First get a shared key</span></span><br><span class="line">    shared_element = private_key * public_key  <span class="comment"># client&#x27;s priv and mix&#x27;s pub</span></span><br><span class="line">    key_material = sha512(shared_element.export()).digest()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use different parts of the shared key for different operations</span></span><br><span class="line">    hmac_key = key_material[:<span class="number">16</span>]</span><br><span class="line">    address_key = key_material[<span class="number">16</span>:<span class="number">32</span>]</span><br><span class="line">    message_key = key_material[<span class="number">32</span>:<span class="number">48</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Encrypt the address and the message</span></span><br><span class="line">    iv = <span class="string">b&quot;\x00&quot;</span>*<span class="number">16</span></span><br><span class="line"></span><br><span class="line">    address_cipher = aes_ctr_enc_dec(address_key, iv, address_plaintext)</span><br><span class="line">    message_cipher = aes_ctr_enc_dec(message_key, iv, message_plaintext)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generate HMAC tag</span></span><br><span class="line">    h = Hmac(<span class="string">b&quot;sha512&quot;</span>, hmac_key)</span><br><span class="line">    h.update(address_cipher)</span><br><span class="line">    h.update(message_cipher)</span><br><span class="line">    expected_mac = h.digest()[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OneHopMixMessage(client_public_key, expected_mac, address_cipher, message_cipher)</span><br></pre></td></tr></table></figure>

<p>测试消息能否正常发送和接收：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_Alice_message</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Encode a single message</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    G = EcGroup()</span><br><span class="line">    g = G.generator()</span><br><span class="line">    o = G.order()</span><br><span class="line"></span><br><span class="line">    private_key = o.random()</span><br><span class="line">    public_key = private_key * g</span><br><span class="line"></span><br><span class="line">    m1 = mix_client_one_hop(public_key, <span class="string">b&quot;Alice&quot;</span>, <span class="string">b&quot;Dear Alice,\nHello!\nBob&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> private_key, m1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_Alice_message_overlong</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Test overlong address or message</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line"></span><br><span class="line">    G = EcGroup()</span><br><span class="line">    g = G.generator()</span><br><span class="line">    o = G.order()</span><br><span class="line"></span><br><span class="line">    private_key = o.random()</span><br><span class="line">    public_key = private_key * g</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        mix_client_one_hop(public_key, urandom(<span class="number">1000</span>), <span class="string">b&quot;Dear Alice,\nHello!\nBob&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        mix_client_one_hop(public_key, <span class="string">b&quot;Alice&quot;</span>, urandom(<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_simple_client_part_type</span>(<span class="params">encode_Alice_message</span>):</span></span><br><span class="line">    private_key, Alice_message = encode_Alice_message</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ensure the client encodes a NamedTuple of type &quot;OneHopMixMessage&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(Alice_message, <span class="built_in">tuple</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(Alice_message) == <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> Alice_message.ec_public_key</span><br><span class="line">    <span class="keyword">assert</span> Alice_message.hmac</span><br><span class="line">    <span class="keyword">assert</span> Alice_message.address</span><br><span class="line">    <span class="keyword">assert</span> Alice_message.message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_simple_client_decode</span>(<span class="params">encode_Alice_message</span>):</span></span><br><span class="line">    private_key, Alice_message = encode_Alice_message</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ensure the mix can decode the message correctly    </span></span><br><span class="line">    res1 = mix_server_one_hop(private_key, [Alice_message])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(res1) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> res1[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">b&quot;Alice&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> res1[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">b&quot;Dear Alice,\nHello!\nBob&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_simple_client_decode_many</span>():</span></span><br><span class="line">    <span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line"></span><br><span class="line">    G = EcGroup()</span><br><span class="line">    g = G.generator()</span><br><span class="line">    o = G.order()</span><br><span class="line"></span><br><span class="line">    private_key = o.random()</span><br><span class="line">    public_key = private_key * g</span><br><span class="line"></span><br><span class="line">    messages = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        m = mix_client_one_hop(public_key, urandom(<span class="number">256</span>), urandom(<span class="number">1000</span>))</span><br><span class="line">        messages += [m]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ensure the mix can decode the message correctly    </span></span><br><span class="line">    res1 = mix_server_one_hop(private_key, messages)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(res1) == <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h4 id="多个-Mix"><a href="#多个-Mix" class="headerlink" title="多个 Mix"></a>多个 Mix</h4><p>为了分散负载和信任，我们可以使用多个 Mix。可以用级联方式增强匿名性（弱负载均衡），也可以用自由路由方式随机选一些 Mix 来传递消息，此时安全性取决于路径长度。</p>
<p>既然目的之一是分散信任，就要考虑如果某个 Mix 被 corrupt 了怎么办。也就是说，我们要不仅要对监听者、还要对 Mix 本身隐藏路径长度以及当前步数。一个比较简单的方法就是嵌套加密，使得 Mix 使用自己的私钥解密时只能知道消息从哪来到哪去，无法了解全局的路径信息。</p>
<p>在代码实现中，我们采用 blinding factor 隐藏公钥信息，并采用级联 HMAC 来检测消息篡改，尤其需要注意的是 blinding factor 和 HMAC 的处理顺序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is the type of messages destined for the n-hop mix</span></span><br><span class="line">NHopMixMessage = namedtuple(<span class="string">&#x27;NHopMixMessage&#x27;</span>, [<span class="string">&#x27;ec_public_key&#x27;</span>,</span><br><span class="line">                                               <span class="string">&#x27;hmacs&#x27;</span>,</span><br><span class="line">                                               <span class="string">&#x27;address&#x27;</span>,</span><br><span class="line">                                               <span class="string">&#x27;message&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mix_server_n_hop</span>(<span class="params">private_key, message_list, final=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Decodes a NHopMixMessage message and outputs either messages destined</span></span><br><span class="line"><span class="string">    to the next mix or a list of tuples (address, message) (if final=True) to be </span></span><br><span class="line"><span class="string">    sent to their final recipients.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Broadly speaking the mix will process each message in turn: </span></span><br><span class="line"><span class="string">        - it derives a shared key (using its private_key), </span></span><br><span class="line"><span class="string">        - checks the first hmac,</span></span><br><span class="line"><span class="string">        - decrypts all other parts,</span></span><br><span class="line"><span class="string">        - either forwards or decodes the message. </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    G = EcGroup()</span><br><span class="line"></span><br><span class="line">    out_queue = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Process all messages</span></span><br><span class="line">    <span class="keyword">for</span> msg <span class="keyword">in</span> message_list:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check elements and lengths</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> G.check_point(msg.ec_public_key) <span class="keyword">or</span> \</span><br><span class="line">                <span class="keyword">not</span> <span class="built_in">isinstance</span>(msg.hmacs, <span class="built_in">list</span>) <span class="keyword">or</span> \</span><br><span class="line">                <span class="keyword">not</span> <span class="built_in">len</span>(msg.hmacs[<span class="number">0</span>]) == <span class="number">20</span> <span class="keyword">or</span> \</span><br><span class="line">                <span class="keyword">not</span> <span class="built_in">len</span>(msg.address) == <span class="number">258</span> <span class="keyword">or</span> \</span><br><span class="line">                <span class="keyword">not</span> <span class="built_in">len</span>(msg.message) == <span class="number">1002</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;Malformed input message&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># First get a shared key</span></span><br><span class="line">        shared_element = private_key * msg.ec_public_key</span><br><span class="line">        key_material = sha512(shared_element.export()).digest()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Use different parts of the shared key for different operations</span></span><br><span class="line">        hmac_key = key_material[:<span class="number">16</span>]</span><br><span class="line">        address_key = key_material[<span class="number">16</span>:<span class="number">32</span>]</span><br><span class="line">        message_key = key_material[<span class="number">32</span>:<span class="number">48</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Extract a blinding factor for the public_key</span></span><br><span class="line">        blinding_factor = Bn.from_binary(key_material[<span class="number">48</span>:])</span><br><span class="line">        new_ec_public_key = blinding_factor * msg.ec_public_key</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check the HMAC</span></span><br><span class="line">        h = Hmac(<span class="string">b&quot;sha512&quot;</span>, hmac_key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> other_mac <span class="keyword">in</span> msg.hmacs[<span class="number">1</span>:]:</span><br><span class="line">            h.update(other_mac)</span><br><span class="line"></span><br><span class="line">        h.update(msg.address)</span><br><span class="line">        h.update(msg.message)</span><br><span class="line"></span><br><span class="line">        expected_mac = h.digest()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> secure_compare(msg.hmacs[<span class="number">0</span>], expected_mac[:<span class="number">20</span>]):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;HMAC check failure&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Decrypt the hmacs, address and the message</span></span><br><span class="line">        aes = Cipher(<span class="string">&quot;AES-128-CTR&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Decrypt hmacs</span></span><br><span class="line">        new_hmacs = []</span><br><span class="line">        <span class="keyword">for</span> i, other_mac <span class="keyword">in</span> <span class="built_in">enumerate</span>(msg.hmacs[<span class="number">1</span>:]):</span><br><span class="line">            <span class="comment"># Ensure the IV is different for each hmac</span></span><br><span class="line">            iv = pack(<span class="string">&quot;H14s&quot;</span>, i, <span class="string">b&quot;\x00&quot;</span> * <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">            hmac_plaintext = aes_ctr_enc_dec(hmac_key, iv, other_mac)</span><br><span class="line">            new_hmacs += [hmac_plaintext]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Decrypt address &amp; message</span></span><br><span class="line">        iv = <span class="string">b&quot;\x00&quot;</span> * <span class="number">16</span></span><br><span class="line"></span><br><span class="line">        address_plaintext = aes_ctr_enc_dec(address_key, iv, msg.address)</span><br><span class="line">        message_plaintext = aes_ctr_enc_dec(message_key, iv, msg.message)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> final:</span><br><span class="line">            <span class="comment"># Decode the address and message</span></span><br><span class="line">            address_len, address_full = unpack(<span class="string">&quot;!H256s&quot;</span>, address_plaintext)</span><br><span class="line">            message_len, message_full = unpack(<span class="string">&quot;!H1000s&quot;</span>, message_plaintext)</span><br><span class="line"></span><br><span class="line">            out_msg = (address_full[:address_len], message_full[:message_len])</span><br><span class="line">            out_queue += [out_msg]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Pass the new mix message to the next mix</span></span><br><span class="line">            out_msg = NHopMixMessage(</span><br><span class="line">                new_ec_public_key, new_hmacs, address_plaintext, message_plaintext)</span><br><span class="line">            out_queue += [out_msg]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out_queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mix_client_n_hop</span>(<span class="params">public_keys, address, message</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Encode a message to travel through a sequence of mixes with a sequence public keys. </span></span><br><span class="line"><span class="string">    The maximum size of the final address and the message are 256 bytes and 1000 bytes respectively.</span></span><br><span class="line"><span class="string">    Returns an &#x27;NHopMixMessage&#x27; with four parts: a public key, a list of hmacs (20 bytes each),</span></span><br><span class="line"><span class="string">    an address ciphertext (256 + 2 bytes) and a message ciphertext (1002 bytes). </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    G = EcGroup()</span><br><span class="line">    <span class="comment"># assert G.check_point(public_key)</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(address, <span class="built_in">bytes</span>) <span class="keyword">and</span> <span class="built_in">len</span>(address) &lt;= <span class="number">256</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(message, <span class="built_in">bytes</span>) <span class="keyword">and</span> <span class="built_in">len</span>(message) &lt;= <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Encode the address and message</span></span><br><span class="line">    <span class="comment"># use those encoded values as the payload you encrypt!</span></span><br><span class="line">    address_plaintext = pack(<span class="string">&quot;!H256s&quot;</span>, <span class="built_in">len</span>(address), address)</span><br><span class="line">    message_plaintext = pack(<span class="string">&quot;!H1000s&quot;</span>, <span class="built_in">len</span>(message), message)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generate a fresh public key</span></span><br><span class="line">    private_key = G.order().random()</span><br><span class="line">    client_public_key = private_key * G.generator()</span><br><span class="line"></span><br><span class="line">    hmacs = []</span><br><span class="line">    hmac_keys, address_keys, message_keys = [], [], []</span><br><span class="line">    blinding_factor = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Preprocess the keys</span></span><br><span class="line">    <span class="keyword">for</span> i, pubkey <span class="keyword">in</span> <span class="built_in">enumerate</span>(public_keys):</span><br><span class="line">        <span class="comment"># First get a shared key</span></span><br><span class="line">        shared_element = private_key * blinding_factor * pubkey</span><br><span class="line">        key_material = sha512(shared_element.export()).digest()</span><br><span class="line">        <span class="comment"># Use different parts of the shared key for different operations</span></span><br><span class="line">        hmac_keys.append(key_material[:<span class="number">16</span>])</span><br><span class="line">        address_keys.append(key_material[<span class="number">16</span>:<span class="number">32</span>])</span><br><span class="line">        message_keys.append(key_material[<span class="number">32</span>:<span class="number">48</span>])</span><br><span class="line">        <span class="comment"># Update blinding factor for next round</span></span><br><span class="line">        blinding_factor = blinding_factor * Bn.from_binary(key_material[<span class="number">48</span>:])</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">len</span>(hmac_keys)</span><br><span class="line">    iv = <span class="string">b&quot;\x00&quot;</span>*<span class="number">16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Traverse the mix server in reversed order</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># Encrypt address &amp; message</span></span><br><span class="line">        address_cipher = aes_ctr_enc_dec(</span><br><span class="line">            address_keys[i], iv, address_plaintext)</span><br><span class="line">        message_cipher = aes_ctr_enc_dec(</span><br><span class="line">            message_keys[i], iv, message_plaintext)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Encrypt other HMAC tags, each with a different IV</span></span><br><span class="line">        <span class="keyword">for</span> j, other_mac <span class="keyword">in</span> <span class="built_in">enumerate</span>(hmacs):</span><br><span class="line">            iv = pack(<span class="string">&quot;H14s&quot;</span>, j, <span class="string">b&quot;\x00&quot;</span>*<span class="number">14</span>)</span><br><span class="line">            hmacs[j] = aes_ctr_enc_dec(hmac_keys[i], iv, other_mac)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Generate HMAC tag and insert to the beginning of hmacs</span></span><br><span class="line">        h = Hmac(<span class="string">b&quot;sha512&quot;</span>, hmac_keys[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> other_mac <span class="keyword">in</span> hmacs:</span><br><span class="line">            h.update(other_mac)</span><br><span class="line"></span><br><span class="line">        h.update(address_cipher)</span><br><span class="line">        h.update(message_cipher)</span><br><span class="line"></span><br><span class="line">        expected_mac = h.digest()[:<span class="number">20</span>]</span><br><span class="line">        hmacs.insert(<span class="number">0</span>, expected_mac)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Update address &amp; message for next round</span></span><br><span class="line">        address_plaintext = address_cipher</span><br><span class="line">        message_plaintext = message_cipher</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NHopMixMessage(client_public_key, hmacs, address_cipher, message_cipher)</span><br></pre></td></tr></table></figure>

<p>然后测试一下 1 跳和 3 跳两种情况下的正确性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_Alice_encode_1_hop</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Test sending a multi-hop message through 1-hop</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line"></span><br><span class="line">    G = EcGroup()</span><br><span class="line">    g = G.generator()</span><br><span class="line">    o = G.order()</span><br><span class="line"></span><br><span class="line">    private_key = o.random()</span><br><span class="line">    public_key = private_key * g</span><br><span class="line"></span><br><span class="line">    address = <span class="string">b&quot;Alice&quot;</span></span><br><span class="line">    message = <span class="string">b&quot;Dear Alice,\nHello!\nBob&quot;</span></span><br><span class="line"></span><br><span class="line">    m1 = mix_client_n_hop([public_key], address, message)</span><br><span class="line">    out = mix_server_n_hop(private_key, [m1], final=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(out) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> out[<span class="number">0</span>][<span class="number">0</span>] == address</span><br><span class="line">    <span class="keyword">assert</span> out[<span class="number">0</span>][<span class="number">1</span>] == message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_Alice_encode_3_hop</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Test sending a multi-hop message through 1-hop</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line"></span><br><span class="line">    G = EcGroup()</span><br><span class="line">    g = G.generator()</span><br><span class="line">    o = G.order()</span><br><span class="line"></span><br><span class="line">    private_keys = [o.random() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">    public_keys = [pk * g <span class="keyword">for</span> pk <span class="keyword">in</span> private_keys]</span><br><span class="line"></span><br><span class="line">    address = <span class="string">b&quot;Alice&quot;</span></span><br><span class="line">    message = <span class="string">b&quot;Dear Alice,\nHello!\nBob&quot;</span></span><br><span class="line"></span><br><span class="line">    m1 = mix_client_n_hop(public_keys, address, message)</span><br><span class="line">    out = mix_server_n_hop(private_keys[<span class="number">0</span>], [m1])</span><br><span class="line">    out = mix_server_n_hop(private_keys[<span class="number">1</span>], out)</span><br><span class="line">    out = mix_server_n_hop(private_keys[<span class="number">2</span>], out, final=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(out) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> out[<span class="number">0</span>][<span class="number">0</span>] == address</span><br><span class="line">    <span class="keyword">assert</span> out[<span class="number">0</span>][<span class="number">1</span>] == message</span><br></pre></td></tr></table></figure>

<h4 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h4><p>我们通过例子来看如何通过简单的流量分析来推断一个发送者发送消息的目标。首先随机生成大量发送/接收消息的 trace：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_trace</span>(<span class="params">number_of_users, threshold_size, number_of_rounds, targets_friends</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Generate a simulated trace of traffic. &quot;&quot;&quot;</span></span><br><span class="line">    target = <span class="number">0</span></span><br><span class="line">    others = <span class="built_in">range</span>(<span class="number">1</span>, number_of_users)</span><br><span class="line">    all_users = <span class="built_in">range</span>(number_of_users)</span><br><span class="line"></span><br><span class="line">    trace = []</span><br><span class="line">    <span class="comment"># Generate traces in which Alice (user 0) is not sending</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(number_of_rounds // <span class="number">2</span>):</span><br><span class="line">        senders = <span class="built_in">sorted</span>(random.sample(others, threshold_size))</span><br><span class="line">        receivers = <span class="built_in">sorted</span>(random.sample(all_users, threshold_size))</span><br><span class="line"></span><br><span class="line">        trace += [(senders, receivers)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generate traces in which Alice (user 0) is sending</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(number_of_rounds // <span class="number">2</span>):</span><br><span class="line">        senders = <span class="built_in">sorted</span>([<span class="number">0</span>] + random.sample(others, threshold_size - <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># Alice sends to a friend</span></span><br><span class="line">        friend = random.choice(targets_friends)</span><br><span class="line">        receivers = <span class="built_in">sorted</span>(</span><br><span class="line">            [friend] + random.sample(all_users, threshold_size - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        trace += [(senders, receivers)]</span><br><span class="line"></span><br><span class="line">    random.shuffle(trace)</span><br><span class="line">    <span class="keyword">return</span> trace</span><br></pre></td></tr></table></figure>

<p>这里 Alice 也就是 user0 会发送一些消息给她的好友，而其他用户之间的消息收发是完全随机的。我们不难发现，Alice 的好友应当比其他用户接收到了更多消息，这就是这次流量分析的关键：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_trace</span>(<span class="params">trace, target_number_of_friends, target=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">    Given a trace of traffic, and a given number of friends, </span></span><br><span class="line"><span class="string">    return the list of receiver identifiers that are the most likely </span></span><br><span class="line"><span class="string">    friends of the target.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    max_users = <span class="number">100</span></span><br><span class="line">    rcv_cnt = <span class="built_in">dict</span>.fromkeys(<span class="built_in">range</span>(max_users), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">round</span> <span class="keyword">in</span> trace:</span><br><span class="line">        senders, receivers = <span class="built_in">round</span></span><br><span class="line">        <span class="keyword">for</span> user <span class="keyword">in</span> receivers:</span><br><span class="line">            rcv_cnt[user] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># sort in descending order according to occurence</span></span><br><span class="line">    occur = <span class="built_in">sorted</span>(rcv_cnt.items(), key=<span class="keyword">lambda</span> d: (d[<span class="number">1</span>], d[<span class="number">0</span>]), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># select the top [target_number_of_friends] users</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">0</span>], occur[:target_number_of_friends]))</span><br></pre></td></tr></table></figure>

<p>这里我们根据接收消息次数对用户进行排序，并选择了前 <code>target_number_of_friends</code> 个用户，推断是 Alice 的好友。进行测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_trace_static</span>():</span></span><br><span class="line">    <span class="comment"># A fixed set and number of friends</span></span><br><span class="line">    trace = generate_trace(<span class="number">100</span>, <span class="number">10</span>, <span class="number">1000</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">    friends = analyze_trace(trace, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(friends) == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">sorted</span>(friends) == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_trace_variable</span>():</span></span><br><span class="line">    <span class="comment"># A random number of friends and random contacts</span></span><br><span class="line">    friend_number = random.choice(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">    friends = random.sample(<span class="built_in">range</span>(<span class="number">100</span>), friend_number)</span><br><span class="line"></span><br><span class="line">    trace = generate_trace(<span class="number">100</span>, <span class="number">10</span>, <span class="number">1000</span>, friends)</span><br><span class="line">    TA_friends = analyze_trace(trace, <span class="built_in">len</span>(friends))</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(TA_friends) == <span class="built_in">len</span>(friends)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">sorted</span>(TA_friends) == <span class="built_in">sorted</span>(friends)</span><br></pre></td></tr></table></figure>

<p>经多次实验，均可以通过这两个测试。</p>
<h3 id="低延迟匿名通信"><a href="#低延迟匿名通信" class="headerlink" title="低延迟匿名通信"></a>低延迟匿名通信</h3><p>也就是 Onion 路由，最著名的例子是 Tor 网络。如果 Alice 要发送消息给 Bob，那么 Alice 会选择 3 个 Tor 节点，将消息经由这 3 个节点发送到 Bob，这样任意节点都不知道消息是从 Alice 到 Bob 的。</p>
<p>上述方法提供了发送者匿名性，但需要 Alice 知道 Bob 身份。如果要双向匿名，则需要 6 个 Tor 节点，两边对称。</p>
<p>Tor 节点将 IP、公钥等信息公开到 Directory Authorities 上，后者则生成一个 Consensus 供 Tor 客户端下载，从而获取 Tor 节点的信息。</p>
<p>对于攻击者来说，依然可以用类似侧信道的方式攻击 Onion 路由。一种方法是将输入和输出放到桶中，计算两者关联，但桶的存在会降低精确度。更好的方法是根据输入和包延迟的概率分布构建模版，并用输出去匹配模版。因此，低延迟匿名通信更容易受到被动攻击。</p>
<p>而如果攻击者能控制部分 Tor 节点，也不一定能控制某次通信的整条路径。如果攻击者控制了 Tor 网络中的 c 个节点，那么整条路径被控制的概率为 O(c^2)，因为攻击者必须控制第一个和最后一个节点才行。</p>
<h2 id="隐私友好型计算"><a href="#隐私友好型计算" class="headerlink" title="隐私友好型计算"></a>隐私友好型计算</h2><p>在前两部分，我们介绍了如何向第三方隐藏隐私信息，如通信内容、身份等，并且已经有类似 TLS 和 Tor 这类成熟的解决方案。但是，如果是要向通信的对方隐藏信息呢？</p>
<p>例如，我们想计算 $y=f(x_1,…,x_n)$，其中涉及的输入 $x_i$ 来自 n 个不同的主体，并且每个主体都不希望别人知道自己的 $x_i$。最简单的办法是引入可信第三方（TTP）来计算 y，然而且不论 TTP 未必存在，我们必须得考虑 4C 问题：</p>
<ul>
<li>Cost：TTP 要花多少钱？</li>
<li>Corruption：TTP 真的可信吗？</li>
<li>Compulsion：TTP 有没有可能受到不可抗力影响（如法律）泄露隐私？</li>
<li>Compromise：TTP 有没有可能被入侵从而泄露隐私？</li>
</ul>
<p>可以看到，寄希望于 TTP 并不明智，不过这可以作为一个很好的比较标准，即我们设计的方案应尽可能接近引入 TTP 所能达到的效果。</p>
<h3 id="同态加密"><a href="#同态加密" class="headerlink" title="同态加密"></a>同态加密</h3><p>一种方法是同态加密，即对密文的运算等同于对明文的运算，此时可以在不知道明文的情况下计算出经过运算的明文所对应的密文。以 ElGamal 为例，我们选择群 $G$ 中的两个元素 $g,h$，随机生成 $x\in(0,ord(G))$ 作为私钥，那么公钥就是 $g^x$。随后再选择随机的 $k\in(0,ord(G))$，计算密文 $E(m,k)=(g^k,g^{xk}h^m)$。</p>
<p>解密时，对于密文 $(a,b)$，只需计算 $m=log_h(b(a^x)^{-1})$。然而离散对数问题是困难的，因此可以先离线计算一张 $log_h$ 表格（这就要求明文空间不能太大）。正确性易证，同态性则包含加法和常数乘法同态：<br>$$<br>E(m_0,k_0)=(a_0,b_0)\\<br>E(m_1,k_1)=(a_1,b_1)\\<br>E(m_0+m_1,k_0+k_1)=(a_0a_1,b_0b_1)=(g^{k0+k1},g^{x(k0+k1)}h^{m0+m1})\\<br>E(cm_0, ck_0)=((a_0)^c,(b_0)^c)<br>$$</p>
<blockquote>
<p>只满足常数乘法同态，不满足乘法同态。</p>
</blockquote>
<p>接下来，我们在椭圆曲线上实现 Elgamal。需要注意上文提到的运算降阶问题，公钥变成了 $xg$，密文为 $(kg,kxg+mh)$，解密时计算 $log_h(b-xa)$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_encrypt</span>():</span></span><br><span class="line">    params = setup()</span><br><span class="line">    priv, pub = keyGen(params)</span><br><span class="line">    <span class="keyword">assert</span> encrypt(params, pub, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">assert</span> encrypt(params, pub, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">assert</span> encrypt(params, pub, <span class="number">-10</span>)</span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        encrypt(params, pub, <span class="number">-1000</span>)</span><br><span class="line">    <span class="keyword">with</span> raises(Exception) <span class="keyword">as</span> excinfo:</span><br><span class="line">        encrypt(params, pub, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_decrypt</span>():</span></span><br><span class="line">    params = setup()</span><br><span class="line">    priv, pub = keyGen(params)</span><br><span class="line">    <span class="keyword">assert</span> decrypt(params, priv, encrypt(params, pub, <span class="number">0</span>)) == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> decrypt(params, priv, encrypt(params, pub, <span class="number">2</span>)) == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> decrypt(params, priv, encrypt(params, pub, <span class="number">-2</span>)) == <span class="number">-2</span></span><br><span class="line">    <span class="keyword">assert</span> decrypt(params, priv, encrypt(params, pub, <span class="number">99</span>)) == <span class="number">99</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generates the Cryptosystem Parameters.&quot;&quot;&quot;</span></span><br><span class="line">    G = EcGroup(nid=<span class="number">713</span>)</span><br><span class="line">    g = G.hash_to_point(<span class="string">b&quot;g&quot;</span>)</span><br><span class="line">    h = G.hash_to_point(<span class="string">b&quot;h&quot;</span>)</span><br><span class="line">    o = G.order()</span><br><span class="line">    <span class="keyword">return</span> G, g, h, o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keyGen</span>(<span class="params">params</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Generate a private / public key pair &quot;&quot;&quot;</span></span><br><span class="line">    G, g, h, o = params</span><br><span class="line"></span><br><span class="line">    priv = G.order().random()</span><br><span class="line">    pub = priv * g</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> priv, pub</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">params, pub, m</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Encrypt a message under the public key &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">-100</span> &lt; m &lt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Message value to low or high.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    G, g, h, o = params</span><br><span class="line">    k = o.random()</span><br><span class="line">    <span class="comment"># (g^k, (pub^k)*(h^m))</span></span><br><span class="line">    c = (k*g, k*pub + m*h)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isCiphertext</span>(<span class="params">params, ciphertext</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Check a ciphertext &quot;&quot;&quot;</span></span><br><span class="line">    (G, g, h, o) = params</span><br><span class="line">    ret = <span class="built_in">len</span>(ciphertext) == <span class="number">2</span></span><br><span class="line">    a, b = ciphertext</span><br><span class="line">    ret &amp;= G.check_point(a)</span><br><span class="line">    ret &amp;= G.check_point(b)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_logh = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logh</span>(<span class="params">params, hm</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Compute a discrete log, for small number only &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> _logh</span><br><span class="line">    G, g, h, o = params</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize the map of logh</span></span><br><span class="line">    <span class="keyword">if</span> _logh <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        _logh = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">-1000</span>, <span class="number">1000</span>):</span><br><span class="line">            _logh[(m * h)] = m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> hm <span class="keyword">not</span> <span class="keyword">in</span> _logh:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;No decryption found.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _logh[hm]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">params, priv, ciphertext</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Decrypt a message using the private key &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> isCiphertext(params, ciphertext)</span><br><span class="line">    a, b = ciphertext</span><br><span class="line"></span><br><span class="line">    <span class="comment"># b * (a^priv)^(-1)</span></span><br><span class="line">    hm = b - priv*a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logh(params, hm)</span><br></pre></td></tr></table></figure>

<p>随后，编写同态加密函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_add</span>():</span></span><br><span class="line">    params = setup()</span><br><span class="line">    priv, pub = keyGen(params)</span><br><span class="line">    one = encrypt(params, pub, <span class="number">1</span>)</span><br><span class="line">    two = encrypt(params, pub, <span class="number">2</span>)</span><br><span class="line">    three = add(params, pub, one, two)</span><br><span class="line">    <span class="keyword">assert</span> decrypt(params, priv, three) == <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Try it for a range of numbers</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">-10</span>, <span class="number">10</span>):</span><br><span class="line">        Ex = encrypt(params, pub, x)</span><br><span class="line">        E2x = add(params, pub, Ex, Ex)</span><br><span class="line">        <span class="keyword">assert</span> decrypt(params, priv, E2x) == <span class="number">2</span> * x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.task2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_mul</span>():</span></span><br><span class="line">    params = setup()</span><br><span class="line">    priv, pub = keyGen(params)</span><br><span class="line">    two = encrypt(params, pub, <span class="number">2</span>)</span><br><span class="line">    three = mul(params, pub, two, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> decrypt(params, priv, three) == <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Try it for a range of numbers</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">-10</span>, <span class="number">10</span>):</span><br><span class="line">        Ex = encrypt(params, pub, x)</span><br><span class="line">        E2x = mul(params, pub, Ex, <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">assert</span> decrypt(params, priv, E2x) == <span class="number">20</span> * x</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">params, pub, c1, c2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Given two ciphertexts compute the ciphertext of the </span></span><br><span class="line"><span class="string">        sum of their plaintexts.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> isCiphertext(params, c1)</span><br><span class="line">    <span class="keyword">assert</span> isCiphertext(params, c2)</span><br><span class="line"></span><br><span class="line">    a1, b1 = c1</span><br><span class="line">    a2, b2 = c2</span><br><span class="line">    c3 = (a1+a2, b1+b2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">params, pub, c1, alpha</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Given a ciphertext compute the ciphertext of the </span></span><br><span class="line"><span class="string">        product of the plaintext time alpha &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> isCiphertext(params, c1)</span><br><span class="line"></span><br><span class="line">    a1, b1 = c1</span><br><span class="line">    c3 = (alpha * a1, alpha * b1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c3</span><br></pre></td></tr></table></figure>

<p>现在，我们来解决多方参与计算的问题。我们根据多方公钥，生成公共公钥。在整数域表示为 $g^{x_1+…+x_n}$，在椭圆曲线上则是 $x_1g+…+x_ng$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_groupKey</span>():</span></span><br><span class="line">    params = setup()</span><br><span class="line">    (G, g, h, o) = params</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generate a group key</span></span><br><span class="line">    priv1, pub1 = keyGen(params)</span><br><span class="line">    priv2, pub2 = keyGen(params)</span><br><span class="line">    pub = groupKey(params, [pub1, pub2])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check it is valid</span></span><br><span class="line">    priv = (priv1 + priv2) % o</span><br><span class="line">    <span class="keyword">assert</span> decrypt(params, priv, encrypt(params, pub, <span class="number">0</span>)) == <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupKey</span>(<span class="params">params, pubKeys=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Generate a group public key from a list of public keys &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> pubKeys <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        pubKeys = []</span><br><span class="line">    G, g, h, o = params</span><br><span class="line"></span><br><span class="line">    pub = G.infinite()  <span class="comment"># 0 elem</span></span><br><span class="line">    <span class="keyword">for</span> pubKey <span class="keyword">in</span> pubKeys:</span><br><span class="line">        pub = pubKey + pub</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pub</span><br></pre></td></tr></table></figure>

<p>随后进行部分解密，最后一个解密的人输出明文。在整数域表示为 $b\cdot a^{-x_1}\cdot …\cdot a^{-x_n}$，在椭圆曲线上表示为 $b-x_1a-…-x_na$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_partial</span>():</span></span><br><span class="line">    params = setup()</span><br><span class="line">    (G, g, h, o) = params</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generate a group key</span></span><br><span class="line">    priv1, pub1 = keyGen(params)</span><br><span class="line">    priv2, pub2 = keyGen(params)</span><br><span class="line">    pub = groupKey(params, [pub1, pub2])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Each authority decrypts in turn</span></span><br><span class="line">    c = encrypt(params, pub, <span class="number">0</span>)</span><br><span class="line">    cprime = partialDecrypt(params, priv1, c)</span><br><span class="line">    m = partialDecrypt(params, priv2, cprime, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">assert</span> m == <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partialDecrypt</span>(<span class="params">params, priv, ciphertext, final=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Given a ciphertext and a private key, perform partial decryption. </span></span><br><span class="line"><span class="string">        If final is True, then return the plaintext. &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> isCiphertext(params, ciphertext)</span><br><span class="line"></span><br><span class="line">    a1, b1 = ciphertext</span><br><span class="line">    b1 = b1 - priv*a1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> final:</span><br><span class="line">        <span class="keyword">return</span> logh(params, b1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> a1, b1</span><br></pre></td></tr></table></figure>

<p>现在假设某一方想要让生成的公共公钥等于自己的公钥，这样自己一个人就能解密密文了。那么他只需要提交一个自己构造的公钥即可，在整数域是 $\frac{g^{x_j}}{\Pi_{i\neq j}\ g^{x_i}}$，这样生成公共公钥 $\Pi_{i\neq j}\ g^{x_i}\cdot \frac{g^{x_j}}{\Pi_{i\neq j}\ g^{x_i}}=g^{x_j}$。在椭圆曲线上则是 $x_jg-\Sigma_{i\neq j}\ x_ig$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_badpub</span>():</span></span><br><span class="line">    params = setup()</span><br><span class="line">    (G, g, h, o) = params</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Four authorities generate keys</span></span><br><span class="line">    priv1, pub1 = keyGen(params)</span><br><span class="line">    priv2, pub2 = keyGen(params)</span><br><span class="line">    priv3, pub3 = keyGen(params)</span><br><span class="line">    priv4, pub4 = keyGen(params)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Derive a bad key</span></span><br><span class="line">    x = o.random()</span><br><span class="line">    badpub = corruptPubKey(params, x, [pub1, pub2, pub3, pub4])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Derive the group key including the bad public key</span></span><br><span class="line">    pub = groupKey(params, [pub1, pub2, pub3, pub4, badpub])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check that the corrupt authority can decrypt a message</span></span><br><span class="line">    <span class="comment"># encrypted under the group key with its secret only.</span></span><br><span class="line">    <span class="keyword">assert</span> decrypt(params, x, encrypt(params, pub, <span class="number">0</span>)) == <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corruptPubKey</span>(<span class="params">params, priv, OtherPubKeys=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Simulate the operation of a corrupt decryption authority. </span></span><br><span class="line"><span class="string">        Given a set of public keys from other authorities return a</span></span><br><span class="line"><span class="string">        public key for the corrupt authority that leads to a group</span></span><br><span class="line"><span class="string">        public key corresponding to a private key known to the</span></span><br><span class="line"><span class="string">        corrupt authority. &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> OtherPubKeys <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        OtherPubKeys = []</span><br><span class="line">    G, g, h, o = params</span><br><span class="line"></span><br><span class="line">    pub = priv*g</span><br><span class="line">    <span class="keyword">for</span> pubkey <span class="keyword">in</span> OtherPubKeys:</span><br><span class="line">        pub = pub - pubkey</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pub</span><br></pre></td></tr></table></figure>

<h3 id="秘密分享"><a href="#秘密分享" class="headerlink" title="秘密分享"></a>秘密分享</h3><p>秘密分享采用了另一种思路，将秘密拆分成若干碎片提供给不同 authorities，从而在避免 authorities 得知秘密的同时，能够让 authorities 进行协同计算。这个“协同计算”部分实际上是依赖于加法同态加密的，例如我们用 <code>&lt;a&gt;</code> 表示 a 的碎片集合，那么 <code>&lt;a+b&gt;=&lt;a&gt;+&lt;b&gt;</code>，此时计算出的是一个新的秘密的一个碎片。加常数和乘常数也是类似的。</p>
<p>不过，如果是秘密碎片之间的乘法就比较复杂了，这需要一些预计算的值以及 authorities 之间的交互。例如，要计算 <code>&lt;x&gt;</code> 和 <code>&lt;y&gt;</code> 的积，我们需要先预计算 <code>&lt;a&gt;,&lt;b&gt;,&lt;c&gt;</code> 使得 <code>&lt;c&gt;=&lt;ab&gt;</code>，其中 <code>&lt;a&gt;,&lt;b&gt;</code> 是随机的，这样才能隐藏 <code>&lt;x&gt;</code> 和 <code>&lt;y&gt;</code>。</p>
<p>接下来，计算 <code>&lt;e&gt;=&lt;x&gt;+&lt;a&gt;</code>，<code>&lt;d&gt;=&lt;y&gt;+&lt;b&gt;</code>，公开 <code>&lt;e&gt;,&lt;d&gt;</code> 获得 <code>e,d</code>。此时方能计算 <code>&lt;z&gt;=&lt;xy&gt;=&lt;c&gt;-e&lt;b&gt;-d&lt;a&gt;+ed</code>。</p>
<p>秘密分享相对于同态加密的优势在于可以加入机制确保完整性。传统方法是 authorities 进行零知识证明，表明其公开的值是合法的，但性能堪忧。SPDZ 则引入 MAC 并将 MAC 也拆成碎片，并通过并行验证提高性能，使得完整性检查较为廉价。</p>
<p>综合来看，秘密分享额外增加了网络负担，而同态加密额外增加了计算负担，对于大规模计算而言总体性能较差。目前两者都依然处于研究阶段，尚不成熟。</p>
<h3 id="私密投票"><a href="#私密投票" class="headerlink" title="私密投票"></a>私密投票</h3><p>最后我们实现一个私密投票的场景：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.task5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_poll</span>():</span></span><br><span class="line">    votes = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">    v0, v1 = simulate_poll(votes)</span><br><span class="line">    <span class="keyword">assert</span> v0 == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> v1 == <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>我们需要在不知道明文的情况下，统计 0 和 1 的个数。首先为 authorities 生成密钥对并生成公共公钥，用 <code>encode_vote()</code> 来加密投票情况。随后调用 <code>process_votes()</code> 针对密文统计个数，最后 <code>partialDecrypt()</code> 解密个数信息并返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_vote</span>(<span class="params">params, pub, vote</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Given a vote 0 or 1 encode the vote as two</span></span><br><span class="line"><span class="string">        ciphertexts representing the count of votes for</span></span><br><span class="line"><span class="string">        zero and the votes for one.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> vote <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    v0, v1 = encrypt(params, pub, vote)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v0, v1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_votes</span>(<span class="params">params, pub, encrypted_votes</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Given a list of encrypted votes tally them</span></span><br><span class="line"><span class="string">        to sum votes for zeros and votes for ones. &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(encrypted_votes, <span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    tv1 = encrypt(params, pub, <span class="number">0</span>)  <span class="comment"># 0 elem</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> encrypted_votes:</span><br><span class="line">        tv1 = add(params, pub, tv1, c)</span><br><span class="line"></span><br><span class="line">    total = <span class="built_in">len</span>(encrypted_votes)</span><br><span class="line">    <span class="comment"># total + (-1)*tv1</span></span><br><span class="line">    tv0 = encrypt(params, pub, total)</span><br><span class="line">    tv0 = add(params, pub, tv0, mul(params, pub, tv1, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tv0, tv1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulate_poll</span>(<span class="params">votes</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Simulates the full process of encrypting votes,</span></span><br><span class="line"><span class="string">        tallying them, and then decrypting the total. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generate parameters for the crypto-system</span></span><br><span class="line">    params = setup()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make keys for 3 authorities</span></span><br><span class="line">    priv1, pub1 = keyGen(params)</span><br><span class="line">    priv2, pub2 = keyGen(params)</span><br><span class="line">    priv3, pub3 = keyGen(params)</span><br><span class="line">    pub = groupKey(params, [pub1, pub2, pub3])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Simulate encrypting votes</span></span><br><span class="line">    encrypted_votes = []</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> votes:</span><br><span class="line">        encrypted_votes.append(encode_vote(params, pub, v))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Tally the votes</span></span><br><span class="line">    total_v0, total_v1 = process_votes(params, pub, encrypted_votes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Simulate threshold decryption</span></span><br><span class="line">    privs = [priv1, priv2, priv3]</span><br><span class="line">    <span class="keyword">for</span> priv <span class="keyword">in</span> privs[:<span class="number">-1</span>]:</span><br><span class="line">        total_v0 = partialDecrypt(params, priv, total_v0)</span><br><span class="line">        total_v1 = partialDecrypt(params, priv, total_v1)</span><br><span class="line"></span><br><span class="line">    total_v0 = partialDecrypt(params, privs[<span class="number">-1</span>], total_v0, <span class="literal">True</span>)</span><br><span class="line">    total_v1 = partialDecrypt(params, privs[<span class="number">-1</span>], total_v1, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return the plaintext values</span></span><br><span class="line">    <span class="keyword">return</span> total_v0, total_v1</span><br></pre></td></tr></table></figure>

<h2 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h2><p>零知识证明中，prover 向 verifier 证明关于 secret 的一个命题，并且不泄露任何 secret 的信息。一个典型的例子就是数字签名，prover 证明他拥有私钥而不泄露私钥信息。</p>
<h3 id="Schnorr-Identification-协议"><a href="#Schnorr-Identification-协议" class="headerlink" title="Schnorr Identification 协议"></a>Schnorr Identification 协议</h3><ul>
<li>公共参数：群 $G$，$q=ord(G)$，生成元 $g$</li>
<li>Prover 拥有私钥 $x$，公钥 $pub=g^x$。选择随机的 $w$，计算 $W=g^w$ 发送给 Verifier</li>
<li>Verifier 返回随机的挑战值 $c$</li>
<li>Prover 计算 $r=w-cx\ (mod\ q)$ 发送给 Verifier</li>
<li>Verifier 验证 $g^r\cdot pub^c=W$</li>
</ul>
<p>我们来看一下这个协议是否满足零知识证明的几条性质：</p>
<ul>
<li>Completeness：即正确性</li>
<li>Integrity / Soundness：即这样做是否就能证明 Prover 真的知道 x</li>
<li>Privacy / Zero-knowledge：即这样做是否会泄露 x 的信息</li>
</ul>
<p>Completeness 很容易证明：$g^r\cdot (g^x)^c=g^{w-cx}g^{cx}=g^w=W$。</p>
<p>为了证明 Soundness，我们假设可能的挑战值只有两个：$c$ 和 $c’$。如果要成功证明，Prover 要以大于二分之一的概率给出正确的 $r$ 或 $r’$，$r=w-cx$，$r’=w-c’x$。然而如果 Prover 不知道 $x$，那么这两个等式均为线性等式且有两个未知数 $w$ 和 $x$，此时 Prover 不可能以大于二分之一的概率给出正确答案。</p>
<p>Zero-knowledge 的证明方式则比较奇怪。我们看到上述协议的 transcript 是 $(W,c,r)$。假如任何人都能构造这样的三元组使得其能通过 Verifier 检查，那么这就说明 $x$ 的信息不可能被泄露，因为这里根本没有用到 $x$。而要构造这样的三元组，只需要随机选择 $r’’,c’’$，计算 $W’’=g^{r’’}pub^{c’’}$（注意 $pub=g^x$ 是公钥，并没有用到 $x$），那么 $(W’’,c’’,r’’)$ 就能通过检查。</p>
<h3 id="Fiat-Shamir-启发式技术"><a href="#Fiat-Shamir-启发式技术" class="headerlink" title="Fiat-Shamir 启发式技术"></a>Fiat-Shamir 启发式技术</h3><p>实际运用中我们更多时候希望能有一种非交互式的零知识证明，而 Fiat-Shamir 启发式技术就是一种将 Schnorr Identification 协议转化为非交互式的通法。</p>
<ul>
<li>公共参数：群 $G$，$q=ord(G)$，生成元 $g$</li>
<li>Prover 拥有私钥 $x$，公钥 $pub=g^x$。选择随机的 $w$，计算 $W=g^w$</li>
<li>计算 $c=H(pub,W,m)$ ，$r=w-cx\ (mod\ q)$，发送 $m,(c,r)$ 给 Verifier</li>
<li>Verifier 验证 $H(pub,g^rpub^c,m)=c$</li>
</ul>
<p>如果攻击者要伪造证明，需要先设置 $r,c$ 再计算 $W$。然而在第三步中 $c$ 依赖于 $W$ 的哈希，因此不能这样计算。</p>
<h3 id="相等性证明"><a href="#相等性证明" class="headerlink" title="相等性证明"></a>相等性证明</h3><p>实际上，零知识证明不仅可以用于证明知道某个秘密，还可以证明任意关于某个秘密的逻辑表达式。以相等性证明为例，假如有 $P_1=g^x,P_2=h^x$，$g,h$ 是群 $G$ 的生成元，而 Prover 想证明两个 $x$ 相等，那么可以结合 2 次 Schnorr 协议，采用 Fiat-Shamir 技术实现 NIKP。</p>
<ul>
<li>Prover 选择随机 $w$，$W_1=g^w,W_2=h^w$</li>
<li>计算 $c=H(g,h,P_1,P_2,W_1,W_2)$，$r=w-cx$，发送 $(c,r)$ 给 Verifier</li>
<li>Verifier 验证 $H(g,h,P_1,P_2,g^rP_1^c,h^rP_2^c)=c$</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>扑朔迷离：隐私增强技术实践</p><p><a href="https://signormercurio.me/post/PET/">https://signormercurio.me/post/PET/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Mercury</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-02-04</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/DistributedSystems/"><span class="level-item">星罗棋布：《分布式系统与安全》课程笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "RkxCznUcvfzFBgfMiMr0BAfd-gzGzoHsz",
            appKey: "sw2sEPOl4haCAXKUFYiBFMrR",
            placeholder: "Leave comments here...",
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "en",
            visitor: true,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: ["nick","mail"],
        });</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#隐私"><span class="level-left"><span class="level-item">1</span><span class="level-item">隐私</span></span></a></li><li><a class="level is-mobile" href="#PET"><span class="level-left"><span class="level-item">2</span><span class="level-item">PET</span></span></a></li><li><a class="level is-mobile" href="#通信隐私"><span class="level-left"><span class="level-item">3</span><span class="level-item">通信隐私</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#对称加密"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">对称加密</span></span></a></li><li><a class="level is-mobile" href="#非对称加密"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">非对称加密</span></span></a></li><li><a class="level is-mobile" href="#签名"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">签名</span></span></a></li><li><a class="level is-mobile" href="#完整的加密通信实现"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">完整的加密通信实现</span></span></a></li><li><a class="level is-mobile" href="#侧信道攻击"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">侧信道攻击</span></span></a></li></ul></li><li><a class="level is-mobile" href="#匿名通信"><span class="level-left"><span class="level-item">4</span><span class="level-item">匿名通信</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#高延迟匿名通信"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">高延迟匿名通信</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#单个-Mix"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">单个 Mix</span></span></a></li><li><a class="level is-mobile" href="#多个-Mix"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">多个 Mix</span></span></a></li><li><a class="level is-mobile" href="#流量分析"><span class="level-left"><span class="level-item">4.1.3</span><span class="level-item">流量分析</span></span></a></li></ul></li><li><a class="level is-mobile" href="#低延迟匿名通信"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">低延迟匿名通信</span></span></a></li></ul></li><li><a class="level is-mobile" href="#隐私友好型计算"><span class="level-left"><span class="level-item">5</span><span class="level-item">隐私友好型计算</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#同态加密"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">同态加密</span></span></a></li><li><a class="level is-mobile" href="#秘密分享"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">秘密分享</span></span></a></li><li><a class="level is-mobile" href="#私密投票"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">私密投票</span></span></a></li></ul></li><li><a class="level is-mobile" href="#零知识证明"><span class="level-left"><span class="level-item">6</span><span class="level-item">零知识证明</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Schnorr-Identification-协议"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Schnorr Identification 协议</span></span></a></li><li><a class="level is-mobile" href="#Fiat-Shamir-启发式技术"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">Fiat-Shamir 启发式技术</span></span></a></li><li><a class="level is-mobile" href="#相等性证明"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">相等性证明</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/post/PET/"><img src="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/PET/0.png" alt="扑朔迷离：隐私增强技术实践"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-02-04T09:23:11.000Z">2022-02-04</time></p><p class="title"><a href="/post/PET/">扑朔迷离：隐私增强技术实践</a></p><p class="categories"><a href="/categories/%E5%AE%89%E5%85%A8/">安全</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/DistributedSystems/"><img src="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/DistributedSystems/0.png" alt="星罗棋布：《分布式系统与安全》课程笔记"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-10-18T10:04:07.000Z">2021-10-18</time></p><p class="title"><a href="/post/DistributedSystems/">星罗棋布：《分布式系统与安全》课程笔记</a></p><p class="categories"><a href="/categories/%E6%8E%A2%E7%B4%A2/">探索</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/Kubernetes/"><img src="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/Kubernetes/0.png" alt="乘风破浪：Kubernetes 笔记"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-10-10T15:31:41.000Z">2021-10-10</time></p><p class="title"><a href="/post/Kubernetes/">乘风破浪：Kubernetes 笔记</a></p><p class="categories"><a href="/categories/%E4%BA%91/">云</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/Dockerfile2GKE/"><img src="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/Dockerfile2GKE/0.png" alt="再探 GitHub Actions：从 Dockerfile 到 GKE"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-09-25T17:44:35.000Z">2021-09-25</time></p><p class="title"><a href="/post/Dockerfile2GKE/">再探 GitHub Actions：从 Dockerfile 到 GKE</a></p><p class="categories"><a href="/categories/%E4%BA%91/">云</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/post/GCP/"><img src="https://cdn.jsdelivr.net/gh/SignorMercurio/blog-cdn/GCP/0.png" alt="高枕无忧：Google Cloud Platform 基础"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-09-23T09:03:42.000Z">2021-09-23</time></p><p class="title"><a href="/post/GCP/">高枕无忧：Google Cloud Platform 基础</a></p><p class="categories"><a href="/categories/%E4%BA%91/">云</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/favicon.png" alt="Lab on Mercury" height="28"></a><p class="is-size-7"><span>&copy; 2022 Mercury</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script src="/js/main.js" defer></script><script src="https://unpkg.com/mermaid@8.13.3/dist/mermaid.min.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>