<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>盘根错节：GLibc 堆内存管理机制简介 - Lab on Mercury</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Lab on Mercury"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Lab on Mercury"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="The heap is a beautiful mess."><meta property="og:type" content="blog"><meta property="og:title" content="盘根错节：GLibc 堆内存管理机制简介"><meta property="og:url" content="https://signormercurio.me/post/GLibcHeap/"><meta property="og:site_name" content="Lab on Mercury"><meta property="og:description" content="The heap is a beautiful mess."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://i.loli.net/2020/08/19/Z34WnsoilmSHpvx.png"><meta property="article:published_time" content="2019-12-08T16:53:39.000Z"><meta property="article:author" content="Mercury"><meta property="article:tag" content="C/C++"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://i.loli.net/2020/08/19/Z34WnsoilmSHpvx.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://signormercurio.me/post/GLibcHeap/"},"headline":"Lab on Mercury","image":["https://i.loli.net/2020/08/19/Z34WnsoilmSHpvx.png"],"datePublished":"2019-12-08T16:53:39.000Z","author":{"@type":"Person","name":"Mercury"},"description":"The heap is a beautiful mess."}</script><link rel="canonical" href="https://signormercurio.me/post/GLibcHeap/"><link rel="alternate" href="/atom.xml" title="Lab on Mercury" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/favicon.png" alt="Lab on Mercury" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://i.loli.net/2020/08/19/Z34WnsoilmSHpvx.png" alt="盘根错节：GLibc 堆内存管理机制简介"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-12-08T16:53:39.000Z" title="2019-12-08T16:53:39.000Z">2019-12-08</time></span><span class="level-item"><a class="link-muted" href="/categories/%E5%AE%89%E5%85%A8/">安全</a><span> / </span><a class="link-muted" href="/categories/%E5%AE%89%E5%85%A8/Pwn/">Pwn</a></span><span class="level-item">32 minutes read (About 4744 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">盘根错节：GLibc 堆内存管理机制简介</h1><div class="content"><p>The heap is a beautiful mess.</p>
<a id="more"></a>

<p>本文将对 Glibc 堆上的内存管理作简要介绍，部分内容翻译自参考资料中的文章。略过了许多细节，主要是为了对新手友好。</p>
<p>默认读者熟悉操作系统、C 语言及其运行机制，并且对于 C 中的函数调用栈有所了解。</p>
<h2 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h2><p>堆是每个程序被分配到的一块内存区域，和栈的区别主要在于堆内存是动态分配的。也就是说，程序可以从 <code>heap</code> 段请求一块内存，或者释放一块内存。</p>
<p>另外，堆内存是全局的，即在程序的任意位置都可以访问到堆，并不一定要在调用 <code>malloc</code> 的那个函数里访问。这是因为 C 语言使用指针指向动态分配的内存。但相比访问栈上的静态局部变量，使用指针也带来了一定的开销。</p>
<h2 id="使用动态分配的内存"><a href="#使用动态分配的内存" class="headerlink" title="使用动态分配的内存"></a>使用动态分配的内存</h2><p>GLibc 采用 ptmalloc2 内存分配器管理堆内存，相比前身 dlmalloc，它增加了对多线程的支持。多线程的好处就不多赘述了。</p>
<p>借助 <code>stdlib.h</code> 我们可以使用 <code>malloc</code> 和 <code>free</code> 函数来操作堆内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *buffer = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(buffer,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(buffer);</span><br></pre></td></tr></table></figure>

<p>第一行分配了 10 字节给 <code>buffer</code>，注意这里的强制类型转换是必须的；第 2-3 行使用了 <code>buffer</code> 这块内存，并在最后一行释放。</p>
<p>下面是 <code>malloc</code> 和 <code>free</code> 函数的注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  free(void* p)</span></span><br><span class="line"><span class="comment">  Releases the chunk of memory pointed to by p, that had been previously</span></span><br><span class="line"><span class="comment">  allocated using malloc or a related routine such as realloc.</span></span><br><span class="line"><span class="comment">  It has no effect if p is null. It can have arbitrary (i.e., bad!)</span></span><br><span class="line"><span class="comment">  effects if p has already been freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless disabled (using mallopt), freeing very large spaces will</span></span><br><span class="line"><span class="comment">  when possible, automatically trigger operations that give</span></span><br><span class="line"><span class="comment">  back unused memory to the system, thus reducing program footprint.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意，即使申请 0 字节内存，<code>malloc</code> 依然会分配一个最小的 chunk；如果传给 <code>free</code> 的参数是空指针，<code>free</code> 不会做任何事，而如果传入的是一个已经 <code>free</code> 过的指针，那么后果是不可预期的。这里尤其需要注意的是，与 <code>Java</code> 等语言不同，C 语言中释放掉分配到的内存的责任在于程序员，并且分配到的内存只应使用<em>一次</em>。</p>
<p>这两个函数在更底层上是使用 <code>brk()</code> 和 <code>mmap()</code> 这两个系统调用来管理内存的。</p>
<h2 id="两个系统调用"><a href="#两个系统调用" class="headerlink" title="两个系统调用"></a>两个系统调用</h2><p>注意申请内存时，Linux 内核只会先分配一段虚拟内存，真正使用时才会映射到物理内存上去。</p>
<h3 id="brk"><a href="#brk" class="headerlink" title="brk()"></a>brk()</h3><p><code>brk()</code> 通过增加 <code>break location</code> 来获取内存，一开始 <code>heap</code> 段的起点 <code>start_brk</code> 和 <code>heap</code> 段的终点 <code>brk</code> 指向同一个位置。</p>
<ul>
<li>ASLR 关闭时，两者指向 data/bss 段的末尾，也就是 <code>end_data</code></li>
<li>ASLR 开启时，两者指向 data/bss 段的末尾加上一段随机 brk 偏移</li>
</ul>
<p><img src="https://i2.wp.com/static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png?zoom=2" alt="Process Virtual Memory Layout"></p>
<blockquote>
<p>注：注意与 <code>sbrk()</code> 的区别，后者是 C 语言库函数，<code>malloc</code> 源码中的 <code>MORECORE</code> 就是调用的 <code>sbrk()</code>。</p>
</blockquote>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h3><p>用于创建私有的匿名映射段，主要是为了分配一块新的内存，且这块内存只有调用 <code>mmap()</code> 的进程可以使用，所以称之为私有的。与之进行相反操作的是 <code>munmap()</code>，删除一块内存区域上的映射。</p>
<h2 id="多线程与-Arena"><a href="#多线程与-Arena" class="headerlink" title="多线程与 Arena"></a>多线程与 Arena</h2><p>前面提到，ptmalloc2 的一大改进就在于多线程，那么他是如何做到的呢？不难猜到，每个线程必定要维护一些独立的数据结构，并且对这些数据结构的访问是需要加锁的。的确，在 ptmalloc2 中，每个线程拥有自己的 <code>freelist</code>，也就是维护空闲内存的一个链表；以及自己的 <code>arena</code>，一段连续的堆内存区域。特别地，主线程的 <code>arena</code> 叫做 <code>main_arena</code>。注意<strong>只有 <code>main_arena</code> 可以访问 <code>heap</code> 段和 <code>mmap</code> 映射区域，<code>non_main_arena</code> 只能访问 <code>mmap</code> 映射区域</strong>。</p>
<blockquote>
<p>注：线程较多时，互斥锁机制会导致性能下降。</p>
</blockquote>
<p>当我们在程序中第一次申请内存时还没有 <code>heap</code> 段，因此 132KB 的 <code>heap</code> 段，也就是我们的 <code>main_arena</code>，会被创建（<strong>通过 <code>brk()</code>调用</strong>），无论我们申请的内存是多大。对于接下来的内存申请，<code>malloc</code> 都会从 <code>main_arena</code> 中尝试取出一块内存进行分配。如果空间不够，<code>main_arena</code> 可以通过 <code>brk()</code> 扩张；如果空闲空间太多，也可以缩小。</p>
<p>那么对于 <code>non_main_arena</code> 呢？前面提到它只能访问 <code>mmap</code> 映射区域，因为在创建时它就是由 <code>mmap()</code> 创建的——1MB 的内存空间会被映射到进程地址空间，不过实际上只有 132KB 是可读写的，这 132KB 就是该线程的 <code>heap</code> 结构，或者叫 <code>non_main_arena</code>。</p>
<blockquote>
<p>注：当然了，当申请的空间大于 128KB 且 <code>arena</code> 中没有足够空间时，无论在哪个 <code>arena</code> 里都只能通过 <code>mmap()</code> 分配内存。</p>
</blockquote>
<p><code>arena</code> 也不是和线程一对一的，实际上有数量限制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For <span class="number">32</span> bit systems:</span><br><span class="line">     Number of arena = <span class="number">2</span> * number of cores.</span><br><span class="line">For <span class="number">64</span> bit systems:</span><br><span class="line">     Number of arena = <span class="number">8</span> * number of cores.</span><br></pre></td></tr></table></figure>

<p>而当我们 <code>free</code> 一小块内存时，内存也不会直接归还给内核，而是给 ptmalloc2 让他去维护，后者会将空闲内存丢入 bin 中，或者说 <code>freelist</code> 中也可以。如果过了一会我们的程序又要申请内存，那么 ptmalloc2 就会从 bin 中找一块空闲的内存进行分配，找不到的话才会去问内核要内存。</p>
<h2 id="维护多个堆"><a href="#维护多个堆" class="headerlink" title="维护多个堆"></a>维护多个堆</h2><p>前面提到，<code>main_arena</code> 只有一个堆，并且可以灵活地放缩；<code>non_main_arena</code> 则只能通过 <code>mmap()</code> 获得一个堆。那么如果 <code>non_main_arena</code> 里分配的堆内存不够了怎么办？很简单，再 <code>mmap()</code> 一次，创建一个新的堆。</p>
<p>所以，在 <code>non_main_arena</code> 里，我们必须考虑如何维护多个堆的问题。这里我们会涉及三个头部：</p>
<ul>
<li><code>heap_info</code>：每个堆的头部，<code>main_arena</code> 是没有的</li>
<li><code>malloc_state</code>：<code>arena</code> 的头部，<code>main_arena</code> 的这个部分是<strong>全局变量</strong>而不属于堆段</li>
<li><code>malloc_chunk</code>：每个 chunk 的头部</li>
</ul>
<p>具体一点，<code>heap_info</code> 完整定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="keyword">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>

<p>而 <code>malloc_state</code> 的完整定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>其中 <code>INTERNAL_SIZE_T</code> 默认和 <code>size_t</code> 相同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在后面介绍 chunk 和 bin 的时候，我们会发现其中几个字段的作用，<code>malloc_chunk</code> 我们也会在后面看到。</p>
<p>对于 <code>arena</code> 中只有单个堆的情况：<br><img src="https://docs.google.com/drawings/d/1367fdYcRTvkyfZ_s27yg6oJp5KYsVAuYqPf8szbRNc0/pub?w=960&h=720" alt="Single Heap"></p>
<p>对于 <code>non_main_arena</code> 中有多个堆的情况：<br><img src="https://docs.google.com/drawings/d/150bTi0uScQlnABDImLYS8rWyL82mmfpMxzRbx-45UKw/pub?w=960&h=720" alt="Multiple Heap"></p>
<p>注意到有多个堆的情况下，旧的堆的 Top chunk 会被认为是普通的空闲块。</p>
<h2 id="Chunk-的结构"><a href="#Chunk-的结构" class="headerlink" title="Chunk 的结构"></a>Chunk 的结构</h2><p>通俗地说，一块由分配器分配的内存块叫做一个 chunk，包含了元数据和用户数据。具体一点，chunk 完整定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>                <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br></pre></td></tr></table></figure>
<p>这里出现的 6 个字段均为元数据。</p>
<p>一个 chunk 可以是以下几种类型之一：</p>
<ul>
<li>已分配的（Allocated chunk）</li>
<li>空闲的（Free chunk）</li>
<li>Top chunk</li>
<li>Last Remainder chunk</li>
</ul>
<p>我们一个一个来看。</p>
<h3 id="Allocated-chunk"><a href="#Allocated-chunk" class="headerlink" title="Allocated chunk"></a>Allocated chunk</h3><p><img src="https://docs.google.com/drawings/d/1eLkG-WF9U3O_ytNs6iFKHacqkjWZeY4KtLqxmd01EVs/pub?w=962&h=682" alt="Allocated chunk"></p>
<p>第一个部分（32 位上 4B，64 位上 8B）叫做 <code>prev_size</code>，只有在前一个 chunk 空闲时才表示前一个块的大小，否则这里就是无效的，可以被前一个块征用（存储用户数据）。</p>
<blockquote>
<p>这里的前一个 chunk，指内存中相邻的前一个，而不是 freelist 链表中的前一个。<code>PREV_INUSE</code> 代表的 “前一个 chunk” 同理。</p>
</blockquote>
<p>第二个部分的高位存储当前 chunk 的大小，低 3 位分别表示：</p>
<ul>
<li>P: <code>PREV_INUSE</code> 之前的 chunk 已经被分配则为 1</li>
<li>M: <code>IS_MMAPED</code> 当前 chunk 是 <code>mmap()</code> 得到的则为 1</li>
<li>N: <code>NON_MAIN_ARENA</code> 当前 chunk 在 <code>non_main_arena</code> 里则为 1</li>
</ul>
<p>对应源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for chunk from non-main arena */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>

<p>你可能会有几个困惑：</p>
<ol>
<li><p><code>fd</code>、<code>bk</code>、<code>fd_nextsize</code>、<code>bk_nextsize</code> 这几个字段去哪里了？<br>对于已分配的 chunk 来说它们没用，所以也被征用了，用来存储用户数据。</p>
</li>
<li><p>为什么第二个部分的低 3 位就这么被吞了而不会影响 <code>size</code>？<br>这是因为 <code>malloc</code> 会将用户申请的内存大小转化为实际分配的内存，以此来满足（至少）8 字节对齐的要求，同时留出额外空间存放 chunk 头部。由于（至少）8 字节对齐了，低 3 位自然就没用了。在获取真正的 <code>size</code> 时，会忽略低 3 位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>malloc</code> 是如何将申请的大小转化为实际分配的大小的呢？<br>核心在于 <code>request2size</code> 宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt;MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>其中用到的其它宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding bit mask value */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE  \</span></span><br><span class="line">  (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>这里还有一个 <code>mem</code> 指针，是做什么用的？<br>这是调用 <code>malloc</code> 时返回给用户的指针。实际上，真正的 chunk 是从 <code>chunk</code> 指针开始的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The corresponding word size */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SZ                (sizeof(INTERNAL_SIZE_T))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用户申请的内存大小就是用户数据可用的内存大小吗？<br>不一定，原因还是字节对齐问题。要获得可用内存大小，可以用 <code>malloc_usable_size()</code> 获得，其核心函数是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">musable (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr p;</span><br><span class="line">  <span class="keyword">if</span> (mem != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (using_malloc_checking == <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> malloc_check_get_size (p);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">        <span class="keyword">return</span> chunksize (p) - <span class="number">2</span> * SIZE_SZ;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (inuse (p))</span><br><span class="line">        <span class="keyword">return</span> chunksize (p) - SIZE_SZ;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Free-chunk"><a href="#Free-chunk" class="headerlink" title="Free chunk"></a>Free chunk</h3><p><img src="https://docs.google.com/drawings/d/1YrlnGa081NpO0D3wcoaJbGvhnPi3X6bBKMc3bN4-oZQ/pub?w=940&h=669" alt="Free chunk"></p>
<p>首先，<code>prev_size</code> 必定存储上一个块的用户数据，因为 Free chunk 的上一个块必定是 Allocated chunk，否则会发生合并。</p>
<p>接着，多出来的 <code>fd</code> 指向同一个 bin 中的前一个 Free chunk，<code>bk</code> 指向同一个 bin 中的后一个 Free chunk。</p>
<p>这里提到了 bin，我们将在后面介绍。</p>
<p>此外，对于 large bins 中的 Free chunk，<code>fd_nextsize</code> 与 <code>bk_nextsize</code> 会生效，分别指向 large bins 中前一个（更大的）和后一个（更小的）空闲块。</p>
<h3 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h3><p>一个 <code>arena</code> 顶部的 chunk 叫做 Top chunk，它不属于任何 bin。当所有 bin 中都没有空闲的可用 chunk 时，我们切割 Top chunk 来满足用户的内存申请。假设 Top chunk 当前大小为 N 字节，用户申请了 K 字节的内存，那么 Top chunk 将被切割为：</p>
<ul>
<li>一个 K 字节的 chunk，分配给用户</li>
<li>一个 N-K 字节的 chunk，称为 Last Remainder chunk</li>
</ul>
<p>后者成为新的 Top chunk。如果连 Top chunk 都不够用了，那么：</p>
<ul>
<li>在 <code>main_arena</code> 中，用 <code>brk()</code> 扩张 Top chunk</li>
<li>在 <code>non_main_arena</code> 中，用 <code>mmap()</code> 分配新的堆</li>
</ul>
<blockquote>
<p>注：Top chunk 的 PREV_INUSE 位总是 1</p>
</blockquote>
<h3 id="Last-Remainder-chunk"><a href="#Last-Remainder-chunk" class="headerlink" title="Last Remainder chunk"></a>Last Remainder chunk</h3><p>当需要分配一个比较小的 K 字节的 chunk 但是 small bins 中找不到满足要求的，且 Last Remainder chunk 的大小 N 能满足要求，那么 Last Remainder chunk 将被切割为：</p>
<ul>
<li>一个 K 字节的 chunk，分配给用户</li>
<li>一个 N-K 字节的 chunk，成为新的 Last Remainder chunk</li>
</ul>
<p>它的存在使得连续的小空间内存申请，分配到的内存都是相邻的，从而达到了更好的局部性。</p>
<h2 id="Bin-的结构"><a href="#Bin-的结构" class="headerlink" title="Bin 的结构"></a>Bin 的结构</h2><p>bin 是实现了空闲链表的数据结构，用来存储空闲 chunk，可分为：</p>
<ul>
<li>10 个 fast bins，存储在 <code>fastbinsY</code> 中</li>
<li>1 个 unsorted bin，存储在 <code>bin[1]</code></li>
<li>62 个 small bins，存储在 <code>bin[2]</code> 至 <code>bin[63]</code></li>
<li>63 个 large bins，存储在 <code>bin[64]</code> 至 <code>bin[126]</code></li>
</ul>
<p>还是一个一个来看。</p>
<h3 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h3><p>非常像高速缓存 cache，主要用于提高小内存分配效率。相邻空闲 chunk 不会被合并，这会导致外部碎片增多但是 <code>free</code> 效率提升。注意 fast bins 是 10 个 <strong>LIFO 的单链表</strong>。最后三个链表保留未使用。</p>
<p>chunk 大小（含 chunk 头部）：0x10-0x40（64 位 0x20-0x80）B，相邻 bin 存放的大小相差 0x8（0x10）B。</p>
<p><img src="https://docs.google.com/drawings/d/144diIfbLqUmOPlAWbtP45mGsZlIl3PZWJvvH-cvQziU/pub?w=960&h=720" alt="fast bins"></p>
<blockquote>
<p>注：加入 fast bins 的 chunk，它的 <code>IN_USE</code> 位（准确地说，是下一个 chunk 的 <code>PREV_INUSE</code> 位）依然是 1。这就是为什么相邻的 “空闲”chunk 不会被合并，因为它们根本不会被认为是空闲的。</p>
</blockquote>
<p>关于 fastbin 最大大小，参见宏 <code>DEFAULT_MXFAST</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在初始化时，这个值会被赋值给全局变量 <code>global_max_fast</code>。</p>
<p>申请 fast chunk 时遵循 <code>first fit</code> 原则。释放一个 fast chunk 时，首先检查它的大小以及对应 fastbin 此时的第一个 chunk <code>old</code> 的大小是否合法，随后它会被插入到对应 fastbin 的链表头，此时其 <code>fd</code> 指向 <code>old</code>。</p>
<h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p>非常像缓冲区 buffer，大小超过 fast bins 阈值的 chunk 被释放时会加入到这里，这使得 ptmalloc2 可以复用最近释放的 chunk，从而提升效率。</p>
<p>unsorted bin 是一个双向循环链表，chunk 大小：大于 <code>global_max_fast</code>。<br><img src="https://docs.google.com/drawings/d/1Kf_eg7uB2mRjSOasTc4dIu5fuBpTAK0GxbnKVTkZd0Y/pub?w=1217&h=865" alt="unsorted bin"></p>
<p>当程序申请大于 <code>global_max_fast</code> 内存时，分配器遍历 unsorted bin，每次取最后的一个 unsorted chunk。</p>
<ol>
<li><p>如果 unsorted chunk 满足以下四个条件，它就会被切割为一块满足申请大小的 chunk 和另一块剩下的 chunk，前者返回给程序，后者重新回到 unsorted bin。</p>
<ul>
<li>申请大小属于 small bin 范围</li>
<li>unosrted bin 中只有该 chunk</li>
<li>这个 chunk 同样也是 last remainder chunk</li>
<li>切割之后的大小依然可以作为一个 chunk</li>
</ul>
</li>
<li><p>否则，从 unsorted bin 中删除 unsorted chunk。</p>
<ul>
<li>若 unsorted chunk 恰好和申请大小相同，则直接返回这个 chunk</li>
<li>若 unsorted chunk 属于 small bin 范围，插入到相应 small bin</li>
<li>若 unsorted chunk 属于 large bin 范围，则跳转到 3。</li>
</ul>
</li>
<li><p>此时 unsorted chunk 属于 large bin 范围。</p>
<ul>
<li>若对应 large bin 为空，直接插入 unsorted chunk，其 <code>fd_nextsize</code> 与 <code>bk_nextsize</code> 指向自身。</li>
<li>否则，跳转到 4。</li>
</ul>
</li>
<li><p>到这一步，我们需按大小降序插入对应 large bin。</p>
<ul>
<li>若对应 large bin 最后一个 chunk 大于 unsorted chunk，则插入到最后</li>
<li>否则，从对应 large bin 第一个 chunk 开始，沿 <code>fd_nextsize</code>（即变小）方向遍历，直到找到一个 chunk <code>fwd</code>，其大小小于等于 unsorted chunk 的大小<ul>
<li>若 <code>fwd</code> 大小等于 unsorted chunk 大小，则插入到 <code>fwd</code> 后面</li>
<li>否则，插入到 <code>fwd</code> 前面</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>直到找到满足要求的 unsorted chunk，或无法找到，去 top chunk 切割为止。</p>
<h3 id="small-bins"><a href="#small-bins" class="headerlink" title="small bins"></a>small bins</h3><p>小于 0x200（0x400）B 的 chunk 叫做 small chunk，而 small bins 可以存放的就是这些 small chunks。chunk 大小同样是从 16B 开始每次 + 8B。</p>
<p>small bins 是 62 个双向循环链表，并且是 FIFO 的，这点和 fast bins 相反。同样相反的是相邻的空闲 chunk 会被合并。</p>
<p>chunk 大小：0x10-0x1f0B（0x20-0x3f0），相邻 bin 存放的大小相差 0x8（0x10）B。</p>
<p>释放非 fast chunk 时，按以下步骤执行：</p>
<ol>
<li>若前一个相邻 chunk 空闲，则合并，触发对前一个相邻 chunk 的 <code>unlink</code> 操作</li>
<li>若下一个相邻 chunk 是 top chunk，则合并并结束；否则继续执行 3</li>
<li>若下一个相邻 chunk 空闲，则合并，触发对下一个相邻 chunk 的 <code>unlink</code> 操作；否则，设置下一个相邻 chunk 的 <code>PREV_INUSE</code> 为 <code>0</code></li>
<li>将现在的 chunk 插入 unsorted bin。</li>
<li>若 <code>size</code> 超过了 <code>FASTBIN_CONSOLIDATION_THRESHOLD</code>，则尽可能地合并 fastbin 中的 chunk，放入 unsorted bin。若 top chunk 大小超过了 <code>mp_.trim_threshold</code>，则归还部分内存给 OS。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_TRIM_THRESHOLD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_TRIM_THRESHOLD (128 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br></pre></td></tr></table></figure>

<h3 id="large-bins"><a href="#large-bins" class="headerlink" title="large bins"></a>large bins</h3><p>大于等于 0x200（0x400）B 的 chunk 叫做 large chunk，而 large bins 可以存放的就是这些 large chunks。</p>
<p>large bins 是 63 个双向循环链表，插入和删除可以发生在任意位置，相邻空闲 chunk 也会被合并。chunk 大小就比较复杂了：</p>
<ul>
<li>前 32 个 bins：从 0x200B 开始每次 + 0x40B</li>
<li>接下来的 16 个 bins：每次 + 0x200B</li>
<li>接下来的 8 个 bins：每次 + 0x1000B</li>
<li>接下来的 4 个 bins：每次 + 0x8000B</li>
<li>接下来的 2 个 bins：每次 + 0x40000B</li>
<li>最后的 1 个 bin：只有一个 chunk，大小和 large bins 剩余的大小相同</li>
</ul>
<p>注意同一个 bin 中的 chunks 不是相同大小的，按大小降序排列。这和上面的几种 bins 都不一样。而在取出 chunk 时，也遵循 <code>best fit</code> 原则，取出满足大小的最小 chunk。</p>
<h2 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h2><p>我觉得这类复杂的流程比较需要靠流程图来理解，因此我画了一下：</p>
<p><img src="https://s2.ax1x.com/2019/12/08/Qdiypn.png" alt="Qdiypn.png"></p>
<p>相关宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT&gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt;(<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD_MIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="内存释放流程"><a href="#内存释放流程" class="headerlink" title="内存释放流程"></a>内存释放流程</h2><p><img src="https://s2.ax1x.com/2020/02/17/3C7AKI.png" alt="3C7AKI.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://heap-exploitation.dhavalkapil.com/">Heap Exploitation</a></li>
<li><a target="_blank" rel="noopener" href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">Understanding glibc malloc</a></li>
<li><a target="_blank" rel="noopener" href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/">Syscalls used by malloc</a></li>
<li><a target="_blank" rel="noopener" href="https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">glibc 内存管理 ptmalloc 源代码分析</a></li>
<li><a target="_blank" rel="noopener" href="https://sensepost.com/blog/2017/painless-intro-to-the-linux-userland-heap/">Painless intro to the Linux userland heap</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>盘根错节：GLibc 堆内存管理机制简介</p><p><a href="https://signormercurio.me/post/GLibcHeap/">https://signormercurio.me/post/GLibcHeap/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Mercury</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2019-12-08</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C-C/">C/C++</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/How2heap/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">how2heap 学习</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/BinaryExp/"><span class="level-item">水漫金山：《二进制漏洞利用入门》课程总结</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content" id="valine-thread"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread' ,
            appId: "RkxCznUcvfzFBgfMiMr0BAfd-gzGzoHsz",
            appKey: "sw2sEPOl4haCAXKUFYiBFMrR",
            placeholder: "Leave comments here...",
            avatar: "mm",
            
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "en",
            visitor: true,
            highlight: true,
            
            
            
            
            
            requiredFields: ["nick","mail"],
        });</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#什么是堆？"><span class="level-left"><span class="level-item">1</span><span class="level-item">什么是堆？</span></span></a></li><li><a class="level is-mobile" href="#使用动态分配的内存"><span class="level-left"><span class="level-item">2</span><span class="level-item">使用动态分配的内存</span></span></a></li><li><a class="level is-mobile" href="#两个系统调用"><span class="level-left"><span class="level-item">3</span><span class="level-item">两个系统调用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#brk"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">brk()</span></span></a></li><li><a class="level is-mobile" href="#mmap"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">mmap()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#多线程与-Arena"><span class="level-left"><span class="level-item">4</span><span class="level-item">多线程与 Arena</span></span></a></li><li><a class="level is-mobile" href="#维护多个堆"><span class="level-left"><span class="level-item">5</span><span class="level-item">维护多个堆</span></span></a></li><li><a class="level is-mobile" href="#Chunk-的结构"><span class="level-left"><span class="level-item">6</span><span class="level-item">Chunk 的结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Allocated-chunk"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Allocated chunk</span></span></a></li><li><a class="level is-mobile" href="#Free-chunk"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">Free chunk</span></span></a></li><li><a class="level is-mobile" href="#Top-chunk"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">Top chunk</span></span></a></li><li><a class="level is-mobile" href="#Last-Remainder-chunk"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">Last Remainder chunk</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Bin-的结构"><span class="level-left"><span class="level-item">7</span><span class="level-item">Bin 的结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#fast-bins"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">fast bins</span></span></a></li><li><a class="level is-mobile" href="#unsorted-bin"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">unsorted bin</span></span></a></li><li><a class="level is-mobile" href="#small-bins"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">small bins</span></span></a></li><li><a class="level is-mobile" href="#large-bins"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">large bins</span></span></a></li></ul></li><li><a class="level is-mobile" href="#内存分配流程"><span class="level-left"><span class="level-item">8</span><span class="level-item">内存分配流程</span></span></a></li><li><a class="level is-mobile" href="#内存释放流程"><span class="level-left"><span class="level-item">9</span><span class="level-item">内存释放流程</span></span></a></li><li><a class="level is-mobile" href="#参考资料"><span class="level-left"><span class="level-item">10</span><span class="level-item">参考资料</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-18T10:04:07.000Z">2021-10-18</time></p><p class="title"><a href="/post/DistributedSystems/">星罗棋布：《分布式系统与安全》课程笔记</a></p><p class="categories"><a href="/categories/%E6%8E%A2%E7%B4%A2/">探索</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-10-10T15:31:41.000Z">2021-10-10</time></p><p class="title"><a href="/post/Kubernetes/">乘风破浪：Kubernetes 笔记</a></p><p class="categories"><a href="/categories/%E4%BA%91/">云</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-25T17:44:35.000Z">2021-09-25</time></p><p class="title"><a href="/post/Dockerfile2GKE/">再探 GitHub Actions：从 Dockerfile 到 GKE</a></p><p class="categories"><a href="/categories/%E4%BA%91/">云</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-23T09:03:42.000Z">2021-09-23</time></p><p class="title"><a href="/post/GCP/">高枕无忧：Google Cloud Platform 基础</a></p><p class="categories"><a href="/categories/%E4%BA%91/">云</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-09-10T08:27:59.000Z">2021-09-10</time></p><p class="title"><a href="/post/CloudNative/">风谲云诡：云原生技术原理</a></p><p class="categories"><a href="/categories/%E4%BA%91/">云</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/favicon.png" alt="Lab on Mercury" height="28"></a><p class="is-size-7"><span>&copy; 2021 Mercury</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>